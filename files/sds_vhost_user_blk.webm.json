{"text": " Hi, my name is Stefan Heinze and I work on QMU and Linux and today I want to talk about Vhost User Block, a fast user space block IO interface. So what is Vhost User Block? Vhost User Block allows an application to connect to a software defined storage system that is running on the same node. So in software defined storage or in storage in general, there are three popular storage models. There's block storage, file storage and object storage. And Vhost User Block is about block storage. So for the rest of this presentation, we're going to be talking about block storage. And block storage interfaces, they have a common set of functionality. First of all, there's the core IO reads, writes and flushes. These are the common commands that are used in order to store and retrieve data from the block device. Then there's data management commands. These are used for mapping and allocation of blocks. Discard and write zeros are examples of these kinds of commands. There are also auxiliary commands like getting the capacity of the device. And then finally, there can be extensions to the model like zone storage that go beyond the traditional block device model. Vhost User Block supports all of these things and it's at a similar level of abstraction to NVMe or to SCSI. So let's start by looking at how Vhost User Block is a little bit different from things like NVMe or SCSI, things that are network protocols or hardware storage interfaces. Vhost User Block is a software user space interface. So let's begin by imagining we have a software defined storage system that is running a user space and it wants to expose storage to applications. So if we're using the kernel storage stack, what will happen is we'll need some way to connect our software defined storage to the kernel and present a block device. These of doing that might be NVMe over TCP or as an iSCSI LAN or maybe as an NBD server and so on. And so that's how a software defined storage system might expose its storage to the kernel. And when our application opens a block device, it gets a file descriptor and then it can read or write using system calls from that file descriptor. And what happens is execution goes into the kernel's file system and block layers and they will then talk to the software defined storage system. Now that can be somewhat convoluted because if we've attached say using NVMe over TCP, the network stack might be involved and so on. And at the end of the day, all we're trying to do is communicate between our application and the software defined storage processes that are both on the same node, they're both running on the same operating system. User space storage interfaces, they leave out this kernel storage stack and instead they allow the application to talk directly to the software defined storage process. Now there are a number of pros and cons to using a user space interface. And I'll go through them here. So I've already kind of alluded to the fact that if you have a user space interface and you don't go through the kernel storage stack, then you can bypass some of that long path that we discussed, for example, going down into the kernel, coming back out using something like NBD or iSCSI in order to connect to another process on the same node. There must be a faster way of doing that, right? So with VO's user block, it turns out we can actually get rid of system calls entirely from the data path, so reads and writes and so on from the device don't require any system calls at all. And we'll have a look at how that's possible later on in this talk. But speed is one of the reasons why a peer user space interface for BlockIO is an interesting thing. Another reason is for security. Typically in order to connect a block device to the kernel, you need to have privileges because it can be a security risk to connect untrusted storage to your kernel. And the reason for that is that there's a bunch of code in the storage stack that's going to run and it's going to process and be exposed to this untrusted data. If you think about a file system and all its metadata, that can be complex. And so there's a security risk associated with that and therefore privileges are required to create block devices. An ordinary unprovedged process cannot attach and mount a block device. So in a scenario where you do have an untrusted block device and you would like to remove the attack surface there, then using a user space interface allows you to avoid that. Also if you don't have permissions, if you simply don't have permissions, then you won't be able to create a kernel block device. So then a user space interface is beneficial as well. Now those were the pros. Of course there are drawbacks to having a user space interface. First of all, it's complex. Compared to simply opening a file and reading and writing from the file descriptor, you're going to have to do a lot more because all the logic for actually doing IO and communicating is now the responsibility of the application and not the kernel. So there's that. In addition, if you think about existing programs that you might want to use to access your storage, they won't have support for any new interface that is user space only. They are probably using the POSIX system calls and read and write and so on and that's what they expect. So you'll have to port those applications in order to access your software defined storage system if you rely on a user space interface. Another disadvantage is that if you have a user space interface, then the kernel storage stack isn't involved. So if you decide you need a feature from the kernel storage stack, whatever that may be, or if you have a legacy application that you cannot port and that needs to talk to a kernel block device, then again you have a problem because your software defined storage system is isolated, its block devices aren't connected to the kernel. What we're going to do today is we're going to look at both these pros and cons and we're going to also see how with VHOS user block we can actually overcome these cons. So let's start a little bit looking at some of the performance aspects, how this can be fast. I said no system calls are required, so how does that even work if the software defined storage system and the application need to communicate? How can they communicate without system calls? Alright so one of the important concepts in IO is how to wait for the completion of IO. When you submit an IO request, maybe you have no more work for your process to do. Maybe the CPU is essentially idle until that IO request completes and at that point you'll be able to do more work. The normal thing to do in that case is to then de-schedule your application and let other threads, other tasks on the system run. And maybe if there are no other tasks then the kernel will just put the CPU into power saving mode. It will put it into some kind of low power state and it will awake once the completion interrupt comes in. And you can see that at the top of this slide, at the top diagram, you can see that there's a green part where we submit the IO and at that point we run out of things to do because we're going to wait for completion. So then there's this gray part where other tasks are running, power saving is taking place and during that time the first portion is spent with the IO actually in flight. That's where we're legitimately waiting for the IO request to complete so that we can proceed. But then what happens is that the IO request completes and we need to somehow get back to our de-scheduled process. Now depending on what other tasks are running, their priorities, the scheduler and so on, our task might not get woken up immediately. Or maybe if the CPU is in a low power state it will just take some time to wake up, handle that interrupt, restore the user space process and resume execution. So this leads to a wake up latency, an overhead that is added. And so this is why notifications or also sometimes called interrupts can be something that actually slows down your IO processing. An alternative is to use polling. So polling is an approach where once you have no more work to do instead of de-scheduling you repeatedly check whether the IO is complete yet. And by doing that you're not giving up the CPU so you keep running and you keep consuming the CPU, the advantage is that you don't have this wake up latency, instead your process will respond immediately once the IO is complete. The drawback of course is that you're hogging the CPU and you're wasting power while there's nothing to do. So these are two techniques and I think we're going to keep them in mind because we'll see how they come into play later. The next performance aspect I wanted to mention that's kind of important to understanding how the host user block is different from maybe using a network protocol or an existing storage interface is message passing versus zero copy. As programmers we learn that when we have a large object in our program we shouldn't pass it around by value because it will be copied and that will be inefficient. And instead what we do is we use references or we use pointers allowing the function that receives the object to just go and access it in place rather than taking copies. And in inter process communication and in networking there's similar concepts. By default things are message passing. We build a message, it gets copied through various buffers along the network path, eventually the receiver receives it into its buffer and then it parses it. And so that model is the traditional networking model, it's also the IPC model, it has strong isolation so for security it's great because it means that the sender and the receiver don't have access to each other's memory therefore they cannot interfere or crash each other and do various things. But the downside is that we have these intermediate copies and that consumes CPU cycles and it's inefficient. So the zero copy approach is an approach where the sender and receiver they've somehow agreed on the memory buffer where the data to be transferred lives. And that way the sender for example can simply place the data directly into the receiver's buffer and all it then has to do is let the receiver know, hey there's some data there for you, it doesn't actually have to copy the data. So these are, this is another important concept that we're going to see with vhost user block. So now that we've got those things out of the way, let's look at vhost user block. What is it? It's a local block IO interface so it only works on a single node, on a single machine. It is not a network protocol. Two, it's a user space interface, it's not a kernel solution in itself. It's a pure user space solution that means it's unprivileged, it doesn't require any privileges for two processes to communicate in this way. It's also a zero copy solution and the way it does that is it uses shared memory. And finally, vhost user block supports both notifications and polling. So depending on your performance requirements, you can choose whether you want to deschedule your process and receive a wake up when it's time to process an IO completion or you can just pull and consume CPU and have the lowest possible latency. And vhost user block is available on Linux, BSD and on Mac OS and the implementations of this started around 2017. Now it's used, it came from SPDK and working together with QEMU, so those communities, they implemented vhost user block. But there are also implementations in other hypervisors like cross VM and cloud hypervisor. So primarily this kind of came from virtualization, from this problem of how do we do software to find storage and let a virtual machine connect to it. But that's not all that vhost user is good for, it's actually a general storage interface. It's generic, just like NVMe or SCSI is. So you could use vhost user block if you had some kind of data intensive application that needs to do a lot of storage IO and needs high performance or needs to be unprivileged. And that's why I'm talking about vhost user block today. So let's have a look at the protocol. So the way that this is realized is that there is a Unix domain socket for our user space storage interface and we speak the vhost user protocol over the socket. What the socket does and the vhost user protocol allows us to do is it lets us set up access to a virtual block device, so a block device that lives in the software defined storage process. So when we have two processes running on a system, a software defined storage process and an application, the application is using vhost user in order to communicate with the Verdeo block device and that's how it does its IO. So what is Verdeo block? Verdeo block is a standard. You can check out the Verdeo specification. Verdeo has a number of other devices, but it includes Verdeo block. Some of the other devices are Verdeo net or Verdeo SCSI and so on. But Verdeo block is one we'll focus on here and it consists of one or more request queues where you can place IO requests. And each one of these has a little structure. You can do all the requests I mentioned in the beginning of the talk, reads, writes, flushes, discard, write zero and so on. And you have multiple queues, so if you want to do multi queue, say you're multi threaded, you can do that as well. And it has a config space that describes the capabilities of the device. Like disk size, the number of queues and so on. So that's what you can think of Verdeo block as, that's the model we have here and that's the block device that our application can interact with. If you think of any other storage interfaces or network protocols that you're familiar with, this should be more or less familiar. Most of the existing protocols also work in this way. You can inquire about a device to find out its size and so on and then you can set up queues and you can submit IO. So underneath Verdeo block, we have the VHOS user protocol. And the VHOS user protocol is this Unix domain socket protocol that allows the two processes to communicate. But it's not the data path. So VHOS user is not how the application actually does IO, instead it's a control path that is used to set up access to these queues, these request queues that I've mentioned. And the IO buffer memory and the queue memory actually belongs to the application. And the application sends it over the Unix domain socket. It sends that shared memory over so that the software defined storage process has access to the IO buffer memory and the queue memory. The application and the software defined storage process, they share access to that memory. That way we can do zero copy. So this is going back to the message passing versus zero copy thing. We don't need to transfer entire IO buffers between the two processes. Instead, the software defined storage process can just read the bytes out of the IO buffer that live in the application process and it can write the result into a buffer as well. So if you want to look at the specification and the details of how VHOS user works, I've put a link on this slide. But really, if you're writing an application, I think the way to do it is to use LibBlockIo. LibBlockIo is a library that has both C and Rust APIs that allows you to connect to VHOS user block as well as other storage interfaces. So VHOS user block is not the only thing, but for the purposes of this talk, we'll just focus on that. LibBlockIo is not a framework, it's a library. It allows you to integrate it into your application regardless of what your architecture is. That means it supports blocking IO, it supports event-driven IO, and it also supports polling. So no matter how you've decided you want to do your application, you can use LibBlockIo. You won't have to change the architecture of your application just to integrate LibBlockIo. I have given a full talk about LibBlockIo. So if you want to understand the details and also some of the background and everything it can do, then please check out that talk, I put a YouTube link on this slide for you. I'll give you a short code example here. So this shows how to connect to a VHOS user block socket using LibBlockIo. And this is pretty straightforward, we essentially just need to give it the path of the Unix domain socket and then we connect and start the block IO instance. And then in order to do IO, we can submit a read request. That's just a function call, that's straightforward as well. A notice here that we do get the queue, we call the get queue function in order to grab a queue. That's because LibBlockIo is a multi-queue library. If you have a multi-threaded application, you could create one dedicated queue for each thread and then avoid any kind of locking and synchronization. All the threads can do IO at the same time. So for completion, what this example shows is it shows blocking completion. So here the program is actually going to wait in the do IO function until the IO is complete. But as I mentioned, the library also supports event-driven IO and it also supports polling. So whatever you like, you'll be able to do that. If you develop your application, you'll need something to test against. And I think the easiest way to test against the VOC user block device is to use the QEMU storage daemon. It's packaged for all the main Linux distros as part of the QEMU packages. And you can just run the storage daemon, you can give it a raw image file and tell it the name of a VOC user block UNIX domain socket that you want to have and then you can connect your application to it. All right, so that's how you can do that. If you want to implement a server, if you're already in the SPDK ecosystem and you're using Intel's software performance development kit in order to write your software defined storage system, then it's very easy because VOC user block support is already built in. So I've put a link to the documentation. There are also RPCs if you want to invoke it from the command line. And just for testing, you can create a VOC user block server using this. Now if you're not using SPDK, instead you're writing your own C daemon, your own process, then one way of using VOC user block is to use the libvhostuser library. So this is a C library that implements the VOC user protocol, the server side of it. So this will allow you to accept VOC user connections. It doesn't actually implement verdioblock. That's your job. That's the job of the software defined storage system. But verdioblock consists of basically just processing the IO requests like reads and writes and so on, and also setting the configuration space so that the disk size is reported there. And you can find an example of a C program that implements VOC user block using the VOC user. I've put a link on the slide here for you. So that's how you can do it in C. In Rust, similarly, there is a library available for you. So there's the VOC user backend Rust crate, and it plays a similar role to the libvhostuser library for C. So this allows you to easily implement whatever VOC user device you want. And in this case, it's your job to implement the verdioblock, just as I mentioned. Okay, now I still wanted to touch on one con that we hadn't covered yet, because we've explained how although a user space interface is complex and is more work than just using file descriptors and read and write, I think that the libvhostuser block and so on, these libraries that are ready for you to integrate into your applications or software find storage systems, they take away that complexity, and they make the integration easier as well. You don't need to duplicate code or write a lot of stuff. But we're still left with one of the disadvantages. How do we connect this back to the kernel if it turns out we want to use some functionality from the kernel storage stack, or if we have a legacy application that we can't port to use the user space interface. So for VOC user block, there is a solution here. There's a Linux VD use feature, which is relatively new. And what it does is it allows a VOC like device to be attached to the kernel. So even though your software defined storage system is in user space, this gives you a way of attaching your block device to the kernel. And then in the kernel, the VerdiO block driver will be used to communicate with your device. And what happens is that a devvda or devvdb block device node will appear, and your application can open that like any other block device, and it can read and write and do everything through there. One of the nice features of this is that because it's quite similar to VOC user block, the code can be largely shared. I think the only difference would be that instead of having the V host user code, you would have the VD use code, which opens this character device that the VD use driver in the kernel offers instead of a Unix domain socket. And the setup and the control path is a little bit different. But the actual data path in the VerdiO block is still the same, so you can reuse that code. So that's an effective way of doing it. There's another new Linux feature that I wanted to mention that is interesting here, and also a little bit more general, even outside of VOC's user block, and that's U block. U block is a new Linux interface for user space block IO, so that your software defined storage system can present host kernel block devices. So you can have your block device and process it in user space. And it uses IO U ring. It's an exciting feature, and it's pretty interesting, so I've left the link here. The only thing with this is that compared to VD use, it does not reuse or share any of the V host user block stuff. So if you already have V host user block support in your software defined storage system, or you just want to streamline things, then U block is kind of a whole different interface that you have to integrate. So that's the only disadvantage, but I think it's pretty exciting too. Okay, so to summarize, if you need a user space block IO interface for the performance, or because you need to be able to do unprivileged IO, or for security, then implement VOC's user block. There are open specs, code, and community. Please let me know if you have any questions, and thank you. Have great FOS-DAM! Thanks for watching. I'll see you in the next video.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 12.200000000000001, "text": " Hi, my name is Stefan Heinze and I work on QMU and Linux and today I want to talk about", "tokens": [50364, 2421, 11, 452, 1315, 307, 32158, 32789, 1381, 293, 286, 589, 322, 1249, 44, 52, 293, 18734, 293, 965, 286, 528, 281, 751, 466, 50974], "temperature": 0.0, "avg_logprob": -0.24947948455810548, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.04269041493535042}, {"id": 1, "seek": 0, "start": 12.200000000000001, "end": 16.82, "text": " Vhost User Block, a fast user space block IO interface.", "tokens": [50974, 691, 6037, 32127, 17500, 11, 257, 2370, 4195, 1901, 3461, 39839, 9226, 13, 51205], "temperature": 0.0, "avg_logprob": -0.24947948455810548, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.04269041493535042}, {"id": 2, "seek": 0, "start": 16.82, "end": 18.8, "text": " So what is Vhost User Block?", "tokens": [51205, 407, 437, 307, 691, 6037, 32127, 17500, 30, 51304], "temperature": 0.0, "avg_logprob": -0.24947948455810548, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.04269041493535042}, {"id": 3, "seek": 0, "start": 18.8, "end": 24.400000000000002, "text": " Vhost User Block allows an application to connect to a software defined storage system", "tokens": [51304, 691, 6037, 32127, 17500, 4045, 364, 3861, 281, 1745, 281, 257, 4722, 7642, 6725, 1185, 51584], "temperature": 0.0, "avg_logprob": -0.24947948455810548, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.04269041493535042}, {"id": 4, "seek": 0, "start": 24.400000000000002, "end": 27.7, "text": " that is running on the same node.", "tokens": [51584, 300, 307, 2614, 322, 264, 912, 9984, 13, 51749], "temperature": 0.0, "avg_logprob": -0.24947948455810548, "compression_ratio": 1.5103092783505154, "no_speech_prob": 0.04269041493535042}, {"id": 5, "seek": 2770, "start": 27.7, "end": 31.9, "text": " So in software defined storage or in storage in general, there are three popular storage", "tokens": [50364, 407, 294, 4722, 7642, 6725, 420, 294, 6725, 294, 2674, 11, 456, 366, 1045, 3743, 6725, 50574], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 6, "seek": 2770, "start": 31.9, "end": 32.9, "text": " models.", "tokens": [50574, 5245, 13, 50624], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 7, "seek": 2770, "start": 32.9, "end": 36.1, "text": " There's block storage, file storage and object storage.", "tokens": [50624, 821, 311, 3461, 6725, 11, 3991, 6725, 293, 2657, 6725, 13, 50784], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 8, "seek": 2770, "start": 36.1, "end": 38.86, "text": " And Vhost User Block is about block storage.", "tokens": [50784, 400, 691, 6037, 32127, 17500, 307, 466, 3461, 6725, 13, 50922], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 9, "seek": 2770, "start": 38.86, "end": 43.66, "text": " So for the rest of this presentation, we're going to be talking about block storage.", "tokens": [50922, 407, 337, 264, 1472, 295, 341, 5860, 11, 321, 434, 516, 281, 312, 1417, 466, 3461, 6725, 13, 51162], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 10, "seek": 2770, "start": 43.66, "end": 49.14, "text": " And block storage interfaces, they have a common set of functionality.", "tokens": [51162, 400, 3461, 6725, 28416, 11, 436, 362, 257, 2689, 992, 295, 14980, 13, 51436], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 11, "seek": 2770, "start": 49.14, "end": 53.22, "text": " First of all, there's the core IO reads, writes and flushes.", "tokens": [51436, 2386, 295, 439, 11, 456, 311, 264, 4965, 39839, 15700, 11, 13657, 293, 19568, 279, 13, 51640], "temperature": 0.0, "avg_logprob": -0.14485906152164235, "compression_ratio": 1.7178423236514522, "no_speech_prob": 0.0010320275323465466}, {"id": 12, "seek": 5322, "start": 53.22, "end": 57.62, "text": " These are the common commands that are used in order to store and retrieve data from the", "tokens": [50364, 1981, 366, 264, 2689, 16901, 300, 366, 1143, 294, 1668, 281, 3531, 293, 30254, 1412, 490, 264, 50584], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 13, "seek": 5322, "start": 57.62, "end": 59.26, "text": " block device.", "tokens": [50584, 3461, 4302, 13, 50666], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 14, "seek": 5322, "start": 59.26, "end": 61.14, "text": " Then there's data management commands.", "tokens": [50666, 1396, 456, 311, 1412, 4592, 16901, 13, 50760], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 15, "seek": 5322, "start": 61.14, "end": 64.7, "text": " These are used for mapping and allocation of blocks.", "tokens": [50760, 1981, 366, 1143, 337, 18350, 293, 27599, 295, 8474, 13, 50938], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 16, "seek": 5322, "start": 64.7, "end": 68.66, "text": " Discard and write zeros are examples of these kinds of commands.", "tokens": [50938, 19839, 515, 293, 2464, 35193, 366, 5110, 295, 613, 3685, 295, 16901, 13, 51136], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 17, "seek": 5322, "start": 68.66, "end": 73.66, "text": " There are also auxiliary commands like getting the capacity of the device.", "tokens": [51136, 821, 366, 611, 43741, 16901, 411, 1242, 264, 6042, 295, 264, 4302, 13, 51386], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 18, "seek": 5322, "start": 73.66, "end": 78.78, "text": " And then finally, there can be extensions to the model like zone storage that go beyond", "tokens": [51386, 400, 550, 2721, 11, 456, 393, 312, 25129, 281, 264, 2316, 411, 6668, 6725, 300, 352, 4399, 51642], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 19, "seek": 5322, "start": 78.78, "end": 82.06, "text": " the traditional block device model.", "tokens": [51642, 264, 5164, 3461, 4302, 2316, 13, 51806], "temperature": 0.0, "avg_logprob": -0.1470534342985887, "compression_ratio": 1.832, "no_speech_prob": 0.013016765005886555}, {"id": 20, "seek": 8206, "start": 82.06, "end": 89.06, "text": " Vhost User Block supports all of these things and it's at a similar level of abstraction", "tokens": [50364, 691, 6037, 32127, 17500, 9346, 439, 295, 613, 721, 293, 309, 311, 412, 257, 2531, 1496, 295, 37765, 50714], "temperature": 0.0, "avg_logprob": -0.15078190074247472, "compression_ratio": 1.678391959798995, "no_speech_prob": 0.0037649362348020077}, {"id": 21, "seek": 8206, "start": 89.06, "end": 93.14, "text": " to NVMe or to SCSI.", "tokens": [50714, 281, 46512, 12671, 420, 281, 9028, 20262, 13, 50918], "temperature": 0.0, "avg_logprob": -0.15078190074247472, "compression_ratio": 1.678391959798995, "no_speech_prob": 0.0037649362348020077}, {"id": 22, "seek": 8206, "start": 93.14, "end": 98.86, "text": " So let's start by looking at how Vhost User Block is a little bit different from things", "tokens": [50918, 407, 718, 311, 722, 538, 1237, 412, 577, 691, 6037, 32127, 17500, 307, 257, 707, 857, 819, 490, 721, 51204], "temperature": 0.0, "avg_logprob": -0.15078190074247472, "compression_ratio": 1.678391959798995, "no_speech_prob": 0.0037649362348020077}, {"id": 23, "seek": 8206, "start": 98.86, "end": 104.30000000000001, "text": " like NVMe or SCSI, things that are network protocols or hardware storage interfaces.", "tokens": [51204, 411, 46512, 12671, 420, 9028, 20262, 11, 721, 300, 366, 3209, 20618, 420, 8837, 6725, 28416, 13, 51476], "temperature": 0.0, "avg_logprob": -0.15078190074247472, "compression_ratio": 1.678391959798995, "no_speech_prob": 0.0037649362348020077}, {"id": 24, "seek": 8206, "start": 104.30000000000001, "end": 109.38, "text": " Vhost User Block is a software user space interface.", "tokens": [51476, 691, 6037, 32127, 17500, 307, 257, 4722, 4195, 1901, 9226, 13, 51730], "temperature": 0.0, "avg_logprob": -0.15078190074247472, "compression_ratio": 1.678391959798995, "no_speech_prob": 0.0037649362348020077}, {"id": 25, "seek": 10938, "start": 109.38, "end": 114.94, "text": " So let's begin by imagining we have a software defined storage system that is running a user", "tokens": [50364, 407, 718, 311, 1841, 538, 27798, 321, 362, 257, 4722, 7642, 6725, 1185, 300, 307, 2614, 257, 4195, 50642], "temperature": 0.0, "avg_logprob": -0.1046225561036004, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.006289263255894184}, {"id": 26, "seek": 10938, "start": 114.94, "end": 119.74, "text": " space and it wants to expose storage to applications.", "tokens": [50642, 1901, 293, 309, 2738, 281, 19219, 6725, 281, 5821, 13, 50882], "temperature": 0.0, "avg_logprob": -0.1046225561036004, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.006289263255894184}, {"id": 27, "seek": 10938, "start": 119.74, "end": 124.14, "text": " So if we're using the kernel storage stack, what will happen is we'll need some way to", "tokens": [50882, 407, 498, 321, 434, 1228, 264, 28256, 6725, 8630, 11, 437, 486, 1051, 307, 321, 603, 643, 512, 636, 281, 51102], "temperature": 0.0, "avg_logprob": -0.1046225561036004, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.006289263255894184}, {"id": 28, "seek": 10938, "start": 124.14, "end": 133.18, "text": " connect our software defined storage to the kernel and present a block device.", "tokens": [51102, 1745, 527, 4722, 7642, 6725, 281, 264, 28256, 293, 1974, 257, 3461, 4302, 13, 51554], "temperature": 0.0, "avg_logprob": -0.1046225561036004, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.006289263255894184}, {"id": 29, "seek": 13318, "start": 133.18, "end": 141.38, "text": " These of doing that might be NVMe over TCP or as an iSCSI LAN or maybe as an NBD server", "tokens": [50364, 1981, 295, 884, 300, 1062, 312, 46512, 12671, 670, 48965, 420, 382, 364, 741, 20839, 20262, 37387, 420, 1310, 382, 364, 426, 33, 35, 7154, 50774], "temperature": 0.0, "avg_logprob": -0.14571861690945095, "compression_ratio": 1.5339366515837105, "no_speech_prob": 0.11118918657302856}, {"id": 30, "seek": 13318, "start": 141.38, "end": 142.78, "text": " and so on.", "tokens": [50774, 293, 370, 322, 13, 50844], "temperature": 0.0, "avg_logprob": -0.14571861690945095, "compression_ratio": 1.5339366515837105, "no_speech_prob": 0.11118918657302856}, {"id": 31, "seek": 13318, "start": 142.78, "end": 149.22, "text": " And so that's how a software defined storage system might expose its storage to the kernel.", "tokens": [50844, 400, 370, 300, 311, 577, 257, 4722, 7642, 6725, 1185, 1062, 19219, 1080, 6725, 281, 264, 28256, 13, 51166], "temperature": 0.0, "avg_logprob": -0.14571861690945095, "compression_ratio": 1.5339366515837105, "no_speech_prob": 0.11118918657302856}, {"id": 32, "seek": 13318, "start": 149.22, "end": 155.06, "text": " And when our application opens a block device, it gets a file descriptor and then it can", "tokens": [51166, 400, 562, 527, 3861, 9870, 257, 3461, 4302, 11, 309, 2170, 257, 3991, 31280, 284, 293, 550, 309, 393, 51458], "temperature": 0.0, "avg_logprob": -0.14571861690945095, "compression_ratio": 1.5339366515837105, "no_speech_prob": 0.11118918657302856}, {"id": 33, "seek": 13318, "start": 155.06, "end": 159.34, "text": " read or write using system calls from that file descriptor.", "tokens": [51458, 1401, 420, 2464, 1228, 1185, 5498, 490, 300, 3991, 31280, 284, 13, 51672], "temperature": 0.0, "avg_logprob": -0.14571861690945095, "compression_ratio": 1.5339366515837105, "no_speech_prob": 0.11118918657302856}, {"id": 34, "seek": 15934, "start": 159.34, "end": 165.42000000000002, "text": " And what happens is execution goes into the kernel's file system and block layers and", "tokens": [50364, 400, 437, 2314, 307, 15058, 1709, 666, 264, 28256, 311, 3991, 1185, 293, 3461, 7914, 293, 50668], "temperature": 0.0, "avg_logprob": -0.10706866790201063, "compression_ratio": 1.6826568265682658, "no_speech_prob": 0.03903692588210106}, {"id": 35, "seek": 15934, "start": 165.42000000000002, "end": 169.86, "text": " they will then talk to the software defined storage system.", "tokens": [50668, 436, 486, 550, 751, 281, 264, 4722, 7642, 6725, 1185, 13, 50890], "temperature": 0.0, "avg_logprob": -0.10706866790201063, "compression_ratio": 1.6826568265682658, "no_speech_prob": 0.03903692588210106}, {"id": 36, "seek": 15934, "start": 169.86, "end": 175.38, "text": " Now that can be somewhat convoluted because if we've attached say using NVMe over TCP,", "tokens": [50890, 823, 300, 393, 312, 8344, 3754, 2308, 292, 570, 498, 321, 600, 8570, 584, 1228, 46512, 12671, 670, 48965, 11, 51166], "temperature": 0.0, "avg_logprob": -0.10706866790201063, "compression_ratio": 1.6826568265682658, "no_speech_prob": 0.03903692588210106}, {"id": 37, "seek": 15934, "start": 175.38, "end": 177.78, "text": " the network stack might be involved and so on.", "tokens": [51166, 264, 3209, 8630, 1062, 312, 3288, 293, 370, 322, 13, 51286], "temperature": 0.0, "avg_logprob": -0.10706866790201063, "compression_ratio": 1.6826568265682658, "no_speech_prob": 0.03903692588210106}, {"id": 38, "seek": 15934, "start": 177.78, "end": 182.34, "text": " And at the end of the day, all we're trying to do is communicate between our application", "tokens": [51286, 400, 412, 264, 917, 295, 264, 786, 11, 439, 321, 434, 1382, 281, 360, 307, 7890, 1296, 527, 3861, 51514], "temperature": 0.0, "avg_logprob": -0.10706866790201063, "compression_ratio": 1.6826568265682658, "no_speech_prob": 0.03903692588210106}, {"id": 39, "seek": 15934, "start": 182.34, "end": 187.5, "text": " and the software defined storage processes that are both on the same node, they're both", "tokens": [51514, 293, 264, 4722, 7642, 6725, 7555, 300, 366, 1293, 322, 264, 912, 9984, 11, 436, 434, 1293, 51772], "temperature": 0.0, "avg_logprob": -0.10706866790201063, "compression_ratio": 1.6826568265682658, "no_speech_prob": 0.03903692588210106}, {"id": 40, "seek": 18750, "start": 187.5, "end": 191.3, "text": " running on the same operating system.", "tokens": [50364, 2614, 322, 264, 912, 7447, 1185, 13, 50554], "temperature": 0.0, "avg_logprob": -0.11088377496470576, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.009411784820258617}, {"id": 41, "seek": 18750, "start": 191.3, "end": 197.1, "text": " User space storage interfaces, they leave out this kernel storage stack and instead", "tokens": [50554, 32127, 1901, 6725, 28416, 11, 436, 1856, 484, 341, 28256, 6725, 8630, 293, 2602, 50844], "temperature": 0.0, "avg_logprob": -0.11088377496470576, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.009411784820258617}, {"id": 42, "seek": 18750, "start": 197.1, "end": 203.86, "text": " they allow the application to talk directly to the software defined storage process.", "tokens": [50844, 436, 2089, 264, 3861, 281, 751, 3838, 281, 264, 4722, 7642, 6725, 1399, 13, 51182], "temperature": 0.0, "avg_logprob": -0.11088377496470576, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.009411784820258617}, {"id": 43, "seek": 18750, "start": 203.86, "end": 209.14, "text": " Now there are a number of pros and cons to using a user space interface.", "tokens": [51182, 823, 456, 366, 257, 1230, 295, 6267, 293, 1014, 281, 1228, 257, 4195, 1901, 9226, 13, 51446], "temperature": 0.0, "avg_logprob": -0.11088377496470576, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.009411784820258617}, {"id": 44, "seek": 18750, "start": 209.14, "end": 210.78, "text": " And I'll go through them here.", "tokens": [51446, 400, 286, 603, 352, 807, 552, 510, 13, 51528], "temperature": 0.0, "avg_logprob": -0.11088377496470576, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.009411784820258617}, {"id": 45, "seek": 18750, "start": 210.78, "end": 215.18, "text": " So I've already kind of alluded to the fact that if you have a user space interface and", "tokens": [51528, 407, 286, 600, 1217, 733, 295, 33919, 281, 264, 1186, 300, 498, 291, 362, 257, 4195, 1901, 9226, 293, 51748], "temperature": 0.0, "avg_logprob": -0.11088377496470576, "compression_ratio": 1.7304347826086957, "no_speech_prob": 0.009411784820258617}, {"id": 46, "seek": 21518, "start": 215.18, "end": 222.1, "text": " you don't go through the kernel storage stack, then you can bypass some of that long path", "tokens": [50364, 291, 500, 380, 352, 807, 264, 28256, 6725, 8630, 11, 550, 291, 393, 24996, 512, 295, 300, 938, 3100, 50710], "temperature": 0.0, "avg_logprob": -0.15882081985473634, "compression_ratio": 1.5372549019607844, "no_speech_prob": 0.04335380718111992}, {"id": 47, "seek": 21518, "start": 222.1, "end": 226.74, "text": " that we discussed, for example, going down into the kernel, coming back out using something", "tokens": [50710, 300, 321, 7152, 11, 337, 1365, 11, 516, 760, 666, 264, 28256, 11, 1348, 646, 484, 1228, 746, 50942], "temperature": 0.0, "avg_logprob": -0.15882081985473634, "compression_ratio": 1.5372549019607844, "no_speech_prob": 0.04335380718111992}, {"id": 48, "seek": 21518, "start": 226.74, "end": 232.34, "text": " like NBD or iSCSI in order to connect to another process on the same node.", "tokens": [50942, 411, 426, 33, 35, 420, 741, 20839, 20262, 294, 1668, 281, 1745, 281, 1071, 1399, 322, 264, 912, 9984, 13, 51222], "temperature": 0.0, "avg_logprob": -0.15882081985473634, "compression_ratio": 1.5372549019607844, "no_speech_prob": 0.04335380718111992}, {"id": 49, "seek": 21518, "start": 232.34, "end": 235.18, "text": " There must be a faster way of doing that, right?", "tokens": [51222, 821, 1633, 312, 257, 4663, 636, 295, 884, 300, 11, 558, 30, 51364], "temperature": 0.0, "avg_logprob": -0.15882081985473634, "compression_ratio": 1.5372549019607844, "no_speech_prob": 0.04335380718111992}, {"id": 50, "seek": 21518, "start": 235.18, "end": 240.42000000000002, "text": " So with VO's user block, it turns out we can actually get rid of system calls entirely", "tokens": [51364, 407, 365, 15216, 311, 4195, 3461, 11, 309, 4523, 484, 321, 393, 767, 483, 3973, 295, 1185, 5498, 7696, 51626], "temperature": 0.0, "avg_logprob": -0.15882081985473634, "compression_ratio": 1.5372549019607844, "no_speech_prob": 0.04335380718111992}, {"id": 51, "seek": 24042, "start": 240.42, "end": 245.61999999999998, "text": " from the data path, so reads and writes and so on from the device don't require any system", "tokens": [50364, 490, 264, 1412, 3100, 11, 370, 15700, 293, 13657, 293, 370, 322, 490, 264, 4302, 500, 380, 3651, 604, 1185, 50624], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 52, "seek": 24042, "start": 245.61999999999998, "end": 246.61999999999998, "text": " calls at all.", "tokens": [50624, 5498, 412, 439, 13, 50674], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 53, "seek": 24042, "start": 246.61999999999998, "end": 250.54, "text": " And we'll have a look at how that's possible later on in this talk.", "tokens": [50674, 400, 321, 603, 362, 257, 574, 412, 577, 300, 311, 1944, 1780, 322, 294, 341, 751, 13, 50870], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 54, "seek": 24042, "start": 250.54, "end": 257.58, "text": " But speed is one of the reasons why a peer user space interface for BlockIO is an interesting", "tokens": [50870, 583, 3073, 307, 472, 295, 264, 4112, 983, 257, 15108, 4195, 1901, 9226, 337, 17500, 15167, 307, 364, 1880, 51222], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 55, "seek": 24042, "start": 257.58, "end": 259.14, "text": " thing.", "tokens": [51222, 551, 13, 51300], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 56, "seek": 24042, "start": 259.14, "end": 262.9, "text": " Another reason is for security.", "tokens": [51300, 3996, 1778, 307, 337, 3825, 13, 51488], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 57, "seek": 24042, "start": 262.9, "end": 268.41999999999996, "text": " Typically in order to connect a block device to the kernel, you need to have privileges", "tokens": [51488, 23129, 294, 1668, 281, 1745, 257, 3461, 4302, 281, 264, 28256, 11, 291, 643, 281, 362, 32588, 51764], "temperature": 0.0, "avg_logprob": -0.1376556169868696, "compression_ratio": 1.5975609756097562, "no_speech_prob": 0.013635232113301754}, {"id": 58, "seek": 26842, "start": 268.42, "end": 274.42, "text": " because it can be a security risk to connect untrusted storage to your kernel.", "tokens": [50364, 570, 309, 393, 312, 257, 3825, 3148, 281, 1745, 1701, 81, 6589, 6725, 281, 428, 28256, 13, 50664], "temperature": 0.0, "avg_logprob": -0.12481151436859707, "compression_ratio": 1.7449392712550607, "no_speech_prob": 0.005910707637667656}, {"id": 59, "seek": 26842, "start": 274.42, "end": 278.5, "text": " And the reason for that is that there's a bunch of code in the storage stack that's", "tokens": [50664, 400, 264, 1778, 337, 300, 307, 300, 456, 311, 257, 3840, 295, 3089, 294, 264, 6725, 8630, 300, 311, 50868], "temperature": 0.0, "avg_logprob": -0.12481151436859707, "compression_ratio": 1.7449392712550607, "no_speech_prob": 0.005910707637667656}, {"id": 60, "seek": 26842, "start": 278.5, "end": 282.42, "text": " going to run and it's going to process and be exposed to this untrusted data.", "tokens": [50868, 516, 281, 1190, 293, 309, 311, 516, 281, 1399, 293, 312, 9495, 281, 341, 1701, 81, 6589, 1412, 13, 51064], "temperature": 0.0, "avg_logprob": -0.12481151436859707, "compression_ratio": 1.7449392712550607, "no_speech_prob": 0.005910707637667656}, {"id": 61, "seek": 26842, "start": 282.42, "end": 287.02000000000004, "text": " If you think about a file system and all its metadata, that can be complex.", "tokens": [51064, 759, 291, 519, 466, 257, 3991, 1185, 293, 439, 1080, 26603, 11, 300, 393, 312, 3997, 13, 51294], "temperature": 0.0, "avg_logprob": -0.12481151436859707, "compression_ratio": 1.7449392712550607, "no_speech_prob": 0.005910707637667656}, {"id": 62, "seek": 26842, "start": 287.02000000000004, "end": 292.14, "text": " And so there's a security risk associated with that and therefore privileges are required", "tokens": [51294, 400, 370, 456, 311, 257, 3825, 3148, 6615, 365, 300, 293, 4412, 32588, 366, 4739, 51550], "temperature": 0.0, "avg_logprob": -0.12481151436859707, "compression_ratio": 1.7449392712550607, "no_speech_prob": 0.005910707637667656}, {"id": 63, "seek": 26842, "start": 292.14, "end": 293.70000000000005, "text": " to create block devices.", "tokens": [51550, 281, 1884, 3461, 5759, 13, 51628], "temperature": 0.0, "avg_logprob": -0.12481151436859707, "compression_ratio": 1.7449392712550607, "no_speech_prob": 0.005910707637667656}, {"id": 64, "seek": 29370, "start": 293.7, "end": 299.65999999999997, "text": " An ordinary unprovedged process cannot attach and mount a block device.", "tokens": [50364, 1107, 10547, 517, 4318, 937, 3004, 1399, 2644, 5085, 293, 3746, 257, 3461, 4302, 13, 50662], "temperature": 0.0, "avg_logprob": -0.11751484614546581, "compression_ratio": 1.737327188940092, "no_speech_prob": 0.030209099873900414}, {"id": 65, "seek": 29370, "start": 299.65999999999997, "end": 305.14, "text": " So in a scenario where you do have an untrusted block device and you would like to remove", "tokens": [50662, 407, 294, 257, 9005, 689, 291, 360, 362, 364, 1701, 81, 6589, 3461, 4302, 293, 291, 576, 411, 281, 4159, 50936], "temperature": 0.0, "avg_logprob": -0.11751484614546581, "compression_ratio": 1.737327188940092, "no_speech_prob": 0.030209099873900414}, {"id": 66, "seek": 29370, "start": 305.14, "end": 312.3, "text": " the attack surface there, then using a user space interface allows you to avoid that.", "tokens": [50936, 264, 2690, 3753, 456, 11, 550, 1228, 257, 4195, 1901, 9226, 4045, 291, 281, 5042, 300, 13, 51294], "temperature": 0.0, "avg_logprob": -0.11751484614546581, "compression_ratio": 1.737327188940092, "no_speech_prob": 0.030209099873900414}, {"id": 67, "seek": 29370, "start": 312.3, "end": 317.3, "text": " Also if you don't have permissions, if you simply don't have permissions, then you won't", "tokens": [51294, 2743, 498, 291, 500, 380, 362, 32723, 11, 498, 291, 2935, 500, 380, 362, 32723, 11, 550, 291, 1582, 380, 51544], "temperature": 0.0, "avg_logprob": -0.11751484614546581, "compression_ratio": 1.737327188940092, "no_speech_prob": 0.030209099873900414}, {"id": 68, "seek": 29370, "start": 317.3, "end": 319.26, "text": " be able to create a kernel block device.", "tokens": [51544, 312, 1075, 281, 1884, 257, 28256, 3461, 4302, 13, 51642], "temperature": 0.0, "avg_logprob": -0.11751484614546581, "compression_ratio": 1.737327188940092, "no_speech_prob": 0.030209099873900414}, {"id": 69, "seek": 31926, "start": 319.26, "end": 323.78, "text": " So then a user space interface is beneficial as well.", "tokens": [50364, 407, 550, 257, 4195, 1901, 9226, 307, 14072, 382, 731, 13, 50590], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 70, "seek": 31926, "start": 323.78, "end": 325.18, "text": " Now those were the pros.", "tokens": [50590, 823, 729, 645, 264, 6267, 13, 50660], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 71, "seek": 31926, "start": 325.18, "end": 329.9, "text": " Of course there are drawbacks to having a user space interface.", "tokens": [50660, 2720, 1164, 456, 366, 2642, 17758, 281, 1419, 257, 4195, 1901, 9226, 13, 50896], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 72, "seek": 31926, "start": 329.9, "end": 332.46, "text": " First of all, it's complex.", "tokens": [50896, 2386, 295, 439, 11, 309, 311, 3997, 13, 51024], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 73, "seek": 31926, "start": 332.46, "end": 337.53999999999996, "text": " Compared to simply opening a file and reading and writing from the file descriptor, you're", "tokens": [51024, 30539, 281, 2935, 5193, 257, 3991, 293, 3760, 293, 3579, 490, 264, 3991, 31280, 284, 11, 291, 434, 51278], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 74, "seek": 31926, "start": 337.53999999999996, "end": 342.06, "text": " going to have to do a lot more because all the logic for actually doing IO and communicating", "tokens": [51278, 516, 281, 362, 281, 360, 257, 688, 544, 570, 439, 264, 9952, 337, 767, 884, 286, 46, 293, 17559, 51504], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 75, "seek": 31926, "start": 342.06, "end": 347.46, "text": " is now the responsibility of the application and not the kernel.", "tokens": [51504, 307, 586, 264, 6357, 295, 264, 3861, 293, 406, 264, 28256, 13, 51774], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 76, "seek": 31926, "start": 347.46, "end": 348.78, "text": " So there's that.", "tokens": [51774, 407, 456, 311, 300, 13, 51840], "temperature": 0.0, "avg_logprob": -0.1480698672207919, "compression_ratio": 1.6704980842911878, "no_speech_prob": 0.006692282855510712}, {"id": 77, "seek": 34878, "start": 348.78, "end": 352.73999999999995, "text": " In addition, if you think about existing programs that you might want to use to access your", "tokens": [50364, 682, 4500, 11, 498, 291, 519, 466, 6741, 4268, 300, 291, 1062, 528, 281, 764, 281, 2105, 428, 50562], "temperature": 0.0, "avg_logprob": -0.10158323037503945, "compression_ratio": 1.6653225806451613, "no_speech_prob": 0.006289447192102671}, {"id": 78, "seek": 34878, "start": 352.73999999999995, "end": 358.53999999999996, "text": " storage, they won't have support for any new interface that is user space only.", "tokens": [50562, 6725, 11, 436, 1582, 380, 362, 1406, 337, 604, 777, 9226, 300, 307, 4195, 1901, 787, 13, 50852], "temperature": 0.0, "avg_logprob": -0.10158323037503945, "compression_ratio": 1.6653225806451613, "no_speech_prob": 0.006289447192102671}, {"id": 79, "seek": 34878, "start": 358.53999999999996, "end": 363.9, "text": " They are probably using the POSIX system calls and read and write and so on and that's what", "tokens": [50852, 814, 366, 1391, 1228, 264, 430, 4367, 21124, 1185, 5498, 293, 1401, 293, 2464, 293, 370, 322, 293, 300, 311, 437, 51120], "temperature": 0.0, "avg_logprob": -0.10158323037503945, "compression_ratio": 1.6653225806451613, "no_speech_prob": 0.006289447192102671}, {"id": 80, "seek": 34878, "start": 363.9, "end": 364.9, "text": " they expect.", "tokens": [51120, 436, 2066, 13, 51170], "temperature": 0.0, "avg_logprob": -0.10158323037503945, "compression_ratio": 1.6653225806451613, "no_speech_prob": 0.006289447192102671}, {"id": 81, "seek": 34878, "start": 364.9, "end": 369.78, "text": " So you'll have to port those applications in order to access your software defined storage", "tokens": [51170, 407, 291, 603, 362, 281, 2436, 729, 5821, 294, 1668, 281, 2105, 428, 4722, 7642, 6725, 51414], "temperature": 0.0, "avg_logprob": -0.10158323037503945, "compression_ratio": 1.6653225806451613, "no_speech_prob": 0.006289447192102671}, {"id": 82, "seek": 34878, "start": 369.78, "end": 374.34, "text": " system if you rely on a user space interface.", "tokens": [51414, 1185, 498, 291, 10687, 322, 257, 4195, 1901, 9226, 13, 51642], "temperature": 0.0, "avg_logprob": -0.10158323037503945, "compression_ratio": 1.6653225806451613, "no_speech_prob": 0.006289447192102671}, {"id": 83, "seek": 37434, "start": 374.34, "end": 380.14, "text": " Another disadvantage is that if you have a user space interface, then the kernel storage", "tokens": [50364, 3996, 24292, 307, 300, 498, 291, 362, 257, 4195, 1901, 9226, 11, 550, 264, 28256, 6725, 50654], "temperature": 0.0, "avg_logprob": -0.10906968005867891, "compression_ratio": 1.7511520737327189, "no_speech_prob": 0.18708771467208862}, {"id": 84, "seek": 37434, "start": 380.14, "end": 382.09999999999997, "text": " stack isn't involved.", "tokens": [50654, 8630, 1943, 380, 3288, 13, 50752], "temperature": 0.0, "avg_logprob": -0.10906968005867891, "compression_ratio": 1.7511520737327189, "no_speech_prob": 0.18708771467208862}, {"id": 85, "seek": 37434, "start": 382.09999999999997, "end": 387.21999999999997, "text": " So if you decide you need a feature from the kernel storage stack, whatever that may be,", "tokens": [50752, 407, 498, 291, 4536, 291, 643, 257, 4111, 490, 264, 28256, 6725, 8630, 11, 2035, 300, 815, 312, 11, 51008], "temperature": 0.0, "avg_logprob": -0.10906968005867891, "compression_ratio": 1.7511520737327189, "no_speech_prob": 0.18708771467208862}, {"id": 86, "seek": 37434, "start": 387.21999999999997, "end": 394.02, "text": " or if you have a legacy application that you cannot port and that needs to talk to a kernel", "tokens": [51008, 420, 498, 291, 362, 257, 11711, 3861, 300, 291, 2644, 2436, 293, 300, 2203, 281, 751, 281, 257, 28256, 51348], "temperature": 0.0, "avg_logprob": -0.10906968005867891, "compression_ratio": 1.7511520737327189, "no_speech_prob": 0.18708771467208862}, {"id": 87, "seek": 37434, "start": 394.02, "end": 399.26, "text": " block device, then again you have a problem because your software defined storage system", "tokens": [51348, 3461, 4302, 11, 550, 797, 291, 362, 257, 1154, 570, 428, 4722, 7642, 6725, 1185, 51610], "temperature": 0.0, "avg_logprob": -0.10906968005867891, "compression_ratio": 1.7511520737327189, "no_speech_prob": 0.18708771467208862}, {"id": 88, "seek": 39926, "start": 399.26, "end": 405.09999999999997, "text": " is isolated, its block devices aren't connected to the kernel.", "tokens": [50364, 307, 14621, 11, 1080, 3461, 5759, 3212, 380, 4582, 281, 264, 28256, 13, 50656], "temperature": 0.0, "avg_logprob": -0.13665843459795107, "compression_ratio": 1.656, "no_speech_prob": 0.11432413756847382}, {"id": 89, "seek": 39926, "start": 405.09999999999997, "end": 409.09999999999997, "text": " What we're going to do today is we're going to look at both these pros and cons and we're", "tokens": [50656, 708, 321, 434, 516, 281, 360, 965, 307, 321, 434, 516, 281, 574, 412, 1293, 613, 6267, 293, 1014, 293, 321, 434, 50856], "temperature": 0.0, "avg_logprob": -0.13665843459795107, "compression_ratio": 1.656, "no_speech_prob": 0.11432413756847382}, {"id": 90, "seek": 39926, "start": 409.09999999999997, "end": 414.78, "text": " going to also see how with VHOS user block we can actually overcome these cons.", "tokens": [50856, 516, 281, 611, 536, 577, 365, 691, 39, 4367, 4195, 3461, 321, 393, 767, 10473, 613, 1014, 13, 51140], "temperature": 0.0, "avg_logprob": -0.13665843459795107, "compression_ratio": 1.656, "no_speech_prob": 0.11432413756847382}, {"id": 91, "seek": 39926, "start": 414.78, "end": 421.14, "text": " So let's start a little bit looking at some of the performance aspects, how this can be", "tokens": [51140, 407, 718, 311, 722, 257, 707, 857, 1237, 412, 512, 295, 264, 3389, 7270, 11, 577, 341, 393, 312, 51458], "temperature": 0.0, "avg_logprob": -0.13665843459795107, "compression_ratio": 1.656, "no_speech_prob": 0.11432413756847382}, {"id": 92, "seek": 39926, "start": 421.14, "end": 422.14, "text": " fast.", "tokens": [51458, 2370, 13, 51508], "temperature": 0.0, "avg_logprob": -0.13665843459795107, "compression_ratio": 1.656, "no_speech_prob": 0.11432413756847382}, {"id": 93, "seek": 39926, "start": 422.14, "end": 426.3, "text": " I said no system calls are required, so how does that even work if the software defined", "tokens": [51508, 286, 848, 572, 1185, 5498, 366, 4739, 11, 370, 577, 775, 300, 754, 589, 498, 264, 4722, 7642, 51716], "temperature": 0.0, "avg_logprob": -0.13665843459795107, "compression_ratio": 1.656, "no_speech_prob": 0.11432413756847382}, {"id": 94, "seek": 42630, "start": 426.3, "end": 429.7, "text": " storage system and the application need to communicate?", "tokens": [50364, 6725, 1185, 293, 264, 3861, 643, 281, 7890, 30, 50534], "temperature": 0.0, "avg_logprob": -0.13240953671034947, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.012051276862621307}, {"id": 95, "seek": 42630, "start": 429.7, "end": 433.26, "text": " How can they communicate without system calls?", "tokens": [50534, 1012, 393, 436, 7890, 1553, 1185, 5498, 30, 50712], "temperature": 0.0, "avg_logprob": -0.13240953671034947, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.012051276862621307}, {"id": 96, "seek": 42630, "start": 433.26, "end": 441.82, "text": " Alright so one of the important concepts in IO is how to wait for the completion of IO.", "tokens": [50712, 2798, 370, 472, 295, 264, 1021, 10392, 294, 39839, 307, 577, 281, 1699, 337, 264, 19372, 295, 39839, 13, 51140], "temperature": 0.0, "avg_logprob": -0.13240953671034947, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.012051276862621307}, {"id": 97, "seek": 42630, "start": 441.82, "end": 447.82, "text": " When you submit an IO request, maybe you have no more work for your process to do.", "tokens": [51140, 1133, 291, 10315, 364, 39839, 5308, 11, 1310, 291, 362, 572, 544, 589, 337, 428, 1399, 281, 360, 13, 51440], "temperature": 0.0, "avg_logprob": -0.13240953671034947, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.012051276862621307}, {"id": 98, "seek": 42630, "start": 447.82, "end": 453.18, "text": " Maybe the CPU is essentially idle until that IO request completes and at that point you'll", "tokens": [51440, 2704, 264, 13199, 307, 4476, 30650, 1826, 300, 39839, 5308, 36362, 293, 412, 300, 935, 291, 603, 51708], "temperature": 0.0, "avg_logprob": -0.13240953671034947, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.012051276862621307}, {"id": 99, "seek": 42630, "start": 453.18, "end": 455.34000000000003, "text": " be able to do more work.", "tokens": [51708, 312, 1075, 281, 360, 544, 589, 13, 51816], "temperature": 0.0, "avg_logprob": -0.13240953671034947, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.012051276862621307}, {"id": 100, "seek": 45534, "start": 455.34, "end": 461.73999999999995, "text": " The normal thing to do in that case is to then de-schedule your application and let", "tokens": [50364, 440, 2710, 551, 281, 360, 294, 300, 1389, 307, 281, 550, 368, 12, 6145, 292, 2271, 428, 3861, 293, 718, 50684], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 101, "seek": 45534, "start": 461.73999999999995, "end": 465.5, "text": " other threads, other tasks on the system run.", "tokens": [50684, 661, 19314, 11, 661, 9608, 322, 264, 1185, 1190, 13, 50872], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 102, "seek": 45534, "start": 465.5, "end": 469.73999999999995, "text": " And maybe if there are no other tasks then the kernel will just put the CPU into power", "tokens": [50872, 400, 1310, 498, 456, 366, 572, 661, 9608, 550, 264, 28256, 486, 445, 829, 264, 13199, 666, 1347, 51084], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 103, "seek": 45534, "start": 469.73999999999995, "end": 470.73999999999995, "text": " saving mode.", "tokens": [51084, 6816, 4391, 13, 51134], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 104, "seek": 45534, "start": 470.73999999999995, "end": 475.26, "text": " It will put it into some kind of low power state and it will awake once the completion", "tokens": [51134, 467, 486, 829, 309, 666, 512, 733, 295, 2295, 1347, 1785, 293, 309, 486, 15994, 1564, 264, 19372, 51360], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 105, "seek": 45534, "start": 475.26, "end": 477.26, "text": " interrupt comes in.", "tokens": [51360, 12729, 1487, 294, 13, 51460], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 106, "seek": 45534, "start": 477.26, "end": 482.14, "text": " And you can see that at the top of this slide, at the top diagram, you can see that there's", "tokens": [51460, 400, 291, 393, 536, 300, 412, 264, 1192, 295, 341, 4137, 11, 412, 264, 1192, 10686, 11, 291, 393, 536, 300, 456, 311, 51704], "temperature": 0.0, "avg_logprob": -0.14056222779410227, "compression_ratio": 1.7469387755102042, "no_speech_prob": 0.0028007214423269033}, {"id": 107, "seek": 48214, "start": 482.14, "end": 486.74, "text": " a green part where we submit the IO and at that point we run out of things to do because", "tokens": [50364, 257, 3092, 644, 689, 321, 10315, 264, 39839, 293, 412, 300, 935, 321, 1190, 484, 295, 721, 281, 360, 570, 50594], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 108, "seek": 48214, "start": 486.74, "end": 488.5, "text": " we're going to wait for completion.", "tokens": [50594, 321, 434, 516, 281, 1699, 337, 19372, 13, 50682], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 109, "seek": 48214, "start": 488.5, "end": 491.97999999999996, "text": " So then there's this gray part where other tasks are running, power saving is taking", "tokens": [50682, 407, 550, 456, 311, 341, 10855, 644, 689, 661, 9608, 366, 2614, 11, 1347, 6816, 307, 1940, 50856], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 110, "seek": 48214, "start": 491.97999999999996, "end": 498.5, "text": " place and during that time the first portion is spent with the IO actually in flight.", "tokens": [50856, 1081, 293, 1830, 300, 565, 264, 700, 8044, 307, 4418, 365, 264, 39839, 767, 294, 7018, 13, 51182], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 111, "seek": 48214, "start": 498.5, "end": 502.86, "text": " That's where we're legitimately waiting for the IO request to complete so that we can", "tokens": [51182, 663, 311, 689, 321, 434, 44431, 3806, 337, 264, 39839, 5308, 281, 3566, 370, 300, 321, 393, 51400], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 112, "seek": 48214, "start": 502.86, "end": 504.58, "text": " proceed.", "tokens": [51400, 8991, 13, 51486], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 113, "seek": 48214, "start": 504.58, "end": 509.86, "text": " But then what happens is that the IO request completes and we need to somehow get back to", "tokens": [51486, 583, 550, 437, 2314, 307, 300, 264, 39839, 5308, 36362, 293, 321, 643, 281, 6063, 483, 646, 281, 51750], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 114, "seek": 48214, "start": 509.86, "end": 511.82, "text": " our de-scheduled process.", "tokens": [51750, 527, 368, 12, 6145, 292, 45893, 1399, 13, 51848], "temperature": 0.0, "avg_logprob": -0.1302689666748047, "compression_ratio": 1.7630662020905923, "no_speech_prob": 0.04741765558719635}, {"id": 115, "seek": 51182, "start": 511.82, "end": 517.3, "text": " Now depending on what other tasks are running, their priorities, the scheduler and so on,", "tokens": [50364, 823, 5413, 322, 437, 661, 9608, 366, 2614, 11, 641, 15503, 11, 264, 12000, 260, 293, 370, 322, 11, 50638], "temperature": 0.0, "avg_logprob": -0.11906135347154405, "compression_ratio": 1.5589519650655022, "no_speech_prob": 0.003945128992199898}, {"id": 116, "seek": 51182, "start": 517.3, "end": 520.22, "text": " our task might not get woken up immediately.", "tokens": [50638, 527, 5633, 1062, 406, 483, 261, 8406, 493, 4258, 13, 50784], "temperature": 0.0, "avg_logprob": -0.11906135347154405, "compression_ratio": 1.5589519650655022, "no_speech_prob": 0.003945128992199898}, {"id": 117, "seek": 51182, "start": 520.22, "end": 524.98, "text": " Or maybe if the CPU is in a low power state it will just take some time to wake up, handle", "tokens": [50784, 1610, 1310, 498, 264, 13199, 307, 294, 257, 2295, 1347, 1785, 309, 486, 445, 747, 512, 565, 281, 6634, 493, 11, 4813, 51022], "temperature": 0.0, "avg_logprob": -0.11906135347154405, "compression_ratio": 1.5589519650655022, "no_speech_prob": 0.003945128992199898}, {"id": 118, "seek": 51182, "start": 524.98, "end": 531.54, "text": " that interrupt, restore the user space process and resume execution.", "tokens": [51022, 300, 12729, 11, 15227, 264, 4195, 1901, 1399, 293, 15358, 15058, 13, 51350], "temperature": 0.0, "avg_logprob": -0.11906135347154405, "compression_ratio": 1.5589519650655022, "no_speech_prob": 0.003945128992199898}, {"id": 119, "seek": 51182, "start": 531.54, "end": 536.98, "text": " So this leads to a wake up latency, an overhead that is added.", "tokens": [51350, 407, 341, 6689, 281, 257, 6634, 493, 27043, 11, 364, 19922, 300, 307, 3869, 13, 51622], "temperature": 0.0, "avg_logprob": -0.11906135347154405, "compression_ratio": 1.5589519650655022, "no_speech_prob": 0.003945128992199898}, {"id": 120, "seek": 53698, "start": 536.98, "end": 544.7, "text": " And so this is why notifications or also sometimes called interrupts can be something", "tokens": [50364, 400, 370, 341, 307, 983, 13426, 420, 611, 2171, 1219, 12729, 82, 393, 312, 746, 50750], "temperature": 0.0, "avg_logprob": -0.12533389643618936, "compression_ratio": 1.6008064516129032, "no_speech_prob": 0.025174584239721298}, {"id": 121, "seek": 53698, "start": 544.7, "end": 549.0600000000001, "text": " that actually slows down your IO processing.", "tokens": [50750, 300, 767, 35789, 760, 428, 39839, 9007, 13, 50968], "temperature": 0.0, "avg_logprob": -0.12533389643618936, "compression_ratio": 1.6008064516129032, "no_speech_prob": 0.025174584239721298}, {"id": 122, "seek": 53698, "start": 549.0600000000001, "end": 551.5, "text": " An alternative is to use polling.", "tokens": [50968, 1107, 8535, 307, 281, 764, 29518, 13, 51090], "temperature": 0.0, "avg_logprob": -0.12533389643618936, "compression_ratio": 1.6008064516129032, "no_speech_prob": 0.025174584239721298}, {"id": 123, "seek": 53698, "start": 551.5, "end": 555.98, "text": " So polling is an approach where once you have no more work to do instead of de-scheduling", "tokens": [51090, 407, 29518, 307, 364, 3109, 689, 1564, 291, 362, 572, 544, 589, 281, 360, 2602, 295, 368, 12, 6145, 292, 425, 278, 51314], "temperature": 0.0, "avg_logprob": -0.12533389643618936, "compression_ratio": 1.6008064516129032, "no_speech_prob": 0.025174584239721298}, {"id": 124, "seek": 53698, "start": 555.98, "end": 559.74, "text": " you repeatedly check whether the IO is complete yet.", "tokens": [51314, 291, 18227, 1520, 1968, 264, 39839, 307, 3566, 1939, 13, 51502], "temperature": 0.0, "avg_logprob": -0.12533389643618936, "compression_ratio": 1.6008064516129032, "no_speech_prob": 0.025174584239721298}, {"id": 125, "seek": 53698, "start": 559.74, "end": 564.62, "text": " And by doing that you're not giving up the CPU so you keep running and you keep consuming", "tokens": [51502, 400, 538, 884, 300, 291, 434, 406, 2902, 493, 264, 13199, 370, 291, 1066, 2614, 293, 291, 1066, 19867, 51746], "temperature": 0.0, "avg_logprob": -0.12533389643618936, "compression_ratio": 1.6008064516129032, "no_speech_prob": 0.025174584239721298}, {"id": 126, "seek": 56462, "start": 564.62, "end": 569.42, "text": " the CPU, the advantage is that you don't have this wake up latency, instead your process", "tokens": [50364, 264, 13199, 11, 264, 5002, 307, 300, 291, 500, 380, 362, 341, 6634, 493, 27043, 11, 2602, 428, 1399, 50604], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 127, "seek": 56462, "start": 569.42, "end": 573.82, "text": " will respond immediately once the IO is complete.", "tokens": [50604, 486, 4196, 4258, 1564, 264, 39839, 307, 3566, 13, 50824], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 128, "seek": 56462, "start": 573.82, "end": 578.22, "text": " The drawback of course is that you're hogging the CPU and you're wasting power while there's", "tokens": [50824, 440, 2642, 3207, 295, 1164, 307, 300, 291, 434, 24855, 3249, 264, 13199, 293, 291, 434, 20457, 1347, 1339, 456, 311, 51044], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 129, "seek": 56462, "start": 578.22, "end": 580.16, "text": " nothing to do.", "tokens": [51044, 1825, 281, 360, 13, 51141], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 130, "seek": 56462, "start": 580.16, "end": 583.18, "text": " So these are two techniques and I think we're going to keep them in mind because we'll", "tokens": [51141, 407, 613, 366, 732, 7512, 293, 286, 519, 321, 434, 516, 281, 1066, 552, 294, 1575, 570, 321, 603, 51292], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 131, "seek": 56462, "start": 583.18, "end": 587.02, "text": " see how they come into play later.", "tokens": [51292, 536, 577, 436, 808, 666, 862, 1780, 13, 51484], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 132, "seek": 56462, "start": 587.02, "end": 590.94, "text": " The next performance aspect I wanted to mention that's kind of important to understanding", "tokens": [51484, 440, 958, 3389, 4171, 286, 1415, 281, 2152, 300, 311, 733, 295, 1021, 281, 3701, 51680], "temperature": 0.0, "avg_logprob": -0.11021408734020886, "compression_ratio": 1.6298932384341638, "no_speech_prob": 0.025173693895339966}, {"id": 133, "seek": 59094, "start": 590.94, "end": 596.62, "text": " how the host user block is different from maybe using a network protocol or an existing", "tokens": [50364, 577, 264, 3975, 4195, 3461, 307, 819, 490, 1310, 1228, 257, 3209, 10336, 420, 364, 6741, 50648], "temperature": 0.0, "avg_logprob": -0.11203886448651895, "compression_ratio": 1.6541666666666666, "no_speech_prob": 0.2118985950946808}, {"id": 134, "seek": 59094, "start": 596.62, "end": 602.1, "text": " storage interface is message passing versus zero copy.", "tokens": [50648, 6725, 9226, 307, 3636, 8437, 5717, 4018, 5055, 13, 50922], "temperature": 0.0, "avg_logprob": -0.11203886448651895, "compression_ratio": 1.6541666666666666, "no_speech_prob": 0.2118985950946808}, {"id": 135, "seek": 59094, "start": 602.1, "end": 607.1400000000001, "text": " As programmers we learn that when we have a large object in our program we shouldn't", "tokens": [50922, 1018, 41504, 321, 1466, 300, 562, 321, 362, 257, 2416, 2657, 294, 527, 1461, 321, 4659, 380, 51174], "temperature": 0.0, "avg_logprob": -0.11203886448651895, "compression_ratio": 1.6541666666666666, "no_speech_prob": 0.2118985950946808}, {"id": 136, "seek": 59094, "start": 607.1400000000001, "end": 612.34, "text": " pass it around by value because it will be copied and that will be inefficient.", "tokens": [51174, 1320, 309, 926, 538, 2158, 570, 309, 486, 312, 25365, 293, 300, 486, 312, 43495, 13, 51434], "temperature": 0.0, "avg_logprob": -0.11203886448651895, "compression_ratio": 1.6541666666666666, "no_speech_prob": 0.2118985950946808}, {"id": 137, "seek": 59094, "start": 612.34, "end": 617.46, "text": " And instead what we do is we use references or we use pointers allowing the function that", "tokens": [51434, 400, 2602, 437, 321, 360, 307, 321, 764, 15400, 420, 321, 764, 44548, 8293, 264, 2445, 300, 51690], "temperature": 0.0, "avg_logprob": -0.11203886448651895, "compression_ratio": 1.6541666666666666, "no_speech_prob": 0.2118985950946808}, {"id": 138, "seek": 61746, "start": 617.46, "end": 623.22, "text": " receives the object to just go and access it in place rather than taking copies.", "tokens": [50364, 20717, 264, 2657, 281, 445, 352, 293, 2105, 309, 294, 1081, 2831, 813, 1940, 14341, 13, 50652], "temperature": 0.0, "avg_logprob": -0.13950880291392503, "compression_ratio": 1.7374517374517375, "no_speech_prob": 0.07804828137159348}, {"id": 139, "seek": 61746, "start": 623.22, "end": 628.02, "text": " And in inter process communication and in networking there's similar concepts.", "tokens": [50652, 400, 294, 728, 1399, 6101, 293, 294, 17985, 456, 311, 2531, 10392, 13, 50892], "temperature": 0.0, "avg_logprob": -0.13950880291392503, "compression_ratio": 1.7374517374517375, "no_speech_prob": 0.07804828137159348}, {"id": 140, "seek": 61746, "start": 628.02, "end": 630.58, "text": " By default things are message passing.", "tokens": [50892, 3146, 7576, 721, 366, 3636, 8437, 13, 51020], "temperature": 0.0, "avg_logprob": -0.13950880291392503, "compression_ratio": 1.7374517374517375, "no_speech_prob": 0.07804828137159348}, {"id": 141, "seek": 61746, "start": 630.58, "end": 636.46, "text": " We build a message, it gets copied through various buffers along the network path, eventually", "tokens": [51020, 492, 1322, 257, 3636, 11, 309, 2170, 25365, 807, 3683, 9204, 433, 2051, 264, 3209, 3100, 11, 4728, 51314], "temperature": 0.0, "avg_logprob": -0.13950880291392503, "compression_ratio": 1.7374517374517375, "no_speech_prob": 0.07804828137159348}, {"id": 142, "seek": 61746, "start": 636.46, "end": 641.7800000000001, "text": " the receiver receives it into its buffer and then it parses it.", "tokens": [51314, 264, 20086, 20717, 309, 666, 1080, 21762, 293, 550, 309, 21156, 279, 309, 13, 51580], "temperature": 0.0, "avg_logprob": -0.13950880291392503, "compression_ratio": 1.7374517374517375, "no_speech_prob": 0.07804828137159348}, {"id": 143, "seek": 61746, "start": 641.7800000000001, "end": 646.4200000000001, "text": " And so that model is the traditional networking model, it's also the IPC model, it has strong", "tokens": [51580, 400, 370, 300, 2316, 307, 264, 5164, 17985, 2316, 11, 309, 311, 611, 264, 8671, 34, 2316, 11, 309, 575, 2068, 51812], "temperature": 0.0, "avg_logprob": -0.13950880291392503, "compression_ratio": 1.7374517374517375, "no_speech_prob": 0.07804828137159348}, {"id": 144, "seek": 64642, "start": 646.4599999999999, "end": 651.74, "text": " isolation so for security it's great because it means that the sender and the receiver don't", "tokens": [50366, 16001, 370, 337, 3825, 309, 311, 869, 570, 309, 1355, 300, 264, 2845, 260, 293, 264, 20086, 500, 380, 50630], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 145, "seek": 64642, "start": 651.74, "end": 656.9, "text": " have access to each other's memory therefore they cannot interfere or crash each other and", "tokens": [50630, 362, 2105, 281, 1184, 661, 311, 4675, 4412, 436, 2644, 23946, 420, 8252, 1184, 661, 293, 50888], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 146, "seek": 64642, "start": 656.9, "end": 658.6999999999999, "text": " do various things.", "tokens": [50888, 360, 3683, 721, 13, 50978], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 147, "seek": 64642, "start": 658.6999999999999, "end": 663.74, "text": " But the downside is that we have these intermediate copies and that consumes CPU cycles and it's", "tokens": [50978, 583, 264, 25060, 307, 300, 321, 362, 613, 19376, 14341, 293, 300, 48823, 13199, 17796, 293, 309, 311, 51230], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 148, "seek": 64642, "start": 663.74, "end": 665.6999999999999, "text": " inefficient.", "tokens": [51230, 43495, 13, 51328], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 149, "seek": 64642, "start": 665.6999999999999, "end": 670.8199999999999, "text": " So the zero copy approach is an approach where the sender and receiver they've somehow agreed", "tokens": [51328, 407, 264, 4018, 5055, 3109, 307, 364, 3109, 689, 264, 2845, 260, 293, 20086, 436, 600, 6063, 9166, 51584], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 150, "seek": 64642, "start": 670.8199999999999, "end": 675.74, "text": " on the memory buffer where the data to be transferred lives.", "tokens": [51584, 322, 264, 4675, 21762, 689, 264, 1412, 281, 312, 15809, 2909, 13, 51830], "temperature": 0.0, "avg_logprob": -0.13539125351678757, "compression_ratio": 1.7622641509433963, "no_speech_prob": 0.00555441016331315}, {"id": 151, "seek": 67574, "start": 675.74, "end": 680.58, "text": " And that way the sender for example can simply place the data directly into the receiver's", "tokens": [50364, 400, 300, 636, 264, 2845, 260, 337, 1365, 393, 2935, 1081, 264, 1412, 3838, 666, 264, 20086, 311, 50606], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 152, "seek": 67574, "start": 680.58, "end": 684.1800000000001, "text": " buffer and all it then has to do is let the receiver know, hey there's some data there", "tokens": [50606, 21762, 293, 439, 309, 550, 575, 281, 360, 307, 718, 264, 20086, 458, 11, 4177, 456, 311, 512, 1412, 456, 50786], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 153, "seek": 67574, "start": 684.1800000000001, "end": 688.86, "text": " for you, it doesn't actually have to copy the data.", "tokens": [50786, 337, 291, 11, 309, 1177, 380, 767, 362, 281, 5055, 264, 1412, 13, 51020], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 154, "seek": 67574, "start": 688.86, "end": 694.34, "text": " So these are, this is another important concept that we're going to see with vhost user block.", "tokens": [51020, 407, 613, 366, 11, 341, 307, 1071, 1021, 3410, 300, 321, 434, 516, 281, 536, 365, 371, 6037, 4195, 3461, 13, 51294], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 155, "seek": 67574, "start": 694.34, "end": 698.1, "text": " So now that we've got those things out of the way, let's look at vhost user block.", "tokens": [51294, 407, 586, 300, 321, 600, 658, 729, 721, 484, 295, 264, 636, 11, 718, 311, 574, 412, 371, 6037, 4195, 3461, 13, 51482], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 156, "seek": 67574, "start": 698.1, "end": 699.1, "text": " What is it?", "tokens": [51482, 708, 307, 309, 30, 51532], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 157, "seek": 67574, "start": 699.1, "end": 705.58, "text": " It's a local block IO interface so it only works on a single node, on a single machine.", "tokens": [51532, 467, 311, 257, 2654, 3461, 39839, 9226, 370, 309, 787, 1985, 322, 257, 2167, 9984, 11, 322, 257, 2167, 3479, 13, 51856], "temperature": 0.0, "avg_logprob": -0.1479979197184245, "compression_ratio": 1.7604166666666667, "no_speech_prob": 0.011330119334161282}, {"id": 158, "seek": 70558, "start": 705.86, "end": 708.38, "text": " It is not a network protocol.", "tokens": [50378, 467, 307, 406, 257, 3209, 10336, 13, 50504], "temperature": 0.0, "avg_logprob": -0.1558849948576127, "compression_ratio": 1.6839378238341969, "no_speech_prob": 0.04532849043607712}, {"id": 159, "seek": 70558, "start": 708.38, "end": 714.26, "text": " Two, it's a user space interface, it's not a kernel solution in itself.", "tokens": [50504, 4453, 11, 309, 311, 257, 4195, 1901, 9226, 11, 309, 311, 406, 257, 28256, 3827, 294, 2564, 13, 50798], "temperature": 0.0, "avg_logprob": -0.1558849948576127, "compression_ratio": 1.6839378238341969, "no_speech_prob": 0.04532849043607712}, {"id": 160, "seek": 70558, "start": 714.26, "end": 719.94, "text": " It's a pure user space solution that means it's unprivileged, it doesn't require any", "tokens": [50798, 467, 311, 257, 6075, 4195, 1901, 3827, 300, 1355, 309, 311, 20994, 29994, 794, 3004, 11, 309, 1177, 380, 3651, 604, 51082], "temperature": 0.0, "avg_logprob": -0.1558849948576127, "compression_ratio": 1.6839378238341969, "no_speech_prob": 0.04532849043607712}, {"id": 161, "seek": 70558, "start": 719.94, "end": 725.14, "text": " privileges for two processes to communicate in this way.", "tokens": [51082, 32588, 337, 732, 7555, 281, 7890, 294, 341, 636, 13, 51342], "temperature": 0.0, "avg_logprob": -0.1558849948576127, "compression_ratio": 1.6839378238341969, "no_speech_prob": 0.04532849043607712}, {"id": 162, "seek": 70558, "start": 725.14, "end": 730.62, "text": " It's also a zero copy solution and the way it does that is it uses shared memory.", "tokens": [51342, 467, 311, 611, 257, 4018, 5055, 3827, 293, 264, 636, 309, 775, 300, 307, 309, 4960, 5507, 4675, 13, 51616], "temperature": 0.0, "avg_logprob": -0.1558849948576127, "compression_ratio": 1.6839378238341969, "no_speech_prob": 0.04532849043607712}, {"id": 163, "seek": 73062, "start": 730.62, "end": 735.74, "text": " And finally, vhost user block supports both notifications and polling.", "tokens": [50364, 400, 2721, 11, 371, 6037, 4195, 3461, 9346, 1293, 13426, 293, 29518, 13, 50620], "temperature": 0.0, "avg_logprob": -0.12277763120589717, "compression_ratio": 1.5952380952380953, "no_speech_prob": 0.0009696927736513317}, {"id": 164, "seek": 73062, "start": 735.74, "end": 741.34, "text": " So depending on your performance requirements, you can choose whether you want to deschedule", "tokens": [50620, 407, 5413, 322, 428, 3389, 7728, 11, 291, 393, 2826, 1968, 291, 528, 281, 730, 19318, 2271, 50900], "temperature": 0.0, "avg_logprob": -0.12277763120589717, "compression_ratio": 1.5952380952380953, "no_speech_prob": 0.0009696927736513317}, {"id": 165, "seek": 73062, "start": 741.34, "end": 747.1, "text": " your process and receive a wake up when it's time to process an IO completion or you can", "tokens": [50900, 428, 1399, 293, 4774, 257, 6634, 493, 562, 309, 311, 565, 281, 1399, 364, 39839, 19372, 420, 291, 393, 51188], "temperature": 0.0, "avg_logprob": -0.12277763120589717, "compression_ratio": 1.5952380952380953, "no_speech_prob": 0.0009696927736513317}, {"id": 166, "seek": 73062, "start": 747.1, "end": 752.94, "text": " just pull and consume CPU and have the lowest possible latency.", "tokens": [51188, 445, 2235, 293, 14732, 13199, 293, 362, 264, 12437, 1944, 27043, 13, 51480], "temperature": 0.0, "avg_logprob": -0.12277763120589717, "compression_ratio": 1.5952380952380953, "no_speech_prob": 0.0009696927736513317}, {"id": 167, "seek": 73062, "start": 752.94, "end": 758.5, "text": " And vhost user block is available on Linux, BSD and on Mac OS and the implementations", "tokens": [51480, 400, 371, 6037, 4195, 3461, 307, 2435, 322, 18734, 11, 363, 23969, 293, 322, 5707, 12731, 293, 264, 4445, 763, 51758], "temperature": 0.0, "avg_logprob": -0.12277763120589717, "compression_ratio": 1.5952380952380953, "no_speech_prob": 0.0009696927736513317}, {"id": 168, "seek": 75850, "start": 758.5, "end": 763.18, "text": " of this started around 2017.", "tokens": [50364, 295, 341, 1409, 926, 6591, 13, 50598], "temperature": 0.0, "avg_logprob": -0.16416511150321575, "compression_ratio": 1.5450980392156863, "no_speech_prob": 0.007120518479496241}, {"id": 169, "seek": 75850, "start": 763.18, "end": 769.66, "text": " Now it's used, it came from SPDK and working together with QEMU, so those communities,", "tokens": [50598, 823, 309, 311, 1143, 11, 309, 1361, 490, 19572, 42, 293, 1364, 1214, 365, 1249, 6683, 52, 11, 370, 729, 4456, 11, 50922], "temperature": 0.0, "avg_logprob": -0.16416511150321575, "compression_ratio": 1.5450980392156863, "no_speech_prob": 0.007120518479496241}, {"id": 170, "seek": 75850, "start": 769.66, "end": 772.62, "text": " they implemented vhost user block.", "tokens": [50922, 436, 12270, 371, 6037, 4195, 3461, 13, 51070], "temperature": 0.0, "avg_logprob": -0.16416511150321575, "compression_ratio": 1.5450980392156863, "no_speech_prob": 0.007120518479496241}, {"id": 171, "seek": 75850, "start": 772.62, "end": 778.14, "text": " But there are also implementations in other hypervisors like cross VM and cloud hypervisor.", "tokens": [51070, 583, 456, 366, 611, 4445, 763, 294, 661, 9848, 4938, 830, 411, 3278, 18038, 293, 4588, 9848, 16457, 13, 51346], "temperature": 0.0, "avg_logprob": -0.16416511150321575, "compression_ratio": 1.5450980392156863, "no_speech_prob": 0.007120518479496241}, {"id": 172, "seek": 75850, "start": 778.14, "end": 783.14, "text": " So primarily this kind of came from virtualization, from this problem of how do we do software", "tokens": [51346, 407, 10029, 341, 733, 295, 1361, 490, 6374, 2144, 11, 490, 341, 1154, 295, 577, 360, 321, 360, 4722, 51596], "temperature": 0.0, "avg_logprob": -0.16416511150321575, "compression_ratio": 1.5450980392156863, "no_speech_prob": 0.007120518479496241}, {"id": 173, "seek": 75850, "start": 783.14, "end": 786.9, "text": " to find storage and let a virtual machine connect to it.", "tokens": [51596, 281, 915, 6725, 293, 718, 257, 6374, 3479, 1745, 281, 309, 13, 51784], "temperature": 0.0, "avg_logprob": -0.16416511150321575, "compression_ratio": 1.5450980392156863, "no_speech_prob": 0.007120518479496241}, {"id": 174, "seek": 78690, "start": 786.9, "end": 791.5, "text": " But that's not all that vhost user is good for, it's actually a general storage interface.", "tokens": [50364, 583, 300, 311, 406, 439, 300, 371, 6037, 4195, 307, 665, 337, 11, 309, 311, 767, 257, 2674, 6725, 9226, 13, 50594], "temperature": 0.0, "avg_logprob": -0.13410060470168655, "compression_ratio": 1.6224899598393574, "no_speech_prob": 0.01065162941813469}, {"id": 175, "seek": 78690, "start": 791.5, "end": 797.4599999999999, "text": " It's generic, just like NVMe or SCSI is.", "tokens": [50594, 467, 311, 19577, 11, 445, 411, 46512, 12671, 420, 9028, 20262, 307, 13, 50892], "temperature": 0.0, "avg_logprob": -0.13410060470168655, "compression_ratio": 1.6224899598393574, "no_speech_prob": 0.01065162941813469}, {"id": 176, "seek": 78690, "start": 797.4599999999999, "end": 802.4599999999999, "text": " So you could use vhost user block if you had some kind of data intensive application that", "tokens": [50892, 407, 291, 727, 764, 371, 6037, 4195, 3461, 498, 291, 632, 512, 733, 295, 1412, 18957, 3861, 300, 51142], "temperature": 0.0, "avg_logprob": -0.13410060470168655, "compression_ratio": 1.6224899598393574, "no_speech_prob": 0.01065162941813469}, {"id": 177, "seek": 78690, "start": 802.4599999999999, "end": 807.5, "text": " needs to do a lot of storage IO and needs high performance or needs to be unprivileged.", "tokens": [51142, 2203, 281, 360, 257, 688, 295, 6725, 39839, 293, 2203, 1090, 3389, 420, 2203, 281, 312, 20994, 29994, 794, 3004, 13, 51394], "temperature": 0.0, "avg_logprob": -0.13410060470168655, "compression_ratio": 1.6224899598393574, "no_speech_prob": 0.01065162941813469}, {"id": 178, "seek": 78690, "start": 807.5, "end": 811.14, "text": " And that's why I'm talking about vhost user block today.", "tokens": [51394, 400, 300, 311, 983, 286, 478, 1417, 466, 371, 6037, 4195, 3461, 965, 13, 51576], "temperature": 0.0, "avg_logprob": -0.13410060470168655, "compression_ratio": 1.6224899598393574, "no_speech_prob": 0.01065162941813469}, {"id": 179, "seek": 78690, "start": 811.14, "end": 813.88, "text": " So let's have a look at the protocol.", "tokens": [51576, 407, 718, 311, 362, 257, 574, 412, 264, 10336, 13, 51713], "temperature": 0.0, "avg_logprob": -0.13410060470168655, "compression_ratio": 1.6224899598393574, "no_speech_prob": 0.01065162941813469}, {"id": 180, "seek": 81388, "start": 813.88, "end": 820.84, "text": " So the way that this is realized is that there is a Unix domain socket for our user space", "tokens": [50364, 407, 264, 636, 300, 341, 307, 5334, 307, 300, 456, 307, 257, 1156, 970, 9274, 19741, 337, 527, 4195, 1901, 50712], "temperature": 0.0, "avg_logprob": -0.17171085797823393, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.0006070563104003668}, {"id": 181, "seek": 81388, "start": 820.84, "end": 826.84, "text": " storage interface and we speak the vhost user protocol over the socket.", "tokens": [50712, 6725, 9226, 293, 321, 1710, 264, 371, 6037, 4195, 10336, 670, 264, 19741, 13, 51012], "temperature": 0.0, "avg_logprob": -0.17171085797823393, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.0006070563104003668}, {"id": 182, "seek": 81388, "start": 826.84, "end": 831.48, "text": " What the socket does and the vhost user protocol allows us to do is it lets us set up access", "tokens": [51012, 708, 264, 19741, 775, 293, 264, 371, 6037, 4195, 10336, 4045, 505, 281, 360, 307, 309, 6653, 505, 992, 493, 2105, 51244], "temperature": 0.0, "avg_logprob": -0.17171085797823393, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.0006070563104003668}, {"id": 183, "seek": 81388, "start": 831.48, "end": 837.92, "text": " to a virtual block device, so a block device that lives in the software defined storage", "tokens": [51244, 281, 257, 6374, 3461, 4302, 11, 370, 257, 3461, 4302, 300, 2909, 294, 264, 4722, 7642, 6725, 51566], "temperature": 0.0, "avg_logprob": -0.17171085797823393, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.0006070563104003668}, {"id": 184, "seek": 81388, "start": 837.92, "end": 839.16, "text": " process.", "tokens": [51566, 1399, 13, 51628], "temperature": 0.0, "avg_logprob": -0.17171085797823393, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.0006070563104003668}, {"id": 185, "seek": 81388, "start": 839.16, "end": 843.12, "text": " So when we have two processes running on a system, a software defined storage process", "tokens": [51628, 407, 562, 321, 362, 732, 7555, 2614, 322, 257, 1185, 11, 257, 4722, 7642, 6725, 1399, 51826], "temperature": 0.0, "avg_logprob": -0.17171085797823393, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.0006070563104003668}, {"id": 186, "seek": 84312, "start": 843.12, "end": 849.12, "text": " and an application, the application is using vhost user in order to communicate with the", "tokens": [50364, 293, 364, 3861, 11, 264, 3861, 307, 1228, 371, 6037, 4195, 294, 1668, 281, 7890, 365, 264, 50664], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 187, "seek": 84312, "start": 849.12, "end": 854.72, "text": " Verdeo block device and that's how it does its IO.", "tokens": [50664, 4281, 1479, 78, 3461, 4302, 293, 300, 311, 577, 309, 775, 1080, 39839, 13, 50944], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 188, "seek": 84312, "start": 854.72, "end": 855.88, "text": " So what is Verdeo block?", "tokens": [50944, 407, 437, 307, 4281, 1479, 78, 3461, 30, 51002], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 189, "seek": 84312, "start": 855.88, "end": 858.88, "text": " Verdeo block is a standard.", "tokens": [51002, 4281, 1479, 78, 3461, 307, 257, 3832, 13, 51152], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 190, "seek": 84312, "start": 858.88, "end": 860.72, "text": " You can check out the Verdeo specification.", "tokens": [51152, 509, 393, 1520, 484, 264, 4281, 1479, 78, 31256, 13, 51244], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 191, "seek": 84312, "start": 860.72, "end": 865.32, "text": " Verdeo has a number of other devices, but it includes Verdeo block.", "tokens": [51244, 4281, 1479, 78, 575, 257, 1230, 295, 661, 5759, 11, 457, 309, 5974, 4281, 1479, 78, 3461, 13, 51474], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 192, "seek": 84312, "start": 865.32, "end": 869.16, "text": " Some of the other devices are Verdeo net or Verdeo SCSI and so on.", "tokens": [51474, 2188, 295, 264, 661, 5759, 366, 4281, 1479, 78, 2533, 420, 4281, 1479, 78, 9028, 20262, 293, 370, 322, 13, 51666], "temperature": 0.0, "avg_logprob": -0.19880736411154806, "compression_ratio": 1.7922705314009661, "no_speech_prob": 0.022280389443039894}, {"id": 193, "seek": 86916, "start": 869.1999999999999, "end": 874.4399999999999, "text": " But Verdeo block is one we'll focus on here and it consists of one or more request queues", "tokens": [50366, 583, 4281, 1479, 78, 3461, 307, 472, 321, 603, 1879, 322, 510, 293, 309, 14689, 295, 472, 420, 544, 5308, 631, 1247, 50628], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 194, "seek": 86916, "start": 874.4399999999999, "end": 876.8399999999999, "text": " where you can place IO requests.", "tokens": [50628, 689, 291, 393, 1081, 39839, 12475, 13, 50748], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 195, "seek": 86916, "start": 876.8399999999999, "end": 879.0, "text": " And each one of these has a little structure.", "tokens": [50748, 400, 1184, 472, 295, 613, 575, 257, 707, 3877, 13, 50856], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 196, "seek": 86916, "start": 879.0, "end": 882.9599999999999, "text": " You can do all the requests I mentioned in the beginning of the talk, reads, writes,", "tokens": [50856, 509, 393, 360, 439, 264, 12475, 286, 2835, 294, 264, 2863, 295, 264, 751, 11, 15700, 11, 13657, 11, 51054], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 197, "seek": 86916, "start": 882.9599999999999, "end": 887.28, "text": " flushes, discard, write zero and so on.", "tokens": [51054, 19568, 279, 11, 31597, 11, 2464, 4018, 293, 370, 322, 13, 51270], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 198, "seek": 86916, "start": 887.28, "end": 891.0799999999999, "text": " And you have multiple queues, so if you want to do multi queue, say you're multi threaded,", "tokens": [51270, 400, 291, 362, 3866, 631, 1247, 11, 370, 498, 291, 528, 281, 360, 4825, 18639, 11, 584, 291, 434, 4825, 47493, 11, 51460], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 199, "seek": 86916, "start": 891.0799999999999, "end": 893.64, "text": " you can do that as well.", "tokens": [51460, 291, 393, 360, 300, 382, 731, 13, 51588], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 200, "seek": 86916, "start": 893.64, "end": 898.24, "text": " And it has a config space that describes the capabilities of the device.", "tokens": [51588, 400, 309, 575, 257, 6662, 1901, 300, 15626, 264, 10862, 295, 264, 4302, 13, 51818], "temperature": 0.0, "avg_logprob": -0.1572898424588717, "compression_ratio": 1.7275985663082438, "no_speech_prob": 0.014061377383768559}, {"id": 201, "seek": 89824, "start": 898.24, "end": 901.92, "text": " Like disk size, the number of queues and so on.", "tokens": [50364, 1743, 12355, 2744, 11, 264, 1230, 295, 631, 1247, 293, 370, 322, 13, 50548], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 202, "seek": 89824, "start": 901.92, "end": 905.48, "text": " So that's what you can think of Verdeo block as, that's the model we have here and that's", "tokens": [50548, 407, 300, 311, 437, 291, 393, 519, 295, 4281, 1479, 78, 3461, 382, 11, 300, 311, 264, 2316, 321, 362, 510, 293, 300, 311, 50726], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 203, "seek": 89824, "start": 905.48, "end": 909.88, "text": " the block device that our application can interact with.", "tokens": [50726, 264, 3461, 4302, 300, 527, 3861, 393, 4648, 365, 13, 50946], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 204, "seek": 89824, "start": 909.88, "end": 913.52, "text": " If you think of any other storage interfaces or network protocols that you're familiar", "tokens": [50946, 759, 291, 519, 295, 604, 661, 6725, 28416, 420, 3209, 20618, 300, 291, 434, 4963, 51128], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 205, "seek": 89824, "start": 913.52, "end": 917.6800000000001, "text": " with, this should be more or less familiar.", "tokens": [51128, 365, 11, 341, 820, 312, 544, 420, 1570, 4963, 13, 51336], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 206, "seek": 89824, "start": 917.6800000000001, "end": 920.6, "text": " Most of the existing protocols also work in this way.", "tokens": [51336, 4534, 295, 264, 6741, 20618, 611, 589, 294, 341, 636, 13, 51482], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 207, "seek": 89824, "start": 920.6, "end": 924.96, "text": " You can inquire about a device to find out its size and so on and then you can set up", "tokens": [51482, 509, 393, 13570, 621, 466, 257, 4302, 281, 915, 484, 1080, 2744, 293, 370, 322, 293, 550, 291, 393, 992, 493, 51700], "temperature": 0.0, "avg_logprob": -0.13173202673594156, "compression_ratio": 1.7481203007518797, "no_speech_prob": 0.008576152846217155}, {"id": 208, "seek": 92496, "start": 924.96, "end": 929.72, "text": " queues and you can submit IO.", "tokens": [50364, 631, 1247, 293, 291, 393, 10315, 39839, 13, 50602], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 209, "seek": 92496, "start": 929.72, "end": 933.2, "text": " So underneath Verdeo block, we have the VHOS user protocol.", "tokens": [50602, 407, 7223, 4281, 1479, 78, 3461, 11, 321, 362, 264, 691, 39, 4367, 4195, 10336, 13, 50776], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 210, "seek": 92496, "start": 933.2, "end": 937.6800000000001, "text": " And the VHOS user protocol is this Unix domain socket protocol that allows the two processes", "tokens": [50776, 400, 264, 691, 39, 4367, 4195, 10336, 307, 341, 1156, 970, 9274, 19741, 10336, 300, 4045, 264, 732, 7555, 51000], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 211, "seek": 92496, "start": 937.6800000000001, "end": 940.2800000000001, "text": " to communicate.", "tokens": [51000, 281, 7890, 13, 51130], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 212, "seek": 92496, "start": 940.2800000000001, "end": 941.76, "text": " But it's not the data path.", "tokens": [51130, 583, 309, 311, 406, 264, 1412, 3100, 13, 51204], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 213, "seek": 92496, "start": 941.76, "end": 947.6, "text": " So VHOS user is not how the application actually does IO, instead it's a control path that", "tokens": [51204, 407, 691, 39, 4367, 4195, 307, 406, 577, 264, 3861, 767, 775, 39839, 11, 2602, 309, 311, 257, 1969, 3100, 300, 51496], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 214, "seek": 92496, "start": 947.6, "end": 952.52, "text": " is used to set up access to these queues, these request queues that I've mentioned.", "tokens": [51496, 307, 1143, 281, 992, 493, 2105, 281, 613, 631, 1247, 11, 613, 5308, 631, 1247, 300, 286, 600, 2835, 13, 51742], "temperature": 0.0, "avg_logprob": -0.1447841197520763, "compression_ratio": 1.6778242677824269, "no_speech_prob": 0.02228209190070629}, {"id": 215, "seek": 95252, "start": 952.52, "end": 957.88, "text": " And the IO buffer memory and the queue memory actually belongs to the application.", "tokens": [50364, 400, 264, 39839, 21762, 4675, 293, 264, 18639, 4675, 767, 12953, 281, 264, 3861, 13, 50632], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 216, "seek": 95252, "start": 957.88, "end": 961.72, "text": " And the application sends it over the Unix domain socket.", "tokens": [50632, 400, 264, 3861, 14790, 309, 670, 264, 1156, 970, 9274, 19741, 13, 50824], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 217, "seek": 95252, "start": 961.72, "end": 967.48, "text": " It sends that shared memory over so that the software defined storage process has access", "tokens": [50824, 467, 14790, 300, 5507, 4675, 670, 370, 300, 264, 4722, 7642, 6725, 1399, 575, 2105, 51112], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 218, "seek": 95252, "start": 967.48, "end": 970.6, "text": " to the IO buffer memory and the queue memory.", "tokens": [51112, 281, 264, 39839, 21762, 4675, 293, 264, 18639, 4675, 13, 51268], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 219, "seek": 95252, "start": 970.6, "end": 975.3199999999999, "text": " The application and the software defined storage process, they share access to that memory.", "tokens": [51268, 440, 3861, 293, 264, 4722, 7642, 6725, 1399, 11, 436, 2073, 2105, 281, 300, 4675, 13, 51504], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 220, "seek": 95252, "start": 975.3199999999999, "end": 978.04, "text": " That way we can do zero copy.", "tokens": [51504, 663, 636, 321, 393, 360, 4018, 5055, 13, 51640], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 221, "seek": 95252, "start": 978.04, "end": 981.92, "text": " So this is going back to the message passing versus zero copy thing.", "tokens": [51640, 407, 341, 307, 516, 646, 281, 264, 3636, 8437, 5717, 4018, 5055, 551, 13, 51834], "temperature": 0.0, "avg_logprob": -0.10106934241528781, "compression_ratio": 2.061946902654867, "no_speech_prob": 0.036211494356393814}, {"id": 222, "seek": 98192, "start": 981.92, "end": 987.5999999999999, "text": " We don't need to transfer entire IO buffers between the two processes.", "tokens": [50364, 492, 500, 380, 643, 281, 5003, 2302, 39839, 9204, 433, 1296, 264, 732, 7555, 13, 50648], "temperature": 0.0, "avg_logprob": -0.12415832477611499, "compression_ratio": 1.6177777777777778, "no_speech_prob": 0.010326954536139965}, {"id": 223, "seek": 98192, "start": 987.5999999999999, "end": 993.12, "text": " Instead, the software defined storage process can just read the bytes out of the IO buffer", "tokens": [50648, 7156, 11, 264, 4722, 7642, 6725, 1399, 393, 445, 1401, 264, 36088, 484, 295, 264, 39839, 21762, 50924], "temperature": 0.0, "avg_logprob": -0.12415832477611499, "compression_ratio": 1.6177777777777778, "no_speech_prob": 0.010326954536139965}, {"id": 224, "seek": 98192, "start": 993.12, "end": 1001.5999999999999, "text": " that live in the application process and it can write the result into a buffer as well.", "tokens": [50924, 300, 1621, 294, 264, 3861, 1399, 293, 309, 393, 2464, 264, 1874, 666, 257, 21762, 382, 731, 13, 51348], "temperature": 0.0, "avg_logprob": -0.12415832477611499, "compression_ratio": 1.6177777777777778, "no_speech_prob": 0.010326954536139965}, {"id": 225, "seek": 98192, "start": 1001.5999999999999, "end": 1006.36, "text": " So if you want to look at the specification and the details of how VHOS user works, I've", "tokens": [51348, 407, 498, 291, 528, 281, 574, 412, 264, 31256, 293, 264, 4365, 295, 577, 691, 39, 4367, 4195, 1985, 11, 286, 600, 51586], "temperature": 0.0, "avg_logprob": -0.12415832477611499, "compression_ratio": 1.6177777777777778, "no_speech_prob": 0.010326954536139965}, {"id": 226, "seek": 98192, "start": 1006.36, "end": 1009.68, "text": " put a link on this slide.", "tokens": [51586, 829, 257, 2113, 322, 341, 4137, 13, 51752], "temperature": 0.0, "avg_logprob": -0.12415832477611499, "compression_ratio": 1.6177777777777778, "no_speech_prob": 0.010326954536139965}, {"id": 227, "seek": 100968, "start": 1009.68, "end": 1013.92, "text": " But really, if you're writing an application, I think the way to do it is to use LibBlockIo.", "tokens": [50364, 583, 534, 11, 498, 291, 434, 3579, 364, 3861, 11, 286, 519, 264, 636, 281, 360, 309, 307, 281, 764, 15834, 33, 4102, 40, 78, 13, 50576], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 228, "seek": 100968, "start": 1013.92, "end": 1020.4399999999999, "text": " LibBlockIo is a library that has both C and Rust APIs that allows you to connect to VHOS", "tokens": [50576, 15834, 33, 4102, 40, 78, 307, 257, 6405, 300, 575, 1293, 383, 293, 34952, 21445, 300, 4045, 291, 281, 1745, 281, 691, 39, 4367, 50902], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 229, "seek": 100968, "start": 1020.4399999999999, "end": 1023.52, "text": " user block as well as other storage interfaces.", "tokens": [50902, 4195, 3461, 382, 731, 382, 661, 6725, 28416, 13, 51056], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 230, "seek": 100968, "start": 1023.52, "end": 1028.1599999999999, "text": " So VHOS user block is not the only thing, but for the purposes of this talk, we'll just", "tokens": [51056, 407, 691, 39, 4367, 4195, 3461, 307, 406, 264, 787, 551, 11, 457, 337, 264, 9932, 295, 341, 751, 11, 321, 603, 445, 51288], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 231, "seek": 100968, "start": 1028.1599999999999, "end": 1030.76, "text": " focus on that.", "tokens": [51288, 1879, 322, 300, 13, 51418], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 232, "seek": 100968, "start": 1030.76, "end": 1033.76, "text": " LibBlockIo is not a framework, it's a library.", "tokens": [51418, 15834, 33, 4102, 40, 78, 307, 406, 257, 8388, 11, 309, 311, 257, 6405, 13, 51568], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 233, "seek": 100968, "start": 1033.76, "end": 1038.76, "text": " It allows you to integrate it into your application regardless of what your architecture is.", "tokens": [51568, 467, 4045, 291, 281, 13365, 309, 666, 428, 3861, 10060, 295, 437, 428, 9482, 307, 13, 51818], "temperature": 0.0, "avg_logprob": -0.177171592425583, "compression_ratio": 1.728937728937729, "no_speech_prob": 0.016400005668401718}, {"id": 234, "seek": 103876, "start": 1038.76, "end": 1044.96, "text": " That means it supports blocking IO, it supports event-driven IO, and it also supports polling.", "tokens": [50364, 663, 1355, 309, 9346, 17776, 39839, 11, 309, 9346, 2280, 12, 25456, 39839, 11, 293, 309, 611, 9346, 29518, 13, 50674], "temperature": 0.0, "avg_logprob": -0.11920467706827018, "compression_ratio": 1.7276595744680852, "no_speech_prob": 0.05337914824485779}, {"id": 235, "seek": 103876, "start": 1044.96, "end": 1049.84, "text": " So no matter how you've decided you want to do your application, you can use LibBlockIo.", "tokens": [50674, 407, 572, 1871, 577, 291, 600, 3047, 291, 528, 281, 360, 428, 3861, 11, 291, 393, 764, 15834, 33, 4102, 40, 78, 13, 50918], "temperature": 0.0, "avg_logprob": -0.11920467706827018, "compression_ratio": 1.7276595744680852, "no_speech_prob": 0.05337914824485779}, {"id": 236, "seek": 103876, "start": 1049.84, "end": 1056.44, "text": " You won't have to change the architecture of your application just to integrate LibBlockIo.", "tokens": [50918, 509, 1582, 380, 362, 281, 1319, 264, 9482, 295, 428, 3861, 445, 281, 13365, 15834, 33, 4102, 40, 78, 13, 51248], "temperature": 0.0, "avg_logprob": -0.11920467706827018, "compression_ratio": 1.7276595744680852, "no_speech_prob": 0.05337914824485779}, {"id": 237, "seek": 103876, "start": 1056.44, "end": 1059.6, "text": " I have given a full talk about LibBlockIo.", "tokens": [51248, 286, 362, 2212, 257, 1577, 751, 466, 15834, 33, 4102, 40, 78, 13, 51406], "temperature": 0.0, "avg_logprob": -0.11920467706827018, "compression_ratio": 1.7276595744680852, "no_speech_prob": 0.05337914824485779}, {"id": 238, "seek": 103876, "start": 1059.6, "end": 1063.16, "text": " So if you want to understand the details and also some of the background and everything", "tokens": [51406, 407, 498, 291, 528, 281, 1223, 264, 4365, 293, 611, 512, 295, 264, 3678, 293, 1203, 51584], "temperature": 0.0, "avg_logprob": -0.11920467706827018, "compression_ratio": 1.7276595744680852, "no_speech_prob": 0.05337914824485779}, {"id": 239, "seek": 106316, "start": 1063.16, "end": 1072.0, "text": " it can do, then please check out that talk, I put a YouTube link on this slide for you.", "tokens": [50364, 309, 393, 360, 11, 550, 1767, 1520, 484, 300, 751, 11, 286, 829, 257, 3088, 2113, 322, 341, 4137, 337, 291, 13, 50806], "temperature": 0.0, "avg_logprob": -0.15301811572202703, "compression_ratio": 1.5252100840336134, "no_speech_prob": 0.034613557159900665}, {"id": 240, "seek": 106316, "start": 1072.0, "end": 1074.72, "text": " I'll give you a short code example here.", "tokens": [50806, 286, 603, 976, 291, 257, 2099, 3089, 1365, 510, 13, 50942], "temperature": 0.0, "avg_logprob": -0.15301811572202703, "compression_ratio": 1.5252100840336134, "no_speech_prob": 0.034613557159900665}, {"id": 241, "seek": 106316, "start": 1074.72, "end": 1080.6000000000001, "text": " So this shows how to connect to a VHOS user block socket using LibBlockIo.", "tokens": [50942, 407, 341, 3110, 577, 281, 1745, 281, 257, 691, 39, 4367, 4195, 3461, 19741, 1228, 15834, 33, 4102, 40, 78, 13, 51236], "temperature": 0.0, "avg_logprob": -0.15301811572202703, "compression_ratio": 1.5252100840336134, "no_speech_prob": 0.034613557159900665}, {"id": 242, "seek": 106316, "start": 1080.6000000000001, "end": 1084.8400000000001, "text": " And this is pretty straightforward, we essentially just need to give it the path of the Unix", "tokens": [51236, 400, 341, 307, 1238, 15325, 11, 321, 4476, 445, 643, 281, 976, 309, 264, 3100, 295, 264, 1156, 970, 51448], "temperature": 0.0, "avg_logprob": -0.15301811572202703, "compression_ratio": 1.5252100840336134, "no_speech_prob": 0.034613557159900665}, {"id": 243, "seek": 106316, "start": 1084.8400000000001, "end": 1090.64, "text": " domain socket and then we connect and start the block IO instance.", "tokens": [51448, 9274, 19741, 293, 550, 321, 1745, 293, 722, 264, 3461, 39839, 5197, 13, 51738], "temperature": 0.0, "avg_logprob": -0.15301811572202703, "compression_ratio": 1.5252100840336134, "no_speech_prob": 0.034613557159900665}, {"id": 244, "seek": 109064, "start": 1090.64, "end": 1094.2, "text": " And then in order to do IO, we can submit a read request.", "tokens": [50364, 400, 550, 294, 1668, 281, 360, 39839, 11, 321, 393, 10315, 257, 1401, 5308, 13, 50542], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 245, "seek": 109064, "start": 1094.2, "end": 1097.8400000000001, "text": " That's just a function call, that's straightforward as well.", "tokens": [50542, 663, 311, 445, 257, 2445, 818, 11, 300, 311, 15325, 382, 731, 13, 50724], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 246, "seek": 109064, "start": 1097.8400000000001, "end": 1102.16, "text": " A notice here that we do get the queue, we call the get queue function in order to grab", "tokens": [50724, 316, 3449, 510, 300, 321, 360, 483, 264, 18639, 11, 321, 818, 264, 483, 18639, 2445, 294, 1668, 281, 4444, 50940], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 247, "seek": 109064, "start": 1102.16, "end": 1103.16, "text": " a queue.", "tokens": [50940, 257, 18639, 13, 50990], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 248, "seek": 109064, "start": 1103.16, "end": 1106.3600000000001, "text": " That's because LibBlockIo is a multi-queue library.", "tokens": [50990, 663, 311, 570, 15834, 33, 4102, 40, 78, 307, 257, 4825, 12, 1077, 622, 6405, 13, 51150], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 249, "seek": 109064, "start": 1106.3600000000001, "end": 1110.8000000000002, "text": " If you have a multi-threaded application, you could create one dedicated queue for each", "tokens": [51150, 759, 291, 362, 257, 4825, 12, 392, 2538, 292, 3861, 11, 291, 727, 1884, 472, 8374, 18639, 337, 1184, 51372], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 250, "seek": 109064, "start": 1110.8000000000002, "end": 1114.6000000000001, "text": " thread and then avoid any kind of locking and synchronization.", "tokens": [51372, 7207, 293, 550, 5042, 604, 733, 295, 23954, 293, 19331, 2144, 13, 51562], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 251, "seek": 109064, "start": 1114.6000000000001, "end": 1118.0800000000002, "text": " All the threads can do IO at the same time.", "tokens": [51562, 1057, 264, 19314, 393, 360, 39839, 412, 264, 912, 565, 13, 51736], "temperature": 0.0, "avg_logprob": -0.13551752586064375, "compression_ratio": 1.7047970479704797, "no_speech_prob": 0.03513536602258682}, {"id": 252, "seek": 111808, "start": 1118.08, "end": 1122.12, "text": " So for completion, what this example shows is it shows blocking completion.", "tokens": [50364, 407, 337, 19372, 11, 437, 341, 1365, 3110, 307, 309, 3110, 17776, 19372, 13, 50566], "temperature": 0.0, "avg_logprob": -0.13618552166482675, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0013249231269583106}, {"id": 253, "seek": 111808, "start": 1122.12, "end": 1128.9199999999998, "text": " So here the program is actually going to wait in the do IO function until the IO is complete.", "tokens": [50566, 407, 510, 264, 1461, 307, 767, 516, 281, 1699, 294, 264, 360, 39839, 2445, 1826, 264, 39839, 307, 3566, 13, 50906], "temperature": 0.0, "avg_logprob": -0.13618552166482675, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0013249231269583106}, {"id": 254, "seek": 111808, "start": 1128.9199999999998, "end": 1133.32, "text": " But as I mentioned, the library also supports event-driven IO and it also supports polling.", "tokens": [50906, 583, 382, 286, 2835, 11, 264, 6405, 611, 9346, 2280, 12, 25456, 39839, 293, 309, 611, 9346, 29518, 13, 51126], "temperature": 0.0, "avg_logprob": -0.13618552166482675, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0013249231269583106}, {"id": 255, "seek": 111808, "start": 1133.32, "end": 1139.52, "text": " So whatever you like, you'll be able to do that.", "tokens": [51126, 407, 2035, 291, 411, 11, 291, 603, 312, 1075, 281, 360, 300, 13, 51436], "temperature": 0.0, "avg_logprob": -0.13618552166482675, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0013249231269583106}, {"id": 256, "seek": 111808, "start": 1139.52, "end": 1143.32, "text": " If you develop your application, you'll need something to test against.", "tokens": [51436, 759, 291, 1499, 428, 3861, 11, 291, 603, 643, 746, 281, 1500, 1970, 13, 51626], "temperature": 0.0, "avg_logprob": -0.13618552166482675, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0013249231269583106}, {"id": 257, "seek": 114332, "start": 1143.32, "end": 1149.12, "text": " And I think the easiest way to test against the VOC user block device is to use the QEMU", "tokens": [50364, 400, 286, 519, 264, 12889, 636, 281, 1500, 1970, 264, 15216, 34, 4195, 3461, 4302, 307, 281, 764, 264, 1249, 6683, 52, 50654], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 258, "seek": 114332, "start": 1149.12, "end": 1150.36, "text": " storage daemon.", "tokens": [50654, 6725, 1120, 36228, 13, 50716], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 259, "seek": 114332, "start": 1150.36, "end": 1156.76, "text": " It's packaged for all the main Linux distros as part of the QEMU packages.", "tokens": [50716, 467, 311, 38162, 337, 439, 264, 2135, 18734, 1483, 2635, 382, 644, 295, 264, 1249, 6683, 52, 17401, 13, 51036], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 260, "seek": 114332, "start": 1156.76, "end": 1161.4399999999998, "text": " And you can just run the storage daemon, you can give it a raw image file and tell it the", "tokens": [51036, 400, 291, 393, 445, 1190, 264, 6725, 1120, 36228, 11, 291, 393, 976, 309, 257, 8936, 3256, 3991, 293, 980, 309, 264, 51270], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 261, "seek": 114332, "start": 1161.4399999999998, "end": 1167.8, "text": " name of a VOC user block UNIX domain socket that you want to have and then you can connect", "tokens": [51270, 1315, 295, 257, 15216, 34, 4195, 3461, 8229, 21124, 9274, 19741, 300, 291, 528, 281, 362, 293, 550, 291, 393, 1745, 51588], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 262, "seek": 114332, "start": 1167.8, "end": 1169.56, "text": " your application to it.", "tokens": [51588, 428, 3861, 281, 309, 13, 51676], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 263, "seek": 114332, "start": 1169.56, "end": 1172.8, "text": " All right, so that's how you can do that.", "tokens": [51676, 1057, 558, 11, 370, 300, 311, 577, 291, 393, 360, 300, 13, 51838], "temperature": 0.0, "avg_logprob": -0.17380329794134974, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.17090082168579102}, {"id": 264, "seek": 117280, "start": 1172.8, "end": 1179.04, "text": " If you want to implement a server, if you're already in the SPDK ecosystem and you're using", "tokens": [50364, 759, 291, 528, 281, 4445, 257, 7154, 11, 498, 291, 434, 1217, 294, 264, 19572, 42, 11311, 293, 291, 434, 1228, 50676], "temperature": 0.0, "avg_logprob": -0.14395234895789105, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.0426955446600914}, {"id": 265, "seek": 117280, "start": 1179.04, "end": 1185.8, "text": " Intel's software performance development kit in order to write your software defined", "tokens": [50676, 19762, 311, 4722, 3389, 3250, 8260, 294, 1668, 281, 2464, 428, 4722, 7642, 51014], "temperature": 0.0, "avg_logprob": -0.14395234895789105, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.0426955446600914}, {"id": 266, "seek": 117280, "start": 1185.8, "end": 1192.96, "text": " storage system, then it's very easy because VOC user block support is already built in.", "tokens": [51014, 6725, 1185, 11, 550, 309, 311, 588, 1858, 570, 15216, 34, 4195, 3461, 1406, 307, 1217, 3094, 294, 13, 51372], "temperature": 0.0, "avg_logprob": -0.14395234895789105, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.0426955446600914}, {"id": 267, "seek": 117280, "start": 1192.96, "end": 1195.8, "text": " So I've put a link to the documentation.", "tokens": [51372, 407, 286, 600, 829, 257, 2113, 281, 264, 14333, 13, 51514], "temperature": 0.0, "avg_logprob": -0.14395234895789105, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.0426955446600914}, {"id": 268, "seek": 117280, "start": 1195.8, "end": 1199.96, "text": " There are also RPCs if you want to invoke it from the command line.", "tokens": [51514, 821, 366, 611, 497, 12986, 82, 498, 291, 528, 281, 41117, 309, 490, 264, 5622, 1622, 13, 51722], "temperature": 0.0, "avg_logprob": -0.14395234895789105, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.0426955446600914}, {"id": 269, "seek": 119996, "start": 1199.96, "end": 1207.68, "text": " And just for testing, you can create a VOC user block server using this.", "tokens": [50364, 400, 445, 337, 4997, 11, 291, 393, 1884, 257, 15216, 34, 4195, 3461, 7154, 1228, 341, 13, 50750], "temperature": 0.0, "avg_logprob": -0.1479655901590983, "compression_ratio": 1.6161616161616161, "no_speech_prob": 0.025951027870178223}, {"id": 270, "seek": 119996, "start": 1207.68, "end": 1215.16, "text": " Now if you're not using SPDK, instead you're writing your own C daemon, your own process,", "tokens": [50750, 823, 498, 291, 434, 406, 1228, 19572, 42, 11, 2602, 291, 434, 3579, 428, 1065, 383, 1120, 36228, 11, 428, 1065, 1399, 11, 51124], "temperature": 0.0, "avg_logprob": -0.1479655901590983, "compression_ratio": 1.6161616161616161, "no_speech_prob": 0.025951027870178223}, {"id": 271, "seek": 119996, "start": 1215.16, "end": 1220.96, "text": " then one way of using VOC user block is to use the libvhostuser library.", "tokens": [51124, 550, 472, 636, 295, 1228, 15216, 34, 4195, 3461, 307, 281, 764, 264, 22854, 85, 6037, 18088, 6405, 13, 51414], "temperature": 0.0, "avg_logprob": -0.1479655901590983, "compression_ratio": 1.6161616161616161, "no_speech_prob": 0.025951027870178223}, {"id": 272, "seek": 119996, "start": 1220.96, "end": 1226.96, "text": " So this is a C library that implements the VOC user protocol, the server side of it.", "tokens": [51414, 407, 341, 307, 257, 383, 6405, 300, 704, 17988, 264, 15216, 34, 4195, 10336, 11, 264, 7154, 1252, 295, 309, 13, 51714], "temperature": 0.0, "avg_logprob": -0.1479655901590983, "compression_ratio": 1.6161616161616161, "no_speech_prob": 0.025951027870178223}, {"id": 273, "seek": 122696, "start": 1226.96, "end": 1230.76, "text": " So this will allow you to accept VOC user connections.", "tokens": [50364, 407, 341, 486, 2089, 291, 281, 3241, 15216, 34, 4195, 9271, 13, 50554], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 274, "seek": 122696, "start": 1230.76, "end": 1232.8400000000001, "text": " It doesn't actually implement verdioblock.", "tokens": [50554, 467, 1177, 380, 767, 4445, 1306, 4504, 996, 4102, 13, 50658], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 275, "seek": 122696, "start": 1232.8400000000001, "end": 1233.8400000000001, "text": " That's your job.", "tokens": [50658, 663, 311, 428, 1691, 13, 50708], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 276, "seek": 122696, "start": 1233.8400000000001, "end": 1236.64, "text": " That's the job of the software defined storage system.", "tokens": [50708, 663, 311, 264, 1691, 295, 264, 4722, 7642, 6725, 1185, 13, 50848], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 277, "seek": 122696, "start": 1236.64, "end": 1240.82, "text": " But verdioblock consists of basically just processing the IO requests like reads and", "tokens": [50848, 583, 1306, 4504, 996, 4102, 14689, 295, 1936, 445, 9007, 264, 39839, 12475, 411, 15700, 293, 51057], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 278, "seek": 122696, "start": 1240.82, "end": 1249.4, "text": " writes and so on, and also setting the configuration space so that the disk size is reported there.", "tokens": [51057, 13657, 293, 370, 322, 11, 293, 611, 3287, 264, 11694, 1901, 370, 300, 264, 12355, 2744, 307, 7055, 456, 13, 51486], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 279, "seek": 122696, "start": 1249.4, "end": 1254.8400000000001, "text": " And you can find an example of a C program that implements VOC user block using the VOC", "tokens": [51486, 400, 291, 393, 915, 364, 1365, 295, 257, 383, 1461, 300, 704, 17988, 15216, 34, 4195, 3461, 1228, 264, 15216, 34, 51758], "temperature": 0.0, "avg_logprob": -0.16405976785195842, "compression_ratio": 1.6679245283018869, "no_speech_prob": 0.06463359296321869}, {"id": 280, "seek": 125484, "start": 1254.84, "end": 1255.84, "text": " user.", "tokens": [50364, 4195, 13, 50414], "temperature": 0.0, "avg_logprob": -0.18193738003994556, "compression_ratio": 1.605, "no_speech_prob": 0.07155757397413254}, {"id": 281, "seek": 125484, "start": 1255.84, "end": 1258.9199999999998, "text": " I've put a link on the slide here for you.", "tokens": [50414, 286, 600, 829, 257, 2113, 322, 264, 4137, 510, 337, 291, 13, 50568], "temperature": 0.0, "avg_logprob": -0.18193738003994556, "compression_ratio": 1.605, "no_speech_prob": 0.07155757397413254}, {"id": 282, "seek": 125484, "start": 1258.9199999999998, "end": 1266.08, "text": " So that's how you can do it in C. In Rust, similarly, there is a library available for", "tokens": [50568, 407, 300, 311, 577, 291, 393, 360, 309, 294, 383, 13, 682, 34952, 11, 14138, 11, 456, 307, 257, 6405, 2435, 337, 50926], "temperature": 0.0, "avg_logprob": -0.18193738003994556, "compression_ratio": 1.605, "no_speech_prob": 0.07155757397413254}, {"id": 283, "seek": 125484, "start": 1266.08, "end": 1267.08, "text": " you.", "tokens": [50926, 291, 13, 50976], "temperature": 0.0, "avg_logprob": -0.18193738003994556, "compression_ratio": 1.605, "no_speech_prob": 0.07155757397413254}, {"id": 284, "seek": 125484, "start": 1267.08, "end": 1272.56, "text": " So there's the VOC user backend Rust crate, and it plays a similar role to the libvhostuser", "tokens": [50976, 407, 456, 311, 264, 15216, 34, 4195, 38087, 34952, 42426, 11, 293, 309, 5749, 257, 2531, 3090, 281, 264, 22854, 85, 6037, 18088, 51250], "temperature": 0.0, "avg_logprob": -0.18193738003994556, "compression_ratio": 1.605, "no_speech_prob": 0.07155757397413254}, {"id": 285, "seek": 125484, "start": 1272.56, "end": 1279.36, "text": " library for C. So this allows you to easily implement whatever VOC user device you want.", "tokens": [51250, 6405, 337, 383, 13, 407, 341, 4045, 291, 281, 3612, 4445, 2035, 15216, 34, 4195, 4302, 291, 528, 13, 51590], "temperature": 0.0, "avg_logprob": -0.18193738003994556, "compression_ratio": 1.605, "no_speech_prob": 0.07155757397413254}, {"id": 286, "seek": 127936, "start": 1279.36, "end": 1285.3999999999999, "text": " And in this case, it's your job to implement the verdioblock, just as I mentioned.", "tokens": [50364, 400, 294, 341, 1389, 11, 309, 311, 428, 1691, 281, 4445, 264, 1306, 4504, 996, 4102, 11, 445, 382, 286, 2835, 13, 50666], "temperature": 0.0, "avg_logprob": -0.17426981244768416, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.032586485147476196}, {"id": 287, "seek": 127936, "start": 1285.3999999999999, "end": 1292.6399999999999, "text": " Okay, now I still wanted to touch on one con that we hadn't covered yet, because we've", "tokens": [50666, 1033, 11, 586, 286, 920, 1415, 281, 2557, 322, 472, 416, 300, 321, 8782, 380, 5343, 1939, 11, 570, 321, 600, 51028], "temperature": 0.0, "avg_logprob": -0.17426981244768416, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.032586485147476196}, {"id": 288, "seek": 127936, "start": 1292.6399999999999, "end": 1298.7199999999998, "text": " explained how although a user space interface is complex and is more work than just using", "tokens": [51028, 8825, 577, 4878, 257, 4195, 1901, 9226, 307, 3997, 293, 307, 544, 589, 813, 445, 1228, 51332], "temperature": 0.0, "avg_logprob": -0.17426981244768416, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.032586485147476196}, {"id": 289, "seek": 127936, "start": 1298.7199999999998, "end": 1305.36, "text": " file descriptors and read and write, I think that the libvhostuser block and so on, these", "tokens": [51332, 3991, 31280, 830, 293, 1401, 293, 2464, 11, 286, 519, 300, 264, 22854, 85, 6037, 18088, 3461, 293, 370, 322, 11, 613, 51664], "temperature": 0.0, "avg_logprob": -0.17426981244768416, "compression_ratio": 1.5442477876106195, "no_speech_prob": 0.032586485147476196}, {"id": 290, "seek": 130536, "start": 1305.36, "end": 1309.4399999999998, "text": " libraries that are ready for you to integrate into your applications or software find storage", "tokens": [50364, 15148, 300, 366, 1919, 337, 291, 281, 13365, 666, 428, 5821, 420, 4722, 915, 6725, 50568], "temperature": 0.0, "avg_logprob": -0.1096001196345058, "compression_ratio": 1.7028985507246377, "no_speech_prob": 0.2280527949333191}, {"id": 291, "seek": 130536, "start": 1309.4399999999998, "end": 1316.6, "text": " systems, they take away that complexity, and they make the integration easier as well.", "tokens": [50568, 3652, 11, 436, 747, 1314, 300, 14024, 11, 293, 436, 652, 264, 10980, 3571, 382, 731, 13, 50926], "temperature": 0.0, "avg_logprob": -0.1096001196345058, "compression_ratio": 1.7028985507246377, "no_speech_prob": 0.2280527949333191}, {"id": 292, "seek": 130536, "start": 1316.6, "end": 1319.1599999999999, "text": " You don't need to duplicate code or write a lot of stuff.", "tokens": [50926, 509, 500, 380, 643, 281, 23976, 3089, 420, 2464, 257, 688, 295, 1507, 13, 51054], "temperature": 0.0, "avg_logprob": -0.1096001196345058, "compression_ratio": 1.7028985507246377, "no_speech_prob": 0.2280527949333191}, {"id": 293, "seek": 130536, "start": 1319.1599999999999, "end": 1321.7199999999998, "text": " But we're still left with one of the disadvantages.", "tokens": [51054, 583, 321, 434, 920, 1411, 365, 472, 295, 264, 37431, 13, 51182], "temperature": 0.0, "avg_logprob": -0.1096001196345058, "compression_ratio": 1.7028985507246377, "no_speech_prob": 0.2280527949333191}, {"id": 294, "seek": 130536, "start": 1321.7199999999998, "end": 1327.6, "text": " How do we connect this back to the kernel if it turns out we want to use some functionality", "tokens": [51182, 1012, 360, 321, 1745, 341, 646, 281, 264, 28256, 498, 309, 4523, 484, 321, 528, 281, 764, 512, 14980, 51476], "temperature": 0.0, "avg_logprob": -0.1096001196345058, "compression_ratio": 1.7028985507246377, "no_speech_prob": 0.2280527949333191}, {"id": 295, "seek": 130536, "start": 1327.6, "end": 1333.6799999999998, "text": " from the kernel storage stack, or if we have a legacy application that we can't port to", "tokens": [51476, 490, 264, 28256, 6725, 8630, 11, 420, 498, 321, 362, 257, 11711, 3861, 300, 321, 393, 380, 2436, 281, 51780], "temperature": 0.0, "avg_logprob": -0.1096001196345058, "compression_ratio": 1.7028985507246377, "no_speech_prob": 0.2280527949333191}, {"id": 296, "seek": 133368, "start": 1333.68, "end": 1337.2, "text": " use the user space interface.", "tokens": [50364, 764, 264, 4195, 1901, 9226, 13, 50540], "temperature": 0.0, "avg_logprob": -0.14028459979641822, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.04207621514797211}, {"id": 297, "seek": 133368, "start": 1337.2, "end": 1341.2, "text": " So for VOC user block, there is a solution here.", "tokens": [50540, 407, 337, 15216, 34, 4195, 3461, 11, 456, 307, 257, 3827, 510, 13, 50740], "temperature": 0.0, "avg_logprob": -0.14028459979641822, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.04207621514797211}, {"id": 298, "seek": 133368, "start": 1341.2, "end": 1346.72, "text": " There's a Linux VD use feature, which is relatively new.", "tokens": [50740, 821, 311, 257, 18734, 691, 35, 764, 4111, 11, 597, 307, 7226, 777, 13, 51016], "temperature": 0.0, "avg_logprob": -0.14028459979641822, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.04207621514797211}, {"id": 299, "seek": 133368, "start": 1346.72, "end": 1353.76, "text": " And what it does is it allows a VOC like device to be attached to the kernel.", "tokens": [51016, 400, 437, 309, 775, 307, 309, 4045, 257, 15216, 34, 411, 4302, 281, 312, 8570, 281, 264, 28256, 13, 51368], "temperature": 0.0, "avg_logprob": -0.14028459979641822, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.04207621514797211}, {"id": 300, "seek": 133368, "start": 1353.76, "end": 1357.8400000000001, "text": " So even though your software defined storage system is in user space, this gives you a", "tokens": [51368, 407, 754, 1673, 428, 4722, 7642, 6725, 1185, 307, 294, 4195, 1901, 11, 341, 2709, 291, 257, 51572], "temperature": 0.0, "avg_logprob": -0.14028459979641822, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.04207621514797211}, {"id": 301, "seek": 133368, "start": 1357.8400000000001, "end": 1361.24, "text": " way of attaching your block device to the kernel.", "tokens": [51572, 636, 295, 39074, 428, 3461, 4302, 281, 264, 28256, 13, 51742], "temperature": 0.0, "avg_logprob": -0.14028459979641822, "compression_ratio": 1.5909090909090908, "no_speech_prob": 0.04207621514797211}, {"id": 302, "seek": 136124, "start": 1361.24, "end": 1368.84, "text": " And then in the kernel, the VerdiO block driver will be used to communicate with your device.", "tokens": [50364, 400, 550, 294, 264, 28256, 11, 264, 4281, 4504, 46, 3461, 6787, 486, 312, 1143, 281, 7890, 365, 428, 4302, 13, 50744], "temperature": 0.0, "avg_logprob": -0.17312703813825334, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.004904729314148426}, {"id": 303, "seek": 136124, "start": 1368.84, "end": 1374.8, "text": " And what happens is that a devvda or devvdb block device node will appear, and your application", "tokens": [50744, 400, 437, 2314, 307, 300, 257, 1905, 85, 2675, 420, 1905, 85, 67, 65, 3461, 4302, 9984, 486, 4204, 11, 293, 428, 3861, 51042], "temperature": 0.0, "avg_logprob": -0.17312703813825334, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.004904729314148426}, {"id": 304, "seek": 136124, "start": 1374.8, "end": 1380.28, "text": " can open that like any other block device, and it can read and write and do everything", "tokens": [51042, 393, 1269, 300, 411, 604, 661, 3461, 4302, 11, 293, 309, 393, 1401, 293, 2464, 293, 360, 1203, 51316], "temperature": 0.0, "avg_logprob": -0.17312703813825334, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.004904729314148426}, {"id": 305, "seek": 136124, "start": 1380.28, "end": 1382.28, "text": " through there.", "tokens": [51316, 807, 456, 13, 51416], "temperature": 0.0, "avg_logprob": -0.17312703813825334, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.004904729314148426}, {"id": 306, "seek": 136124, "start": 1382.28, "end": 1388.44, "text": " One of the nice features of this is that because it's quite similar to VOC user block, the", "tokens": [51416, 1485, 295, 264, 1481, 4122, 295, 341, 307, 300, 570, 309, 311, 1596, 2531, 281, 15216, 34, 4195, 3461, 11, 264, 51724], "temperature": 0.0, "avg_logprob": -0.17312703813825334, "compression_ratio": 1.6754385964912282, "no_speech_prob": 0.004904729314148426}, {"id": 307, "seek": 138844, "start": 1388.44, "end": 1391.64, "text": " code can be largely shared.", "tokens": [50364, 3089, 393, 312, 11611, 5507, 13, 50524], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 308, "seek": 138844, "start": 1391.64, "end": 1396.3200000000002, "text": " I think the only difference would be that instead of having the V host user code, you", "tokens": [50524, 286, 519, 264, 787, 2649, 576, 312, 300, 2602, 295, 1419, 264, 691, 3975, 4195, 3089, 11, 291, 50758], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 309, "seek": 138844, "start": 1396.3200000000002, "end": 1401.8, "text": " would have the VD use code, which opens this character device that the VD use driver in", "tokens": [50758, 576, 362, 264, 691, 35, 764, 3089, 11, 597, 9870, 341, 2517, 4302, 300, 264, 691, 35, 764, 6787, 294, 51032], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 310, "seek": 138844, "start": 1401.8, "end": 1404.96, "text": " the kernel offers instead of a Unix domain socket.", "tokens": [51032, 264, 28256, 7736, 2602, 295, 257, 1156, 970, 9274, 19741, 13, 51190], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 311, "seek": 138844, "start": 1404.96, "end": 1407.56, "text": " And the setup and the control path is a little bit different.", "tokens": [51190, 400, 264, 8657, 293, 264, 1969, 3100, 307, 257, 707, 857, 819, 13, 51320], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 312, "seek": 138844, "start": 1407.56, "end": 1412.22, "text": " But the actual data path in the VerdiO block is still the same, so you can reuse that code.", "tokens": [51320, 583, 264, 3539, 1412, 3100, 294, 264, 4281, 4504, 46, 3461, 307, 920, 264, 912, 11, 370, 291, 393, 26225, 300, 3089, 13, 51553], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 313, "seek": 138844, "start": 1412.22, "end": 1416.48, "text": " So that's an effective way of doing it.", "tokens": [51553, 407, 300, 311, 364, 4942, 636, 295, 884, 309, 13, 51766], "temperature": 0.0, "avg_logprob": -0.13784974253075755, "compression_ratio": 1.702290076335878, "no_speech_prob": 0.012820053845643997}, {"id": 314, "seek": 141648, "start": 1416.76, "end": 1421.96, "text": " There's another new Linux feature that I wanted to mention that is interesting here, and also", "tokens": [50378, 821, 311, 1071, 777, 18734, 4111, 300, 286, 1415, 281, 2152, 300, 307, 1880, 510, 11, 293, 611, 50638], "temperature": 0.0, "avg_logprob": -0.21490283634351648, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.02800055406987667}, {"id": 315, "seek": 141648, "start": 1421.96, "end": 1425.96, "text": " a little bit more general, even outside of VOC's user block, and that's U block.", "tokens": [50638, 257, 707, 857, 544, 2674, 11, 754, 2380, 295, 15216, 34, 311, 4195, 3461, 11, 293, 300, 311, 624, 3461, 13, 50838], "temperature": 0.0, "avg_logprob": -0.21490283634351648, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.02800055406987667}, {"id": 316, "seek": 141648, "start": 1425.96, "end": 1431.3600000000001, "text": " U block is a new Linux interface for user space block IO, so that your software defined", "tokens": [50838, 624, 3461, 307, 257, 777, 18734, 9226, 337, 4195, 1901, 3461, 39839, 11, 370, 300, 428, 4722, 7642, 51108], "temperature": 0.0, "avg_logprob": -0.21490283634351648, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.02800055406987667}, {"id": 317, "seek": 141648, "start": 1431.3600000000001, "end": 1438.76, "text": " storage system can present host kernel block devices.", "tokens": [51108, 6725, 1185, 393, 1974, 3975, 28256, 3461, 5759, 13, 51478], "temperature": 0.0, "avg_logprob": -0.21490283634351648, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.02800055406987667}, {"id": 318, "seek": 141648, "start": 1438.76, "end": 1444.88, "text": " So you can have your block device and process it in user space.", "tokens": [51478, 407, 291, 393, 362, 428, 3461, 4302, 293, 1399, 309, 294, 4195, 1901, 13, 51784], "temperature": 0.0, "avg_logprob": -0.21490283634351648, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.02800055406987667}, {"id": 319, "seek": 144488, "start": 1444.88, "end": 1447.1200000000001, "text": " And it uses IO U ring.", "tokens": [50364, 400, 309, 4960, 39839, 624, 4875, 13, 50476], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 320, "seek": 144488, "start": 1447.1200000000001, "end": 1450.96, "text": " It's an exciting feature, and it's pretty interesting, so I've left the link here.", "tokens": [50476, 467, 311, 364, 4670, 4111, 11, 293, 309, 311, 1238, 1880, 11, 370, 286, 600, 1411, 264, 2113, 510, 13, 50668], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 321, "seek": 144488, "start": 1450.96, "end": 1456.72, "text": " The only thing with this is that compared to VD use, it does not reuse or share any", "tokens": [50668, 440, 787, 551, 365, 341, 307, 300, 5347, 281, 691, 35, 764, 11, 309, 775, 406, 26225, 420, 2073, 604, 50956], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 322, "seek": 144488, "start": 1456.72, "end": 1459.0400000000002, "text": " of the V host user block stuff.", "tokens": [50956, 295, 264, 691, 3975, 4195, 3461, 1507, 13, 51072], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 323, "seek": 144488, "start": 1459.0400000000002, "end": 1463.2800000000002, "text": " So if you already have V host user block support in your software defined storage system, or", "tokens": [51072, 407, 498, 291, 1217, 362, 691, 3975, 4195, 3461, 1406, 294, 428, 4722, 7642, 6725, 1185, 11, 420, 51284], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 324, "seek": 144488, "start": 1463.2800000000002, "end": 1467.96, "text": " you just want to streamline things, then U block is kind of a whole different interface", "tokens": [51284, 291, 445, 528, 281, 47141, 721, 11, 550, 624, 3461, 307, 733, 295, 257, 1379, 819, 9226, 51518], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 325, "seek": 144488, "start": 1467.96, "end": 1469.0400000000002, "text": " that you have to integrate.", "tokens": [51518, 300, 291, 362, 281, 13365, 13, 51572], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 326, "seek": 144488, "start": 1469.0400000000002, "end": 1473.6000000000001, "text": " So that's the only disadvantage, but I think it's pretty exciting too.", "tokens": [51572, 407, 300, 311, 264, 787, 24292, 11, 457, 286, 519, 309, 311, 1238, 4670, 886, 13, 51800], "temperature": 0.0, "avg_logprob": -0.16707430619459887, "compression_ratio": 1.6755852842809364, "no_speech_prob": 0.08032549172639847}, {"id": 327, "seek": 147360, "start": 1474.52, "end": 1481.0, "text": " Okay, so to summarize, if you need a user space block IO interface for the performance,", "tokens": [50410, 1033, 11, 370, 281, 20858, 11, 498, 291, 643, 257, 4195, 1901, 3461, 39839, 9226, 337, 264, 3389, 11, 50734], "temperature": 0.0, "avg_logprob": -0.2592096223935976, "compression_ratio": 1.4253393665158371, "no_speech_prob": 0.001324842101894319}, {"id": 328, "seek": 147360, "start": 1481.0, "end": 1487.4399999999998, "text": " or because you need to be able to do unprivileged IO, or for security, then implement VOC's", "tokens": [50734, 420, 570, 291, 643, 281, 312, 1075, 281, 360, 20994, 29994, 794, 3004, 39839, 11, 420, 337, 3825, 11, 550, 4445, 15216, 34, 311, 51056], "temperature": 0.0, "avg_logprob": -0.2592096223935976, "compression_ratio": 1.4253393665158371, "no_speech_prob": 0.001324842101894319}, {"id": 329, "seek": 147360, "start": 1487.4399999999998, "end": 1488.4399999999998, "text": " user block.", "tokens": [51056, 4195, 3461, 13, 51106], "temperature": 0.0, "avg_logprob": -0.2592096223935976, "compression_ratio": 1.4253393665158371, "no_speech_prob": 0.001324842101894319}, {"id": 330, "seek": 147360, "start": 1488.4399999999998, "end": 1491.52, "text": " There are open specs, code, and community.", "tokens": [51106, 821, 366, 1269, 27911, 11, 3089, 11, 293, 1768, 13, 51260], "temperature": 0.0, "avg_logprob": -0.2592096223935976, "compression_ratio": 1.4253393665158371, "no_speech_prob": 0.001324842101894319}, {"id": 331, "seek": 147360, "start": 1491.52, "end": 1494.52, "text": " Please let me know if you have any questions, and thank you.", "tokens": [51260, 2555, 718, 385, 458, 498, 291, 362, 604, 1651, 11, 293, 1309, 291, 13, 51410], "temperature": 0.0, "avg_logprob": -0.2592096223935976, "compression_ratio": 1.4253393665158371, "no_speech_prob": 0.001324842101894319}, {"id": 332, "seek": 147360, "start": 1494.52, "end": 1495.1999999999998, "text": " Have great FOS-DAM!", "tokens": [51410, 3560, 869, 479, 4367, 12, 35, 2865, 0, 51444], "temperature": 0.0, "avg_logprob": -0.2592096223935976, "compression_ratio": 1.4253393665158371, "no_speech_prob": 0.001324842101894319}, {"id": 333, "seek": 150360, "start": 1503.6, "end": 1504.6, "text": " Thanks for watching.", "tokens": [50364, 2561, 337, 1976, 13, 50414], "temperature": 0.4, "avg_logprob": -0.7624364332719282, "compression_ratio": 0.8769230769230769, "no_speech_prob": 0.9988890290260315}, {"id": 334, "seek": 150360, "start": 1504.6, "end": 1505.6, "text": " I'll see you in the next video.", "tokens": [50414, 286, 603, 536, 291, 294, 264, 958, 960, 13, 50464], "temperature": 0.4, "avg_logprob": -0.7624364332719282, "compression_ratio": 0.8769230769230769, "no_speech_prob": 0.9988890290260315}, {"id": 335, "seek": 150360, "start": 1505.6, "end": 1505.6, "text": "", "tokens": [], "temperature": 0.4, "avg_logprob": -0.7624364332719282, "compression_ratio": 0.8769230769230769, "no_speech_prob": 0.9988890290260315, "words": []}], "language": "en"}