{"text": " Let's move on everyone. So we have to keep the schedule and to keep the pace for all our viewers online and the rest of FOSDEM. So for this next talk we are welcoming Romain We are going to talk about dependency injections. Please give Romain a warm welcome. So thank you for having me. I'm really glad to be here with you. I'm Romain Boacelle and today I will guide you through our journey of improving the use of codeine and dependency injection library using KSP. So you already seen that commercial art so I'll make it really quick. I'm really happy to work with Salomon on advocating as well as providing services and trainings on codeine and I'm really grateful that TreadBrains is rewarding us years after years. So let's talk about the real subject here, open source. So we are maintaining a set of codeine multi-platform independent tools that are compatible on every target on which we can compile codeine and obviously today we're going to talk about dependency injection with codeine. So let's team up and see what are our problems today and how we are trying to solve them with KSP. First a little bit of context on why we are using dependency injection in our applications. So let's assume that I have a view model that needs multiple instances of use cases. So I will need to initialize every one of those use cases and their dependencies and so on. So to avoid managing those initializations we often use the dependency injection pattern. In dependency injection the DI container has the responsibility to initialize every instances we need to make our objects works and so we can lazily retrieve them with a simple function call. So here we see that we used a generic function that is called instance or we often see get inject or whatever. In some other libraries our framework we often see a huge amount of annotations. So that sounds like magic to a lot of people. Another problem with the generic instance function is that I don't really know what is behind it. Is it a single term, a factory, do I need to pass an argument? I don't really know. Another problem comes with the DI binding declaration. As a maintainer I know what's behind all that but it can be confusing for newcomers. And on top of that there is no compilation checks. So this means that if you missed, if you forgot some bindings you will probably know it when your application crashes or in most cases in your dashboard. So did we just create a monster? Not quite. But there is still room for improvement. So let's do what we do best and refactor everything to get a better API and improve the use of code in. So let's welcome KSP. It stands for Kotlin Symbol Processor. A Kotlin Symbol Processor is a metaprogramming tool that allows us to generate code generally based on some existing code base. Symbol Processor are generally used with annotations that are used to mark our code that needs a special treatment by the processor. In short terms it's a lightweight compiler plugin that because it can just generate code and not modify some. A quick example here I have a full interface that is annotated to be processed. So a Kotlin Symbol Processor should be able to generate a concrete class of this full interface overriding the check function. So back to our initial problem. What do we need to improve the Kotlin API? First we need a readable and typed API to be able to avoid the use of this generic function instance everywhere. As we cannot easily have compile checks, at least we want an easy way to check the dependency container consistency with a few lines of unit tests. Note that the API you'll see today are still working progressive. They may change a little before landing on the release. So the main idea is that you should be able to declare one or more interfaces that represents the dependencies you need in your applications and that's the one that you need to retrieve at least. So after that we need to annotate our interface so that the Kotlin Symbol Processor should be able to generate some code to interact with the DI container to retrieve your dependencies in a typed way. So let's introduce the result annotation for that. Once we have annotated our interface, the Kotlin Symbol Processor should be able to detect and generate code for us. So in that case, you will see that we need a parameter to create a browser service so it will know that we need to interact with a factory that needs a string as parameter to get a browser service instance as well as the controller functions needs to return a simple instance depending on the context. Here is what the Kotlin Symbol Processor will generate for us. A concrete class implementing our app dependencies interface and that needs a DI container as input. So the DI container will be used to retrieve the proper instances here either a factory because it can detect that we need a parameter or a simple instance for the controller. Now let's see how we can use it in our application code. So first we need to declare our DI bindings so our implementation should be able to interact with. For that, we still use our current API of Kotlin's DSL or it will improve it a little bit but we will keep it as well as it is. Why? Because we have history with solutions like daggers that have gone wild with annotations. Even so, it's where Kotlin was created in the first place to avoid that forest of annotations. So we didn't want to introduce tons of annotations again and go full circle. Finally, we think our binding declaration API is good enough to express our dependencies. So here are the dependencies we need to meet the app dependencies interface contract. We need factories that take a string and return a service and a single tons that return an instance of a controller that itself needs an instance of a service. Welcome to that later. So now we can instantiate the generated class with our DI container and retrieve our dependencies with a truly typed API. As we don't want our user to know how we are generating our function or class implementation, sorry, we also introduced an extension function that helps us instantiate the app dependencies for us. So now that we are able to retrieve our dependencies with a truly typed API, let's see how we can check their consistency. For that, we introduced a DI resolver interface that only needs to respect the contract of a check function. So now we can combine the DI resolver interface with an atresolve annotation. In an ideal world, the atresolve annotation should be able to add that DI resolver type to our interface itself. But as we are using Kotlin symbol processor, we can just generate some code and not modify existing one. So now that we are fully packed with our annotation and our DI resolver interface, the code in the symbol processor will be able to generate the override and function check and create a requirement for everyone of the function or accessor we have defined in our app dependency interface. Before, with that code, you will have taken the risk to go in production without easily knowing if you forgot some bindings. No more. Now we just add a test and as we saw before, we instantiate our app dependencies interface with a concrete class and just call the check function. That way, if you missed a binding, your test suite will warn you instantly with a proper message. So here, we saw that we missed a factory binding that returns a broad service and takes a string argument as input. One more thing. Earlier, we saw that the code in binding DSL was impacted with the use of those instance functions. So let's see how we can improve this user as well. Let's take this example. When I need a controller that needs itself a use case, that also needs a service. Here is the binding we will have defined to meet our architecture expectation. So you probably have seen me coming with those instance functions. In the explicit world, we will have written those functions with their targeted type so we saw that we need a service and a use case. So why not using a type API and get this instance directly? This is not that simple because in the code in DSL, this is a type DI builder. So it doesn't know anything about the app dependencies API. Thus, the code in the symbol processor will also generate a new function for us that is called off with the name of the app dependencies contract we have. Thus, it creates a new DI builder that is aware of the DI building API and the app dependencies. Allowing us to call straight functions to get our instances as long as they are part of the app dependencies API, obviously. So as a result of type dependencies, I can now easily check the consistency of my DI container or retrieve dependencies in my application. So I feel the tension and excitement in the room, right? No? Same question on everybody's mind. Is this live? So I can spoil it earlier. It's still a work in progress and we still have some corner cases to crack, like how to use tags, how to manage modules, how to declare and handle scopes and context is and a few more. Here is a sneak peek of some ideas we have to solve those problems. An easy one is the tag API when we can retrieve a dependencies by passing a tag parameter. We could add an annotation with that tag and easily retrieve our dependencies without having to pass or know the tag that is needed behind. For the module management, we could just provide two ways to interact with dependencies either with a fully packed DI container or a DI module or add some parameters or annotations or either create a new annotations again. We'll see. Maybe not. A more complicated use case is how to handle scopes. With code ends, we can define some bindings that are with some life cycle depending on the scope or context and retrieve them with their own function. So to define a scope with a KSP, we could define that a contract is scoped entirely and then be able to retrieve our dependencies with the right context. Maybe this rings a bell. It sounds like context receivers, right? But unfortunately, context receivers are not available in Kotlin multi-platform yet, so we'll have to find another way. Also, we have plenty of ideas to make this work. This is an open source project, so obviously, if you want to contribute, you're welcome. That's it for me. Thank you for hearing me. If you have some questions, I think we have time for it. Thank you very much again. We do have quite a lot of time for questions now, so please raise your hand if you have any. Just shout it and you will have to repeat it. So the question is, is there some support in the IDE? So as for the mocking library, you will need to build your code the first time to be able to have the right APIs, like the new function and the off-app dependencies function, for example. No. All right. I think it's clear. One question. With this dependency injection framework, are all dependencies compiled statically, like the dependency injection part, or is that still dynamic runtime? So the dependencies injection are resolved statically or at runtime? Is this your question? So they are resolved at runtime, but as we saw, we provide tools to check that all your bindings are well-defined with your test suite, but they are resolved at runtime. There is no reflection like Salomon showed you earlier. That's how Dagger works, for example. So it's basically the best focus between Spring and Dagger. There was another. I think it's a bit of an obvious question. The question is how does it compete with coin? I think we have taken different routes with coin. I think Arnault will present you this afternoon. It provides an API using annotation, more that we are doing. We prefer keeping the binding declaration as much explicit as possible. After that, I think it's more some internal implementation that does not really compete, I think.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 12.68, "text": " Let's move on everyone. So we have to keep the schedule and to keep the pace for all", "tokens": [961, 311, 1286, 322, 1518, 13, 407, 321, 362, 281, 1066, 264, 7567, 293, 281, 1066, 264, 11638, 337, 439], "temperature": 0.0, "avg_logprob": -0.3884766896565755, "compression_ratio": 1.3206106870229009, "no_speech_prob": 0.33075031638145447}, {"id": 1, "seek": 0, "start": 12.68, "end": 20.88, "text": " our viewers online and the rest of FOSDEM. So for this next talk we are welcoming Romain", "tokens": [527, 8499, 2950, 293, 264, 1472, 295, 479, 4367, 35, 6683, 13, 407, 337, 341, 958, 751, 321, 366, 17378, 10141, 491], "temperature": 0.0, "avg_logprob": -0.3884766896565755, "compression_ratio": 1.3206106870229009, "no_speech_prob": 0.33075031638145447}, {"id": 2, "seek": 2088, "start": 20.88, "end": 31.88, "text": " We are going to talk about dependency injections. Please give Romain a warm welcome.", "tokens": [492, 366, 516, 281, 751, 466, 33621, 47178, 13, 2555, 976, 10141, 491, 257, 4561, 2928, 13], "temperature": 0.0, "avg_logprob": -0.3225887780902029, "compression_ratio": 1.5605381165919283, "no_speech_prob": 0.0011323627550154924}, {"id": 3, "seek": 2088, "start": 31.88, "end": 37.76, "text": " So thank you for having me. I'm really glad to be here with you. I'm Romain Boacelle and", "tokens": [407, 1309, 291, 337, 1419, 385, 13, 286, 478, 534, 5404, 281, 312, 510, 365, 291, 13, 286, 478, 10141, 491, 3286, 617, 2447, 293], "temperature": 0.0, "avg_logprob": -0.3225887780902029, "compression_ratio": 1.5605381165919283, "no_speech_prob": 0.0011323627550154924}, {"id": 4, "seek": 2088, "start": 37.76, "end": 44.36, "text": " today I will guide you through our journey of improving the use of codeine and dependency", "tokens": [965, 286, 486, 5934, 291, 807, 527, 4671, 295, 11470, 264, 764, 295, 3089, 533, 293, 33621], "temperature": 0.0, "avg_logprob": -0.3225887780902029, "compression_ratio": 1.5605381165919283, "no_speech_prob": 0.0011323627550154924}, {"id": 5, "seek": 2088, "start": 44.36, "end": 50.480000000000004, "text": " injection library using KSP. So you already seen that commercial art so I'll make it", "tokens": [22873, 6405, 1228, 591, 27921, 13, 407, 291, 1217, 1612, 300, 6841, 1523, 370, 286, 603, 652, 309], "temperature": 0.0, "avg_logprob": -0.3225887780902029, "compression_ratio": 1.5605381165919283, "no_speech_prob": 0.0011323627550154924}, {"id": 6, "seek": 5048, "start": 50.48, "end": 55.879999999999995, "text": " really quick. I'm really happy to work with Salomon on advocating as well as providing", "tokens": [534, 1702, 13, 286, 478, 534, 2055, 281, 589, 365, 5996, 24488, 322, 32050, 382, 731, 382, 6530], "temperature": 0.0, "avg_logprob": -0.19532906458928034, "compression_ratio": 1.4802259887005649, "no_speech_prob": 0.00019344754400663078}, {"id": 7, "seek": 5048, "start": 55.879999999999995, "end": 63.559999999999995, "text": " services and trainings on codeine and I'm really grateful that TreadBrains is rewarding", "tokens": [3328, 293, 33856, 322, 3089, 533, 293, 286, 478, 534, 7941, 300, 314, 2538, 45606, 1292, 307, 20063], "temperature": 0.0, "avg_logprob": -0.19532906458928034, "compression_ratio": 1.4802259887005649, "no_speech_prob": 0.00019344754400663078}, {"id": 8, "seek": 5048, "start": 63.559999999999995, "end": 72.36, "text": " us years after years. So let's talk about the real subject here, open source. So we are", "tokens": [505, 924, 934, 924, 13, 407, 718, 311, 751, 466, 264, 957, 3983, 510, 11, 1269, 4009, 13, 407, 321, 366], "temperature": 0.0, "avg_logprob": -0.19532906458928034, "compression_ratio": 1.4802259887005649, "no_speech_prob": 0.00019344754400663078}, {"id": 9, "seek": 7236, "start": 72.36, "end": 79.84, "text": " maintaining a set of codeine multi-platform independent tools that are compatible on", "tokens": [14916, 257, 992, 295, 3089, 533, 4825, 12, 39975, 837, 6695, 3873, 300, 366, 18218, 322], "temperature": 0.0, "avg_logprob": -0.17694876988728842, "compression_ratio": 1.5562130177514792, "no_speech_prob": 0.00020383762603159994}, {"id": 10, "seek": 7236, "start": 79.84, "end": 86.12, "text": " every target on which we can compile codeine and obviously today we're going to talk about", "tokens": [633, 3779, 322, 597, 321, 393, 31413, 3089, 533, 293, 2745, 965, 321, 434, 516, 281, 751, 466], "temperature": 0.0, "avg_logprob": -0.17694876988728842, "compression_ratio": 1.5562130177514792, "no_speech_prob": 0.00020383762603159994}, {"id": 11, "seek": 7236, "start": 86.12, "end": 92.8, "text": " dependency injection with codeine. So let's team up and see what are our problems today", "tokens": [33621, 22873, 365, 3089, 533, 13, 407, 718, 311, 1469, 493, 293, 536, 437, 366, 527, 2740, 965], "temperature": 0.0, "avg_logprob": -0.17694876988728842, "compression_ratio": 1.5562130177514792, "no_speech_prob": 0.00020383762603159994}, {"id": 12, "seek": 9280, "start": 92.8, "end": 103.44, "text": " and how we are trying to solve them with KSP. First a little bit of context on why we are", "tokens": [293, 577, 321, 366, 1382, 281, 5039, 552, 365, 591, 27921, 13, 2386, 257, 707, 857, 295, 4319, 322, 983, 321, 366], "temperature": 0.0, "avg_logprob": -0.12438479336825284, "compression_ratio": 1.4516129032258065, "no_speech_prob": 0.0005282018682919443}, {"id": 13, "seek": 9280, "start": 103.44, "end": 109.12, "text": " using dependency injection in our applications. So let's assume that I have a view model that", "tokens": [1228, 33621, 22873, 294, 527, 5821, 13, 407, 718, 311, 6552, 300, 286, 362, 257, 1910, 2316, 300], "temperature": 0.0, "avg_logprob": -0.12438479336825284, "compression_ratio": 1.4516129032258065, "no_speech_prob": 0.0005282018682919443}, {"id": 14, "seek": 9280, "start": 109.12, "end": 115.92, "text": " needs multiple instances of use cases. So I will need to initialize every one of those", "tokens": [2203, 3866, 14519, 295, 764, 3331, 13, 407, 286, 486, 643, 281, 5883, 1125, 633, 472, 295, 729], "temperature": 0.0, "avg_logprob": -0.12438479336825284, "compression_ratio": 1.4516129032258065, "no_speech_prob": 0.0005282018682919443}, {"id": 15, "seek": 11592, "start": 115.92, "end": 124.68, "text": " use cases and their dependencies and so on. So to avoid managing those initializations", "tokens": [764, 3331, 293, 641, 36606, 293, 370, 322, 13, 407, 281, 5042, 11642, 729, 5883, 14455], "temperature": 0.0, "avg_logprob": -0.16313094752175467, "compression_ratio": 1.6524390243902438, "no_speech_prob": 0.00027267466066405177}, {"id": 16, "seek": 11592, "start": 124.68, "end": 132.32, "text": " we often use the dependency injection pattern. In dependency injection the DI container has", "tokens": [321, 2049, 764, 264, 33621, 22873, 5102, 13, 682, 33621, 22873, 264, 11953, 10129, 575], "temperature": 0.0, "avg_logprob": -0.16313094752175467, "compression_ratio": 1.6524390243902438, "no_speech_prob": 0.00027267466066405177}, {"id": 17, "seek": 11592, "start": 132.32, "end": 144.04, "text": " the responsibility to initialize every instances we need to make our objects works and so we", "tokens": [264, 6357, 281, 5883, 1125, 633, 14519, 321, 643, 281, 652, 527, 6565, 1985, 293, 370, 321], "temperature": 0.0, "avg_logprob": -0.16313094752175467, "compression_ratio": 1.6524390243902438, "no_speech_prob": 0.00027267466066405177}, {"id": 18, "seek": 14404, "start": 144.04, "end": 153.76, "text": " can lazily retrieve them with a simple function call. So here we see that we used a generic", "tokens": [393, 19320, 953, 30254, 552, 365, 257, 2199, 2445, 818, 13, 407, 510, 321, 536, 300, 321, 1143, 257, 19577], "temperature": 0.0, "avg_logprob": -0.21522305088658486, "compression_ratio": 1.5773809523809523, "no_speech_prob": 9.960427269106731e-05}, {"id": 19, "seek": 14404, "start": 153.76, "end": 162.48, "text": " function that is called instance or we often see get inject or whatever. In some other", "tokens": [2445, 300, 307, 1219, 5197, 420, 321, 2049, 536, 483, 10711, 420, 2035, 13, 682, 512, 661], "temperature": 0.0, "avg_logprob": -0.21522305088658486, "compression_ratio": 1.5773809523809523, "no_speech_prob": 9.960427269106731e-05}, {"id": 20, "seek": 14404, "start": 162.48, "end": 170.28, "text": " libraries our framework we often see a huge amount of annotations. So that sounds like", "tokens": [15148, 527, 8388, 321, 2049, 536, 257, 2603, 2372, 295, 25339, 763, 13, 407, 300, 3263, 411], "temperature": 0.0, "avg_logprob": -0.21522305088658486, "compression_ratio": 1.5773809523809523, "no_speech_prob": 9.960427269106731e-05}, {"id": 21, "seek": 17028, "start": 170.28, "end": 177.76, "text": " magic to a lot of people. Another problem with the generic instance function is that", "tokens": [5585, 281, 257, 688, 295, 561, 13, 3996, 1154, 365, 264, 19577, 5197, 2445, 307, 300], "temperature": 0.0, "avg_logprob": -0.15677811882712625, "compression_ratio": 1.5688622754491017, "no_speech_prob": 0.0002632436517160386}, {"id": 22, "seek": 17028, "start": 177.76, "end": 184.28, "text": " I don't really know what is behind it. Is it a single term, a factory, do I need to pass", "tokens": [286, 500, 380, 534, 458, 437, 307, 2261, 309, 13, 1119, 309, 257, 2167, 1433, 11, 257, 9265, 11, 360, 286, 643, 281, 1320], "temperature": 0.0, "avg_logprob": -0.15677811882712625, "compression_ratio": 1.5688622754491017, "no_speech_prob": 0.0002632436517160386}, {"id": 23, "seek": 17028, "start": 184.28, "end": 195.6, "text": " an argument? I don't really know. Another problem comes with the DI binding declaration.", "tokens": [364, 6770, 30, 286, 500, 380, 534, 458, 13, 3996, 1154, 1487, 365, 264, 11953, 17359, 27606, 13], "temperature": 0.0, "avg_logprob": -0.15677811882712625, "compression_ratio": 1.5688622754491017, "no_speech_prob": 0.0002632436517160386}, {"id": 24, "seek": 19560, "start": 195.6, "end": 201.6, "text": " As a maintainer I know what's behind all that but it can be confusing for newcomers. And", "tokens": [1018, 257, 6909, 260, 286, 458, 437, 311, 2261, 439, 300, 457, 309, 393, 312, 13181, 337, 40014, 433, 13, 400], "temperature": 0.0, "avg_logprob": -0.16945441801156572, "compression_ratio": 1.5, "no_speech_prob": 0.0002206096105510369}, {"id": 25, "seek": 19560, "start": 201.6, "end": 210.04, "text": " on top of that there is no compilation checks. So this means that if you missed, if you forgot", "tokens": [322, 1192, 295, 300, 456, 307, 572, 40261, 13834, 13, 407, 341, 1355, 300, 498, 291, 6721, 11, 498, 291, 5298], "temperature": 0.0, "avg_logprob": -0.16945441801156572, "compression_ratio": 1.5, "no_speech_prob": 0.0002206096105510369}, {"id": 26, "seek": 19560, "start": 210.04, "end": 217.35999999999999, "text": " some bindings you will probably know it when your application crashes or in most cases in", "tokens": [512, 14786, 1109, 291, 486, 1391, 458, 309, 562, 428, 3861, 28642, 420, 294, 881, 3331, 294], "temperature": 0.0, "avg_logprob": -0.16945441801156572, "compression_ratio": 1.5, "no_speech_prob": 0.0002206096105510369}, {"id": 27, "seek": 21736, "start": 217.36, "end": 229.12, "text": " your dashboard. So did we just create a monster? Not quite. But there is still room for improvement.", "tokens": [428, 18342, 13, 407, 630, 321, 445, 1884, 257, 10090, 30, 1726, 1596, 13, 583, 456, 307, 920, 1808, 337, 10444, 13], "temperature": 0.0, "avg_logprob": -0.21538719949843008, "compression_ratio": 1.5235602094240839, "no_speech_prob": 0.00011630197695922107}, {"id": 28, "seek": 21736, "start": 229.12, "end": 235.92000000000002, "text": " So let's do what we do best and refactor everything to get a better API and improve the use of", "tokens": [407, 718, 311, 360, 437, 321, 360, 1151, 293, 1895, 15104, 1203, 281, 483, 257, 1101, 9362, 293, 3470, 264, 764, 295], "temperature": 0.0, "avg_logprob": -0.21538719949843008, "compression_ratio": 1.5235602094240839, "no_speech_prob": 0.00011630197695922107}, {"id": 29, "seek": 21736, "start": 235.92000000000002, "end": 243.48000000000002, "text": " code in. So let's welcome KSP. It stands for Kotlin Symbol Processor. A Kotlin Symbol Processor", "tokens": [3089, 294, 13, 407, 718, 311, 2928, 591, 27921, 13, 467, 7382, 337, 30123, 5045, 3902, 5612, 1705, 25432, 13, 316, 30123, 5045, 3902, 5612, 1705, 25432], "temperature": 0.0, "avg_logprob": -0.21538719949843008, "compression_ratio": 1.5235602094240839, "no_speech_prob": 0.00011630197695922107}, {"id": 30, "seek": 24348, "start": 243.48, "end": 249.6, "text": " is a metaprogramming tool that allows us to generate code generally based on some existing", "tokens": [307, 257, 1131, 569, 340, 1342, 2810, 2290, 300, 4045, 505, 281, 8460, 3089, 5101, 2361, 322, 512, 6741], "temperature": 0.0, "avg_logprob": -0.17312121012854198, "compression_ratio": 1.576470588235294, "no_speech_prob": 0.000282518652966246}, {"id": 31, "seek": 24348, "start": 249.6, "end": 259.59999999999997, "text": " code base. Symbol Processor are generally used with annotations that are used to mark our", "tokens": [3089, 3096, 13, 3902, 5612, 1705, 25432, 366, 5101, 1143, 365, 25339, 763, 300, 366, 1143, 281, 1491, 527], "temperature": 0.0, "avg_logprob": -0.17312121012854198, "compression_ratio": 1.576470588235294, "no_speech_prob": 0.000282518652966246}, {"id": 32, "seek": 24348, "start": 259.59999999999997, "end": 265.12, "text": " code that needs a special treatment by the processor. In short terms it's a lightweight", "tokens": [3089, 300, 2203, 257, 2121, 5032, 538, 264, 15321, 13, 682, 2099, 2115, 309, 311, 257, 22052], "temperature": 0.0, "avg_logprob": -0.17312121012854198, "compression_ratio": 1.576470588235294, "no_speech_prob": 0.000282518652966246}, {"id": 33, "seek": 26512, "start": 265.12, "end": 276.48, "text": " compiler plugin that because it can just generate code and not modify some. A quick example", "tokens": [31958, 23407, 300, 570, 309, 393, 445, 8460, 3089, 293, 406, 16927, 512, 13, 316, 1702, 1365], "temperature": 0.0, "avg_logprob": -0.16867026686668396, "compression_ratio": 1.4863387978142077, "no_speech_prob": 6.73510367050767e-05}, {"id": 34, "seek": 26512, "start": 276.48, "end": 285.6, "text": " here I have a full interface that is annotated to be processed. So a Kotlin Symbol Processor", "tokens": [510, 286, 362, 257, 1577, 9226, 300, 307, 25339, 770, 281, 312, 18846, 13, 407, 257, 30123, 5045, 3902, 5612, 1705, 25432], "temperature": 0.0, "avg_logprob": -0.16867026686668396, "compression_ratio": 1.4863387978142077, "no_speech_prob": 6.73510367050767e-05}, {"id": 35, "seek": 26512, "start": 285.6, "end": 290.88, "text": " should be able to generate a concrete class of this full interface overriding the check", "tokens": [820, 312, 1075, 281, 8460, 257, 9859, 1508, 295, 341, 1577, 9226, 670, 81, 2819, 264, 1520], "temperature": 0.0, "avg_logprob": -0.16867026686668396, "compression_ratio": 1.4863387978142077, "no_speech_prob": 6.73510367050767e-05}, {"id": 36, "seek": 29088, "start": 290.88, "end": 301.4, "text": " function. So back to our initial problem. What do we need to improve the Kotlin API? First", "tokens": [2445, 13, 407, 646, 281, 527, 5883, 1154, 13, 708, 360, 321, 643, 281, 3470, 264, 30123, 5045, 9362, 30, 2386], "temperature": 0.0, "avg_logprob": -0.14913949966430665, "compression_ratio": 1.3134328358208955, "no_speech_prob": 6.380444392561913e-05}, {"id": 37, "seek": 29088, "start": 301.4, "end": 310.32, "text": " we need a readable and typed API to be able to avoid the use of this generic function", "tokens": [321, 643, 257, 49857, 293, 33941, 9362, 281, 312, 1075, 281, 5042, 264, 764, 295, 341, 19577, 2445], "temperature": 0.0, "avg_logprob": -0.14913949966430665, "compression_ratio": 1.3134328358208955, "no_speech_prob": 6.380444392561913e-05}, {"id": 38, "seek": 31032, "start": 310.32, "end": 322.71999999999997, "text": " instance everywhere. As we cannot easily have compile checks, at least we want an easy way", "tokens": [5197, 5315, 13, 1018, 321, 2644, 3612, 362, 31413, 13834, 11, 412, 1935, 321, 528, 364, 1858, 636], "temperature": 0.0, "avg_logprob": -0.23266737461090087, "compression_ratio": 1.390625, "no_speech_prob": 0.00010898214532062411}, {"id": 39, "seek": 31032, "start": 322.71999999999997, "end": 335.0, "text": " to check the dependency container consistency with a few lines of unit tests. Note that", "tokens": [281, 1520, 264, 33621, 10129, 14416, 365, 257, 1326, 3876, 295, 4985, 6921, 13, 11633, 300], "temperature": 0.0, "avg_logprob": -0.23266737461090087, "compression_ratio": 1.390625, "no_speech_prob": 0.00010898214532062411}, {"id": 40, "seek": 33500, "start": 335.0, "end": 340.28, "text": " the API you'll see today are still working progressive. They may change a little before", "tokens": [264, 9362, 291, 603, 536, 965, 366, 920, 1364, 16131, 13, 814, 815, 1319, 257, 707, 949], "temperature": 0.0, "avg_logprob": -0.19379829148114738, "compression_ratio": 1.4833333333333334, "no_speech_prob": 5.182222230359912e-05}, {"id": 41, "seek": 33500, "start": 340.28, "end": 348.24, "text": " landing on the release. So the main idea is that you should be able to declare one or", "tokens": [11202, 322, 264, 4374, 13, 407, 264, 2135, 1558, 307, 300, 291, 820, 312, 1075, 281, 19710, 472, 420], "temperature": 0.0, "avg_logprob": -0.19379829148114738, "compression_ratio": 1.4833333333333334, "no_speech_prob": 5.182222230359912e-05}, {"id": 42, "seek": 33500, "start": 348.24, "end": 355.08, "text": " more interfaces that represents the dependencies you need in your applications and that's the", "tokens": [544, 28416, 300, 8855, 264, 36606, 291, 643, 294, 428, 5821, 293, 300, 311, 264], "temperature": 0.0, "avg_logprob": -0.19379829148114738, "compression_ratio": 1.4833333333333334, "no_speech_prob": 5.182222230359912e-05}, {"id": 43, "seek": 35508, "start": 355.08, "end": 366.15999999999997, "text": " one that you need to retrieve at least. So after that we need to annotate our interface", "tokens": [472, 300, 291, 643, 281, 30254, 412, 1935, 13, 407, 934, 300, 321, 643, 281, 25339, 473, 527, 9226], "temperature": 0.0, "avg_logprob": -0.13847674429416656, "compression_ratio": 1.542857142857143, "no_speech_prob": 2.306646274519153e-05}, {"id": 44, "seek": 35508, "start": 366.15999999999997, "end": 371.08, "text": " so that the Kotlin Symbol Processor should be able to generate some code to interact", "tokens": [370, 300, 264, 30123, 5045, 3902, 5612, 1705, 25432, 820, 312, 1075, 281, 8460, 512, 3089, 281, 4648], "temperature": 0.0, "avg_logprob": -0.13847674429416656, "compression_ratio": 1.542857142857143, "no_speech_prob": 2.306646274519153e-05}, {"id": 45, "seek": 35508, "start": 371.08, "end": 383.44, "text": " with the DI container to retrieve your dependencies in a typed way. So let's introduce the result", "tokens": [365, 264, 11953, 10129, 281, 30254, 428, 36606, 294, 257, 33941, 636, 13, 407, 718, 311, 5366, 264, 1874], "temperature": 0.0, "avg_logprob": -0.13847674429416656, "compression_ratio": 1.542857142857143, "no_speech_prob": 2.306646274519153e-05}, {"id": 46, "seek": 38344, "start": 383.44, "end": 393.8, "text": " annotation for that. Once we have annotated our interface, the Kotlin Symbol Processor", "tokens": [48654, 337, 300, 13, 3443, 321, 362, 25339, 770, 527, 9226, 11, 264, 30123, 5045, 3902, 5612, 1705, 25432], "temperature": 0.0, "avg_logprob": -0.16201512018839517, "compression_ratio": 1.5465116279069768, "no_speech_prob": 5.959753252682276e-05}, {"id": 47, "seek": 38344, "start": 393.8, "end": 401.6, "text": " should be able to detect and generate code for us. So in that case, you will see that", "tokens": [820, 312, 1075, 281, 5531, 293, 8460, 3089, 337, 505, 13, 407, 294, 300, 1389, 11, 291, 486, 536, 300], "temperature": 0.0, "avg_logprob": -0.16201512018839517, "compression_ratio": 1.5465116279069768, "no_speech_prob": 5.959753252682276e-05}, {"id": 48, "seek": 38344, "start": 401.6, "end": 408.76, "text": " we need a parameter to create a browser service so it will know that we need to interact with", "tokens": [321, 643, 257, 13075, 281, 1884, 257, 11185, 2643, 370, 309, 486, 458, 300, 321, 643, 281, 4648, 365], "temperature": 0.0, "avg_logprob": -0.16201512018839517, "compression_ratio": 1.5465116279069768, "no_speech_prob": 5.959753252682276e-05}, {"id": 49, "seek": 40876, "start": 408.76, "end": 418.8, "text": " a factory that needs a string as parameter to get a browser service instance as well", "tokens": [257, 9265, 300, 2203, 257, 6798, 382, 13075, 281, 483, 257, 11185, 2643, 5197, 382, 731], "temperature": 0.0, "avg_logprob": -0.25727081298828125, "compression_ratio": 1.4453781512605042, "no_speech_prob": 5.9191472246311605e-05}, {"id": 50, "seek": 40876, "start": 418.8, "end": 432.52, "text": " as the controller functions needs to return a simple instance depending on the context.", "tokens": [382, 264, 10561, 6828, 2203, 281, 2736, 257, 2199, 5197, 5413, 322, 264, 4319, 13], "temperature": 0.0, "avg_logprob": -0.25727081298828125, "compression_ratio": 1.4453781512605042, "no_speech_prob": 5.9191472246311605e-05}, {"id": 51, "seek": 43252, "start": 432.52, "end": 441.15999999999997, "text": " Here is what the Kotlin Symbol Processor will generate for us. A concrete class implementing", "tokens": [1692, 307, 437, 264, 30123, 5045, 3902, 5612, 1705, 25432, 486, 8460, 337, 505, 13, 316, 9859, 1508, 18114], "temperature": 0.0, "avg_logprob": -0.1372924009958903, "compression_ratio": 1.4918032786885247, "no_speech_prob": 0.0001258942938875407}, {"id": 52, "seek": 43252, "start": 441.15999999999997, "end": 448.68, "text": " our app dependencies interface and that needs a DI container as input. So the DI container", "tokens": [527, 724, 36606, 9226, 293, 300, 2203, 257, 11953, 10129, 382, 4846, 13, 407, 264, 11953, 10129], "temperature": 0.0, "avg_logprob": -0.1372924009958903, "compression_ratio": 1.4918032786885247, "no_speech_prob": 0.0001258942938875407}, {"id": 53, "seek": 43252, "start": 448.68, "end": 458.03999999999996, "text": " will be used to retrieve the proper instances here either a factory because it can detect", "tokens": [486, 312, 1143, 281, 30254, 264, 2296, 14519, 510, 2139, 257, 9265, 570, 309, 393, 5531], "temperature": 0.0, "avg_logprob": -0.1372924009958903, "compression_ratio": 1.4918032786885247, "no_speech_prob": 0.0001258942938875407}, {"id": 54, "seek": 45804, "start": 458.04, "end": 466.76000000000005, "text": " that we need a parameter or a simple instance for the controller. Now let's see how we", "tokens": [300, 321, 643, 257, 13075, 420, 257, 2199, 5197, 337, 264, 10561, 13, 823, 718, 311, 536, 577, 321], "temperature": 0.0, "avg_logprob": -0.12227849662303925, "compression_ratio": 1.4772727272727273, "no_speech_prob": 6.81657693348825e-05}, {"id": 55, "seek": 45804, "start": 466.76000000000005, "end": 476.52000000000004, "text": " can use it in our application code. So first we need to declare our DI bindings so our", "tokens": [393, 764, 309, 294, 527, 3861, 3089, 13, 407, 700, 321, 643, 281, 19710, 527, 11953, 14786, 1109, 370, 527], "temperature": 0.0, "avg_logprob": -0.12227849662303925, "compression_ratio": 1.4772727272727273, "no_speech_prob": 6.81657693348825e-05}, {"id": 56, "seek": 45804, "start": 476.52000000000004, "end": 482.68, "text": " implementation should be able to interact with. For that, we still use our current API", "tokens": [11420, 820, 312, 1075, 281, 4648, 365, 13, 1171, 300, 11, 321, 920, 764, 527, 2190, 9362], "temperature": 0.0, "avg_logprob": -0.12227849662303925, "compression_ratio": 1.4772727272727273, "no_speech_prob": 6.81657693348825e-05}, {"id": 57, "seek": 48268, "start": 482.68, "end": 494.76, "text": " of Kotlin's DSL or it will improve it a little bit but we will keep it as well as it is.", "tokens": [295, 30123, 5045, 311, 15816, 43, 420, 309, 486, 3470, 309, 257, 707, 857, 457, 321, 486, 1066, 309, 382, 731, 382, 309, 307, 13], "temperature": 0.0, "avg_logprob": -0.20373544177493533, "compression_ratio": 1.5027027027027027, "no_speech_prob": 0.00018829740292858332}, {"id": 58, "seek": 48268, "start": 494.76, "end": 504.56, "text": " Why? Because we have history with solutions like daggers that have gone wild with annotations.", "tokens": [1545, 30, 1436, 321, 362, 2503, 365, 6547, 411, 15460, 9458, 300, 362, 2780, 4868, 365, 25339, 763, 13], "temperature": 0.0, "avg_logprob": -0.20373544177493533, "compression_ratio": 1.5027027027027027, "no_speech_prob": 0.00018829740292858332}, {"id": 59, "seek": 48268, "start": 504.56, "end": 512.64, "text": " Even so, it's where Kotlin was created in the first place to avoid that forest of annotations.", "tokens": [2754, 370, 11, 309, 311, 689, 30123, 5045, 390, 2942, 294, 264, 700, 1081, 281, 5042, 300, 6719, 295, 25339, 763, 13], "temperature": 0.0, "avg_logprob": -0.20373544177493533, "compression_ratio": 1.5027027027027027, "no_speech_prob": 0.00018829740292858332}, {"id": 60, "seek": 51264, "start": 512.64, "end": 524.4, "text": " So we didn't want to introduce tons of annotations again and go full circle. Finally, we think", "tokens": [407, 321, 994, 380, 528, 281, 5366, 9131, 295, 25339, 763, 797, 293, 352, 1577, 6329, 13, 6288, 11, 321, 519], "temperature": 0.0, "avg_logprob": -0.16911191940307618, "compression_ratio": 1.5363128491620113, "no_speech_prob": 9.101087925955653e-05}, {"id": 61, "seek": 51264, "start": 524.4, "end": 530.52, "text": " our binding declaration API is good enough to express our dependencies. So here are the", "tokens": [527, 17359, 27606, 9362, 307, 665, 1547, 281, 5109, 527, 36606, 13, 407, 510, 366, 264], "temperature": 0.0, "avg_logprob": -0.16911191940307618, "compression_ratio": 1.5363128491620113, "no_speech_prob": 9.101087925955653e-05}, {"id": 62, "seek": 51264, "start": 530.52, "end": 538.2, "text": " dependencies we need to meet the app dependencies interface contract. We need factories that", "tokens": [36606, 321, 643, 281, 1677, 264, 724, 36606, 9226, 4364, 13, 492, 643, 24813, 300], "temperature": 0.0, "avg_logprob": -0.16911191940307618, "compression_ratio": 1.5363128491620113, "no_speech_prob": 9.101087925955653e-05}, {"id": 63, "seek": 53820, "start": 538.2, "end": 546.12, "text": " take a string and return a service and a single tons that return an instance of a controller", "tokens": [747, 257, 6798, 293, 2736, 257, 2643, 293, 257, 2167, 9131, 300, 2736, 364, 5197, 295, 257, 10561], "temperature": 0.0, "avg_logprob": -0.1858527183532715, "compression_ratio": 1.6981132075471699, "no_speech_prob": 0.00016398604202549905}, {"id": 64, "seek": 53820, "start": 546.12, "end": 555.6400000000001, "text": " that itself needs an instance of a service. Welcome to that later. So now we can instantiate", "tokens": [300, 2564, 2203, 364, 5197, 295, 257, 2643, 13, 4027, 281, 300, 1780, 13, 407, 586, 321, 393, 9836, 13024], "temperature": 0.0, "avg_logprob": -0.1858527183532715, "compression_ratio": 1.6981132075471699, "no_speech_prob": 0.00016398604202549905}, {"id": 65, "seek": 53820, "start": 555.6400000000001, "end": 562.24, "text": " the generated class with our DI container and retrieve our dependencies with a truly", "tokens": [264, 10833, 1508, 365, 527, 11953, 10129, 293, 30254, 527, 36606, 365, 257, 4908], "temperature": 0.0, "avg_logprob": -0.1858527183532715, "compression_ratio": 1.6981132075471699, "no_speech_prob": 0.00016398604202549905}, {"id": 66, "seek": 56224, "start": 562.24, "end": 571.92, "text": " typed API. As we don't want our user to know how we are generating our function or class", "tokens": [33941, 9362, 13, 1018, 321, 500, 380, 528, 527, 4195, 281, 458, 577, 321, 366, 17746, 527, 2445, 420, 1508], "temperature": 0.0, "avg_logprob": -0.16728310585021972, "compression_ratio": 1.497175141242938, "no_speech_prob": 8.772288856562227e-05}, {"id": 67, "seek": 56224, "start": 571.92, "end": 580.84, "text": " implementation, sorry, we also introduced an extension function that helps us instantiate", "tokens": [11420, 11, 2597, 11, 321, 611, 7268, 364, 10320, 2445, 300, 3665, 505, 9836, 13024], "temperature": 0.0, "avg_logprob": -0.16728310585021972, "compression_ratio": 1.497175141242938, "no_speech_prob": 8.772288856562227e-05}, {"id": 68, "seek": 56224, "start": 580.84, "end": 591.28, "text": " the app dependencies for us. So now that we are able to retrieve our dependencies with", "tokens": [264, 724, 36606, 337, 505, 13, 407, 586, 300, 321, 366, 1075, 281, 30254, 527, 36606, 365], "temperature": 0.0, "avg_logprob": -0.16728310585021972, "compression_ratio": 1.497175141242938, "no_speech_prob": 8.772288856562227e-05}, {"id": 69, "seek": 59128, "start": 591.28, "end": 600.0799999999999, "text": " a truly typed API, let's see how we can check their consistency. For that, we introduced", "tokens": [257, 4908, 33941, 9362, 11, 718, 311, 536, 577, 321, 393, 1520, 641, 14416, 13, 1171, 300, 11, 321, 7268], "temperature": 0.0, "avg_logprob": -0.15644438304598368, "compression_ratio": 1.5748502994011977, "no_speech_prob": 2.7751184461521916e-05}, {"id": 70, "seek": 59128, "start": 600.0799999999999, "end": 611.72, "text": " a DI resolver interface that only needs to respect the contract of a check function.", "tokens": [257, 11953, 34480, 9226, 300, 787, 2203, 281, 3104, 264, 4364, 295, 257, 1520, 2445, 13], "temperature": 0.0, "avg_logprob": -0.15644438304598368, "compression_ratio": 1.5748502994011977, "no_speech_prob": 2.7751184461521916e-05}, {"id": 71, "seek": 59128, "start": 611.72, "end": 619.28, "text": " So now we can combine the DI resolver interface with an atresolve annotation. In an ideal", "tokens": [407, 586, 321, 393, 10432, 264, 11953, 34480, 9226, 365, 364, 412, 495, 37361, 48654, 13, 682, 364, 7157], "temperature": 0.0, "avg_logprob": -0.15644438304598368, "compression_ratio": 1.5748502994011977, "no_speech_prob": 2.7751184461521916e-05}, {"id": 72, "seek": 61928, "start": 619.28, "end": 625.12, "text": " world, the atresolve annotation should be able to add that DI resolver type to our interface", "tokens": [1002, 11, 264, 412, 495, 37361, 48654, 820, 312, 1075, 281, 909, 300, 11953, 34480, 2010, 281, 527, 9226], "temperature": 0.0, "avg_logprob": -0.2287735822724133, "compression_ratio": 1.7177033492822966, "no_speech_prob": 9.448525088373572e-05}, {"id": 73, "seek": 61928, "start": 625.12, "end": 631.0799999999999, "text": " itself. But as we are using Kotlin symbol processor, we can just generate some code", "tokens": [2564, 13, 583, 382, 321, 366, 1228, 30123, 5045, 5986, 15321, 11, 321, 393, 445, 8460, 512, 3089], "temperature": 0.0, "avg_logprob": -0.2287735822724133, "compression_ratio": 1.7177033492822966, "no_speech_prob": 9.448525088373572e-05}, {"id": 74, "seek": 61928, "start": 631.0799999999999, "end": 639.28, "text": " and not modify existing one. So now that we are fully packed with our annotation and our", "tokens": [293, 406, 16927, 6741, 472, 13, 407, 586, 300, 321, 366, 4498, 13265, 365, 527, 48654, 293, 527], "temperature": 0.0, "avg_logprob": -0.2287735822724133, "compression_ratio": 1.7177033492822966, "no_speech_prob": 9.448525088373572e-05}, {"id": 75, "seek": 61928, "start": 639.28, "end": 647.8399999999999, "text": " DI resolver interface, the code in the symbol processor will be able to generate the override", "tokens": [11953, 34480, 9226, 11, 264, 3089, 294, 264, 5986, 15321, 486, 312, 1075, 281, 8460, 264, 42321], "temperature": 0.0, "avg_logprob": -0.2287735822724133, "compression_ratio": 1.7177033492822966, "no_speech_prob": 9.448525088373572e-05}, {"id": 76, "seek": 64784, "start": 647.84, "end": 655.0, "text": " and function check and create a requirement for everyone of the function or accessor we", "tokens": [293, 2445, 1520, 293, 1884, 257, 11695, 337, 1518, 295, 264, 2445, 420, 2105, 284, 321], "temperature": 0.0, "avg_logprob": -0.1384451350227731, "compression_ratio": 1.5084745762711864, "no_speech_prob": 2.3832031729398295e-05}, {"id": 77, "seek": 64784, "start": 655.0, "end": 665.08, "text": " have defined in our app dependency interface. Before, with that code, you will have taken", "tokens": [362, 7642, 294, 527, 724, 33621, 9226, 13, 4546, 11, 365, 300, 3089, 11, 291, 486, 362, 2726], "temperature": 0.0, "avg_logprob": -0.1384451350227731, "compression_ratio": 1.5084745762711864, "no_speech_prob": 2.3832031729398295e-05}, {"id": 78, "seek": 64784, "start": 665.08, "end": 673.88, "text": " the risk to go in production without easily knowing if you forgot some bindings. No more.", "tokens": [264, 3148, 281, 352, 294, 4265, 1553, 3612, 5276, 498, 291, 5298, 512, 14786, 1109, 13, 883, 544, 13], "temperature": 0.0, "avg_logprob": -0.1384451350227731, "compression_ratio": 1.5084745762711864, "no_speech_prob": 2.3832031729398295e-05}, {"id": 79, "seek": 67388, "start": 673.88, "end": 683.16, "text": " Now we just add a test and as we saw before, we instantiate our app dependencies interface", "tokens": [823, 321, 445, 909, 257, 1500, 293, 382, 321, 1866, 949, 11, 321, 9836, 13024, 527, 724, 36606, 9226], "temperature": 0.0, "avg_logprob": -0.17660486336910364, "compression_ratio": 1.5314285714285714, "no_speech_prob": 5.929188409936614e-05}, {"id": 80, "seek": 67388, "start": 683.16, "end": 695.8, "text": " with a concrete class and just call the check function. That way, if you missed a binding,", "tokens": [365, 257, 9859, 1508, 293, 445, 818, 264, 1520, 2445, 13, 663, 636, 11, 498, 291, 6721, 257, 17359, 11], "temperature": 0.0, "avg_logprob": -0.17660486336910364, "compression_ratio": 1.5314285714285714, "no_speech_prob": 5.929188409936614e-05}, {"id": 81, "seek": 67388, "start": 695.8, "end": 701.48, "text": " your test suite will warn you instantly with a proper message. So here, we saw that we", "tokens": [428, 1500, 14205, 486, 12286, 291, 13518, 365, 257, 2296, 3636, 13, 407, 510, 11, 321, 1866, 300, 321], "temperature": 0.0, "avg_logprob": -0.17660486336910364, "compression_ratio": 1.5314285714285714, "no_speech_prob": 5.929188409936614e-05}, {"id": 82, "seek": 70148, "start": 701.48, "end": 711.24, "text": " missed a factory binding that returns a broad service and takes a string argument as input.", "tokens": [6721, 257, 9265, 17359, 300, 11247, 257, 4152, 2643, 293, 2516, 257, 6798, 6770, 382, 4846, 13], "temperature": 0.0, "avg_logprob": -0.22100793954097864, "compression_ratio": 1.469945355191257, "no_speech_prob": 7.333073153859004e-05}, {"id": 83, "seek": 70148, "start": 711.24, "end": 718.96, "text": " One more thing. Earlier, we saw that the code in binding DSL was impacted with the use of", "tokens": [1485, 544, 551, 13, 24552, 11, 321, 1866, 300, 264, 3089, 294, 17359, 15816, 43, 390, 15653, 365, 264, 764, 295], "temperature": 0.0, "avg_logprob": -0.22100793954097864, "compression_ratio": 1.469945355191257, "no_speech_prob": 7.333073153859004e-05}, {"id": 84, "seek": 70148, "start": 718.96, "end": 726.0, "text": " those instance functions. So let's see how we can improve this user as well. Let's take", "tokens": [729, 5197, 6828, 13, 407, 718, 311, 536, 577, 321, 393, 3470, 341, 4195, 382, 731, 13, 961, 311, 747], "temperature": 0.0, "avg_logprob": -0.22100793954097864, "compression_ratio": 1.469945355191257, "no_speech_prob": 7.333073153859004e-05}, {"id": 85, "seek": 72600, "start": 726.0, "end": 733.96, "text": " this example. When I need a controller that needs itself a use case, that also needs a", "tokens": [341, 1365, 13, 1133, 286, 643, 257, 10561, 300, 2203, 2564, 257, 764, 1389, 11, 300, 611, 2203, 257], "temperature": 0.0, "avg_logprob": -0.19591886569292116, "compression_ratio": 1.6232558139534883, "no_speech_prob": 4.7295703552663326e-05}, {"id": 86, "seek": 72600, "start": 733.96, "end": 742.16, "text": " service. Here is the binding we will have defined to meet our architecture expectation.", "tokens": [2643, 13, 1692, 307, 264, 17359, 321, 486, 362, 7642, 281, 1677, 527, 9482, 14334, 13], "temperature": 0.0, "avg_logprob": -0.19591886569292116, "compression_ratio": 1.6232558139534883, "no_speech_prob": 4.7295703552663326e-05}, {"id": 87, "seek": 72600, "start": 742.16, "end": 748.08, "text": " So you probably have seen me coming with those instance functions. In the explicit world,", "tokens": [407, 291, 1391, 362, 1612, 385, 1348, 365, 729, 5197, 6828, 13, 682, 264, 13691, 1002, 11], "temperature": 0.0, "avg_logprob": -0.19591886569292116, "compression_ratio": 1.6232558139534883, "no_speech_prob": 4.7295703552663326e-05}, {"id": 88, "seek": 72600, "start": 748.08, "end": 753.08, "text": " we will have written those functions with their targeted type so we saw that we need", "tokens": [321, 486, 362, 3720, 729, 6828, 365, 641, 15045, 2010, 370, 321, 1866, 300, 321, 643], "temperature": 0.0, "avg_logprob": -0.19591886569292116, "compression_ratio": 1.6232558139534883, "no_speech_prob": 4.7295703552663326e-05}, {"id": 89, "seek": 75308, "start": 753.08, "end": 764.5600000000001, "text": " a service and a use case. So why not using a type API and get this instance directly?", "tokens": [257, 2643, 293, 257, 764, 1389, 13, 407, 983, 406, 1228, 257, 2010, 9362, 293, 483, 341, 5197, 3838, 30], "temperature": 0.0, "avg_logprob": -0.20529186248779296, "compression_ratio": 1.3185185185185184, "no_speech_prob": 0.0002166069607483223}, {"id": 90, "seek": 75308, "start": 764.5600000000001, "end": 774.44, "text": " This is not that simple because in the code in DSL, this is a type DI builder. So it doesn't", "tokens": [639, 307, 406, 300, 2199, 570, 294, 264, 3089, 294, 15816, 43, 11, 341, 307, 257, 2010, 11953, 27377, 13, 407, 309, 1177, 380], "temperature": 0.0, "avg_logprob": -0.20529186248779296, "compression_ratio": 1.3185185185185184, "no_speech_prob": 0.0002166069607483223}, {"id": 91, "seek": 77444, "start": 774.44, "end": 782.9200000000001, "text": " know anything about the app dependencies API. Thus, the code in the symbol processor will", "tokens": [458, 1340, 466, 264, 724, 36606, 9362, 13, 13827, 11, 264, 3089, 294, 264, 5986, 15321, 486], "temperature": 0.0, "avg_logprob": -0.1834091307624938, "compression_ratio": 1.6130952380952381, "no_speech_prob": 8.622650057077408e-05}, {"id": 92, "seek": 77444, "start": 782.9200000000001, "end": 790.44, "text": " also generate a new function for us that is called off with the name of the app dependencies", "tokens": [611, 8460, 257, 777, 2445, 337, 505, 300, 307, 1219, 766, 365, 264, 1315, 295, 264, 724, 36606], "temperature": 0.0, "avg_logprob": -0.1834091307624938, "compression_ratio": 1.6130952380952381, "no_speech_prob": 8.622650057077408e-05}, {"id": 93, "seek": 77444, "start": 790.44, "end": 801.48, "text": " contract we have. Thus, it creates a new DI builder that is aware of the DI building API", "tokens": [4364, 321, 362, 13, 13827, 11, 309, 7829, 257, 777, 11953, 27377, 300, 307, 3650, 295, 264, 11953, 2390, 9362], "temperature": 0.0, "avg_logprob": -0.1834091307624938, "compression_ratio": 1.6130952380952381, "no_speech_prob": 8.622650057077408e-05}, {"id": 94, "seek": 80148, "start": 801.48, "end": 809.32, "text": " and the app dependencies. Allowing us to call straight functions to get our instances as", "tokens": [293, 264, 724, 36606, 13, 1057, 9637, 505, 281, 818, 2997, 6828, 281, 483, 527, 14519, 382], "temperature": 0.0, "avg_logprob": -0.19767218730488761, "compression_ratio": 1.5689655172413792, "no_speech_prob": 0.0001372623082716018}, {"id": 95, "seek": 80148, "start": 809.32, "end": 816.96, "text": " long as they are part of the app dependencies API, obviously. So as a result of type dependencies,", "tokens": [938, 382, 436, 366, 644, 295, 264, 724, 36606, 9362, 11, 2745, 13, 407, 382, 257, 1874, 295, 2010, 36606, 11], "temperature": 0.0, "avg_logprob": -0.19767218730488761, "compression_ratio": 1.5689655172413792, "no_speech_prob": 0.0001372623082716018}, {"id": 96, "seek": 80148, "start": 816.96, "end": 824.6, "text": " I can now easily check the consistency of my DI container or retrieve dependencies in", "tokens": [286, 393, 586, 3612, 1520, 264, 14416, 295, 452, 11953, 10129, 420, 30254, 36606, 294], "temperature": 0.0, "avg_logprob": -0.19767218730488761, "compression_ratio": 1.5689655172413792, "no_speech_prob": 0.0001372623082716018}, {"id": 97, "seek": 82460, "start": 824.6, "end": 832.9200000000001, "text": " my application. So I feel the tension and excitement in the room, right? No? Same question", "tokens": [452, 3861, 13, 407, 286, 841, 264, 8980, 293, 14755, 294, 264, 1808, 11, 558, 30, 883, 30, 10635, 1168], "temperature": 0.0, "avg_logprob": -0.21079576015472412, "compression_ratio": 1.436842105263158, "no_speech_prob": 0.00013095777831040323}, {"id": 98, "seek": 82460, "start": 832.9200000000001, "end": 841.4, "text": " on everybody's mind. Is this live? So I can spoil it earlier. It's still a work in progress", "tokens": [322, 2201, 311, 1575, 13, 1119, 341, 1621, 30, 407, 286, 393, 18630, 309, 3071, 13, 467, 311, 920, 257, 589, 294, 4205], "temperature": 0.0, "avg_logprob": -0.21079576015472412, "compression_ratio": 1.436842105263158, "no_speech_prob": 0.00013095777831040323}, {"id": 99, "seek": 82460, "start": 841.4, "end": 849.88, "text": " and we still have some corner cases to crack, like how to use tags, how to manage modules,", "tokens": [293, 321, 920, 362, 512, 4538, 3331, 281, 6226, 11, 411, 577, 281, 764, 18632, 11, 577, 281, 3067, 16679, 11], "temperature": 0.0, "avg_logprob": -0.21079576015472412, "compression_ratio": 1.436842105263158, "no_speech_prob": 0.00013095777831040323}, {"id": 100, "seek": 84988, "start": 849.88, "end": 858.2, "text": " how to declare and handle scopes and context is and a few more. Here is a sneak peek of", "tokens": [577, 281, 19710, 293, 4813, 795, 30545, 293, 4319, 307, 293, 257, 1326, 544, 13, 1692, 307, 257, 13164, 19604, 295], "temperature": 0.0, "avg_logprob": -0.21640375888708865, "compression_ratio": 1.4751381215469612, "no_speech_prob": 6.913637480465695e-05}, {"id": 101, "seek": 84988, "start": 858.2, "end": 869.68, "text": " some ideas we have to solve those problems. An easy one is the tag API when we can retrieve", "tokens": [512, 3487, 321, 362, 281, 5039, 729, 2740, 13, 1107, 1858, 472, 307, 264, 6162, 9362, 562, 321, 393, 30254], "temperature": 0.0, "avg_logprob": -0.21640375888708865, "compression_ratio": 1.4751381215469612, "no_speech_prob": 6.913637480465695e-05}, {"id": 102, "seek": 84988, "start": 869.68, "end": 879.84, "text": " a dependencies by passing a tag parameter. We could add an annotation with that tag and", "tokens": [257, 36606, 538, 8437, 257, 6162, 13075, 13, 492, 727, 909, 364, 48654, 365, 300, 6162, 293], "temperature": 0.0, "avg_logprob": -0.21640375888708865, "compression_ratio": 1.4751381215469612, "no_speech_prob": 6.913637480465695e-05}, {"id": 103, "seek": 87984, "start": 879.84, "end": 890.6, "text": " easily retrieve our dependencies without having to pass or know the tag that is needed behind.", "tokens": [3612, 30254, 527, 36606, 1553, 1419, 281, 1320, 420, 458, 264, 6162, 300, 307, 2978, 2261, 13], "temperature": 0.0, "avg_logprob": -0.13778345401470476, "compression_ratio": 1.4104477611940298, "no_speech_prob": 0.0002104941086145118}, {"id": 104, "seek": 87984, "start": 890.6, "end": 901.6, "text": " For the module management, we could just provide two ways to interact with dependencies either", "tokens": [1171, 264, 10088, 4592, 11, 321, 727, 445, 2893, 732, 2098, 281, 4648, 365, 36606, 2139], "temperature": 0.0, "avg_logprob": -0.13778345401470476, "compression_ratio": 1.4104477611940298, "no_speech_prob": 0.0002104941086145118}, {"id": 105, "seek": 90160, "start": 901.6, "end": 911.9200000000001, "text": " with a fully packed DI container or a DI module or add some parameters or annotations or either", "tokens": [365, 257, 4498, 13265, 11953, 10129, 420, 257, 11953, 10088, 420, 909, 512, 9834, 420, 25339, 763, 420, 2139], "temperature": 0.0, "avg_logprob": -0.18342113494873047, "compression_ratio": 1.362962962962963, "no_speech_prob": 0.00022691818594466895}, {"id": 106, "seek": 90160, "start": 911.9200000000001, "end": 924.0, "text": " create a new annotations again. We'll see. Maybe not. A more complicated use case is how", "tokens": [1884, 257, 777, 25339, 763, 797, 13, 492, 603, 536, 13, 2704, 406, 13, 316, 544, 6179, 764, 1389, 307, 577], "temperature": 0.0, "avg_logprob": -0.18342113494873047, "compression_ratio": 1.362962962962963, "no_speech_prob": 0.00022691818594466895}, {"id": 107, "seek": 92400, "start": 924.0, "end": 936.44, "text": " to handle scopes. With code ends, we can define some bindings that are with some life cycle", "tokens": [281, 4813, 795, 30545, 13, 2022, 3089, 5314, 11, 321, 393, 6964, 512, 14786, 1109, 300, 366, 365, 512, 993, 6586], "temperature": 0.0, "avg_logprob": -0.2427737062627619, "compression_ratio": 1.4140625, "no_speech_prob": 0.0005070192855782807}, {"id": 108, "seek": 92400, "start": 936.44, "end": 949.96, "text": " depending on the scope or context and retrieve them with their own function. So to define", "tokens": [5413, 322, 264, 11923, 420, 4319, 293, 30254, 552, 365, 641, 1065, 2445, 13, 407, 281, 6964], "temperature": 0.0, "avg_logprob": -0.2427737062627619, "compression_ratio": 1.4140625, "no_speech_prob": 0.0005070192855782807}, {"id": 109, "seek": 94996, "start": 949.96, "end": 963.5600000000001, "text": " a scope with a KSP, we could define that a contract is scoped entirely and then be able", "tokens": [257, 11923, 365, 257, 591, 27921, 11, 321, 727, 6964, 300, 257, 4364, 307, 795, 27277, 7696, 293, 550, 312, 1075], "temperature": 0.0, "avg_logprob": -0.15973870716397726, "compression_ratio": 1.5055555555555555, "no_speech_prob": 0.00010130299779120833}, {"id": 110, "seek": 94996, "start": 963.5600000000001, "end": 971.32, "text": " to retrieve our dependencies with the right context. Maybe this rings a bell. It sounds", "tokens": [281, 30254, 527, 36606, 365, 264, 558, 4319, 13, 2704, 341, 11136, 257, 4549, 13, 467, 3263], "temperature": 0.0, "avg_logprob": -0.15973870716397726, "compression_ratio": 1.5055555555555555, "no_speech_prob": 0.00010130299779120833}, {"id": 111, "seek": 94996, "start": 971.32, "end": 978.12, "text": " like context receivers, right? But unfortunately, context receivers are not available in Kotlin", "tokens": [411, 4319, 49196, 11, 558, 30, 583, 7015, 11, 4319, 49196, 366, 406, 2435, 294, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.15973870716397726, "compression_ratio": 1.5055555555555555, "no_speech_prob": 0.00010130299779120833}, {"id": 112, "seek": 97812, "start": 978.12, "end": 987.4, "text": " multi-platform yet, so we'll have to find another way. Also, we have plenty of ideas", "tokens": [4825, 12, 39975, 837, 1939, 11, 370, 321, 603, 362, 281, 915, 1071, 636, 13, 2743, 11, 321, 362, 7140, 295, 3487], "temperature": 0.0, "avg_logprob": -0.1694461221564306, "compression_ratio": 1.4585635359116023, "no_speech_prob": 0.0001920156937558204}, {"id": 113, "seek": 97812, "start": 987.4, "end": 996.64, "text": " to make this work. This is an open source project, so obviously, if you want to contribute,", "tokens": [281, 652, 341, 589, 13, 639, 307, 364, 1269, 4009, 1716, 11, 370, 2745, 11, 498, 291, 528, 281, 10586, 11], "temperature": 0.0, "avg_logprob": -0.1694461221564306, "compression_ratio": 1.4585635359116023, "no_speech_prob": 0.0001920156937558204}, {"id": 114, "seek": 97812, "start": 996.64, "end": 1004.04, "text": " you're welcome. That's it for me. Thank you for hearing me. If you have some questions,", "tokens": [291, 434, 2928, 13, 663, 311, 309, 337, 385, 13, 1044, 291, 337, 4763, 385, 13, 759, 291, 362, 512, 1651, 11], "temperature": 0.0, "avg_logprob": -0.1694461221564306, "compression_ratio": 1.4585635359116023, "no_speech_prob": 0.0001920156937558204}, {"id": 115, "seek": 100404, "start": 1004.04, "end": 1016.24, "text": " I think we have time for it. Thank you very much again. We do have quite a lot of time", "tokens": [286, 519, 321, 362, 565, 337, 309, 13, 1044, 291, 588, 709, 797, 13, 492, 360, 362, 1596, 257, 688, 295, 565], "temperature": 0.0, "avg_logprob": -0.12637157241503397, "compression_ratio": 1.3461538461538463, "no_speech_prob": 0.0010608350858092308}, {"id": 116, "seek": 100404, "start": 1016.24, "end": 1024.68, "text": " for questions now, so please raise your hand if you have any. Just shout it and you will", "tokens": [337, 1651, 586, 11, 370, 1767, 5300, 428, 1011, 498, 291, 362, 604, 13, 1449, 8043, 309, 293, 291, 486], "temperature": 0.0, "avg_logprob": -0.12637157241503397, "compression_ratio": 1.3461538461538463, "no_speech_prob": 0.0010608350858092308}, {"id": 117, "seek": 102468, "start": 1024.68, "end": 1050.6000000000001, "text": " have to repeat it. So the question is, is there some support", "tokens": [362, 281, 7149, 309, 13, 407, 264, 1168, 307, 11, 307, 456, 512, 1406], "temperature": 0.0, "avg_logprob": -0.28123315175374347, "compression_ratio": 0.9523809523809523, "no_speech_prob": 0.00201219180598855}, {"id": 118, "seek": 105060, "start": 1050.6, "end": 1065.52, "text": " in the IDE? So as for the mocking library, you will need to build your code the first", "tokens": [294, 264, 40930, 30, 407, 382, 337, 264, 49792, 6405, 11, 291, 486, 643, 281, 1322, 428, 3089, 264, 700], "temperature": 0.0, "avg_logprob": -0.20614570120106573, "compression_ratio": 1.3134328358208955, "no_speech_prob": 0.0019729065243154764}, {"id": 119, "seek": 105060, "start": 1065.52, "end": 1075.4399999999998, "text": " time to be able to have the right APIs, like the new function and the off-app dependencies", "tokens": [565, 281, 312, 1075, 281, 362, 264, 558, 21445, 11, 411, 264, 777, 2445, 293, 264, 766, 12, 1746, 36606], "temperature": 0.0, "avg_logprob": -0.20614570120106573, "compression_ratio": 1.3134328358208955, "no_speech_prob": 0.0019729065243154764}, {"id": 120, "seek": 107544, "start": 1075.44, "end": 1102.28, "text": " function, for example. No. All right. I think it's clear.", "tokens": [2445, 11, 337, 1365, 13, 883, 13, 1057, 558, 13, 286, 519, 309, 311, 1850, 13], "temperature": 0.0, "avg_logprob": -0.41861591339111326, "compression_ratio": 0.8769230769230769, "no_speech_prob": 0.0008337993640452623}, {"id": 121, "seek": 110228, "start": 1102.28, "end": 1117.6, "text": " One question. With this dependency injection framework, are all dependencies compiled statically,", "tokens": [1485, 1168, 13, 2022, 341, 33621, 22873, 8388, 11, 366, 439, 36606, 36548, 2219, 984, 11], "temperature": 0.0, "avg_logprob": -0.3993316650390625, "compression_ratio": 1.4152542372881356, "no_speech_prob": 0.0048815589398145676}, {"id": 122, "seek": 110228, "start": 1117.6, "end": 1126.8799999999999, "text": " like the dependency injection part, or is that still dynamic runtime?", "tokens": [411, 264, 33621, 22873, 644, 11, 420, 307, 300, 920, 8546, 34474, 30], "temperature": 0.0, "avg_logprob": -0.3993316650390625, "compression_ratio": 1.4152542372881356, "no_speech_prob": 0.0048815589398145676}, {"id": 123, "seek": 112688, "start": 1126.88, "end": 1138.8000000000002, "text": " So the dependencies injection are resolved statically or at runtime? Is this your question?", "tokens": [407, 264, 36606, 22873, 366, 20772, 2219, 984, 420, 412, 34474, 30, 1119, 341, 428, 1168, 30], "temperature": 0.0, "avg_logprob": -0.1613825975462448, "compression_ratio": 1.4206349206349207, "no_speech_prob": 0.00024948266218416393}, {"id": 124, "seek": 112688, "start": 1138.8000000000002, "end": 1149.24, "text": " So they are resolved at runtime, but as we saw, we provide tools to check that all your", "tokens": [407, 436, 366, 20772, 412, 34474, 11, 457, 382, 321, 1866, 11, 321, 2893, 3873, 281, 1520, 300, 439, 428], "temperature": 0.0, "avg_logprob": -0.1613825975462448, "compression_ratio": 1.4206349206349207, "no_speech_prob": 0.00024948266218416393}, {"id": 125, "seek": 114924, "start": 1149.24, "end": 1159.16, "text": " bindings are well-defined with your test suite, but they are resolved at runtime. There is", "tokens": [14786, 1109, 366, 731, 12, 37716, 365, 428, 1500, 14205, 11, 457, 436, 366, 20772, 412, 34474, 13, 821, 307], "temperature": 0.0, "avg_logprob": -0.33647505442301434, "compression_ratio": 1.3059701492537314, "no_speech_prob": 0.000849240692332387}, {"id": 126, "seek": 114924, "start": 1159.16, "end": 1168.8, "text": " no reflection like Salomon showed you earlier. That's how Dagger works, for example.", "tokens": [572, 12914, 411, 5996, 24488, 4712, 291, 3071, 13, 663, 311, 577, 413, 11062, 1985, 11, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.33647505442301434, "compression_ratio": 1.3059701492537314, "no_speech_prob": 0.000849240692332387}, {"id": 127, "seek": 116880, "start": 1168.8, "end": 1179.48, "text": " So it's basically the best focus between Spring and Dagger.", "tokens": [407, 309, 311, 1936, 264, 1151, 1879, 1296, 14013, 293, 413, 11062, 13], "temperature": 0.0, "avg_logprob": -0.5174882552203011, "compression_ratio": 0.8939393939393939, "no_speech_prob": 0.00774416932836175}, {"id": 128, "seek": 117948, "start": 1179.48, "end": 1202.72, "text": " There was another. I think it's a bit of an obvious question. The question is how does", "tokens": [821, 390, 1071, 13, 286, 519, 309, 311, 257, 857, 295, 364, 6322, 1168, 13, 440, 1168, 307, 577, 775], "temperature": 0.0, "avg_logprob": -0.4201941092809041, "compression_ratio": 1.1168831168831168, "no_speech_prob": 0.005260131321847439}, {"id": 129, "seek": 120272, "start": 1202.72, "end": 1219.1200000000001, "text": " it compete with coin? I think we have taken different routes with coin. I think Arnault", "tokens": [309, 11831, 365, 11464, 30, 286, 519, 321, 362, 2726, 819, 18242, 365, 11464, 13, 286, 519, 1587, 629, 723], "temperature": 0.0, "avg_logprob": -0.26529374233511993, "compression_ratio": 1.359375, "no_speech_prob": 0.0005024445708841085}, {"id": 130, "seek": 120272, "start": 1219.1200000000001, "end": 1229.28, "text": " will present you this afternoon. It provides an API using annotation, more that we are", "tokens": [486, 1974, 291, 341, 6499, 13, 467, 6417, 364, 9362, 1228, 48654, 11, 544, 300, 321, 366], "temperature": 0.0, "avg_logprob": -0.26529374233511993, "compression_ratio": 1.359375, "no_speech_prob": 0.0005024445708841085}, {"id": 131, "seek": 122928, "start": 1229.28, "end": 1245.44, "text": " doing. We prefer keeping the binding declaration as much explicit as possible. After that,", "tokens": [884, 13, 492, 4382, 5145, 264, 17359, 27606, 382, 709, 13691, 382, 1944, 13, 2381, 300, 11], "temperature": 0.0, "avg_logprob": -0.18538131032671248, "compression_ratio": 1.0588235294117647, "no_speech_prob": 0.0009174825972877443}, {"id": 132, "seek": 124544, "start": 1245.44, "end": 1263.2, "text": " I think it's more some internal implementation that does not really compete, I think.", "tokens": [50364, 286, 519, 309, 311, 544, 512, 6920, 11420, 300, 775, 406, 534, 11831, 11, 286, 519, 13, 51252], "temperature": 0.0, "avg_logprob": -0.29516656398773194, "compression_ratio": 1.0897435897435896, "no_speech_prob": 0.004278754349797964}], "language": "en"}