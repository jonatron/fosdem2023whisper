{"text": " All right, so we move on to our next talk. We have Udo here with the NOVA microhypervisor update. Udo, please. Thank you, Arsalan. Good morning, everybody. Welcome to my talk at FOSSTEM. It's good to be back here after three years. The last time I presented at FOSSTEM, I gave a talk about the NOVA microhypervisor on V8, and this talk will cover the things that happened in the NOVA ecosystem since then. So just a brief overview of the agenda. For all of those who might not be familiar with NOVA, I'll give a very brief architecture overview and explain the NOVA building blocks. Then we look at all the recent innovations that happened in NOVA in the last three years. I'll talk a bit about the code unification between ARM and X86, the two architectures that we support at this point. And then I'll spend the majority of the talk going into details, into all the advanced security features, particularly in X86 that we added to NOVA recently. And towards the end, I'll talk a little bit about performance, and hopefully we'll have some time for questions. So the architecture in NOVA is similar to the microkernel-based systems that you've seen before. At the bottom, we have a kernel, which is not just a microkernel, it's actually a microhypervisor called a NOVA microhypervisor. And on top of it, we have this component-based multi-server user mode environment. Genote would be one instantiation of it. And Martin has explained that most microkernel-based systems have this structure. In our case, the HostOS consists of all these colorful boxes. We have a master controller, which is sort of the init process, which manages all the resources that the microhypervisor does not need for itself. We have a bunch of drivers. All the device drivers run in user mode, they're privileged. We have a platform manager, which primarily deals with resource enumeration and power management. You can run arbitrary host applications, many of them. And there's a bunch of multiplexers, like you want multiplexer that everybody can get a serial console and you have a single interface to it, or a network multiplexer which acts as some sort of virtual switch. And virtualization is provided by virtual machine monitors, which are also user mode applications. And we have this special configuration or this special design principle that every virtual machine uses its own instance of a virtual machine monitor. They don't all have to be the same. For example, if you run a unique kernel in VM, as shown to the far right, the virtual machine monitor could be much smaller because it doesn't need to deal with all the complexity that you would find in an OS, like Linux or Windows. So the entire HostOS consisting of the Nova Microhypervisor and the HostOS, the user mode portion of it is what Bedrock calls the ultravisor, which is a product that we ship. And once you have a virtualization layer that is very small, very secure, and basically sits outside the guest operating system, you can build interesting features like virtual machine introspection or virtualization assisted security, which uses features like nested paging, breakpoints, and patched civil overrides to harden the security of the guest operating systems, like protecting critical data structures, introspecting memory, and also features in the virtual switch for doing access control between the different virtual machines and the outside world as to who can send what types of packets. And all of that is another product which is called ultra security. The whole stack, not just the kernel, the whole stack is undergoing rigorous formal verification. And one of the properties that this formal verification effort is proving is what we call the bare metal property. And the bare metal property basically says that combining all these virtual machines on a single hypervisor has the same behavior as if you were running these as separate physical machines connected by a real ethernet switch, so that whatever happens in a virtual machine could have happened on a real physical machine that was not virtualized. That's what the bare metal property says. So the building blocks of NOVA are those that you would find in an ordinary microkernel. It's basically address basis, threads, and IPC. And NOVA address basis are called protection domains, or PD. And threads or virtual CPUs are called execution context, short EC. And for those of you who don't know NOVA very well, I've just given a very brief introductory slide for how all these mechanisms interact. So let's say you have two protection domains, PD, A and B. Each of them have one or more threads inside. And obviously, at some point, you want to intentionally cross these protection domain boundaries because these components somehow need to communicate. And that's what IPC is for. So assume that this client thread wants to send a message to the server thread. It has a thread control block, which is like a message box, puts the message in there, invokes a call, an IPC call to the hypervisor, it vectors through a portal, which routes that IPC to the server protection domain, and then the server receives the message in its UTCB. As part of this control and data transfer, the scheduling context, which is a time slice coupled with a priority, is donated to the other side. And as you can see on the right, that's the situation after the IPC call has gone through. So now the server is executing on the scheduling context of the client. The server computes a reply, puts it in its UTCB, issues a hypercall called IPC reply, and the data goes back, the reply goes back to the client, the scheduling context donation is reverted, and the client gets its time slice back. So what you get with that is very fast synchronous IPC, this time donation, and priority inheritance. And it's very fast because there's no scheduling decision on that pass. Also, NOVA is a capability-based microkernel or hypervisor, which means all operations that user components do with the kernel have capabilities as parameters. And capabilities have the nice property that they both name a resource and at the same time have to convey what access you have under that resource. So it's a very powerful access control primitive. So that said, let's look at all the things that happened in NOVA over the last two and a half or so years. And we are now on a release cadence where we put out a new release of NOVA approximately every two months. So it's always the year and the week of the year where we do releases, and this shows what we added in NOVA in 21, 22, and what we'll add to the first release of this year at the end of this month. So we started out at the beginning of 21 by unifying the code base between X86 and ARM, making the load address flexible, adding power management like suspend-resume, then extended that support to ARM. And later in 22, when that unification was complete, we started adding a lot of, let's say, advanced security features in X86, like control flow enforcement, code patching, cache allocation technology, multiple spaces, multi-key total memory encryption. And recently, we've added some APIC virtualization. So the difference between the things that are listed in bold here and those that are not listed in bold, everything in bold I'll try to cover in this talk, which is a lot, so hopefully we'll have enough time to go through all this. First of all, the design goals that we have in NOVA. And Martin already mentioned that not all microchones have the same design goals. Our design goal is that we want to provide the same or at least similar functionality across all architectures, which means the API is designed in such a way that it abstracts from architectural differences as much as possible. That you get a uniform experience, whether you're on X86 and ARM, you can create a thread and you don't have to worry about details of instructions that register set, page table format, NOVA tries to abstract all of that away. You want to have a really simple build infrastructure and you'll see in a moment what the directory layout looks like, but suffice it to say that you can build NOVA with a very simple make command where you say make architecture equals X86 or ARM, and in some cases, bold equals I don't know, Raspberry Pi or NXP, I'm X8, whatever, and it runs for maybe five seconds and then you get a binary. We use standardized processes like the standardized boot process and standardized resource enumeration as much as possible because that allows for a great reuse of code. So we use multi-boot version two or one, and if I for booting, we use ACPI for resource enumeration. You can also use the FDT, but that's more of a fallback. And for ARM, there's this interface called PSCI for power state coordination that's also abstracting this functionality across many different ARM boards. So we try to use these interfaces as much as possible. The code is designed in such a way that is formally verifiable, and in our particular case, that means formally verifying highly concurrency plus plus code, not C code, not a similar code, but C++ code, and even weekly ordered memory because ARM V8 is weak memory. And obviously, we want to be, we want Nova to be modern, small, and fast, best in class security and performance, and we'll see how we did in that. So first, let me talk about the code structure, and Martin mentioned in this talk this morning, that using directories to your advantage can really help. So on the right, you see the directory structure that we have in the unified Nova code base. We have a generic ink directory and a generic source directory. Those are the ones listed in green. And then we have architecture-specific subdirectories for ARC64 and X8664, and we have architecture-specific build directories. There's also a doc directory in which you will find the Nova interface specification, and there's a single make file unified. And when we looked at the source code and we discussed them with our formal methods engineers, we recognized that basically all the functions can be categorized into three different buckets. The first one is what we call same API and same implementation. This is totally generic code. All the system calls are totally generic code. All the memory allocators are totally generic code. Surprisingly, even page tables can be totally generic code. So these can all share the source files, the header files, and the spec files, which basically describe the interface pre and post conditions. The second bucket is functions that have the same API, but maybe a different implementation. And an example of that would be a timer where the API could be set a deadline for when a timer interrupts should fire. So the API for all callers is the same, so you can potentially share the header or the spec file. But the implementation might be different on each architecture or is very likely different. And the final bucket is those functions that have a different API and implementation and you can't share anything. So the code structure is such that architecture-specific code lives in the architecture-specific subdirectories and generic code lives in the sort of parent directories of that. And whenever you have an architecture-specific file with the same name as a generic file, the architecture-specific file takes precedence and basically overrides or shadows the generic file. And that makes it very easy to move files from architecture-specific to generic and back. So the unified code base that we ended up with, and these are the numbers from the very recent upcoming release, 2308, which will come out at the end of this month, shows sort of what we ended up with in terms of architecture-specific versus generic code. So in the middle, the green part is the generic code that's shared between all architectures and it's 4,300 lines today. x86 adds 7,000 and some lines specific code and ARM to the right adds some 5,600 lines. So if you sum that up for x86, it's roughly 11,500 lines and for ARM it's less than 10,000 lines of code. It's very small and if you look at it, ballpark 40% of the code for each architecture is generic and shareable. And that's really great, not just from a maintainability perspective, but also from a verifiability perspective because you have to specify and verify those generic portions only once. If you compile that into binaries, then the resulting binaries are also very small, like a little less than 70K in code size and obviously if you use a different compiler version or different NOVA version, these numbers will slightly differ, but it gives you an idea of how small the code base and how small the binaries will be. So let's look at some interesting aspects of the architecture because assume you've downloaded NOVA, you've built such a small binary from source code and now you want to boot it. And typical boot procedure, both on x86 and ARM, which are converging towards using UFI as firmware, will basically have this structure where UFI firmware runs first and then invokes some bootloader, passing some information like an image handle and a system table and then the bootloader runs and invokes a NOVA microhypervisor, passing also the image handle and the system table maybe adding multi-boot information. And at some point there will have to be a platform handover of all the hardware from firmware to the operating system in our case NOVA. And this handover point is called exit boot services. It's basically the very last function that you call as either a bootloader or a kernel in firmware and that's the point where firmware stops accessing all the hardware and the ownership of the hardware basically transitions over to the kernel. And the unfortunate situation is that as you call exit boot services, firmware which may have enabled the IOMU or SMMU at boot time to protect against DMA attacks drops it at this point, which sounds kind of silly, but that's what happens. And the reason if you ask those who are familiar with UFI is for legacy OS support because UFI assumes that maybe the next stage is a legacy OS which can't deal with DMA protection so it gets turned off, which is really unfortunate because between the point where you call exit boot services to take over the platform hardware and the point where NOVA can actually enable the IOMU, there's this window of opportunity shown in red here where there's no DMA protections and that's the point. It's very small, maybe a few nanoseconds or microseconds where an attacker could perform a DMA attack. And for that reason, NOVA takes complete control of the exit boot services flow, so it's not the bootloader who calls exit boot services, NOVA actually drives the UFI infrastructure and it disables all busmaster activity before calling exit boot services so that we eliminate this window of opportunity. That was a very aggressive change in NOVA because it means NOVA has to comprehend UFI. The next thing that we added was a flexible load address. So when the bootloader wants to put a binary into physical memory, it invokes it with paging being disabled, which means you have to load it at some physical address. And you can define an arbitrary physical address but it would be good if whatever physical address you define worked on all the boards. And that is simply impossible, especially in the ARM ecosystem. So in ARM some platforms have the DRAM starting at physical address zero, some have MMIO starting at address zero, so you will not find a single physical address range that works across all ARM platforms where you can say always load NOVA at two megabytes, one gigabyte, whatever. So we made the load address flexible. Also the bootloader might want to move NOVA to a dedicated point in memory like at the very top so that the bottom portion can be given one to one to a VM. So the load address is now flexible for NOVA. Not fully flexible but you can move NOVA up down by arbitrary multiples of two megabytes so add super page boundaries. And the interesting insight into this is for pulling this off, there is no L3 location complexity required. NOVA consists of two sections, a very small init section which is mapped, which is identity map which means virtual addresses equal physical addresses and that's the code that initializes the platform up to the point where you can enable paging and then there's a runtime section which runs paged so it has virtual to physical memory mappings and for those virtual to physical memory mappings if you run this paging enabled the physical addresses that back these virtual memory ranges simply don't matter. So paging is basically some form of relocation. You only need to deal with relocation for the init section and you can solve that by making the init section be position independent code. And it's assembler anyway so making that position independent is not hard. We actually didn't make the code just position independent, it is also mode independent which means no matter if UEFI starts you in 32-bit mode or 64-bit mode that code is dealing with all these situations. There's a limit, an artificial limit of you still have to load NOVA below four gigabytes because multi-boot has been defined in such a way that you can't express addresses above four gigabytes because some of these structures are still 32-bit and that little emoticon expresses what we think of that. So then after we had figured this out we wanted to do some power management and this is an overview of all the power management that ACPI defines so ACPI defines a few global states like working, sleeping and off. Those aren't all that interesting, the really interesting states are the sleep states. And the things that have this black bold border around it is the state in which the system is when it's fully up and running, no idling, no sleeping, no nothing. It's called the S0 working state and then there's some sleep state. You might know suspend to run, suspend to disk and soft off and when you're in the S0 working state you can have a bunch of idle states and in the C0 idle state you can have a bunch of performance state which roughly correspond to voltage and frequency scaling so ramping up the clock speed up and down. So unfortunately we don't have a lot of time to go into all the details of these sleep states but I want to still say a few words about this. We implemented suspend resume on both x86 and ARM and there's two ways you can go about it. One which is I would say a brute force approach and the other which is the smart approach. And the brute force approach basically goes like you look at all the devices that lose their state during a suspend resume transition and you save their entire register state. And that's a significant amount of state that you have to manage and it may even be impossible to manage it because if you have devices with hidden internal state you may not be able to get it it or if the device has a hidden internal state machine you may not know what the internal state of that device is at that point. So it may be suitable for some generic devices like if you wanted to save the configuration space of every PCI device that's generic enough that you could do that. But for some interrupt controllers or SMM use with internal state that's not smart. So for that you can actually use the second approach which Nova uses which is you save a high level configuration and you initialize the device based on that. So as an example say you had an interrupt routed to core zero in edge triggered mode. You would save that as a high level information and that's sufficient to reinitialize all the interrupt controllers all the redirection entries all the trigger modes based on just this bit of information. So there's lots less information to maintain saving becomes basically a know up restoring can actually use the same code pass that you used to initially bring up that particular device and that's the approach for all the interrupt controllers all the SMM use all the devices managed by Nova. The next thing I want to briefly talk about is P states performance states which are these gears for ramping up the clock speed on x86 and Nova can now deal with all these P states. The interesting aspect is that most modern x86 processors have something called Turbo mode and Turbo mode allows one or more processors to exceed the nominal clock speed to actually turbo up higher if other cores are idle. So if other cores are not using their thermal or power headroom is elected set of course maybe just one core maybe a few other cores can actually turbo up many bins and this is shown here on active core zero which basically gets the thermal headroom of core one core two and core three to clock up higher. So Nova will exploit that feature when it's available but there are situations where you want predictable performance where you want every core to run at its guaranteed high frequency mode and there's a command line parameter that you can set that basically clamps the maximum speed to the guaranteed frequency. You could also lower the frequency to something less than the guaranteed frequency there's a point an operating point it's called maximum efficiency and there's even points below that where you can clock really high but then it's actually less efficient than this point. So all of that is also supported. So as an overview from a feature comparison perspective ARM versus x86 we support p-states on x86 not on ARM because there's no generic interface on ARM yet we support all the s-states on x86 like stop clock, suspend, resume, hibernation, power off, platform reset. On ARM there's no such concept as one but we also support suspend, resume and suspend to disk if it's supported and what does it mean if it's supported it means if platform firmware like psci implements it and there are some features that are mandatory and some features that are optional. So suspend, resume for example works great on the nxpimx8m that Stefan had for his demo it doesn't work so great on Raspberry Pi because the firmware simply has no support for jumping back to the operating system after a suspend. So it's not a novel limitation. There's a new suspend feature called low power idle which we don't support yet because it requires way more support than just Nova basically requires powering down the GPU, powering down all the devices, powering down all the links so this is a concerted platform effort. But from a hypercore perspective the hypercore that you would invoke to transition the platform to a sleep state is called control hardware and whenever you try to invoke it with something that's not supported it returns bad feature and for the hypercodes that assign devices or interrupts the state that the system had when you assign devices or interrupts to particular domains will completely be preserved across the suspend, resume codes using this safety high level state approach. So next I'll talk about some radical API change that we made and being a micro kernel and not being Linux we don't have to remain backward compatible. So that's one of these major API changes that took quite a lot of time to implement. What we had in the past was basically an interface with five kernel objects. Protection domains, execution context, scheduling context, portals and sum of course and every protection domain looked as shown on this slide. It actually had six resource spaces built into it, an object space which hosts capabilities to all the kernel objects that you have access to, a host space which represents the stage one page table, a guest space which represents the stage two guest page table, the DMA space for memory transactions that are remapped by the IOMU, port IO space and an MSR space. So all of these existed in one single instance in every protection domain and when you created a host EC, a guest EC, like a virtual CPU or device they were automatically bound to the PD and picking up the spaces that they needed. And that is, that worked great for us for more than 10 years but it turned out to be suboptimal for some more advanced use cases like nested virtualization. If you run a hypervisor inside a virtual machine and that hypervisor creates multiple guests itself then you suddenly need more than one guest space. You need one guest space per sub guest. So you need multiple of these yellow guest spaces or when you virtualize the SMMU and the SMMU has multiple contexts and every context has its own page table then you suddenly need more than one DMA space. So you need more of these blue boxes and the same can be said for port IO and MSR spaces. So how do we get more than one if the protection domain has all these single instance? So what we did and it was quite a major API in internal reshuffling is we separated these spaces from the protection domain. They are now new first class objects. So Nova just got six new kernel objects that when you create them you get individual capabilities for them and you can manage them independently from the protection domain. So the way that this works is first you create a protection domain with create PD then you create one or more of these spaces again with create PD. So that's a sub function of create PD. And then you create an EC like a host EC and it binds to those spaces that are relevant for host EC. So a host EC like a hypostrat needs capabilities so it needs an object space it binds to that it needs a stage one page table so it binds to that and it needs access to ports so it binds to that on x86 only because on ARM there's no such thing. So for host thread all these assignments are static. We could make them flexible but we have not found a need. Gets more interesting for a guest EC which is a virtual CPU that runs in a guest. So again the sequence is the same you first create a protection domain then you create one or more of these spaces and when you create the virtual CPU it binds to those spaces that it urgently needs which is the object space and the host space. It does not yet bind to any of the flexible spaces shown to the right. And that binding is established on the startup IPC during IPC reply. You pass selectors, capability selectors to these spaces that you want to attach to and then you flexibly bind to those spaces as denoted by these dashed lines. And that assignment can be changed on every event. So every time you take a VM exit Nova synthesizers and exception IPC or architectural IPC sends it to the VMM for handling and when the VMM replies it can set a bit in the message transfer descriptor to say I want to change the space assignment it passes new selectors and then you can flexibly switch between those spaces and that allows us to implement for example nested virtualization. The same for a device which in x86 is represented by a bus device function or an arm is represented by a stream ID. The assigned depth hypercall can flexibly rebind the device to a DMA space at any time. So that took quite a while to implement but it gives us so much more flexibility and I heard that some of the Nova forks have come across the same problem so maybe that's something that could work for you too. So let's talk about page tables and I mentioned earlier that page tables are actually generic code which is somewhat surprising. Nova manages three page tables per architecture, the stage one which is the host page table, the stage two which is the guest page table and a DMA page table which is used by the IOMU and these correspond to the three memory spaces that I showed in the previous slide. And the way we made this page table code architecture independent is by using a template base class which is completely lockless so it's very scalable and the reason why it can be lockless is because the MMU doesn't honor any software locks anyway so if you put a lock around your page table infrastructure the MMU wouldn't know anything about those locks so it has to be written in a way that it does atomic transformations anyway so that the MMU never sees an inconsistent state and once you have this there's also no need to put the lock around it for any software updates so that's completely lock free. And that architecture independent base class deals with all the complexities of allocating and deallocating page tables, splitting superpages into page tables or overmapping page tables with superpages and you can derive architecture specific subclasses from it and the subclasses themselves inject themselves as a parameter to the base class that's called the curiously recurring template pattern. And the subclasses then do the transformation between the high level attributes like this page is readable, writable, user accessible, whatever into the individual bits and coding of the page table entries as that architecture needs it and also there are some coherency requirements on ARM and some coherency requirements between SMM use that don't snoop the caches so these architecture specific subclasses deal with all that complexity but it allows us to share the page table class and to specify and verify it only once. So let's look at page tables in a little bit more detail because there's some interesting stuff you need to do on ARM. So most of you who've been in an OS class or who've written a microconnet will have come across this page table format where an input address like a host virtual or guest physical address is split up into an offset portion into the final page 12 bits and then you have nine bits indexing into the individual levels of the page table. So when an address is transformed by the MMU into virtual address into physical address the MMU first uses bits 30 to 38 to index into the level two page table to find the level one and then to find the level zero and the walk can terminate early. You can have a leaf page at any level so it gives you one gigabyte, two megabyte or four k superpages and with that page table structure like this three levels you can create an address space of 512 gigabytes of size and that should be good enough but it turns out we came across several ARM platforms which have an address space size of one terabyte. So twice that they need one extra bit which you can't represent with 39 bits so you have a 40 bit address space. So what would you do if you were designing a chip? You would expect that it would just open a new level here and that you get a four level page table but ARM decided differently because they said if I just add one bit the level three page table would have just two entries and that's not worse building basically another level into it. So what they did is they came up with a concept called concatenated page table and it makes the level two page table twice as large by adding another bit at the top. So now suddenly the level two page table has 10 bits of indexing and the backing page table has 1024 entries and is 8k in size. And this concept was extended so if you go to 41 address space again you get one additional bit and the page table gets larger and this keeps going on. It can extend to up to four bits that the level two page table is 64k in size. And there's no way around it, the only time at which you can actually open the level three is when you exceed 44 bits. And then when you get 44 bits you can go to a four level and it looks like this. So the functionality that we also had to add to NOVA is to comprehend this concatenated page table format so that we can deal with arbitrary address space sizes on ARM. And we actually had a device, I think it was a Xilin CCO one or two which had something mapped above 512 gigabytes and just below one terabyte and you can't pass that through to a guest if you don't have concatenated page sheets. So the generic page table cluster we have right now is so flexible that it can basically do what's shown on this slide and the simple case is x86. You have three level, four level, or five level page tables with a uniform structure of nine bits per level and 12 offset bits. 39 isn't used by the MMU but might be used by the SMMU and the MMU typically uses four levels and in high end boxes like servers for 57. On ARM, depending on what type of SOC you have it either has something between 32 or up to 52 physical address bits and the table shows the page table level split, indexing split that NOVA has to do and all these colored boxes are basically instances of concatenated page tables. So 42 would require three bits to be concatenated, here we have four, here we have one, here we have two, so we really have to exercise all of those and we support all of those. And unlike the past where NOVA said page tables is so many levels per so many bits, we now have turned this around by saying the page table covers so many bits and we can compute the number of bits per level and the concatenation at the top level automatically in the code. So that was another fairly invasive change. While we were at re-architecting all the page tables, we took advantage of a new feature that Intel added to Islake servers and to all the Lake desktop platforms which is called total memory encryption with multiple keys. And what Intel did there is they repurposed certain bits of the physical address in the page table entry, the top bits shown here as key ID bits and so it's stealing some bits from the physical address and the key ID bits index into a key programming table shown here that basically select a slot and let's say you have four key bits that gives you 16 keys, two to the power of four, so your key indexing or your key programming table would have the opportunity to program 16 different keys. We've also come across platforms that have six bits, it's basically flexible how many bits are stolen from the physical address can vary per platform depending on how many keys are supported and those keys are used by a component called the memory encryption engine. The memory encryption engine sits at the perimeter of the package or the socket, basically at the boundary where data leaves the chip that you plug in the socket and enters the interconnect and enters RAM. So inside this green area which is inside the SOC, everything is unencrypted in the cores, in the caches, in the internal data structure, but as it leaves the die and moves out to the interconnect, it gets encrypted automatically by the memory encryption engine with the key and this example shows a separate key being used for each virtual machine which is a typical use case but it's actually very more flexible than that, you can select the key on a per page basis. So you could even say if there was a need for these two VMs to share some memory that some blue pages would appear here and some yellow pages would appear here, that's possible. So we added support in the page tables for encoding these key ID bits, we added support for using the P-config instruction for programming keys into the memory encryption engine and the keys can come in two forms, you can either randomly generate them, in which case Nova will also drive the digital random number generator to generate entropy or you can program tenant keys. So you can say I want to use this particular AS key for encrypting the memory and that's useful for things like VM migration where you want to take an encrypted VM and move it from one machine to another. And the reason why Intel introduced this feature is for confidential computing but also because DRAM is slowly moving towards non-volatile RAM and offline either made a tag or so where somebody unplugged your RAM or takes your non-volatile RAM and then looks at it in another computer is a big problem and they can still unplug your RAM but they would only see ciphertext. So next thing we looked at was, so this was more of a confidentiality improvement, next thing we looked at is improving the availability and we added some support for dealing with noisy neighbor domains. So what are noisy neighbor domains? Let's say you have a quad core system as shown on this slide and you have a bunch of virtual machines as shown at the top. On some cores you may over provision the cores run more than one VM like on core zero and core one. For some use cases you might want to run a single VM on a core only like a real time VM which is exclusively assigned to core two but then on some cores like shown on far right you may have a VM that's somewhat misbehaving and somewhat misbehaving means it uses excessive amounts of memory and basically evicts everybody else out of the cache. So if you look at the last level cache portion here, the amount of cache that is assigned to the noisy VM is very disproportionate to the amount of cache given to the other VM simply because this is trampling all over memory. And this is very undesirable from a predictability perspective especially if you have a VM like the green one that's real time which may want to have most of its working set in the cache. So is there something we can do about it? And yes there is. It's called cat. Cat is Intel's acronym for cache allocation technology and what they added in the hardware is a concept called class of service. And you can think of class of service as a number and again like the key idea is there's a limited number of classes of service available like four or sixteen and you can assign this class of service number to each entity that shares the cache. So you could make it a property of a protection domain or a property of a thread. And for each of the classes of service you can program a capacity bit mask which says what proportion of the cache can this class of service use? Can it use 20%, 50% and even which portion? There are some limitations like the bit mask must be contiguous but they can overlap for sharing and there's a model specific register which is not cheap to program where you can say this is the active class of service on this core right now. So this is something you would have to contact switch to say I'm now using something else. And when you use this it improves the predictability like the worst case execution time quite nicely and that's what it was originally designed for. But it turns out it also helps tremendously with dealing with cache side channel attacks because if you can partition your cache in such a way that your attacker doesn't allocate into the same ways as the VM you're trying to protect then all the flush and reload attacks simply don't work. So here's an example for how this works and to the right I've shown an example number of six classes of service and a cache which has 20 ways. And you can program and this is again just an example you can program the capacity bit mask for each class of service for example to create full isolation so you could say class of service gets 40% of the cache, weighs 0 to 7 and class of service 1 gets 20% and everybody else gets 10% and these capacity bit masks don't overlap at all which means you get zero interference through the level 3 cache. You could also program them to overlap. There's another mode which is called CDP code and data prioritization which splits the number of classes of service in half and basically redefines the meaning of the bit mask to say those with an even number are for data and those with an odd number are for code. So you can even discriminate how the cache is being used between code and data and gives you more fine-grained control and the NOVA API forces users to declare upfront whether they want to use CAT or CDP to partition their cache and only after you've made that decision can you actually configure the capacity bit masks. So with CDP it would look like this. You get three classes of service instead of six, distinguished between D and C, data and code and you could for example say class of service 1 as shown on the right gets 20% of the cache for data, 30% of cache for the code, so 50% of the capacity in total exclusively assigned to anybody who's class of service 1 and the rest shares capacity bit masks and here you see an example of how the bit masks can overlap and wherever they overlap the cache capacity is being competitively shared. So that's also a new feature that we support right now. Now the question is class of service is something you need to assign to cache sharing entities. To what type of object do you assign that? And you could assign that to a protection domain. You could say every box on the architecture slide gets assigned a certain class of service and the question is then what do you assign to a server that has multiple clients? It's really unfortunate and what also means is if you have a protection domain that spends multiple cores and you say I want this protection domain to use 40% of the cache, you have to program the class of service settings on all cores the same way. So it's really a loss of flexibility. So that wasn't our favorite choice and we said maybe we should assign class of service to execution contexts instead. And again the question is what class of service do you assign to a server execution context that does work on behalf of clients and the actual killer argument was that you would need to set the class of service in this model specific register again during each context switch which is really bad for performance. So even option two is not what we went for. Instead we made the class of service a property of the scheduling context and that has very nice properties. We only need to context switch it during scheduling decisions so the cost of reprogramming that MSR is really not relevant anymore and it extends the already existing model of time and priority donation with class of service donation. So a server does not need to have a class of service assigned to it at all. It uses the class of service of its client. So if let's say your server implements some file system or so, then the amount of cache it can use depends on whether your client can use a lot of cache or whether your client cannot use a lot of cache. So it's a nice extension of an existing feature and the additional benefit is that the classes of service can be programmed differently per core. So 8 cores times 6 classes of service gives you 48 classes of service in total instead of 6. So that was a feature for availability. We also added some features for integrity and if you look at the history, there's a long history of features being added to paging that improve the integrity of code against injection attacks. And it all started out many years ago with these 64-bit architecture where you could mark pages non-executable and you could basically enforce that pages are either writable or executable but never both. So there's no confusion between data and code. And then over the years, more features were added like supervisor mode execution prevention where if you use that feature, kernel code can never jump into a user page and be confused as executing some user code. And then there's another feature called supervisor mode access prevention which even says kernel code can never without explicitly declaring that it wants to do that, read some user data page. So all of these tighten the security and naturally Nova supports them. There's a new one called mode-based execution control which is only relevant for guest page tables or stage two which gives you two separate execution bits. So there's not a single X bit. There's now executable for user and executable for super user. And that is a feature that ultra security can, for example, use where we can say even if the guest screws up its page tables, it's stage one page tables, the stage two page tables can still say Linux user applications or Linux kernel code can never execute Linux user application code if it's marked as XS in the stage two page table. So it's again a feature that can tighten the security of guest operating systems from the host. But even if you have all that, there are still opportunities for code injection and these classes of attacks basically reuse existing code snippets and chain them together in interesting ways using control flow hijacking like Rob attacks. And I'm not sure who's familiar with Rob attacks is basically you create a call stack with lots of return addresses that chain together simple code snippets like add this register return, multiply this register return, jump to this function return. And by chaining them all together, you can build programs out of existing code snippets that do what the attacker wants. You don't have to inject any code. You simply find snippets in existing code that do what you what you want. And this doesn't work so well on arm. It still works on arm, but on arm, the instruction length is flex is fixed to four bytes. So you can't jump into the middle of instructions. But on x86 with a flexible instruction size, you can even jump into the middle of instructions and completely reinterpret what existing code looks like. And that's quite unfortunate. So there's feature that tightens the security around that and it's called control flow enforcement technology or CT. And that feature adds integrity to the control flow graph, both to the forward edge and to the backward edge and forward edge basically means you protect jumps or calls that jump from one location forward to somewhere else. And the way that this works is that the legitimate jump destination where you want the jump to land, this landing pad, must have a specific end branch instruction placed there. And if you try to jump to a place which doesn't have an end branch landing pad, then you get a control flow violation exception. So you need the help of the compiler to put that landing pad at the beginning of every legitimate function and luckily GCC and other compilers have had that support for quite a while. So GCC sends eight and we are now at 12. So that works for forward edges. For backward edges, there's another feature called shadow stack. And that protects the return addresses on your stack and we'll have an example later. And it basically has a shadow call stack which you can't write to. It's protected by paging and if it's writable, then it won't be usable as a shadow stack. And you can independently compile Nova with branch protection, with return address protection or both. So let's look at indirect branch tracking and I try to come up with a good example and I actually found a function in Nova which is suitable to explaining how this works. Nova has a body allocator that can allocate contiguous chunks of memory and that body allocator has a free function where you basically return an address and say free this block. And the function is really as simple as shown there, it just consists of these few instructions because it's a tail call that jumps to some coalescing function here later and you don't have to understand all the complicated assembler but suffice it to say that there's a little test here of these two instructions which performs some meaningful check and you know that you can't free a null pointer. So this test checks if the address passed as the first parameter is a null pointer and if so it jumps out right here. So basically the function does nothing, does no harm, it's basically a knob. Let's say an attacker actually wanted to compromise memory and instead of jumping to the beginning of this function, it wanted to jump past that check to this red instruction to bypass the check and then corrupt memory. Without control flow enforcement that would be possible if the attacker could gain execution but with control flow it wouldn't work because when you do a call or a jump you have to land on an end branch instruction and the compiler has put that instruction there. So if an attacker managed to get control and tried to jump to a vtable or some indirect pointer to this address, you would immediately crash. So this is how indirect branch tracking works. Shadow stacks work like this. With a normal data stack you have your local variables on your stack, you have the parameters for the next function on the stack, so the green function wants to call the blue function and then when you do the call instruction the return address gets put on your stack. Then the blue function puts its local variables on a stack, wants to call the yellow function, puts the parameters for the yellow function on the stack, calls the yellow function so the return address for the blue function gets put on a stack. And you see in the stack grows downward and you see that the return address always lives above the local variables. So if your local variables, if you allocate an array on a stack and you don't have proper bounds checking, it's possible to override the return address by writing past the array and this is a popular attack technique, buffer overflow exploits that you find in the wild. So if you have code that is potentially susceptible to these kind of return address overrides, then you could benefit from shadow stacks. And the way that this works is there's a separate stack, this shadow stack, which is protected by paging so you can't write to it with any ordinary memory instructions, it's basically invisible and the only instructions that can write to it are call and read instructions and some shadow management instructions. And when the green function calls the blue function, the return address will not just be put on the ordinary data stack, but will additionally be put on the shadow stack and likewise with the blue and the yellow return address. And whenever you execute a return instruction, the hardware will compare the two return addresses that it pops off the two stacks and if they don't match, you again get a control flow violation. So that way, you can protect the backward edge of the control flow graph also using shadow stacks. There's a feature that NOVA uses on Tiger Lake and all the lake and platforms beyond that that have this feature. But there's a problem. And the problem is that using shadow stack instructions is possible on newer CPUs that have these instructions, that basically have this ISA extension, but if you have a binary containing those instructions, it would crash on older CPUs that don't comprehend that. And luckily, Intel defined the end branch instruction to be a knob, but some shadow stack instructions are not knobs. So if you try to execute a CET and able NOVA binary on something older without other effort, it might crash. So obviously, we don't want that. So what NOVA does instead, it detects at runtime whether CET is supported and if CET is not supported, it patches out all these CET instructions in the existing binary to turn them into knobs. And obviously, being a microkernel, we try to generalize the mechanism. So we generalize that mechanism to be able to rewrite arbitrary assembler snippets from one version to another version. And there's other examples for newer instructions that do better work than older instructions like the Xsave feature set, which can save supervisor state or save floating point state in a compact format. And the binary, as you build it originally, always uses the most sophisticated version. So it uses the most advanced instruction that you can find. And if we run that on some CPU, which doesn't support the instruction or which supports some older instruction, then we use code patching to rewrite the newer instruction into the older one. So the binary automatically adjusts to the feature set of the underlying hardware. The newer your CPU, the less patching occurs, but it works quite well. And the reason we chose this approach, because the alternatives aren't actually great. So the alternatives would have been that you put some if-defs in your code and you say, if they've CET, use the CET instructions, and otherwise don't. And then you force your customers or your community to always compile the binary the right way, and that doesn't scale. The other option could have been that you put some if-then-else, you say, if CET is supported, do this, otherwise do that. And that would be a runtime check every time. And that runtime check is prohibitive in certain code paths, like NT paths, where you simply don't have any register-free for doing this check because you have to save them all. But in order to save them, you already need to know whether Shadows.Tex are supported or not. So doing this feature check at boot time and rewriting the binary to the suitable instruction is what we do, and that works great. So the way it works is you declare some assembler snippets, like Xsave S is the preferred version. If Xsave S is not supported, the snippet gets rewritten to Xsave, or a Shadows.Tex instruction gets rewritten to a knob. We don't need to patch any high-level C++ functions because they never compile to those complicated instructions. And yeah, we basically have a binary that automatically adjusts. So finally, let's take a look at performance because IPC performance is still a relevant metric if you want to be not just small but also fast. And the blue bars here in the slide show Nova's baseline performance on modern Intel platforms like NUC12 with Alder Lake and NUC11 with Tiger Lake. And you can see that if you do an IPC between two threads in the same address space, it's really in the low nanosecond range, like 200 and some cycles. If you cross address spaces, you have to switch page tables, you have to maybe switch class of service, then it takes 536 cycles. And it's comparable on other micro-architectures, but the interesting thing that I want to show with this slide is that there's overhead for control flow protection. So if you just enable indirect branch tracking, the performance overhead is some 13% to 15%. If you enable shadow stacks, the performance overhead is increased some more. And if you enable the full control flow protection, the performance overhead is in the relevant case, which is the cross address space case, it's up to 30%. So users can freely choose through these compile time options what level of control flow protection they are willing to trade for what in decrease in performance. So the numbers are basically just ballpark figures to give people feeling for if I use this feature, how much IPC performance do I lose? So with that, I'm at the end of my talk. There are some links here where you can download releases, where you can find more information. And now I'll open it up for questions. Thank you so much, Udon. So we have time for some questions. Yeah. And then you're partying. Thank you. It was really, really nice talk with us to see how many new things are in Nova. One thing I would like to ask is you mentioned that page table code is formally verified and that it's also lock free. What tools did you use for formal verification, especially in regards of memory model for verification? Thank you. So I must say that I'm not a formal verification expert, but I obviously have regular meetings and discussions with all the people. And the tools that we are using is the Koch theorem for basically doing the proofs. But for concurrent verification, there's a tool called iris that implements separation logic. Well, the memory model that we verify depends on whether you're talking about x86 or ARM. For ARM, we're using multi-copy atomic memory model. Also, thanks for the talk. And it's great to see such a nice progress. Just a quick question. In the beginning of the talk, you said that you have this command line option to clamp the CPU frequency to disable the turbo boosting. Why can't you do that at runtime? Why can't you configure it at runtime? We could configure it at runtime too, but we haven't added an API yet because the code that would have to do that simply doesn't exist yet. But there's no technical reason for why userland couldn't control the CPU frequency at arbitrary points in time. Okay, wonderful. Thanks. I was going to ask you about the verification aspect of this. Okay, got you. Any other questions? Yeah. Can you just say, sorry, Jonathan, it's going to be a lot too. Yeah, just to clarify, on the point of the DMA attack, were you talking about protecting the guests or the host or the DMA attack? So the question was for the DMA attack that I showed in this slide here, and you'll find the slides online after the talk. This is not a DMA attack of guest versus host, this is a boot time DMA attack. So this is, you can really think of this as a timeline, firmware starts, boot loader starts, Nova starts. And at the time that Nova turns on the IOMU, both guests and hosts will be DMA protected. But Nova itself could be susceptible to DMA attack if we didn't disable bus master simply because the firmware does this legacy backward compatible shenanigans that we don't like. And I bet a lot of other microcalls are susceptible to problems like this too, and the fix would work for them as well. Thanks, Udo, for the talk. I would like to know, can you approximate how much percentage of the architecture specific code is now added because of the security measures? So most of the security measures that I talked about are x86 specific, and ARM has similar features like they have a guarded control stack specified in ARM v9, but I don't think you can buy any hardware yet. You can take the difference between x86 and ARX64 as a rough ballpark figure, but it's really not all that much the, for example, the multi key total memory encryption. That's just a few lines of code added to the x86 specific pitch table class because it was already built into the generic class to begin with. Code flow enforcement is probably 400 lines of assembler code in entry, pass, and the switching. I did a quick test as to how many end branch instructions a compiler would actually inject into the code. It's like 500 or so because you get one for every interrupt entry and then one for every function, and it also inflates the size of the binary a bit, but not much. And the performance decrease for indirect branch checking, among other things, comes from the fact that the code gets inflated and it's not as dense anymore. Okay. Yeah, final question, please, because red is one of the, yeah. You were saying that you were able to achieve an L binary without rotations. Yeah. Can you elaborate a little bit on how did you do that, which linker did you use? So it's the normal GNU-LD, but you could also use gold or mold or any of the normal linkers. So the reason for why no relocation is needed is for the page code, as long as you put the right physical address in your page table, the virtual address is always the same. So virtual memory is some form of relocation where you say no matter where I run in physical memory, the virtual memory is always the same. For the unpaged code, which doesn't know at which physical address it was actually launched, you have to use position independent code, basically say I don't care at which physical address I run, I can run it in arbitrary address because all my data structures are addressed with relative or something like that. And at some point you need to know what the offset is between where you want it to run and where you do actually run, but that's simple. It's like you call your next instruction, you pop the return address of the stack, you compute the difference and then you know. Thank you so much, Udo. Thank you. So the slides are online, the recording as well.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 8.72, "text": " All right, so we move on to our next talk.", "tokens": [1057, 558, 11, 370, 321, 1286, 322, 281, 527, 958, 751, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 1, "seek": 0, "start": 8.72, "end": 12.76, "text": " We have Udo here with the NOVA microhypervisor update.", "tokens": [492, 362, 624, 2595, 510, 365, 264, 9146, 20914, 4532, 3495, 610, 16457, 5623, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 2, "seek": 0, "start": 12.76, "end": 13.76, "text": " Udo, please.", "tokens": [624, 2595, 11, 1767, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 3, "seek": 0, "start": 13.76, "end": 14.76, "text": " Thank you, Arsalan.", "tokens": [1044, 291, 11, 1587, 82, 14163, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 4, "seek": 0, "start": 14.76, "end": 16.6, "text": " Good morning, everybody.", "tokens": [2205, 2446, 11, 2201, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 5, "seek": 0, "start": 16.6, "end": 18.8, "text": " Welcome to my talk at FOSSTEM.", "tokens": [4027, 281, 452, 751, 412, 479, 4367, 6840, 6683, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 6, "seek": 0, "start": 18.8, "end": 21.28, "text": " It's good to be back here after three years.", "tokens": [467, 311, 665, 281, 312, 646, 510, 934, 1045, 924, 13], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 7, "seek": 0, "start": 21.28, "end": 29.0, "text": " The last time I presented at FOSSTEM, I gave a talk about the NOVA microhypervisor on V8,", "tokens": [440, 1036, 565, 286, 8212, 412, 479, 4367, 6840, 6683, 11, 286, 2729, 257, 751, 466, 264, 9146, 20914, 4532, 3495, 610, 16457, 322, 691, 23, 11], "temperature": 0.0, "avg_logprob": -0.2828844417225231, "compression_ratio": 1.4930232558139536, "no_speech_prob": 0.3173436224460602}, {"id": 8, "seek": 2900, "start": 29.0, "end": 34.68, "text": " and this talk will cover the things that happened in the NOVA ecosystem since then.", "tokens": [293, 341, 751, 486, 2060, 264, 721, 300, 2011, 294, 264, 9146, 20914, 11311, 1670, 550, 13], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 9, "seek": 2900, "start": 34.68, "end": 37.04, "text": " So just a brief overview of the agenda.", "tokens": [407, 445, 257, 5353, 12492, 295, 264, 9829, 13], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 10, "seek": 2900, "start": 37.04, "end": 41.64, "text": " For all of those who might not be familiar with NOVA, I'll give a very brief architecture", "tokens": [1171, 439, 295, 729, 567, 1062, 406, 312, 4963, 365, 9146, 20914, 11, 286, 603, 976, 257, 588, 5353, 9482], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 11, "seek": 2900, "start": 41.64, "end": 44.6, "text": " overview and explain the NOVA building blocks.", "tokens": [12492, 293, 2903, 264, 9146, 20914, 2390, 8474, 13], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 12, "seek": 2900, "start": 44.6, "end": 49.84, "text": " Then we look at all the recent innovations that happened in NOVA in the last three years.", "tokens": [1396, 321, 574, 412, 439, 264, 5162, 24283, 300, 2011, 294, 9146, 20914, 294, 264, 1036, 1045, 924, 13], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 13, "seek": 2900, "start": 49.84, "end": 53.96, "text": " I'll talk a bit about the code unification between ARM and X86, the two architectures", "tokens": [286, 603, 751, 257, 857, 466, 264, 3089, 517, 3774, 1296, 45209, 293, 1783, 22193, 11, 264, 732, 6331, 1303], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 14, "seek": 2900, "start": 53.96, "end": 56.16, "text": " that we support at this point.", "tokens": [300, 321, 1406, 412, 341, 935, 13], "temperature": 0.0, "avg_logprob": -0.11610130570892595, "compression_ratio": 1.6738351254480286, "no_speech_prob": 8.567896293243393e-05}, {"id": 15, "seek": 5616, "start": 56.16, "end": 61.36, "text": " And then I'll spend the majority of the talk going into details, into all the advanced", "tokens": [400, 550, 286, 603, 3496, 264, 6286, 295, 264, 751, 516, 666, 4365, 11, 666, 439, 264, 7339], "temperature": 0.0, "avg_logprob": -0.11193876587942744, "compression_ratio": 1.51931330472103, "no_speech_prob": 1.2021793736494146e-05}, {"id": 16, "seek": 5616, "start": 61.36, "end": 68.2, "text": " security features, particularly in X86 that we added to NOVA recently.", "tokens": [3825, 4122, 11, 4098, 294, 1783, 22193, 300, 321, 3869, 281, 9146, 20914, 3938, 13], "temperature": 0.0, "avg_logprob": -0.11193876587942744, "compression_ratio": 1.51931330472103, "no_speech_prob": 1.2021793736494146e-05}, {"id": 17, "seek": 5616, "start": 68.2, "end": 71.64, "text": " And towards the end, I'll talk a little bit about performance, and hopefully we'll have", "tokens": [400, 3030, 264, 917, 11, 286, 603, 751, 257, 707, 857, 466, 3389, 11, 293, 4696, 321, 603, 362], "temperature": 0.0, "avg_logprob": -0.11193876587942744, "compression_ratio": 1.51931330472103, "no_speech_prob": 1.2021793736494146e-05}, {"id": 18, "seek": 5616, "start": 71.64, "end": 73.88, "text": " some time for questions.", "tokens": [512, 565, 337, 1651, 13], "temperature": 0.0, "avg_logprob": -0.11193876587942744, "compression_ratio": 1.51931330472103, "no_speech_prob": 1.2021793736494146e-05}, {"id": 19, "seek": 5616, "start": 73.88, "end": 81.19999999999999, "text": " So the architecture in NOVA is similar to the microkernel-based systems that you've", "tokens": [407, 264, 9482, 294, 9146, 20914, 307, 2531, 281, 264, 4532, 74, 1248, 338, 12, 6032, 3652, 300, 291, 600], "temperature": 0.0, "avg_logprob": -0.11193876587942744, "compression_ratio": 1.51931330472103, "no_speech_prob": 1.2021793736494146e-05}, {"id": 20, "seek": 8120, "start": 81.2, "end": 87.16, "text": " seen before. At the bottom, we have a kernel, which is not just a microkernel, it's actually", "tokens": [1612, 949, 13, 1711, 264, 2767, 11, 321, 362, 257, 28256, 11, 597, 307, 406, 445, 257, 4532, 74, 1248, 338, 11, 309, 311, 767], "temperature": 0.0, "avg_logprob": -0.1637932961447197, "compression_ratio": 1.642570281124498, "no_speech_prob": 2.1103693143231794e-05}, {"id": 21, "seek": 8120, "start": 87.16, "end": 90.48, "text": " a microhypervisor called a NOVA microhypervisor.", "tokens": [257, 4532, 3495, 610, 16457, 1219, 257, 9146, 20914, 4532, 3495, 610, 16457, 13], "temperature": 0.0, "avg_logprob": -0.1637932961447197, "compression_ratio": 1.642570281124498, "no_speech_prob": 2.1103693143231794e-05}, {"id": 22, "seek": 8120, "start": 90.48, "end": 95.56, "text": " And on top of it, we have this component-based multi-server user mode environment.", "tokens": [400, 322, 1192, 295, 309, 11, 321, 362, 341, 6542, 12, 6032, 4825, 12, 12484, 331, 4195, 4391, 2823, 13], "temperature": 0.0, "avg_logprob": -0.1637932961447197, "compression_ratio": 1.642570281124498, "no_speech_prob": 2.1103693143231794e-05}, {"id": 23, "seek": 8120, "start": 95.56, "end": 97.76, "text": " Genote would be one instantiation of it.", "tokens": [3632, 1370, 576, 312, 472, 9836, 6642, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.1637932961447197, "compression_ratio": 1.642570281124498, "no_speech_prob": 2.1103693143231794e-05}, {"id": 24, "seek": 8120, "start": 97.76, "end": 102.68, "text": " And Martin has explained that most microkernel-based systems have this structure.", "tokens": [400, 9184, 575, 8825, 300, 881, 4532, 74, 1248, 338, 12, 6032, 3652, 362, 341, 3877, 13], "temperature": 0.0, "avg_logprob": -0.1637932961447197, "compression_ratio": 1.642570281124498, "no_speech_prob": 2.1103693143231794e-05}, {"id": 25, "seek": 8120, "start": 102.68, "end": 106.96000000000001, "text": " In our case, the HostOS consists of all these colorful boxes.", "tokens": [682, 527, 1389, 11, 264, 22047, 4367, 14689, 295, 439, 613, 18506, 9002, 13], "temperature": 0.0, "avg_logprob": -0.1637932961447197, "compression_ratio": 1.642570281124498, "no_speech_prob": 2.1103693143231794e-05}, {"id": 26, "seek": 10696, "start": 106.96, "end": 111.39999999999999, "text": " We have a master controller, which is sort of the init process, which manages all the", "tokens": [492, 362, 257, 4505, 10561, 11, 597, 307, 1333, 295, 264, 3157, 1399, 11, 597, 22489, 439, 264], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 27, "seek": 10696, "start": 111.39999999999999, "end": 115.08, "text": " resources that the microhypervisor does not need for itself.", "tokens": [3593, 300, 264, 4532, 3495, 610, 16457, 775, 406, 643, 337, 2564, 13], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 28, "seek": 10696, "start": 115.08, "end": 116.32, "text": " We have a bunch of drivers.", "tokens": [492, 362, 257, 3840, 295, 11590, 13], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 29, "seek": 10696, "start": 116.32, "end": 120.19999999999999, "text": " All the device drivers run in user mode, they're privileged.", "tokens": [1057, 264, 4302, 11590, 1190, 294, 4195, 4391, 11, 436, 434, 25293, 13], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 30, "seek": 10696, "start": 120.19999999999999, "end": 125.63999999999999, "text": " We have a platform manager, which primarily deals with resource enumeration and power", "tokens": [492, 362, 257, 3663, 6598, 11, 597, 10029, 11215, 365, 7684, 465, 449, 5053, 293, 1347], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 31, "seek": 10696, "start": 125.63999999999999, "end": 126.96, "text": " management.", "tokens": [4592, 13], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 32, "seek": 10696, "start": 126.96, "end": 132.16, "text": " You can run arbitrary host applications, many of them.", "tokens": [509, 393, 1190, 23211, 3975, 5821, 11, 867, 295, 552, 13], "temperature": 0.0, "avg_logprob": -0.18610682090123495, "compression_ratio": 1.6869565217391305, "no_speech_prob": 3.166451642755419e-05}, {"id": 33, "seek": 13216, "start": 132.16, "end": 137.16, "text": " And there's a bunch of multiplexers, like you want multiplexer that everybody can get", "tokens": [400, 456, 311, 257, 3840, 295, 3311, 2021, 433, 11, 411, 291, 528, 3311, 2021, 260, 300, 2201, 393, 483], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 34, "seek": 13216, "start": 137.16, "end": 142.96, "text": " a serial console and you have a single interface to it, or a network multiplexer which acts", "tokens": [257, 17436, 11076, 293, 291, 362, 257, 2167, 9226, 281, 309, 11, 420, 257, 3209, 3311, 2021, 260, 597, 10672], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 35, "seek": 13216, "start": 142.96, "end": 145.07999999999998, "text": " as some sort of virtual switch.", "tokens": [382, 512, 1333, 295, 6374, 3679, 13], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 36, "seek": 13216, "start": 145.07999999999998, "end": 149.35999999999999, "text": " And virtualization is provided by virtual machine monitors, which are also user mode", "tokens": [400, 6374, 2144, 307, 5649, 538, 6374, 3479, 26518, 11, 597, 366, 611, 4195, 4391], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 37, "seek": 13216, "start": 149.35999999999999, "end": 150.92, "text": " applications.", "tokens": [5821, 13], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 38, "seek": 13216, "start": 150.92, "end": 157.44, "text": " And we have this special configuration or this special design principle that every virtual", "tokens": [400, 321, 362, 341, 2121, 11694, 420, 341, 2121, 1715, 8665, 300, 633, 6374], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 39, "seek": 13216, "start": 157.44, "end": 161.28, "text": " machine uses its own instance of a virtual machine monitor.", "tokens": [3479, 4960, 1080, 1065, 5197, 295, 257, 6374, 3479, 6002, 13], "temperature": 0.0, "avg_logprob": -0.1464471907842727, "compression_ratio": 1.8508064516129032, "no_speech_prob": 2.8840036975452676e-05}, {"id": 40, "seek": 16128, "start": 161.28, "end": 162.68, "text": " They don't all have to be the same.", "tokens": [814, 500, 380, 439, 362, 281, 312, 264, 912, 13], "temperature": 0.0, "avg_logprob": -0.13924082289350795, "compression_ratio": 1.510548523206751, "no_speech_prob": 1.4052067854208872e-05}, {"id": 41, "seek": 16128, "start": 162.68, "end": 167.56, "text": " For example, if you run a unique kernel in VM, as shown to the far right, the virtual", "tokens": [1171, 1365, 11, 498, 291, 1190, 257, 3845, 28256, 294, 18038, 11, 382, 4898, 281, 264, 1400, 558, 11, 264, 6374], "temperature": 0.0, "avg_logprob": -0.13924082289350795, "compression_ratio": 1.510548523206751, "no_speech_prob": 1.4052067854208872e-05}, {"id": 42, "seek": 16128, "start": 167.56, "end": 172.2, "text": " machine monitor could be much smaller because it doesn't need to deal with all the complexity", "tokens": [3479, 6002, 727, 312, 709, 4356, 570, 309, 1177, 380, 643, 281, 2028, 365, 439, 264, 14024], "temperature": 0.0, "avg_logprob": -0.13924082289350795, "compression_ratio": 1.510548523206751, "no_speech_prob": 1.4052067854208872e-05}, {"id": 43, "seek": 16128, "start": 172.2, "end": 180.16, "text": " that you would find in an OS, like Linux or Windows.", "tokens": [300, 291, 576, 915, 294, 364, 12731, 11, 411, 18734, 420, 8591, 13], "temperature": 0.0, "avg_logprob": -0.13924082289350795, "compression_ratio": 1.510548523206751, "no_speech_prob": 1.4052067854208872e-05}, {"id": 44, "seek": 16128, "start": 180.16, "end": 188.72, "text": " So the entire HostOS consisting of the Nova Microhypervisor and the HostOS, the user mode", "tokens": [407, 264, 2302, 22047, 4367, 33921, 295, 264, 27031, 25642, 3495, 610, 16457, 293, 264, 22047, 4367, 11, 264, 4195, 4391], "temperature": 0.0, "avg_logprob": -0.13924082289350795, "compression_ratio": 1.510548523206751, "no_speech_prob": 1.4052067854208872e-05}, {"id": 45, "seek": 18872, "start": 188.72, "end": 195.32, "text": " portion of it is what Bedrock calls the ultravisor, which is a product that we ship.", "tokens": [8044, 295, 309, 307, 437, 19893, 17799, 5498, 264, 14808, 16457, 11, 597, 307, 257, 1674, 300, 321, 5374, 13], "temperature": 0.0, "avg_logprob": -0.16381077888684395, "compression_ratio": 1.6842105263157894, "no_speech_prob": 2.282045352330897e-05}, {"id": 46, "seek": 18872, "start": 195.32, "end": 200.6, "text": " And once you have a virtualization layer that is very small, very secure, and basically", "tokens": [400, 1564, 291, 362, 257, 6374, 2144, 4583, 300, 307, 588, 1359, 11, 588, 7144, 11, 293, 1936], "temperature": 0.0, "avg_logprob": -0.16381077888684395, "compression_ratio": 1.6842105263157894, "no_speech_prob": 2.282045352330897e-05}, {"id": 47, "seek": 18872, "start": 200.6, "end": 206.28, "text": " sits outside the guest operating system, you can build interesting features like virtual", "tokens": [12696, 2380, 264, 8341, 7447, 1185, 11, 291, 393, 1322, 1880, 4122, 411, 6374], "temperature": 0.0, "avg_logprob": -0.16381077888684395, "compression_ratio": 1.6842105263157894, "no_speech_prob": 2.282045352330897e-05}, {"id": 48, "seek": 18872, "start": 206.28, "end": 211.96, "text": " machine introspection or virtualization assisted security, which uses features like nested", "tokens": [3479, 560, 2635, 19997, 420, 6374, 2144, 30291, 3825, 11, 597, 4960, 4122, 411, 15646, 292], "temperature": 0.0, "avg_logprob": -0.16381077888684395, "compression_ratio": 1.6842105263157894, "no_speech_prob": 2.282045352330897e-05}, {"id": 49, "seek": 21196, "start": 211.96, "end": 219.44, "text": " paging, breakpoints, and patched civil overrides to harden the security of the guest operating", "tokens": [280, 3568, 11, 1821, 20552, 11, 293, 9972, 292, 5605, 670, 81, 1875, 281, 50203, 264, 3825, 295, 264, 8341, 7447], "temperature": 0.0, "avg_logprob": -0.16564079884732708, "compression_ratio": 1.6680497925311204, "no_speech_prob": 1.1297044693492353e-05}, {"id": 50, "seek": 21196, "start": 219.44, "end": 226.24, "text": " systems, like protecting critical data structures, introspecting memory, and also features in", "tokens": [3652, 11, 411, 12316, 4924, 1412, 9227, 11, 560, 28713, 278, 4675, 11, 293, 611, 4122, 294], "temperature": 0.0, "avg_logprob": -0.16564079884732708, "compression_ratio": 1.6680497925311204, "no_speech_prob": 1.1297044693492353e-05}, {"id": 51, "seek": 21196, "start": 226.24, "end": 232.88, "text": " the virtual switch for doing access control between the different virtual machines and", "tokens": [264, 6374, 3679, 337, 884, 2105, 1969, 1296, 264, 819, 6374, 8379, 293], "temperature": 0.0, "avg_logprob": -0.16564079884732708, "compression_ratio": 1.6680497925311204, "no_speech_prob": 1.1297044693492353e-05}, {"id": 52, "seek": 21196, "start": 232.88, "end": 236.48000000000002, "text": " the outside world as to who can send what types of packets.", "tokens": [264, 2380, 1002, 382, 281, 567, 393, 2845, 437, 3467, 295, 30364, 13], "temperature": 0.0, "avg_logprob": -0.16564079884732708, "compression_ratio": 1.6680497925311204, "no_speech_prob": 1.1297044693492353e-05}, {"id": 53, "seek": 21196, "start": 236.48000000000002, "end": 241.56, "text": " And all of that is another product which is called ultra security.", "tokens": [400, 439, 295, 300, 307, 1071, 1674, 597, 307, 1219, 14808, 3825, 13], "temperature": 0.0, "avg_logprob": -0.16564079884732708, "compression_ratio": 1.6680497925311204, "no_speech_prob": 1.1297044693492353e-05}, {"id": 54, "seek": 24156, "start": 241.56, "end": 248.28, "text": " The whole stack, not just the kernel, the whole stack is undergoing rigorous formal verification.", "tokens": [440, 1379, 8630, 11, 406, 445, 264, 28256, 11, 264, 1379, 8630, 307, 40033, 29882, 9860, 30206, 13], "temperature": 0.0, "avg_logprob": -0.12417959585422422, "compression_ratio": 1.7818181818181817, "no_speech_prob": 1.7772377759683877e-05}, {"id": 55, "seek": 24156, "start": 248.28, "end": 252.48, "text": " And one of the properties that this formal verification effort is proving is what we", "tokens": [400, 472, 295, 264, 7221, 300, 341, 9860, 30206, 4630, 307, 27221, 307, 437, 321], "temperature": 0.0, "avg_logprob": -0.12417959585422422, "compression_ratio": 1.7818181818181817, "no_speech_prob": 1.7772377759683877e-05}, {"id": 56, "seek": 24156, "start": 252.48, "end": 254.76, "text": " call the bare metal property.", "tokens": [818, 264, 6949, 5760, 4707, 13], "temperature": 0.0, "avg_logprob": -0.12417959585422422, "compression_ratio": 1.7818181818181817, "no_speech_prob": 1.7772377759683877e-05}, {"id": 57, "seek": 24156, "start": 254.76, "end": 261.56, "text": " And the bare metal property basically says that combining all these virtual machines on", "tokens": [400, 264, 6949, 5760, 4707, 1936, 1619, 300, 21928, 439, 613, 6374, 8379, 322], "temperature": 0.0, "avg_logprob": -0.12417959585422422, "compression_ratio": 1.7818181818181817, "no_speech_prob": 1.7772377759683877e-05}, {"id": 58, "seek": 24156, "start": 261.56, "end": 268.16, "text": " a single hypervisor has the same behavior as if you were running these as separate physical", "tokens": [257, 2167, 9848, 16457, 575, 264, 912, 5223, 382, 498, 291, 645, 2614, 613, 382, 4994, 4001], "temperature": 0.0, "avg_logprob": -0.12417959585422422, "compression_ratio": 1.7818181818181817, "no_speech_prob": 1.7772377759683877e-05}, {"id": 59, "seek": 26816, "start": 268.16, "end": 274.68, "text": " machines connected by a real ethernet switch, so that whatever happens in a virtual machine", "tokens": [8379, 4582, 538, 257, 957, 37096, 7129, 3679, 11, 370, 300, 2035, 2314, 294, 257, 6374, 3479], "temperature": 0.0, "avg_logprob": -0.16699017917408662, "compression_ratio": 1.5520361990950227, "no_speech_prob": 1.1474087841634173e-05}, {"id": 60, "seek": 26816, "start": 274.68, "end": 279.0, "text": " could have happened on a real physical machine that was not virtualized.", "tokens": [727, 362, 2011, 322, 257, 957, 4001, 3479, 300, 390, 406, 6374, 1602, 13], "temperature": 0.0, "avg_logprob": -0.16699017917408662, "compression_ratio": 1.5520361990950227, "no_speech_prob": 1.1474087841634173e-05}, {"id": 61, "seek": 26816, "start": 279.0, "end": 282.64000000000004, "text": " That's what the bare metal property says.", "tokens": [663, 311, 437, 264, 6949, 5760, 4707, 1619, 13], "temperature": 0.0, "avg_logprob": -0.16699017917408662, "compression_ratio": 1.5520361990950227, "no_speech_prob": 1.1474087841634173e-05}, {"id": 62, "seek": 26816, "start": 282.64000000000004, "end": 289.68, "text": " So the building blocks of NOVA are those that you would find in an ordinary microkernel.", "tokens": [407, 264, 2390, 8474, 295, 9146, 20914, 366, 729, 300, 291, 576, 915, 294, 364, 10547, 4532, 74, 1248, 338, 13], "temperature": 0.0, "avg_logprob": -0.16699017917408662, "compression_ratio": 1.5520361990950227, "no_speech_prob": 1.1474087841634173e-05}, {"id": 63, "seek": 26816, "start": 289.68, "end": 293.92, "text": " It's basically address basis, threads, and IPC.", "tokens": [467, 311, 1936, 2985, 5143, 11, 19314, 11, 293, 8671, 34, 13], "temperature": 0.0, "avg_logprob": -0.16699017917408662, "compression_ratio": 1.5520361990950227, "no_speech_prob": 1.1474087841634173e-05}, {"id": 64, "seek": 29392, "start": 293.92, "end": 298.52000000000004, "text": " And NOVA address basis are called protection domains, or PD.", "tokens": [400, 9146, 20914, 2985, 5143, 366, 1219, 6334, 25514, 11, 420, 10464, 13], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 65, "seek": 29392, "start": 298.52000000000004, "end": 303.76, "text": " And threads or virtual CPUs are called execution context, short EC.", "tokens": [400, 19314, 420, 6374, 13199, 82, 366, 1219, 15058, 4319, 11, 2099, 19081, 13], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 66, "seek": 29392, "start": 303.76, "end": 309.48, "text": " And for those of you who don't know NOVA very well, I've just given a very brief introductory", "tokens": [400, 337, 729, 295, 291, 567, 500, 380, 458, 9146, 20914, 588, 731, 11, 286, 600, 445, 2212, 257, 588, 5353, 39048], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 67, "seek": 29392, "start": 309.48, "end": 312.84000000000003, "text": " slide for how all these mechanisms interact.", "tokens": [4137, 337, 577, 439, 613, 15902, 4648, 13], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 68, "seek": 29392, "start": 312.84000000000003, "end": 316.36, "text": " So let's say you have two protection domains, PD, A and B.", "tokens": [407, 718, 311, 584, 291, 362, 732, 6334, 25514, 11, 10464, 11, 316, 293, 363, 13], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 69, "seek": 29392, "start": 316.36, "end": 318.76, "text": " Each of them have one or more threads inside.", "tokens": [6947, 295, 552, 362, 472, 420, 544, 19314, 1854, 13], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 70, "seek": 29392, "start": 318.76, "end": 323.48, "text": " And obviously, at some point, you want to intentionally cross these protection domain", "tokens": [400, 2745, 11, 412, 512, 935, 11, 291, 528, 281, 22062, 3278, 613, 6334, 9274], "temperature": 0.0, "avg_logprob": -0.15246304294519258, "compression_ratio": 1.6654545454545455, "no_speech_prob": 1.3002882951695938e-05}, {"id": 71, "seek": 32348, "start": 323.48, "end": 327.64000000000004, "text": " boundaries because these components somehow need to communicate.", "tokens": [13180, 570, 613, 6677, 6063, 643, 281, 7890, 13], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 72, "seek": 32348, "start": 327.64000000000004, "end": 329.32, "text": " And that's what IPC is for.", "tokens": [400, 300, 311, 437, 8671, 34, 307, 337, 13], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 73, "seek": 32348, "start": 329.32, "end": 333.36, "text": " So assume that this client thread wants to send a message to the server thread.", "tokens": [407, 6552, 300, 341, 6423, 7207, 2738, 281, 2845, 257, 3636, 281, 264, 7154, 7207, 13], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 74, "seek": 32348, "start": 333.36, "end": 338.72, "text": " It has a thread control block, which is like a message box, puts the message in there,", "tokens": [467, 575, 257, 7207, 1969, 3461, 11, 597, 307, 411, 257, 3636, 2424, 11, 8137, 264, 3636, 294, 456, 11], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 75, "seek": 32348, "start": 338.72, "end": 343.48, "text": " invokes a call, an IPC call to the hypervisor, it vectors through a portal, which routes", "tokens": [1048, 8606, 257, 818, 11, 364, 8671, 34, 818, 281, 264, 9848, 16457, 11, 309, 18875, 807, 257, 14982, 11, 597, 18242], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 76, "seek": 32348, "start": 343.48, "end": 348.88, "text": " that IPC to the server protection domain, and then the server receives the message in", "tokens": [300, 8671, 34, 281, 264, 7154, 6334, 9274, 11, 293, 550, 264, 7154, 20717, 264, 3636, 294], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 77, "seek": 32348, "start": 348.88, "end": 350.88, "text": " its UTCB.", "tokens": [1080, 624, 18238, 33, 13], "temperature": 0.0, "avg_logprob": -0.12153659787094384, "compression_ratio": 1.7209302325581395, "no_speech_prob": 8.663588232593611e-06}, {"id": 78, "seek": 35088, "start": 350.88, "end": 355.84, "text": " As part of this control and data transfer, the scheduling context, which is a time slice", "tokens": [1018, 644, 295, 341, 1969, 293, 1412, 5003, 11, 264, 29055, 4319, 11, 597, 307, 257, 565, 13153], "temperature": 0.0, "avg_logprob": -0.08333746592203777, "compression_ratio": 1.6307053941908713, "no_speech_prob": 1.9827044525300153e-05}, {"id": 79, "seek": 35088, "start": 355.84, "end": 359.44, "text": " coupled with a priority, is donated to the other side.", "tokens": [29482, 365, 257, 9365, 11, 307, 23723, 281, 264, 661, 1252, 13], "temperature": 0.0, "avg_logprob": -0.08333746592203777, "compression_ratio": 1.6307053941908713, "no_speech_prob": 1.9827044525300153e-05}, {"id": 80, "seek": 35088, "start": 359.44, "end": 364.48, "text": " And as you can see on the right, that's the situation after the IPC call has gone through.", "tokens": [400, 382, 291, 393, 536, 322, 264, 558, 11, 300, 311, 264, 2590, 934, 264, 8671, 34, 818, 575, 2780, 807, 13], "temperature": 0.0, "avg_logprob": -0.08333746592203777, "compression_ratio": 1.6307053941908713, "no_speech_prob": 1.9827044525300153e-05}, {"id": 81, "seek": 35088, "start": 364.48, "end": 369.12, "text": " So now the server is executing on the scheduling context of the client.", "tokens": [407, 586, 264, 7154, 307, 32368, 322, 264, 29055, 4319, 295, 264, 6423, 13], "temperature": 0.0, "avg_logprob": -0.08333746592203777, "compression_ratio": 1.6307053941908713, "no_speech_prob": 1.9827044525300153e-05}, {"id": 82, "seek": 35088, "start": 369.12, "end": 375.76, "text": " The server computes a reply, puts it in its UTCB, issues a hypercall called IPC reply,", "tokens": [440, 7154, 715, 1819, 257, 16972, 11, 8137, 309, 294, 1080, 624, 18238, 33, 11, 2663, 257, 9848, 45459, 1219, 8671, 34, 16972, 11], "temperature": 0.0, "avg_logprob": -0.08333746592203777, "compression_ratio": 1.6307053941908713, "no_speech_prob": 1.9827044525300153e-05}, {"id": 83, "seek": 37576, "start": 375.76, "end": 380.84, "text": " and the data goes back, the reply goes back to the client, the scheduling context donation", "tokens": [293, 264, 1412, 1709, 646, 11, 264, 16972, 1709, 646, 281, 264, 6423, 11, 264, 29055, 4319, 19724], "temperature": 0.0, "avg_logprob": -0.13768921852111815, "compression_ratio": 1.639676113360324, "no_speech_prob": 5.173370482225437e-06}, {"id": 84, "seek": 37576, "start": 380.84, "end": 384.15999999999997, "text": " is reverted, and the client gets its time slice back.", "tokens": [307, 319, 18537, 11, 293, 264, 6423, 2170, 1080, 565, 13153, 646, 13], "temperature": 0.0, "avg_logprob": -0.13768921852111815, "compression_ratio": 1.639676113360324, "no_speech_prob": 5.173370482225437e-06}, {"id": 85, "seek": 37576, "start": 384.15999999999997, "end": 389.76, "text": " So what you get with that is very fast synchronous IPC, this time donation, and priority inheritance.", "tokens": [407, 437, 291, 483, 365, 300, 307, 588, 2370, 44743, 8671, 34, 11, 341, 565, 19724, 11, 293, 9365, 32122, 13], "temperature": 0.0, "avg_logprob": -0.13768921852111815, "compression_ratio": 1.639676113360324, "no_speech_prob": 5.173370482225437e-06}, {"id": 86, "seek": 37576, "start": 389.76, "end": 393.96, "text": " And it's very fast because there's no scheduling decision on that pass.", "tokens": [400, 309, 311, 588, 2370, 570, 456, 311, 572, 29055, 3537, 322, 300, 1320, 13], "temperature": 0.0, "avg_logprob": -0.13768921852111815, "compression_ratio": 1.639676113360324, "no_speech_prob": 5.173370482225437e-06}, {"id": 87, "seek": 37576, "start": 393.96, "end": 401.28, "text": " Also, NOVA is a capability-based microkernel or hypervisor, which means all operations", "tokens": [2743, 11, 9146, 20914, 307, 257, 13759, 12, 6032, 4532, 74, 1248, 338, 420, 9848, 16457, 11, 597, 1355, 439, 7705], "temperature": 0.0, "avg_logprob": -0.13768921852111815, "compression_ratio": 1.639676113360324, "no_speech_prob": 5.173370482225437e-06}, {"id": 88, "seek": 40128, "start": 401.28, "end": 406.03999999999996, "text": " that user components do with the kernel have capabilities as parameters.", "tokens": [300, 4195, 6677, 360, 365, 264, 28256, 362, 10862, 382, 9834, 13], "temperature": 0.0, "avg_logprob": -0.10107801248739054, "compression_ratio": 1.6434782608695653, "no_speech_prob": 6.64198614686029e-06}, {"id": 89, "seek": 40128, "start": 406.03999999999996, "end": 411.84, "text": " And capabilities have the nice property that they both name a resource and at the same", "tokens": [400, 10862, 362, 264, 1481, 4707, 300, 436, 1293, 1315, 257, 7684, 293, 412, 264, 912], "temperature": 0.0, "avg_logprob": -0.10107801248739054, "compression_ratio": 1.6434782608695653, "no_speech_prob": 6.64198614686029e-06}, {"id": 90, "seek": 40128, "start": 411.84, "end": 416.08, "text": " time have to convey what access you have under that resource.", "tokens": [565, 362, 281, 16965, 437, 2105, 291, 362, 833, 300, 7684, 13], "temperature": 0.0, "avg_logprob": -0.10107801248739054, "compression_ratio": 1.6434782608695653, "no_speech_prob": 6.64198614686029e-06}, {"id": 91, "seek": 40128, "start": 416.08, "end": 420.59999999999997, "text": " So it's a very powerful access control primitive.", "tokens": [407, 309, 311, 257, 588, 4005, 2105, 1969, 28540, 13], "temperature": 0.0, "avg_logprob": -0.10107801248739054, "compression_ratio": 1.6434782608695653, "no_speech_prob": 6.64198614686029e-06}, {"id": 92, "seek": 40128, "start": 420.59999999999997, "end": 426.28, "text": " So that said, let's look at all the things that happened in NOVA over the last two and", "tokens": [407, 300, 848, 11, 718, 311, 574, 412, 439, 264, 721, 300, 2011, 294, 9146, 20914, 670, 264, 1036, 732, 293], "temperature": 0.0, "avg_logprob": -0.10107801248739054, "compression_ratio": 1.6434782608695653, "no_speech_prob": 6.64198614686029e-06}, {"id": 93, "seek": 40128, "start": 426.28, "end": 428.52, "text": " a half or so years.", "tokens": [257, 1922, 420, 370, 924, 13], "temperature": 0.0, "avg_logprob": -0.10107801248739054, "compression_ratio": 1.6434782608695653, "no_speech_prob": 6.64198614686029e-06}, {"id": 94, "seek": 42852, "start": 428.52, "end": 433.32, "text": " And we are now on a release cadence where we put out a new release of NOVA approximately", "tokens": [400, 321, 366, 586, 322, 257, 4374, 46109, 689, 321, 829, 484, 257, 777, 4374, 295, 9146, 20914, 10447], "temperature": 0.0, "avg_logprob": -0.10322398609585232, "compression_ratio": 1.6680851063829787, "no_speech_prob": 5.0586651923367754e-05}, {"id": 95, "seek": 42852, "start": 433.32, "end": 435.2, "text": " every two months.", "tokens": [633, 732, 2493, 13], "temperature": 0.0, "avg_logprob": -0.10322398609585232, "compression_ratio": 1.6680851063829787, "no_speech_prob": 5.0586651923367754e-05}, {"id": 96, "seek": 42852, "start": 435.2, "end": 440.71999999999997, "text": " So it's always the year and the week of the year where we do releases, and this shows", "tokens": [407, 309, 311, 1009, 264, 1064, 293, 264, 1243, 295, 264, 1064, 689, 321, 360, 16952, 11, 293, 341, 3110], "temperature": 0.0, "avg_logprob": -0.10322398609585232, "compression_ratio": 1.6680851063829787, "no_speech_prob": 5.0586651923367754e-05}, {"id": 97, "seek": 42852, "start": 440.71999999999997, "end": 446.79999999999995, "text": " what we added in NOVA in 21, 22, and what we'll add to the first release of this year", "tokens": [437, 321, 3869, 294, 9146, 20914, 294, 5080, 11, 5853, 11, 293, 437, 321, 603, 909, 281, 264, 700, 4374, 295, 341, 1064], "temperature": 0.0, "avg_logprob": -0.10322398609585232, "compression_ratio": 1.6680851063829787, "no_speech_prob": 5.0586651923367754e-05}, {"id": 98, "seek": 42852, "start": 446.79999999999995, "end": 448.76, "text": " at the end of this month.", "tokens": [412, 264, 917, 295, 341, 1618, 13], "temperature": 0.0, "avg_logprob": -0.10322398609585232, "compression_ratio": 1.6680851063829787, "no_speech_prob": 5.0586651923367754e-05}, {"id": 99, "seek": 42852, "start": 448.76, "end": 456.91999999999996, "text": " So we started out at the beginning of 21 by unifying the code base between X86 and ARM,", "tokens": [407, 321, 1409, 484, 412, 264, 2863, 295, 5080, 538, 517, 5489, 264, 3089, 3096, 1296, 1783, 22193, 293, 45209, 11], "temperature": 0.0, "avg_logprob": -0.10322398609585232, "compression_ratio": 1.6680851063829787, "no_speech_prob": 5.0586651923367754e-05}, {"id": 100, "seek": 45692, "start": 456.92, "end": 462.56, "text": " making the load address flexible, adding power management like suspend-resume, then extended", "tokens": [1455, 264, 3677, 2985, 11358, 11, 5127, 1347, 4592, 411, 42546, 12, 495, 2540, 11, 550, 10913], "temperature": 0.0, "avg_logprob": -0.1621088049877649, "compression_ratio": 1.5040983606557377, "no_speech_prob": 2.6250345399603248e-05}, {"id": 101, "seek": 45692, "start": 462.56, "end": 465.44, "text": " that support to ARM.", "tokens": [300, 1406, 281, 45209, 13], "temperature": 0.0, "avg_logprob": -0.1621088049877649, "compression_ratio": 1.5040983606557377, "no_speech_prob": 2.6250345399603248e-05}, {"id": 102, "seek": 45692, "start": 465.44, "end": 471.16, "text": " And later in 22, when that unification was complete, we started adding a lot of, let's", "tokens": [400, 1780, 294, 5853, 11, 562, 300, 517, 3774, 390, 3566, 11, 321, 1409, 5127, 257, 688, 295, 11, 718, 311], "temperature": 0.0, "avg_logprob": -0.1621088049877649, "compression_ratio": 1.5040983606557377, "no_speech_prob": 2.6250345399603248e-05}, {"id": 103, "seek": 45692, "start": 471.16, "end": 477.56, "text": " say, advanced security features in X86, like control flow enforcement, code patching,", "tokens": [584, 11, 7339, 3825, 4122, 294, 1783, 22193, 11, 411, 1969, 3095, 11475, 11, 3089, 9972, 278, 11], "temperature": 0.0, "avg_logprob": -0.1621088049877649, "compression_ratio": 1.5040983606557377, "no_speech_prob": 2.6250345399603248e-05}, {"id": 104, "seek": 45692, "start": 477.56, "end": 483.96000000000004, "text": " cache allocation technology, multiple spaces, multi-key total memory encryption.", "tokens": [19459, 27599, 2899, 11, 3866, 7673, 11, 4825, 12, 4119, 3217, 4675, 29575, 13], "temperature": 0.0, "avg_logprob": -0.1621088049877649, "compression_ratio": 1.5040983606557377, "no_speech_prob": 2.6250345399603248e-05}, {"id": 105, "seek": 48396, "start": 483.96, "end": 487.91999999999996, "text": " And recently, we've added some APIC virtualization.", "tokens": [400, 3938, 11, 321, 600, 3869, 512, 5372, 2532, 6374, 2144, 13], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 106, "seek": 48396, "start": 487.91999999999996, "end": 492.0, "text": " So the difference between the things that are listed in bold here and those that are", "tokens": [407, 264, 2649, 1296, 264, 721, 300, 366, 10052, 294, 11928, 510, 293, 729, 300, 366], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 107, "seek": 48396, "start": 492.0, "end": 496.84, "text": " not listed in bold, everything in bold I'll try to cover in this talk, which is a lot,", "tokens": [406, 10052, 294, 11928, 11, 1203, 294, 11928, 286, 603, 853, 281, 2060, 294, 341, 751, 11, 597, 307, 257, 688, 11], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 108, "seek": 48396, "start": 496.84, "end": 500.76, "text": " so hopefully we'll have enough time to go through all this.", "tokens": [370, 4696, 321, 603, 362, 1547, 565, 281, 352, 807, 439, 341, 13], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 109, "seek": 48396, "start": 500.76, "end": 504.0, "text": " First of all, the design goals that we have in NOVA.", "tokens": [2386, 295, 439, 11, 264, 1715, 5493, 300, 321, 362, 294, 9146, 20914, 13], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 110, "seek": 48396, "start": 504.0, "end": 508.64, "text": " And Martin already mentioned that not all microchones have the same design goals.", "tokens": [400, 9184, 1217, 2835, 300, 406, 439, 4532, 339, 2213, 362, 264, 912, 1715, 5493, 13], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 111, "seek": 48396, "start": 508.64, "end": 513.0799999999999, "text": " Our design goal is that we want to provide the same or at least similar functionality", "tokens": [2621, 1715, 3387, 307, 300, 321, 528, 281, 2893, 264, 912, 420, 412, 1935, 2531, 14980], "temperature": 0.0, "avg_logprob": -0.1260550308227539, "compression_ratio": 1.7142857142857142, "no_speech_prob": 4.936055574944476e-06}, {"id": 112, "seek": 51308, "start": 513.08, "end": 519.2800000000001, "text": " across all architectures, which means the API is designed in such a way that it abstracts", "tokens": [2108, 439, 6331, 1303, 11, 597, 1355, 264, 9362, 307, 4761, 294, 1270, 257, 636, 300, 309, 12649, 82], "temperature": 0.0, "avg_logprob": -0.139966686120194, "compression_ratio": 1.5206611570247934, "no_speech_prob": 1.6956520994426683e-05}, {"id": 113, "seek": 51308, "start": 519.2800000000001, "end": 522.12, "text": " from architectural differences as much as possible.", "tokens": [490, 26621, 7300, 382, 709, 382, 1944, 13], "temperature": 0.0, "avg_logprob": -0.139966686120194, "compression_ratio": 1.5206611570247934, "no_speech_prob": 1.6956520994426683e-05}, {"id": 114, "seek": 51308, "start": 522.12, "end": 528.8000000000001, "text": " That you get a uniform experience, whether you're on X86 and ARM, you can create a thread", "tokens": [663, 291, 483, 257, 9452, 1752, 11, 1968, 291, 434, 322, 1783, 22193, 293, 45209, 11, 291, 393, 1884, 257, 7207], "temperature": 0.0, "avg_logprob": -0.139966686120194, "compression_ratio": 1.5206611570247934, "no_speech_prob": 1.6956520994426683e-05}, {"id": 115, "seek": 51308, "start": 528.8000000000001, "end": 534.44, "text": " and you don't have to worry about details of instructions that register set, page table", "tokens": [293, 291, 500, 380, 362, 281, 3292, 466, 4365, 295, 9415, 300, 7280, 992, 11, 3028, 3199], "temperature": 0.0, "avg_logprob": -0.139966686120194, "compression_ratio": 1.5206611570247934, "no_speech_prob": 1.6956520994426683e-05}, {"id": 116, "seek": 51308, "start": 534.44, "end": 537.9200000000001, "text": " format, NOVA tries to abstract all of that away.", "tokens": [7877, 11, 9146, 20914, 9898, 281, 12649, 439, 295, 300, 1314, 13], "temperature": 0.0, "avg_logprob": -0.139966686120194, "compression_ratio": 1.5206611570247934, "no_speech_prob": 1.6956520994426683e-05}, {"id": 117, "seek": 53792, "start": 537.92, "end": 545.4399999999999, "text": " You want to have a really simple build infrastructure and you'll see in a moment what the directory", "tokens": [509, 528, 281, 362, 257, 534, 2199, 1322, 6896, 293, 291, 603, 536, 294, 257, 1623, 437, 264, 21120], "temperature": 0.0, "avg_logprob": -0.2130740115517064, "compression_ratio": 1.512396694214876, "no_speech_prob": 1.6687727111275308e-05}, {"id": 118, "seek": 53792, "start": 545.4399999999999, "end": 549.88, "text": " layout looks like, but suffice it to say that you can build NOVA with a very simple make", "tokens": [13333, 1542, 411, 11, 457, 3889, 573, 309, 281, 584, 300, 291, 393, 1322, 9146, 20914, 365, 257, 588, 2199, 652], "temperature": 0.0, "avg_logprob": -0.2130740115517064, "compression_ratio": 1.512396694214876, "no_speech_prob": 1.6687727111275308e-05}, {"id": 119, "seek": 53792, "start": 549.88, "end": 556.3199999999999, "text": " command where you say make architecture equals X86 or ARM, and in some cases, bold equals", "tokens": [5622, 689, 291, 584, 652, 9482, 6915, 1783, 22193, 420, 45209, 11, 293, 294, 512, 3331, 11, 11928, 6915], "temperature": 0.0, "avg_logprob": -0.2130740115517064, "compression_ratio": 1.512396694214876, "no_speech_prob": 1.6687727111275308e-05}, {"id": 120, "seek": 53792, "start": 556.3199999999999, "end": 564.4399999999999, "text": " I don't know, Raspberry Pi or NXP, I'm X8, whatever, and it runs for maybe five seconds", "tokens": [286, 500, 380, 458, 11, 41154, 17741, 420, 426, 55, 47, 11, 286, 478, 1783, 23, 11, 2035, 11, 293, 309, 6676, 337, 1310, 1732, 3949], "temperature": 0.0, "avg_logprob": -0.2130740115517064, "compression_ratio": 1.512396694214876, "no_speech_prob": 1.6687727111275308e-05}, {"id": 121, "seek": 56444, "start": 564.44, "end": 568.32, "text": " and then you get a binary.", "tokens": [293, 550, 291, 483, 257, 17434, 13], "temperature": 0.0, "avg_logprob": -0.19628617198196882, "compression_ratio": 1.6388888888888888, "no_speech_prob": 1.543989492347464e-05}, {"id": 122, "seek": 56444, "start": 568.32, "end": 574.96, "text": " We use standardized processes like the standardized boot process and standardized resource enumeration", "tokens": [492, 764, 31677, 7555, 411, 264, 31677, 11450, 1399, 293, 31677, 7684, 465, 449, 5053], "temperature": 0.0, "avg_logprob": -0.19628617198196882, "compression_ratio": 1.6388888888888888, "no_speech_prob": 1.543989492347464e-05}, {"id": 123, "seek": 56444, "start": 574.96, "end": 579.48, "text": " as much as possible because that allows for a great reuse of code.", "tokens": [382, 709, 382, 1944, 570, 300, 4045, 337, 257, 869, 26225, 295, 3089, 13], "temperature": 0.0, "avg_logprob": -0.19628617198196882, "compression_ratio": 1.6388888888888888, "no_speech_prob": 1.543989492347464e-05}, {"id": 124, "seek": 56444, "start": 579.48, "end": 587.44, "text": " So we use multi-boot version two or one, and if I for booting, we use ACPI for resource", "tokens": [407, 321, 764, 4825, 12, 1763, 310, 3037, 732, 420, 472, 11, 293, 498, 286, 337, 11450, 278, 11, 321, 764, 8157, 31701, 337, 7684], "temperature": 0.0, "avg_logprob": -0.19628617198196882, "compression_ratio": 1.6388888888888888, "no_speech_prob": 1.543989492347464e-05}, {"id": 125, "seek": 56444, "start": 587.44, "end": 588.44, "text": " enumeration.", "tokens": [465, 449, 5053, 13], "temperature": 0.0, "avg_logprob": -0.19628617198196882, "compression_ratio": 1.6388888888888888, "no_speech_prob": 1.543989492347464e-05}, {"id": 126, "seek": 56444, "start": 588.44, "end": 592.12, "text": " You can also use the FDT, but that's more of a fallback.", "tokens": [509, 393, 611, 764, 264, 479, 35, 51, 11, 457, 300, 311, 544, 295, 257, 2100, 3207, 13], "temperature": 0.0, "avg_logprob": -0.19628617198196882, "compression_ratio": 1.6388888888888888, "no_speech_prob": 1.543989492347464e-05}, {"id": 127, "seek": 59212, "start": 592.12, "end": 597.1, "text": " And for ARM, there's this interface called PSCI for power state coordination that's also", "tokens": [400, 337, 45209, 11, 456, 311, 341, 9226, 1219, 8168, 25240, 337, 1347, 1785, 21252, 300, 311, 611], "temperature": 0.0, "avg_logprob": -0.15350127488039852, "compression_ratio": 1.594142259414226, "no_speech_prob": 1.1298710887786001e-05}, {"id": 128, "seek": 59212, "start": 597.1, "end": 602.12, "text": " abstracting this functionality across many different ARM boards.", "tokens": [12649, 278, 341, 14980, 2108, 867, 819, 45209, 13293, 13], "temperature": 0.0, "avg_logprob": -0.15350127488039852, "compression_ratio": 1.594142259414226, "no_speech_prob": 1.1298710887786001e-05}, {"id": 129, "seek": 59212, "start": 602.12, "end": 605.5600000000001, "text": " So we try to use these interfaces as much as possible.", "tokens": [407, 321, 853, 281, 764, 613, 28416, 382, 709, 382, 1944, 13], "temperature": 0.0, "avg_logprob": -0.15350127488039852, "compression_ratio": 1.594142259414226, "no_speech_prob": 1.1298710887786001e-05}, {"id": 130, "seek": 59212, "start": 605.5600000000001, "end": 611.52, "text": " The code is designed in such a way that is formally verifiable, and in our particular", "tokens": [440, 3089, 307, 4761, 294, 1270, 257, 636, 300, 307, 25983, 1306, 30876, 11, 293, 294, 527, 1729], "temperature": 0.0, "avg_logprob": -0.15350127488039852, "compression_ratio": 1.594142259414226, "no_speech_prob": 1.1298710887786001e-05}, {"id": 131, "seek": 59212, "start": 611.52, "end": 617.32, "text": " case, that means formally verifying highly concurrency plus plus code, not C code, not", "tokens": [1389, 11, 300, 1355, 25983, 1306, 5489, 5405, 23702, 10457, 1804, 1804, 3089, 11, 406, 383, 3089, 11, 406], "temperature": 0.0, "avg_logprob": -0.15350127488039852, "compression_ratio": 1.594142259414226, "no_speech_prob": 1.1298710887786001e-05}, {"id": 132, "seek": 61732, "start": 617.32, "end": 625.9200000000001, "text": " a similar code, but C++ code, and even weekly ordered memory because ARM V8 is weak memory.", "tokens": [257, 2531, 3089, 11, 457, 383, 25472, 3089, 11, 293, 754, 12460, 8866, 4675, 570, 45209, 691, 23, 307, 5336, 4675, 13], "temperature": 0.0, "avg_logprob": -0.1517326598073922, "compression_ratio": 1.591093117408907, "no_speech_prob": 9.076109563466161e-06}, {"id": 133, "seek": 61732, "start": 625.9200000000001, "end": 631.9200000000001, "text": " And obviously, we want to be, we want Nova to be modern, small, and fast, best in class", "tokens": [400, 2745, 11, 321, 528, 281, 312, 11, 321, 528, 27031, 281, 312, 4363, 11, 1359, 11, 293, 2370, 11, 1151, 294, 1508], "temperature": 0.0, "avg_logprob": -0.1517326598073922, "compression_ratio": 1.591093117408907, "no_speech_prob": 9.076109563466161e-06}, {"id": 134, "seek": 61732, "start": 631.9200000000001, "end": 636.7600000000001, "text": " security and performance, and we'll see how we did in that.", "tokens": [3825, 293, 3389, 11, 293, 321, 603, 536, 577, 321, 630, 294, 300, 13], "temperature": 0.0, "avg_logprob": -0.1517326598073922, "compression_ratio": 1.591093117408907, "no_speech_prob": 9.076109563466161e-06}, {"id": 135, "seek": 61732, "start": 636.7600000000001, "end": 642.5600000000001, "text": " So first, let me talk about the code structure, and Martin mentioned in this talk this morning,", "tokens": [407, 700, 11, 718, 385, 751, 466, 264, 3089, 3877, 11, 293, 9184, 2835, 294, 341, 751, 341, 2446, 11], "temperature": 0.0, "avg_logprob": -0.1517326598073922, "compression_ratio": 1.591093117408907, "no_speech_prob": 9.076109563466161e-06}, {"id": 136, "seek": 61732, "start": 642.5600000000001, "end": 645.6800000000001, "text": " that using directories to your advantage can really help.", "tokens": [300, 1228, 5391, 530, 281, 428, 5002, 393, 534, 854, 13], "temperature": 0.0, "avg_logprob": -0.1517326598073922, "compression_ratio": 1.591093117408907, "no_speech_prob": 9.076109563466161e-06}, {"id": 137, "seek": 64568, "start": 645.68, "end": 653.28, "text": " So on the right, you see the directory structure that we have in the unified Nova code base.", "tokens": [407, 322, 264, 558, 11, 291, 536, 264, 21120, 3877, 300, 321, 362, 294, 264, 26787, 27031, 3089, 3096, 13], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 138, "seek": 64568, "start": 653.28, "end": 656.4399999999999, "text": " We have a generic ink directory and a generic source directory.", "tokens": [492, 362, 257, 19577, 11276, 21120, 293, 257, 19577, 4009, 21120, 13], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 139, "seek": 64568, "start": 656.4399999999999, "end": 658.4399999999999, "text": " Those are the ones listed in green.", "tokens": [3950, 366, 264, 2306, 10052, 294, 3092, 13], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 140, "seek": 64568, "start": 658.4399999999999, "end": 666.0, "text": " And then we have architecture-specific subdirectories for ARC64 and X8664, and we have architecture-specific", "tokens": [400, 550, 321, 362, 9482, 12, 29258, 1422, 18267, 1672, 530, 337, 8943, 34, 19395, 293, 1783, 22193, 19395, 11, 293, 321, 362, 9482, 12, 29258], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 141, "seek": 64568, "start": 666.0, "end": 667.0, "text": " build directories.", "tokens": [1322, 5391, 530, 13], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 142, "seek": 64568, "start": 667.0, "end": 671.24, "text": " There's also a doc directory in which you will find the Nova interface specification,", "tokens": [821, 311, 611, 257, 3211, 21120, 294, 597, 291, 486, 915, 264, 27031, 9226, 31256, 11], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 143, "seek": 64568, "start": 671.24, "end": 674.3199999999999, "text": " and there's a single make file unified.", "tokens": [293, 456, 311, 257, 2167, 652, 3991, 26787, 13], "temperature": 0.0, "avg_logprob": -0.1845562049934456, "compression_ratio": 1.8353909465020577, "no_speech_prob": 1.891774809337221e-05}, {"id": 144, "seek": 67432, "start": 674.32, "end": 679.6, "text": " And when we looked at the source code and we discussed them with our formal methods engineers,", "tokens": [400, 562, 321, 2956, 412, 264, 4009, 3089, 293, 321, 7152, 552, 365, 527, 9860, 7150, 11955, 11], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 145, "seek": 67432, "start": 679.6, "end": 686.4000000000001, "text": " we recognized that basically all the functions can be categorized into three different buckets.", "tokens": [321, 9823, 300, 1936, 439, 264, 6828, 393, 312, 19250, 1602, 666, 1045, 819, 32191, 13], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 146, "seek": 67432, "start": 686.4000000000001, "end": 690.4000000000001, "text": " The first one is what we call same API and same implementation.", "tokens": [440, 700, 472, 307, 437, 321, 818, 912, 9362, 293, 912, 11420, 13], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 147, "seek": 67432, "start": 690.4000000000001, "end": 692.6800000000001, "text": " This is totally generic code.", "tokens": [639, 307, 3879, 19577, 3089, 13], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 148, "seek": 67432, "start": 692.6800000000001, "end": 694.72, "text": " All the system calls are totally generic code.", "tokens": [1057, 264, 1185, 5498, 366, 3879, 19577, 3089, 13], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 149, "seek": 67432, "start": 694.72, "end": 697.72, "text": " All the memory allocators are totally generic code.", "tokens": [1057, 264, 4675, 12660, 3391, 366, 3879, 19577, 3089, 13], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 150, "seek": 67432, "start": 697.72, "end": 701.2800000000001, "text": " Surprisingly, even page tables can be totally generic code.", "tokens": [49908, 11, 754, 3028, 8020, 393, 312, 3879, 19577, 3089, 13], "temperature": 0.0, "avg_logprob": -0.14267924337676077, "compression_ratio": 1.838174273858921, "no_speech_prob": 6.338658295135247e-06}, {"id": 151, "seek": 70128, "start": 701.28, "end": 706.24, "text": " So these can all share the source files, the header files, and the spec files, which basically", "tokens": [407, 613, 393, 439, 2073, 264, 4009, 7098, 11, 264, 23117, 7098, 11, 293, 264, 1608, 7098, 11, 597, 1936], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 152, "seek": 70128, "start": 706.24, "end": 709.68, "text": " describe the interface pre and post conditions.", "tokens": [6786, 264, 9226, 659, 293, 2183, 4487, 13], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 153, "seek": 70128, "start": 709.68, "end": 715.1999999999999, "text": " The second bucket is functions that have the same API, but maybe a different implementation.", "tokens": [440, 1150, 13058, 307, 6828, 300, 362, 264, 912, 9362, 11, 457, 1310, 257, 819, 11420, 13], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 154, "seek": 70128, "start": 715.1999999999999, "end": 719.8, "text": " And an example of that would be a timer where the API could be set a deadline for when a", "tokens": [400, 364, 1365, 295, 300, 576, 312, 257, 19247, 689, 264, 9362, 727, 312, 992, 257, 20615, 337, 562, 257], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 155, "seek": 70128, "start": 719.8, "end": 721.6, "text": " timer interrupts should fire.", "tokens": [19247, 12729, 82, 820, 2610, 13], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 156, "seek": 70128, "start": 721.6, "end": 725.88, "text": " So the API for all callers is the same, so you can potentially share the header or the", "tokens": [407, 264, 9362, 337, 439, 818, 433, 307, 264, 912, 11, 370, 291, 393, 7263, 2073, 264, 23117, 420, 264], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 157, "seek": 70128, "start": 725.88, "end": 727.12, "text": " spec file.", "tokens": [1608, 3991, 13], "temperature": 0.0, "avg_logprob": -0.12416999990289862, "compression_ratio": 1.779527559055118, "no_speech_prob": 6.338448201859137e-06}, {"id": 158, "seek": 72712, "start": 727.12, "end": 733.08, "text": " But the implementation might be different on each architecture or is very likely different.", "tokens": [583, 264, 11420, 1062, 312, 819, 322, 1184, 9482, 420, 307, 588, 3700, 819, 13], "temperature": 0.0, "avg_logprob": -0.09476969080063903, "compression_ratio": 1.9506172839506173, "no_speech_prob": 1.9032224827242317e-06}, {"id": 159, "seek": 72712, "start": 733.08, "end": 736.5600000000001, "text": " And the final bucket is those functions that have a different API and implementation and", "tokens": [400, 264, 2572, 13058, 307, 729, 6828, 300, 362, 257, 819, 9362, 293, 11420, 293], "temperature": 0.0, "avg_logprob": -0.09476969080063903, "compression_ratio": 1.9506172839506173, "no_speech_prob": 1.9032224827242317e-06}, {"id": 160, "seek": 72712, "start": 736.5600000000001, "end": 738.48, "text": " you can't share anything.", "tokens": [291, 393, 380, 2073, 1340, 13], "temperature": 0.0, "avg_logprob": -0.09476969080063903, "compression_ratio": 1.9506172839506173, "no_speech_prob": 1.9032224827242317e-06}, {"id": 161, "seek": 72712, "start": 738.48, "end": 745.12, "text": " So the code structure is such that architecture-specific code lives in the architecture-specific subdirectories", "tokens": [407, 264, 3089, 3877, 307, 1270, 300, 9482, 12, 29258, 3089, 2909, 294, 264, 9482, 12, 29258, 1422, 18267, 1672, 530], "temperature": 0.0, "avg_logprob": -0.09476969080063903, "compression_ratio": 1.9506172839506173, "no_speech_prob": 1.9032224827242317e-06}, {"id": 162, "seek": 72712, "start": 745.12, "end": 748.96, "text": " and generic code lives in the sort of parent directories of that.", "tokens": [293, 19577, 3089, 2909, 294, 264, 1333, 295, 2596, 5391, 530, 295, 300, 13], "temperature": 0.0, "avg_logprob": -0.09476969080063903, "compression_ratio": 1.9506172839506173, "no_speech_prob": 1.9032224827242317e-06}, {"id": 163, "seek": 72712, "start": 748.96, "end": 753.6, "text": " And whenever you have an architecture-specific file with the same name as a generic file,", "tokens": [400, 5699, 291, 362, 364, 9482, 12, 29258, 3991, 365, 264, 912, 1315, 382, 257, 19577, 3991, 11], "temperature": 0.0, "avg_logprob": -0.09476969080063903, "compression_ratio": 1.9506172839506173, "no_speech_prob": 1.9032224827242317e-06}, {"id": 164, "seek": 75360, "start": 753.6, "end": 759.88, "text": " the architecture-specific file takes precedence and basically overrides or shadows the generic", "tokens": [264, 9482, 12, 29258, 3991, 2516, 16969, 655, 293, 1936, 670, 81, 1875, 420, 14740, 264, 19577], "temperature": 0.0, "avg_logprob": -0.09723041274330833, "compression_ratio": 1.6486486486486487, "no_speech_prob": 8.138305929605849e-06}, {"id": 165, "seek": 75360, "start": 759.88, "end": 760.88, "text": " file.", "tokens": [3991, 13], "temperature": 0.0, "avg_logprob": -0.09723041274330833, "compression_ratio": 1.6486486486486487, "no_speech_prob": 8.138305929605849e-06}, {"id": 166, "seek": 75360, "start": 760.88, "end": 767.64, "text": " And that makes it very easy to move files from architecture-specific to generic and back.", "tokens": [400, 300, 1669, 309, 588, 1858, 281, 1286, 7098, 490, 9482, 12, 29258, 281, 19577, 293, 646, 13], "temperature": 0.0, "avg_logprob": -0.09723041274330833, "compression_ratio": 1.6486486486486487, "no_speech_prob": 8.138305929605849e-06}, {"id": 167, "seek": 75360, "start": 767.64, "end": 772.6, "text": " So the unified code base that we ended up with, and these are the numbers from the very", "tokens": [407, 264, 26787, 3089, 3096, 300, 321, 4590, 493, 365, 11, 293, 613, 366, 264, 3547, 490, 264, 588], "temperature": 0.0, "avg_logprob": -0.09723041274330833, "compression_ratio": 1.6486486486486487, "no_speech_prob": 8.138305929605849e-06}, {"id": 168, "seek": 75360, "start": 772.6, "end": 781.08, "text": " recent upcoming release, 2308, which will come out at the end of this month, shows sort", "tokens": [5162, 11500, 4374, 11, 35311, 23, 11, 597, 486, 808, 484, 412, 264, 917, 295, 341, 1618, 11, 3110, 1333], "temperature": 0.0, "avg_logprob": -0.09723041274330833, "compression_ratio": 1.6486486486486487, "no_speech_prob": 8.138305929605849e-06}, {"id": 169, "seek": 78108, "start": 781.08, "end": 785.64, "text": " of what we ended up with in terms of architecture-specific versus generic code.", "tokens": [295, 437, 321, 4590, 493, 365, 294, 2115, 295, 9482, 12, 29258, 5717, 19577, 3089, 13], "temperature": 0.0, "avg_logprob": -0.13106881720679148, "compression_ratio": 1.6694915254237288, "no_speech_prob": 1.749750845192466e-05}, {"id": 170, "seek": 78108, "start": 785.64, "end": 790.4000000000001, "text": " So in the middle, the green part is the generic code that's shared between all architectures", "tokens": [407, 294, 264, 2808, 11, 264, 3092, 644, 307, 264, 19577, 3089, 300, 311, 5507, 1296, 439, 6331, 1303], "temperature": 0.0, "avg_logprob": -0.13106881720679148, "compression_ratio": 1.6694915254237288, "no_speech_prob": 1.749750845192466e-05}, {"id": 171, "seek": 78108, "start": 790.4000000000001, "end": 793.44, "text": " and it's 4,300 lines today.", "tokens": [293, 309, 311, 1017, 11, 12566, 3876, 965, 13], "temperature": 0.0, "avg_logprob": -0.13106881720679148, "compression_ratio": 1.6694915254237288, "no_speech_prob": 1.749750845192466e-05}, {"id": 172, "seek": 78108, "start": 793.44, "end": 803.2, "text": " x86 adds 7,000 and some lines specific code and ARM to the right adds some 5,600 lines.", "tokens": [2031, 22193, 10860, 1614, 11, 1360, 293, 512, 3876, 2685, 3089, 293, 45209, 281, 264, 558, 10860, 512, 1025, 11, 15707, 3876, 13], "temperature": 0.0, "avg_logprob": -0.13106881720679148, "compression_ratio": 1.6694915254237288, "no_speech_prob": 1.749750845192466e-05}, {"id": 173, "seek": 78108, "start": 803.2, "end": 809.2, "text": " So if you sum that up for x86, it's roughly 11,500 lines and for ARM it's less than 10,000", "tokens": [407, 498, 291, 2408, 300, 493, 337, 2031, 22193, 11, 309, 311, 9810, 2975, 11, 7526, 3876, 293, 337, 45209, 309, 311, 1570, 813, 1266, 11, 1360], "temperature": 0.0, "avg_logprob": -0.13106881720679148, "compression_ratio": 1.6694915254237288, "no_speech_prob": 1.749750845192466e-05}, {"id": 174, "seek": 78108, "start": 809.2, "end": 810.2, "text": " lines of code.", "tokens": [3876, 295, 3089, 13], "temperature": 0.0, "avg_logprob": -0.13106881720679148, "compression_ratio": 1.6694915254237288, "no_speech_prob": 1.749750845192466e-05}, {"id": 175, "seek": 81020, "start": 810.2, "end": 820.2, "text": " It's very small and if you look at it, ballpark 40% of the code for each architecture is generic", "tokens": [467, 311, 588, 1359, 293, 498, 291, 574, 412, 309, 11, 2594, 31239, 3356, 4, 295, 264, 3089, 337, 1184, 9482, 307, 19577], "temperature": 0.0, "avg_logprob": -0.16515429301928447, "compression_ratio": 1.6452991452991452, "no_speech_prob": 1.7223845134139992e-05}, {"id": 176, "seek": 81020, "start": 820.2, "end": 821.4000000000001, "text": " and shareable.", "tokens": [293, 2073, 712, 13], "temperature": 0.0, "avg_logprob": -0.16515429301928447, "compression_ratio": 1.6452991452991452, "no_speech_prob": 1.7223845134139992e-05}, {"id": 177, "seek": 81020, "start": 821.4000000000001, "end": 826.44, "text": " And that's really great, not just from a maintainability perspective, but also from a verifiability", "tokens": [400, 300, 311, 534, 869, 11, 406, 445, 490, 257, 6909, 2310, 4585, 11, 457, 611, 490, 257, 1306, 17638, 2310], "temperature": 0.0, "avg_logprob": -0.16515429301928447, "compression_ratio": 1.6452991452991452, "no_speech_prob": 1.7223845134139992e-05}, {"id": 178, "seek": 81020, "start": 826.44, "end": 831.6800000000001, "text": " perspective because you have to specify and verify those generic portions only once.", "tokens": [4585, 570, 291, 362, 281, 16500, 293, 16888, 729, 19577, 25070, 787, 1564, 13], "temperature": 0.0, "avg_logprob": -0.16515429301928447, "compression_ratio": 1.6452991452991452, "no_speech_prob": 1.7223845134139992e-05}, {"id": 179, "seek": 81020, "start": 831.6800000000001, "end": 838.5600000000001, "text": " If you compile that into binaries, then the resulting binaries are also very small, like", "tokens": [759, 291, 31413, 300, 666, 5171, 4889, 11, 550, 264, 16505, 5171, 4889, 366, 611, 588, 1359, 11, 411], "temperature": 0.0, "avg_logprob": -0.16515429301928447, "compression_ratio": 1.6452991452991452, "no_speech_prob": 1.7223845134139992e-05}, {"id": 180, "seek": 83856, "start": 838.56, "end": 845.8399999999999, "text": " a little less than 70K in code size and obviously if you use a different compiler version or", "tokens": [257, 707, 1570, 813, 5285, 42, 294, 3089, 2744, 293, 2745, 498, 291, 764, 257, 819, 31958, 3037, 420], "temperature": 0.0, "avg_logprob": -0.1311327148886288, "compression_ratio": 1.640625, "no_speech_prob": 2.1426545572467148e-05}, {"id": 181, "seek": 83856, "start": 845.8399999999999, "end": 850.3599999999999, "text": " different NOVA version, these numbers will slightly differ, but it gives you an idea", "tokens": [819, 9146, 20914, 3037, 11, 613, 3547, 486, 4748, 743, 11, 457, 309, 2709, 291, 364, 1558], "temperature": 0.0, "avg_logprob": -0.1311327148886288, "compression_ratio": 1.640625, "no_speech_prob": 2.1426545572467148e-05}, {"id": 182, "seek": 83856, "start": 850.3599999999999, "end": 855.92, "text": " of how small the code base and how small the binaries will be.", "tokens": [295, 577, 1359, 264, 3089, 3096, 293, 577, 1359, 264, 5171, 4889, 486, 312, 13], "temperature": 0.0, "avg_logprob": -0.1311327148886288, "compression_ratio": 1.640625, "no_speech_prob": 2.1426545572467148e-05}, {"id": 183, "seek": 83856, "start": 855.92, "end": 861.88, "text": " So let's look at some interesting aspects of the architecture because assume you've", "tokens": [407, 718, 311, 574, 412, 512, 1880, 7270, 295, 264, 9482, 570, 6552, 291, 600], "temperature": 0.0, "avg_logprob": -0.1311327148886288, "compression_ratio": 1.640625, "no_speech_prob": 2.1426545572467148e-05}, {"id": 184, "seek": 83856, "start": 861.88, "end": 865.8399999999999, "text": " downloaded NOVA, you've built such a small binary from source code and now you want to", "tokens": [21748, 9146, 20914, 11, 291, 600, 3094, 1270, 257, 1359, 17434, 490, 4009, 3089, 293, 586, 291, 528, 281], "temperature": 0.0, "avg_logprob": -0.1311327148886288, "compression_ratio": 1.640625, "no_speech_prob": 2.1426545572467148e-05}, {"id": 185, "seek": 83856, "start": 865.8399999999999, "end": 866.8399999999999, "text": " boot it.", "tokens": [11450, 309, 13], "temperature": 0.0, "avg_logprob": -0.1311327148886288, "compression_ratio": 1.640625, "no_speech_prob": 2.1426545572467148e-05}, {"id": 186, "seek": 86684, "start": 866.84, "end": 874.36, "text": " And typical boot procedure, both on x86 and ARM, which are converging towards using UFI", "tokens": [400, 7476, 11450, 10747, 11, 1293, 322, 2031, 22193, 293, 45209, 11, 597, 366, 9652, 3249, 3030, 1228, 624, 38568], "temperature": 0.0, "avg_logprob": -0.19473710390600826, "compression_ratio": 1.709016393442623, "no_speech_prob": 4.004048605565913e-05}, {"id": 187, "seek": 86684, "start": 874.36, "end": 879.6800000000001, "text": " as firmware, will basically have this structure where UFI firmware runs first and then invokes", "tokens": [382, 30289, 11, 486, 1936, 362, 341, 3877, 689, 624, 38568, 30289, 6676, 700, 293, 550, 1048, 8606], "temperature": 0.0, "avg_logprob": -0.19473710390600826, "compression_ratio": 1.709016393442623, "no_speech_prob": 4.004048605565913e-05}, {"id": 188, "seek": 86684, "start": 879.6800000000001, "end": 884.36, "text": " some bootloader, passing some information like an image handle and a system table and", "tokens": [512, 11450, 2907, 260, 11, 8437, 512, 1589, 411, 364, 3256, 4813, 293, 257, 1185, 3199, 293], "temperature": 0.0, "avg_logprob": -0.19473710390600826, "compression_ratio": 1.709016393442623, "no_speech_prob": 4.004048605565913e-05}, {"id": 189, "seek": 86684, "start": 884.36, "end": 891.84, "text": " then the bootloader runs and invokes a NOVA microhypervisor, passing also the image handle", "tokens": [550, 264, 11450, 2907, 260, 6676, 293, 1048, 8606, 257, 9146, 20914, 4532, 3495, 610, 16457, 11, 8437, 611, 264, 3256, 4813], "temperature": 0.0, "avg_logprob": -0.19473710390600826, "compression_ratio": 1.709016393442623, "no_speech_prob": 4.004048605565913e-05}, {"id": 190, "seek": 86684, "start": 891.84, "end": 896.5600000000001, "text": " and the system table maybe adding multi-boot information.", "tokens": [293, 264, 1185, 3199, 1310, 5127, 4825, 12, 1763, 310, 1589, 13], "temperature": 0.0, "avg_logprob": -0.19473710390600826, "compression_ratio": 1.709016393442623, "no_speech_prob": 4.004048605565913e-05}, {"id": 191, "seek": 89656, "start": 896.56, "end": 901.56, "text": " And at some point there will have to be a platform handover of all the hardware from", "tokens": [400, 412, 512, 935, 456, 486, 362, 281, 312, 257, 3663, 1011, 3570, 295, 439, 264, 8837, 490], "temperature": 0.0, "avg_logprob": -0.09635650634765625, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.0612659025355242e-05}, {"id": 192, "seek": 89656, "start": 901.56, "end": 904.88, "text": " firmware to the operating system in our case NOVA.", "tokens": [30289, 281, 264, 7447, 1185, 294, 527, 1389, 9146, 20914, 13], "temperature": 0.0, "avg_logprob": -0.09635650634765625, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.0612659025355242e-05}, {"id": 193, "seek": 89656, "start": 904.88, "end": 907.92, "text": " And this handover point is called exit boot services.", "tokens": [400, 341, 1011, 3570, 935, 307, 1219, 11043, 11450, 3328, 13], "temperature": 0.0, "avg_logprob": -0.09635650634765625, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.0612659025355242e-05}, {"id": 194, "seek": 89656, "start": 907.92, "end": 913.92, "text": " It's basically the very last function that you call as either a bootloader or a kernel", "tokens": [467, 311, 1936, 264, 588, 1036, 2445, 300, 291, 818, 382, 2139, 257, 11450, 2907, 260, 420, 257, 28256], "temperature": 0.0, "avg_logprob": -0.09635650634765625, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.0612659025355242e-05}, {"id": 195, "seek": 89656, "start": 913.92, "end": 920.52, "text": " in firmware and that's the point where firmware stops accessing all the hardware and the ownership", "tokens": [294, 30289, 293, 300, 311, 264, 935, 689, 30289, 10094, 26440, 439, 264, 8837, 293, 264, 15279], "temperature": 0.0, "avg_logprob": -0.09635650634765625, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.0612659025355242e-05}, {"id": 196, "seek": 89656, "start": 920.52, "end": 923.68, "text": " of the hardware basically transitions over to the kernel.", "tokens": [295, 264, 8837, 1936, 23767, 670, 281, 264, 28256, 13], "temperature": 0.0, "avg_logprob": -0.09635650634765625, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.0612659025355242e-05}, {"id": 197, "seek": 92368, "start": 923.68, "end": 928.92, "text": " And the unfortunate situation is that as you call exit boot services, firmware which may", "tokens": [400, 264, 17843, 2590, 307, 300, 382, 291, 818, 11043, 11450, 3328, 11, 30289, 597, 815], "temperature": 0.0, "avg_logprob": -0.14717678840343767, "compression_ratio": 1.5730337078651686, "no_speech_prob": 1.3840962310496252e-05}, {"id": 198, "seek": 92368, "start": 928.92, "end": 935.4799999999999, "text": " have enabled the IOMU or SMMU at boot time to protect against DMA attacks drops it at", "tokens": [362, 15172, 264, 286, 5251, 52, 420, 13115, 44, 52, 412, 11450, 565, 281, 2371, 1970, 413, 9998, 8122, 11438, 309, 412], "temperature": 0.0, "avg_logprob": -0.14717678840343767, "compression_ratio": 1.5730337078651686, "no_speech_prob": 1.3840962310496252e-05}, {"id": 199, "seek": 92368, "start": 935.4799999999999, "end": 939.88, "text": " this point, which sounds kind of silly, but that's what happens.", "tokens": [341, 935, 11, 597, 3263, 733, 295, 11774, 11, 457, 300, 311, 437, 2314, 13], "temperature": 0.0, "avg_logprob": -0.14717678840343767, "compression_ratio": 1.5730337078651686, "no_speech_prob": 1.3840962310496252e-05}, {"id": 200, "seek": 92368, "start": 939.88, "end": 946.4799999999999, "text": " And the reason if you ask those who are familiar with UFI is for legacy OS support because", "tokens": [400, 264, 1778, 498, 291, 1029, 729, 567, 366, 4963, 365, 624, 38568, 307, 337, 11711, 12731, 1406, 570], "temperature": 0.0, "avg_logprob": -0.14717678840343767, "compression_ratio": 1.5730337078651686, "no_speech_prob": 1.3840962310496252e-05}, {"id": 201, "seek": 92368, "start": 946.4799999999999, "end": 951.56, "text": " UFI assumes that maybe the next stage is a legacy OS which can't deal with DMA protection", "tokens": [624, 38568, 37808, 300, 1310, 264, 958, 3233, 307, 257, 11711, 12731, 597, 393, 380, 2028, 365, 413, 9998, 6334], "temperature": 0.0, "avg_logprob": -0.14717678840343767, "compression_ratio": 1.5730337078651686, "no_speech_prob": 1.3840962310496252e-05}, {"id": 202, "seek": 95156, "start": 951.56, "end": 958.0, "text": " so it gets turned off, which is really unfortunate because between the point where you call exit", "tokens": [370, 309, 2170, 3574, 766, 11, 597, 307, 534, 17843, 570, 1296, 264, 935, 689, 291, 818, 11043], "temperature": 0.0, "avg_logprob": -0.11492063484939874, "compression_ratio": 1.644, "no_speech_prob": 1.3626422514789738e-05}, {"id": 203, "seek": 95156, "start": 958.0, "end": 964.64, "text": " boot services to take over the platform hardware and the point where NOVA can actually enable", "tokens": [11450, 3328, 281, 747, 670, 264, 3663, 8837, 293, 264, 935, 689, 9146, 20914, 393, 767, 9528], "temperature": 0.0, "avg_logprob": -0.11492063484939874, "compression_ratio": 1.644, "no_speech_prob": 1.3626422514789738e-05}, {"id": 204, "seek": 95156, "start": 964.64, "end": 970.1199999999999, "text": " the IOMU, there's this window of opportunity shown in red here where there's no DMA protections", "tokens": [264, 286, 5251, 52, 11, 456, 311, 341, 4910, 295, 2650, 4898, 294, 2182, 510, 689, 456, 311, 572, 413, 9998, 29031], "temperature": 0.0, "avg_logprob": -0.11492063484939874, "compression_ratio": 1.644, "no_speech_prob": 1.3626422514789738e-05}, {"id": 205, "seek": 95156, "start": 970.1199999999999, "end": 971.9599999999999, "text": " and that's the point.", "tokens": [293, 300, 311, 264, 935, 13], "temperature": 0.0, "avg_logprob": -0.11492063484939874, "compression_ratio": 1.644, "no_speech_prob": 1.3626422514789738e-05}, {"id": 206, "seek": 95156, "start": 971.9599999999999, "end": 976.9599999999999, "text": " It's very small, maybe a few nanoseconds or microseconds where an attacker could perform", "tokens": [467, 311, 588, 1359, 11, 1310, 257, 1326, 14067, 541, 28750, 420, 3123, 37841, 28750, 689, 364, 35871, 727, 2042], "temperature": 0.0, "avg_logprob": -0.11492063484939874, "compression_ratio": 1.644, "no_speech_prob": 1.3626422514789738e-05}, {"id": 207, "seek": 95156, "start": 976.9599999999999, "end": 979.1199999999999, "text": " a DMA attack.", "tokens": [257, 413, 9998, 2690, 13], "temperature": 0.0, "avg_logprob": -0.11492063484939874, "compression_ratio": 1.644, "no_speech_prob": 1.3626422514789738e-05}, {"id": 208, "seek": 97912, "start": 979.12, "end": 984.96, "text": " And for that reason, NOVA takes complete control of the exit boot services flow, so it's not", "tokens": [400, 337, 300, 1778, 11, 9146, 20914, 2516, 3566, 1969, 295, 264, 11043, 11450, 3328, 3095, 11, 370, 309, 311, 406], "temperature": 0.0, "avg_logprob": -0.12269825063725953, "compression_ratio": 1.625, "no_speech_prob": 3.903878223354695e-06}, {"id": 209, "seek": 97912, "start": 984.96, "end": 990.6, "text": " the bootloader who calls exit boot services, NOVA actually drives the UFI infrastructure", "tokens": [264, 11450, 2907, 260, 567, 5498, 11043, 11450, 3328, 11, 9146, 20914, 767, 11754, 264, 624, 38568, 6896], "temperature": 0.0, "avg_logprob": -0.12269825063725953, "compression_ratio": 1.625, "no_speech_prob": 3.903878223354695e-06}, {"id": 210, "seek": 97912, "start": 990.6, "end": 996.04, "text": " and it disables all busmaster activity before calling exit boot services so that we eliminate", "tokens": [293, 309, 717, 2965, 439, 1255, 21640, 5191, 949, 5141, 11043, 11450, 3328, 370, 300, 321, 13819], "temperature": 0.0, "avg_logprob": -0.12269825063725953, "compression_ratio": 1.625, "no_speech_prob": 3.903878223354695e-06}, {"id": 211, "seek": 97912, "start": 996.04, "end": 1001.72, "text": " this window of opportunity.", "tokens": [341, 4910, 295, 2650, 13], "temperature": 0.0, "avg_logprob": -0.12269825063725953, "compression_ratio": 1.625, "no_speech_prob": 3.903878223354695e-06}, {"id": 212, "seek": 97912, "start": 1001.72, "end": 1008.84, "text": " That was a very aggressive change in NOVA because it means NOVA has to comprehend UFI.", "tokens": [663, 390, 257, 588, 10762, 1319, 294, 9146, 20914, 570, 309, 1355, 9146, 20914, 575, 281, 38183, 624, 38568, 13], "temperature": 0.0, "avg_logprob": -0.12269825063725953, "compression_ratio": 1.625, "no_speech_prob": 3.903878223354695e-06}, {"id": 213, "seek": 100884, "start": 1008.84, "end": 1011.88, "text": " The next thing that we added was a flexible load address.", "tokens": [440, 958, 551, 300, 321, 3869, 390, 257, 11358, 3677, 2985, 13], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 214, "seek": 100884, "start": 1011.88, "end": 1016.2800000000001, "text": " So when the bootloader wants to put a binary into physical memory, it invokes it with paging", "tokens": [407, 562, 264, 11450, 2907, 260, 2738, 281, 829, 257, 17434, 666, 4001, 4675, 11, 309, 1048, 8606, 309, 365, 280, 3568], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 215, "seek": 100884, "start": 1016.2800000000001, "end": 1020.72, "text": " being disabled, which means you have to load it at some physical address.", "tokens": [885, 15191, 11, 597, 1355, 291, 362, 281, 3677, 309, 412, 512, 4001, 2985, 13], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 216, "seek": 100884, "start": 1020.72, "end": 1024.64, "text": " And you can define an arbitrary physical address but it would be good if whatever physical", "tokens": [400, 291, 393, 6964, 364, 23211, 4001, 2985, 457, 309, 576, 312, 665, 498, 2035, 4001], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 217, "seek": 100884, "start": 1024.64, "end": 1027.3600000000001, "text": " address you define worked on all the boards.", "tokens": [2985, 291, 6964, 2732, 322, 439, 264, 13293, 13], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 218, "seek": 100884, "start": 1027.3600000000001, "end": 1031.8400000000001, "text": " And that is simply impossible, especially in the ARM ecosystem.", "tokens": [400, 300, 307, 2935, 6243, 11, 2318, 294, 264, 45209, 11311, 13], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 219, "seek": 100884, "start": 1031.8400000000001, "end": 1037.72, "text": " So in ARM some platforms have the DRAM starting at physical address zero, some have MMIO starting", "tokens": [407, 294, 45209, 512, 9473, 362, 264, 12118, 2865, 2891, 412, 4001, 2985, 4018, 11, 512, 362, 34191, 15167, 2891], "temperature": 0.0, "avg_logprob": -0.12001990490272398, "compression_ratio": 1.7938144329896908, "no_speech_prob": 2.7963125830865465e-05}, {"id": 220, "seek": 103772, "start": 1037.72, "end": 1043.04, "text": " at address zero, so you will not find a single physical address range that works across all", "tokens": [412, 2985, 4018, 11, 370, 291, 486, 406, 915, 257, 2167, 4001, 2985, 3613, 300, 1985, 2108, 439], "temperature": 0.0, "avg_logprob": -0.12439764530286876, "compression_ratio": 1.6614173228346456, "no_speech_prob": 1.3843625310983043e-05}, {"id": 221, "seek": 103772, "start": 1043.04, "end": 1049.96, "text": " ARM platforms where you can say always load NOVA at two megabytes, one gigabyte, whatever.", "tokens": [45209, 9473, 689, 291, 393, 584, 1009, 3677, 9146, 20914, 412, 732, 10816, 24538, 11, 472, 8741, 34529, 11, 2035, 13], "temperature": 0.0, "avg_logprob": -0.12439764530286876, "compression_ratio": 1.6614173228346456, "no_speech_prob": 1.3843625310983043e-05}, {"id": 222, "seek": 103772, "start": 1049.96, "end": 1053.0, "text": " So we made the load address flexible.", "tokens": [407, 321, 1027, 264, 3677, 2985, 11358, 13], "temperature": 0.0, "avg_logprob": -0.12439764530286876, "compression_ratio": 1.6614173228346456, "no_speech_prob": 1.3843625310983043e-05}, {"id": 223, "seek": 103772, "start": 1053.0, "end": 1057.08, "text": " Also the bootloader might want to move NOVA to a dedicated point in memory like at the", "tokens": [2743, 264, 11450, 2907, 260, 1062, 528, 281, 1286, 9146, 20914, 281, 257, 8374, 935, 294, 4675, 411, 412, 264], "temperature": 0.0, "avg_logprob": -0.12439764530286876, "compression_ratio": 1.6614173228346456, "no_speech_prob": 1.3843625310983043e-05}, {"id": 224, "seek": 103772, "start": 1057.08, "end": 1061.88, "text": " very top so that the bottom portion can be given one to one to a VM.", "tokens": [588, 1192, 370, 300, 264, 2767, 8044, 393, 312, 2212, 472, 281, 472, 281, 257, 18038, 13], "temperature": 0.0, "avg_logprob": -0.12439764530286876, "compression_ratio": 1.6614173228346456, "no_speech_prob": 1.3843625310983043e-05}, {"id": 225, "seek": 103772, "start": 1061.88, "end": 1065.0, "text": " So the load address is now flexible for NOVA.", "tokens": [407, 264, 3677, 2985, 307, 586, 11358, 337, 9146, 20914, 13], "temperature": 0.0, "avg_logprob": -0.12439764530286876, "compression_ratio": 1.6614173228346456, "no_speech_prob": 1.3843625310983043e-05}, {"id": 226, "seek": 106500, "start": 1065.0, "end": 1069.88, "text": " Not fully flexible but you can move NOVA up down by arbitrary multiples of two megabytes", "tokens": [1726, 4498, 11358, 457, 291, 393, 1286, 9146, 20914, 493, 760, 538, 23211, 46099, 295, 732, 10816, 24538], "temperature": 0.0, "avg_logprob": -0.19350630171755526, "compression_ratio": 1.6108949416342413, "no_speech_prob": 1.749887269397732e-05}, {"id": 227, "seek": 106500, "start": 1069.88, "end": 1072.72, "text": " so add super page boundaries.", "tokens": [370, 909, 1687, 3028, 13180, 13], "temperature": 0.0, "avg_logprob": -0.19350630171755526, "compression_ratio": 1.6108949416342413, "no_speech_prob": 1.749887269397732e-05}, {"id": 228, "seek": 106500, "start": 1072.72, "end": 1079.08, "text": " And the interesting insight into this is for pulling this off, there is no L3 location", "tokens": [400, 264, 1880, 11269, 666, 341, 307, 337, 8407, 341, 766, 11, 456, 307, 572, 441, 18, 4914], "temperature": 0.0, "avg_logprob": -0.19350630171755526, "compression_ratio": 1.6108949416342413, "no_speech_prob": 1.749887269397732e-05}, {"id": 229, "seek": 106500, "start": 1079.08, "end": 1081.56, "text": " complexity required.", "tokens": [14024, 4739, 13], "temperature": 0.0, "avg_logprob": -0.19350630171755526, "compression_ratio": 1.6108949416342413, "no_speech_prob": 1.749887269397732e-05}, {"id": 230, "seek": 106500, "start": 1081.56, "end": 1086.32, "text": " NOVA consists of two sections, a very small init section which is mapped, which is identity", "tokens": [9146, 20914, 14689, 295, 732, 10863, 11, 257, 588, 1359, 3157, 3541, 597, 307, 33318, 11, 597, 307, 6575], "temperature": 0.0, "avg_logprob": -0.19350630171755526, "compression_ratio": 1.6108949416342413, "no_speech_prob": 1.749887269397732e-05}, {"id": 231, "seek": 106500, "start": 1086.32, "end": 1091.76, "text": " map which means virtual addresses equal physical addresses and that's the code that initializes", "tokens": [4471, 597, 1355, 6374, 16862, 2681, 4001, 16862, 293, 300, 311, 264, 3089, 300, 5883, 5660], "temperature": 0.0, "avg_logprob": -0.19350630171755526, "compression_ratio": 1.6108949416342413, "no_speech_prob": 1.749887269397732e-05}, {"id": 232, "seek": 109176, "start": 1091.76, "end": 1096.84, "text": " the platform up to the point where you can enable paging and then there's a runtime section", "tokens": [264, 3663, 493, 281, 264, 935, 689, 291, 393, 9528, 280, 3568, 293, 550, 456, 311, 257, 34474, 3541], "temperature": 0.0, "avg_logprob": -0.11052190689813524, "compression_ratio": 1.8907563025210083, "no_speech_prob": 1.2605502888618503e-05}, {"id": 233, "seek": 109176, "start": 1096.84, "end": 1102.48, "text": " which runs paged so it has virtual to physical memory mappings and for those virtual to physical", "tokens": [597, 6676, 280, 2980, 370, 309, 575, 6374, 281, 4001, 4675, 463, 28968, 293, 337, 729, 6374, 281, 4001], "temperature": 0.0, "avg_logprob": -0.11052190689813524, "compression_ratio": 1.8907563025210083, "no_speech_prob": 1.2605502888618503e-05}, {"id": 234, "seek": 109176, "start": 1102.48, "end": 1108.36, "text": " memory mappings if you run this paging enabled the physical addresses that back these virtual", "tokens": [4675, 463, 28968, 498, 291, 1190, 341, 280, 3568, 15172, 264, 4001, 16862, 300, 646, 613, 6374], "temperature": 0.0, "avg_logprob": -0.11052190689813524, "compression_ratio": 1.8907563025210083, "no_speech_prob": 1.2605502888618503e-05}, {"id": 235, "seek": 109176, "start": 1108.36, "end": 1110.76, "text": " memory ranges simply don't matter.", "tokens": [4675, 22526, 2935, 500, 380, 1871, 13], "temperature": 0.0, "avg_logprob": -0.11052190689813524, "compression_ratio": 1.8907563025210083, "no_speech_prob": 1.2605502888618503e-05}, {"id": 236, "seek": 109176, "start": 1110.76, "end": 1114.56, "text": " So paging is basically some form of relocation.", "tokens": [407, 280, 3568, 307, 1936, 512, 1254, 295, 26981, 399, 13], "temperature": 0.0, "avg_logprob": -0.11052190689813524, "compression_ratio": 1.8907563025210083, "no_speech_prob": 1.2605502888618503e-05}, {"id": 237, "seek": 109176, "start": 1114.56, "end": 1118.8, "text": " You only need to deal with relocation for the init section and you can solve that by", "tokens": [509, 787, 643, 281, 2028, 365, 26981, 399, 337, 264, 3157, 3541, 293, 291, 393, 5039, 300, 538], "temperature": 0.0, "avg_logprob": -0.11052190689813524, "compression_ratio": 1.8907563025210083, "no_speech_prob": 1.2605502888618503e-05}, {"id": 238, "seek": 111880, "start": 1118.8, "end": 1122.6399999999999, "text": " making the init section be position independent code.", "tokens": [1455, 264, 3157, 3541, 312, 2535, 6695, 3089, 13], "temperature": 0.0, "avg_logprob": -0.16099854271010597, "compression_ratio": 1.6892430278884463, "no_speech_prob": 6.961608505662298e-06}, {"id": 239, "seek": 111880, "start": 1122.6399999999999, "end": 1126.9199999999998, "text": " And it's assembler anyway so making that position independent is not hard.", "tokens": [400, 309, 311, 8438, 1918, 4033, 370, 1455, 300, 2535, 6695, 307, 406, 1152, 13], "temperature": 0.0, "avg_logprob": -0.16099854271010597, "compression_ratio": 1.6892430278884463, "no_speech_prob": 6.961608505662298e-06}, {"id": 240, "seek": 111880, "start": 1126.9199999999998, "end": 1132.6399999999999, "text": " We actually didn't make the code just position independent, it is also mode independent", "tokens": [492, 767, 994, 380, 652, 264, 3089, 445, 2535, 6695, 11, 309, 307, 611, 4391, 6695], "temperature": 0.0, "avg_logprob": -0.16099854271010597, "compression_ratio": 1.6892430278884463, "no_speech_prob": 6.961608505662298e-06}, {"id": 241, "seek": 111880, "start": 1132.6399999999999, "end": 1139.28, "text": " which means no matter if UEFI starts you in 32-bit mode or 64-bit mode that code is dealing", "tokens": [597, 1355, 572, 1871, 498, 42260, 38568, 3719, 291, 294, 8858, 12, 5260, 4391, 420, 12145, 12, 5260, 4391, 300, 3089, 307, 6260], "temperature": 0.0, "avg_logprob": -0.16099854271010597, "compression_ratio": 1.6892430278884463, "no_speech_prob": 6.961608505662298e-06}, {"id": 242, "seek": 111880, "start": 1139.28, "end": 1143.08, "text": " with all these situations.", "tokens": [365, 439, 613, 6851, 13], "temperature": 0.0, "avg_logprob": -0.16099854271010597, "compression_ratio": 1.6892430278884463, "no_speech_prob": 6.961608505662298e-06}, {"id": 243, "seek": 111880, "start": 1143.08, "end": 1148.1599999999999, "text": " There's a limit, an artificial limit of you still have to load NOVA below four gigabytes", "tokens": [821, 311, 257, 4948, 11, 364, 11677, 4948, 295, 291, 920, 362, 281, 3677, 9146, 20914, 2507, 1451, 42741], "temperature": 0.0, "avg_logprob": -0.16099854271010597, "compression_ratio": 1.6892430278884463, "no_speech_prob": 6.961608505662298e-06}, {"id": 244, "seek": 114816, "start": 1148.16, "end": 1154.16, "text": " because multi-boot has been defined in such a way that you can't express addresses above", "tokens": [570, 4825, 12, 1763, 310, 575, 668, 7642, 294, 1270, 257, 636, 300, 291, 393, 380, 5109, 16862, 3673], "temperature": 0.0, "avg_logprob": -0.11401638617882362, "compression_ratio": 1.6566523605150214, "no_speech_prob": 1.8049729987978935e-05}, {"id": 245, "seek": 114816, "start": 1154.16, "end": 1160.96, "text": " four gigabytes because some of these structures are still 32-bit and that little emoticon expresses", "tokens": [1451, 42741, 570, 512, 295, 613, 9227, 366, 920, 8858, 12, 5260, 293, 300, 707, 3626, 11911, 39204], "temperature": 0.0, "avg_logprob": -0.11401638617882362, "compression_ratio": 1.6566523605150214, "no_speech_prob": 1.8049729987978935e-05}, {"id": 246, "seek": 114816, "start": 1160.96, "end": 1163.96, "text": " what we think of that.", "tokens": [437, 321, 519, 295, 300, 13], "temperature": 0.0, "avg_logprob": -0.11401638617882362, "compression_ratio": 1.6566523605150214, "no_speech_prob": 1.8049729987978935e-05}, {"id": 247, "seek": 114816, "start": 1163.96, "end": 1169.8400000000001, "text": " So then after we had figured this out we wanted to do some power management and this is an", "tokens": [407, 550, 934, 321, 632, 8932, 341, 484, 321, 1415, 281, 360, 512, 1347, 4592, 293, 341, 307, 364], "temperature": 0.0, "avg_logprob": -0.11401638617882362, "compression_ratio": 1.6566523605150214, "no_speech_prob": 1.8049729987978935e-05}, {"id": 248, "seek": 114816, "start": 1169.8400000000001, "end": 1175.52, "text": " overview of all the power management that ACPI defines so ACPI defines a few global", "tokens": [12492, 295, 439, 264, 1347, 4592, 300, 8157, 31701, 23122, 370, 8157, 31701, 23122, 257, 1326, 4338], "temperature": 0.0, "avg_logprob": -0.11401638617882362, "compression_ratio": 1.6566523605150214, "no_speech_prob": 1.8049729987978935e-05}, {"id": 249, "seek": 117552, "start": 1175.52, "end": 1178.8799999999999, "text": " states like working, sleeping and off.", "tokens": [4368, 411, 1364, 11, 8296, 293, 766, 13], "temperature": 0.0, "avg_logprob": -0.1566932504827326, "compression_ratio": 1.8174273858921162, "no_speech_prob": 2.3176125978352502e-05}, {"id": 250, "seek": 117552, "start": 1178.8799999999999, "end": 1184.48, "text": " Those aren't all that interesting, the really interesting states are the sleep states.", "tokens": [3950, 3212, 380, 439, 300, 1880, 11, 264, 534, 1880, 4368, 366, 264, 2817, 4368, 13], "temperature": 0.0, "avg_logprob": -0.1566932504827326, "compression_ratio": 1.8174273858921162, "no_speech_prob": 2.3176125978352502e-05}, {"id": 251, "seek": 117552, "start": 1184.48, "end": 1188.72, "text": " And the things that have this black bold border around it is the state in which the system", "tokens": [400, 264, 721, 300, 362, 341, 2211, 11928, 7838, 926, 309, 307, 264, 1785, 294, 597, 264, 1185], "temperature": 0.0, "avg_logprob": -0.1566932504827326, "compression_ratio": 1.8174273858921162, "no_speech_prob": 2.3176125978352502e-05}, {"id": 252, "seek": 117552, "start": 1188.72, "end": 1193.72, "text": " is when it's fully up and running, no idling, no sleeping, no nothing.", "tokens": [307, 562, 309, 311, 4498, 493, 293, 2614, 11, 572, 4496, 1688, 11, 572, 8296, 11, 572, 1825, 13], "temperature": 0.0, "avg_logprob": -0.1566932504827326, "compression_ratio": 1.8174273858921162, "no_speech_prob": 2.3176125978352502e-05}, {"id": 253, "seek": 117552, "start": 1193.72, "end": 1198.0, "text": " It's called the S0 working state and then there's some sleep state.", "tokens": [467, 311, 1219, 264, 318, 15, 1364, 1785, 293, 550, 456, 311, 512, 2817, 1785, 13], "temperature": 0.0, "avg_logprob": -0.1566932504827326, "compression_ratio": 1.8174273858921162, "no_speech_prob": 2.3176125978352502e-05}, {"id": 254, "seek": 117552, "start": 1198.0, "end": 1203.0, "text": " You might know suspend to run, suspend to disk and soft off and when you're in the", "tokens": [509, 1062, 458, 42546, 281, 1190, 11, 42546, 281, 12355, 293, 2787, 766, 293, 562, 291, 434, 294, 264], "temperature": 0.0, "avg_logprob": -0.1566932504827326, "compression_ratio": 1.8174273858921162, "no_speech_prob": 2.3176125978352502e-05}, {"id": 255, "seek": 120300, "start": 1203.0, "end": 1208.56, "text": " S0 working state you can have a bunch of idle states and in the C0 idle state you can have", "tokens": [318, 15, 1364, 1785, 291, 393, 362, 257, 3840, 295, 30650, 4368, 293, 294, 264, 383, 15, 30650, 1785, 291, 393, 362], "temperature": 0.0, "avg_logprob": -0.09616059197319879, "compression_ratio": 1.6759259259259258, "no_speech_prob": 1.6694782971171662e-05}, {"id": 256, "seek": 120300, "start": 1208.56, "end": 1213.6, "text": " a bunch of performance state which roughly correspond to voltage and frequency scaling", "tokens": [257, 3840, 295, 3389, 1785, 597, 9810, 6805, 281, 8352, 293, 7893, 21589], "temperature": 0.0, "avg_logprob": -0.09616059197319879, "compression_ratio": 1.6759259259259258, "no_speech_prob": 1.6694782971171662e-05}, {"id": 257, "seek": 120300, "start": 1213.6, "end": 1217.16, "text": " so ramping up the clock speed up and down.", "tokens": [370, 12428, 278, 493, 264, 7830, 3073, 493, 293, 760, 13], "temperature": 0.0, "avg_logprob": -0.09616059197319879, "compression_ratio": 1.6759259259259258, "no_speech_prob": 1.6694782971171662e-05}, {"id": 258, "seek": 120300, "start": 1217.16, "end": 1221.52, "text": " So unfortunately we don't have a lot of time to go into all the details of these sleep", "tokens": [407, 7015, 321, 500, 380, 362, 257, 688, 295, 565, 281, 352, 666, 439, 264, 4365, 295, 613, 2817], "temperature": 0.0, "avg_logprob": -0.09616059197319879, "compression_ratio": 1.6759259259259258, "no_speech_prob": 1.6694782971171662e-05}, {"id": 259, "seek": 120300, "start": 1221.52, "end": 1227.44, "text": " states but I want to still say a few words about this.", "tokens": [4368, 457, 286, 528, 281, 920, 584, 257, 1326, 2283, 466, 341, 13], "temperature": 0.0, "avg_logprob": -0.09616059197319879, "compression_ratio": 1.6759259259259258, "no_speech_prob": 1.6694782971171662e-05}, {"id": 260, "seek": 122744, "start": 1227.44, "end": 1234.64, "text": " We implemented suspend resume on both x86 and ARM and there's two ways you can go about", "tokens": [492, 12270, 42546, 15358, 322, 1293, 2031, 22193, 293, 45209, 293, 456, 311, 732, 2098, 291, 393, 352, 466], "temperature": 0.0, "avg_logprob": -0.11066992306014867, "compression_ratio": 1.7401574803149606, "no_speech_prob": 7.069964794936823e-06}, {"id": 261, "seek": 122744, "start": 1234.64, "end": 1235.64, "text": " it.", "tokens": [309, 13], "temperature": 0.0, "avg_logprob": -0.11066992306014867, "compression_ratio": 1.7401574803149606, "no_speech_prob": 7.069964794936823e-06}, {"id": 262, "seek": 122744, "start": 1235.64, "end": 1242.1200000000001, "text": " One which is I would say a brute force approach and the other which is the smart approach.", "tokens": [1485, 597, 307, 286, 576, 584, 257, 47909, 3464, 3109, 293, 264, 661, 597, 307, 264, 4069, 3109, 13], "temperature": 0.0, "avg_logprob": -0.11066992306014867, "compression_ratio": 1.7401574803149606, "no_speech_prob": 7.069964794936823e-06}, {"id": 263, "seek": 122744, "start": 1242.1200000000001, "end": 1246.0800000000002, "text": " And the brute force approach basically goes like you look at all the devices that lose", "tokens": [400, 264, 47909, 3464, 3109, 1936, 1709, 411, 291, 574, 412, 439, 264, 5759, 300, 3624], "temperature": 0.0, "avg_logprob": -0.11066992306014867, "compression_ratio": 1.7401574803149606, "no_speech_prob": 7.069964794936823e-06}, {"id": 264, "seek": 122744, "start": 1246.0800000000002, "end": 1251.8, "text": " their state during a suspend resume transition and you save their entire register state.", "tokens": [641, 1785, 1830, 257, 42546, 15358, 6034, 293, 291, 3155, 641, 2302, 7280, 1785, 13], "temperature": 0.0, "avg_logprob": -0.11066992306014867, "compression_ratio": 1.7401574803149606, "no_speech_prob": 7.069964794936823e-06}, {"id": 265, "seek": 122744, "start": 1251.8, "end": 1255.3600000000001, "text": " And that's a significant amount of state that you have to manage and it may even be", "tokens": [400, 300, 311, 257, 4776, 2372, 295, 1785, 300, 291, 362, 281, 3067, 293, 309, 815, 754, 312], "temperature": 0.0, "avg_logprob": -0.11066992306014867, "compression_ratio": 1.7401574803149606, "no_speech_prob": 7.069964794936823e-06}, {"id": 266, "seek": 125536, "start": 1255.36, "end": 1259.84, "text": " impossible to manage it because if you have devices with hidden internal state you may", "tokens": [6243, 281, 3067, 309, 570, 498, 291, 362, 5759, 365, 7633, 6920, 1785, 291, 815], "temperature": 0.0, "avg_logprob": -0.09101798704692296, "compression_ratio": 1.8984375, "no_speech_prob": 5.862346824869746e-06}, {"id": 267, "seek": 125536, "start": 1259.84, "end": 1265.4799999999998, "text": " not be able to get it it or if the device has a hidden internal state machine you may", "tokens": [406, 312, 1075, 281, 483, 309, 309, 420, 498, 264, 4302, 575, 257, 7633, 6920, 1785, 3479, 291, 815], "temperature": 0.0, "avg_logprob": -0.09101798704692296, "compression_ratio": 1.8984375, "no_speech_prob": 5.862346824869746e-06}, {"id": 268, "seek": 125536, "start": 1265.4799999999998, "end": 1269.4399999999998, "text": " not know what the internal state of that device is at that point.", "tokens": [406, 458, 437, 264, 6920, 1785, 295, 300, 4302, 307, 412, 300, 935, 13], "temperature": 0.0, "avg_logprob": -0.09101798704692296, "compression_ratio": 1.8984375, "no_speech_prob": 5.862346824869746e-06}, {"id": 269, "seek": 125536, "start": 1269.4399999999998, "end": 1273.76, "text": " So it may be suitable for some generic devices like if you wanted to save the configuration", "tokens": [407, 309, 815, 312, 12873, 337, 512, 19577, 5759, 411, 498, 291, 1415, 281, 3155, 264, 11694], "temperature": 0.0, "avg_logprob": -0.09101798704692296, "compression_ratio": 1.8984375, "no_speech_prob": 5.862346824869746e-06}, {"id": 270, "seek": 125536, "start": 1273.76, "end": 1278.08, "text": " space of every PCI device that's generic enough that you could do that.", "tokens": [1901, 295, 633, 6465, 40, 4302, 300, 311, 19577, 1547, 300, 291, 727, 360, 300, 13], "temperature": 0.0, "avg_logprob": -0.09101798704692296, "compression_ratio": 1.8984375, "no_speech_prob": 5.862346824869746e-06}, {"id": 271, "seek": 125536, "start": 1278.08, "end": 1283.6799999999998, "text": " But for some interrupt controllers or SMM use with internal state that's not smart.", "tokens": [583, 337, 512, 12729, 26903, 420, 13115, 44, 764, 365, 6920, 1785, 300, 311, 406, 4069, 13], "temperature": 0.0, "avg_logprob": -0.09101798704692296, "compression_ratio": 1.8984375, "no_speech_prob": 5.862346824869746e-06}, {"id": 272, "seek": 128368, "start": 1283.68, "end": 1288.92, "text": " So for that you can actually use the second approach which Nova uses which is you save", "tokens": [407, 337, 300, 291, 393, 767, 764, 264, 1150, 3109, 597, 27031, 4960, 597, 307, 291, 3155], "temperature": 0.0, "avg_logprob": -0.1106341160260714, "compression_ratio": 1.796, "no_speech_prob": 3.288345169494278e-06}, {"id": 273, "seek": 128368, "start": 1288.92, "end": 1293.6000000000001, "text": " a high level configuration and you initialize the device based on that.", "tokens": [257, 1090, 1496, 11694, 293, 291, 5883, 1125, 264, 4302, 2361, 322, 300, 13], "temperature": 0.0, "avg_logprob": -0.1106341160260714, "compression_ratio": 1.796, "no_speech_prob": 3.288345169494278e-06}, {"id": 274, "seek": 128368, "start": 1293.6000000000001, "end": 1300.96, "text": " So as an example say you had an interrupt routed to core zero in edge triggered mode.", "tokens": [407, 382, 364, 1365, 584, 291, 632, 364, 12729, 4020, 292, 281, 4965, 4018, 294, 4691, 21710, 4391, 13], "temperature": 0.0, "avg_logprob": -0.1106341160260714, "compression_ratio": 1.796, "no_speech_prob": 3.288345169494278e-06}, {"id": 275, "seek": 128368, "start": 1300.96, "end": 1305.68, "text": " You would save that as a high level information and that's sufficient to reinitialize all", "tokens": [509, 576, 3155, 300, 382, 257, 1090, 1496, 1589, 293, 300, 311, 11563, 281, 6561, 270, 831, 1125, 439], "temperature": 0.0, "avg_logprob": -0.1106341160260714, "compression_ratio": 1.796, "no_speech_prob": 3.288345169494278e-06}, {"id": 276, "seek": 128368, "start": 1305.68, "end": 1310.48, "text": " the interrupt controllers all the redirection entries all the trigger modes based on just", "tokens": [264, 12729, 26903, 439, 264, 2182, 621, 882, 23041, 439, 264, 7875, 14068, 2361, 322, 445], "temperature": 0.0, "avg_logprob": -0.1106341160260714, "compression_ratio": 1.796, "no_speech_prob": 3.288345169494278e-06}, {"id": 277, "seek": 128368, "start": 1310.48, "end": 1311.76, "text": " this bit of information.", "tokens": [341, 857, 295, 1589, 13], "temperature": 0.0, "avg_logprob": -0.1106341160260714, "compression_ratio": 1.796, "no_speech_prob": 3.288345169494278e-06}, {"id": 278, "seek": 131176, "start": 1311.76, "end": 1318.56, "text": " So there's lots less information to maintain saving becomes basically a know up restoring", "tokens": [407, 456, 311, 3195, 1570, 1589, 281, 6909, 6816, 3643, 1936, 257, 458, 493, 36349], "temperature": 0.0, "avg_logprob": -0.15753726499626436, "compression_ratio": 1.6118143459915613, "no_speech_prob": 2.7692231014952995e-06}, {"id": 279, "seek": 131176, "start": 1318.56, "end": 1324.28, "text": " can actually use the same code pass that you used to initially bring up that particular", "tokens": [393, 767, 764, 264, 912, 3089, 1320, 300, 291, 1143, 281, 9105, 1565, 493, 300, 1729], "temperature": 0.0, "avg_logprob": -0.15753726499626436, "compression_ratio": 1.6118143459915613, "no_speech_prob": 2.7692231014952995e-06}, {"id": 280, "seek": 131176, "start": 1324.28, "end": 1328.92, "text": " device and that's the approach for all the interrupt controllers all the SMM use all", "tokens": [4302, 293, 300, 311, 264, 3109, 337, 439, 264, 12729, 26903, 439, 264, 13115, 44, 764, 439], "temperature": 0.0, "avg_logprob": -0.15753726499626436, "compression_ratio": 1.6118143459915613, "no_speech_prob": 2.7692231014952995e-06}, {"id": 281, "seek": 131176, "start": 1328.92, "end": 1333.16, "text": " the devices managed by Nova.", "tokens": [264, 5759, 6453, 538, 27031, 13], "temperature": 0.0, "avg_logprob": -0.15753726499626436, "compression_ratio": 1.6118143459915613, "no_speech_prob": 2.7692231014952995e-06}, {"id": 282, "seek": 131176, "start": 1333.16, "end": 1338.28, "text": " The next thing I want to briefly talk about is P states performance states which are these", "tokens": [440, 958, 551, 286, 528, 281, 10515, 751, 466, 307, 430, 4368, 3389, 4368, 597, 366, 613], "temperature": 0.0, "avg_logprob": -0.15753726499626436, "compression_ratio": 1.6118143459915613, "no_speech_prob": 2.7692231014952995e-06}, {"id": 283, "seek": 133828, "start": 1338.28, "end": 1348.68, "text": " gears for ramping up the clock speed on x86 and Nova can now deal with all these P states.", "tokens": [20915, 337, 12428, 278, 493, 264, 7830, 3073, 322, 2031, 22193, 293, 27031, 393, 586, 2028, 365, 439, 613, 430, 4368, 13], "temperature": 0.0, "avg_logprob": -0.1484816206826104, "compression_ratio": 1.596938775510204, "no_speech_prob": 2.8845195629401132e-05}, {"id": 284, "seek": 133828, "start": 1348.68, "end": 1353.8, "text": " The interesting aspect is that most modern x86 processors have something called Turbo", "tokens": [440, 1880, 4171, 307, 300, 881, 4363, 2031, 22193, 27751, 362, 746, 1219, 35848], "temperature": 0.0, "avg_logprob": -0.1484816206826104, "compression_ratio": 1.596938775510204, "no_speech_prob": 2.8845195629401132e-05}, {"id": 285, "seek": 133828, "start": 1353.8, "end": 1359.96, "text": " mode and Turbo mode allows one or more processors to exceed the nominal clock speed to actually", "tokens": [4391, 293, 35848, 4391, 4045, 472, 420, 544, 27751, 281, 14048, 264, 41641, 7830, 3073, 281, 767], "temperature": 0.0, "avg_logprob": -0.1484816206826104, "compression_ratio": 1.596938775510204, "no_speech_prob": 2.8845195629401132e-05}, {"id": 286, "seek": 133828, "start": 1359.96, "end": 1364.2, "text": " turbo up higher if other cores are idle.", "tokens": [20902, 493, 2946, 498, 661, 24826, 366, 30650, 13], "temperature": 0.0, "avg_logprob": -0.1484816206826104, "compression_ratio": 1.596938775510204, "no_speech_prob": 2.8845195629401132e-05}, {"id": 287, "seek": 136420, "start": 1364.2, "end": 1369.72, "text": " So if other cores are not using their thermal or power headroom is elected set of course", "tokens": [407, 498, 661, 24826, 366, 406, 1228, 641, 15070, 420, 1347, 1378, 2861, 307, 11776, 992, 295, 1164], "temperature": 0.0, "avg_logprob": -0.12747168318133487, "compression_ratio": 1.7526881720430108, "no_speech_prob": 9.078650691662915e-06}, {"id": 288, "seek": 136420, "start": 1369.72, "end": 1374.0800000000002, "text": " maybe just one core maybe a few other cores can actually turbo up many bins and this is", "tokens": [1310, 445, 472, 4965, 1310, 257, 1326, 661, 24826, 393, 767, 20902, 493, 867, 41275, 293, 341, 307], "temperature": 0.0, "avg_logprob": -0.12747168318133487, "compression_ratio": 1.7526881720430108, "no_speech_prob": 9.078650691662915e-06}, {"id": 289, "seek": 136420, "start": 1374.0800000000002, "end": 1379.2, "text": " shown here on active core zero which basically gets the thermal headroom of core one core", "tokens": [4898, 510, 322, 4967, 4965, 4018, 597, 1936, 2170, 264, 15070, 1378, 2861, 295, 4965, 472, 4965], "temperature": 0.0, "avg_logprob": -0.12747168318133487, "compression_ratio": 1.7526881720430108, "no_speech_prob": 9.078650691662915e-06}, {"id": 290, "seek": 136420, "start": 1379.2, "end": 1382.0800000000002, "text": " two and core three to clock up higher.", "tokens": [732, 293, 4965, 1045, 281, 7830, 493, 2946, 13], "temperature": 0.0, "avg_logprob": -0.12747168318133487, "compression_ratio": 1.7526881720430108, "no_speech_prob": 9.078650691662915e-06}, {"id": 291, "seek": 136420, "start": 1382.0800000000002, "end": 1386.72, "text": " So Nova will exploit that feature when it's available but there are situations where you", "tokens": [407, 27031, 486, 25924, 300, 4111, 562, 309, 311, 2435, 457, 456, 366, 6851, 689, 291], "temperature": 0.0, "avg_logprob": -0.12747168318133487, "compression_ratio": 1.7526881720430108, "no_speech_prob": 9.078650691662915e-06}, {"id": 292, "seek": 136420, "start": 1386.72, "end": 1391.56, "text": " want predictable performance where you want every core to run at its guaranteed high frequency", "tokens": [528, 27737, 3389, 689, 291, 528, 633, 4965, 281, 1190, 412, 1080, 18031, 1090, 7893], "temperature": 0.0, "avg_logprob": -0.12747168318133487, "compression_ratio": 1.7526881720430108, "no_speech_prob": 9.078650691662915e-06}, {"id": 293, "seek": 139156, "start": 1391.56, "end": 1397.56, "text": " mode and there's a command line parameter that you can set that basically clamps the", "tokens": [4391, 293, 456, 311, 257, 5622, 1622, 13075, 300, 291, 393, 992, 300, 1936, 44423, 264], "temperature": 0.0, "avg_logprob": -0.11278631332072805, "compression_ratio": 1.9115044247787611, "no_speech_prob": 8.26564610179048e-06}, {"id": 294, "seek": 139156, "start": 1397.56, "end": 1401.0, "text": " maximum speed to the guaranteed frequency.", "tokens": [6674, 3073, 281, 264, 18031, 7893, 13], "temperature": 0.0, "avg_logprob": -0.11278631332072805, "compression_ratio": 1.9115044247787611, "no_speech_prob": 8.26564610179048e-06}, {"id": 295, "seek": 139156, "start": 1401.0, "end": 1408.6399999999999, "text": " You could also lower the frequency to something less than the guaranteed frequency there's", "tokens": [509, 727, 611, 3126, 264, 7893, 281, 746, 1570, 813, 264, 18031, 7893, 456, 311], "temperature": 0.0, "avg_logprob": -0.11278631332072805, "compression_ratio": 1.9115044247787611, "no_speech_prob": 8.26564610179048e-06}, {"id": 296, "seek": 139156, "start": 1408.6399999999999, "end": 1413.3999999999999, "text": " a point an operating point it's called maximum efficiency and there's even points below that", "tokens": [257, 935, 364, 7447, 935, 309, 311, 1219, 6674, 10493, 293, 456, 311, 754, 2793, 2507, 300], "temperature": 0.0, "avg_logprob": -0.11278631332072805, "compression_ratio": 1.9115044247787611, "no_speech_prob": 8.26564610179048e-06}, {"id": 297, "seek": 139156, "start": 1413.3999999999999, "end": 1418.08, "text": " where you can clock really high but then it's actually less efficient than this point.", "tokens": [689, 291, 393, 7830, 534, 1090, 457, 550, 309, 311, 767, 1570, 7148, 813, 341, 935, 13], "temperature": 0.0, "avg_logprob": -0.11278631332072805, "compression_ratio": 1.9115044247787611, "no_speech_prob": 8.26564610179048e-06}, {"id": 298, "seek": 139156, "start": 1418.08, "end": 1420.76, "text": " So all of that is also supported.", "tokens": [407, 439, 295, 300, 307, 611, 8104, 13], "temperature": 0.0, "avg_logprob": -0.11278631332072805, "compression_ratio": 1.9115044247787611, "no_speech_prob": 8.26564610179048e-06}, {"id": 299, "seek": 142076, "start": 1420.76, "end": 1426.92, "text": " So as an overview from a feature comparison perspective ARM versus x86 we support p-states", "tokens": [407, 382, 364, 12492, 490, 257, 4111, 9660, 4585, 45209, 5717, 2031, 22193, 321, 1406, 280, 12, 372, 1024], "temperature": 0.0, "avg_logprob": -0.17288877675821493, "compression_ratio": 1.6556603773584906, "no_speech_prob": 3.701122841448523e-05}, {"id": 300, "seek": 142076, "start": 1426.92, "end": 1434.04, "text": " on x86 not on ARM because there's no generic interface on ARM yet we support all the s-states", "tokens": [322, 2031, 22193, 406, 322, 45209, 570, 456, 311, 572, 19577, 9226, 322, 45209, 1939, 321, 1406, 439, 264, 262, 12, 372, 1024], "temperature": 0.0, "avg_logprob": -0.17288877675821493, "compression_ratio": 1.6556603773584906, "no_speech_prob": 3.701122841448523e-05}, {"id": 301, "seek": 142076, "start": 1434.04, "end": 1442.44, "text": " on x86 like stop clock, suspend, resume, hibernation, power off, platform reset.", "tokens": [322, 2031, 22193, 411, 1590, 7830, 11, 42546, 11, 15358, 11, 4879, 26848, 399, 11, 1347, 766, 11, 3663, 14322, 13], "temperature": 0.0, "avg_logprob": -0.17288877675821493, "compression_ratio": 1.6556603773584906, "no_speech_prob": 3.701122841448523e-05}, {"id": 302, "seek": 142076, "start": 1442.44, "end": 1449.84, "text": " On ARM there's no such concept as one but we also support suspend, resume and suspend", "tokens": [1282, 45209, 456, 311, 572, 1270, 3410, 382, 472, 457, 321, 611, 1406, 42546, 11, 15358, 293, 42546], "temperature": 0.0, "avg_logprob": -0.17288877675821493, "compression_ratio": 1.6556603773584906, "no_speech_prob": 3.701122841448523e-05}, {"id": 303, "seek": 144984, "start": 1449.84, "end": 1455.76, "text": " to disk if it's supported and what does it mean if it's supported it means if platform", "tokens": [281, 12355, 498, 309, 311, 8104, 293, 437, 775, 309, 914, 498, 309, 311, 8104, 309, 1355, 498, 3663], "temperature": 0.0, "avg_logprob": -0.14096411750430152, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.982104549824726e-05}, {"id": 304, "seek": 144984, "start": 1455.76, "end": 1460.9199999999998, "text": " firmware like psci implements it and there are some features that are mandatory and some", "tokens": [30289, 411, 18815, 537, 704, 17988, 309, 293, 456, 366, 512, 4122, 300, 366, 22173, 293, 512], "temperature": 0.0, "avg_logprob": -0.14096411750430152, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.982104549824726e-05}, {"id": 305, "seek": 144984, "start": 1460.9199999999998, "end": 1462.12, "text": " features that are optional.", "tokens": [4122, 300, 366, 17312, 13], "temperature": 0.0, "avg_logprob": -0.14096411750430152, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.982104549824726e-05}, {"id": 306, "seek": 144984, "start": 1462.12, "end": 1468.0, "text": " So suspend, resume for example works great on the nxpimx8m that Stefan had for his demo", "tokens": [407, 42546, 11, 15358, 337, 1365, 1985, 869, 322, 264, 297, 87, 79, 332, 87, 23, 76, 300, 32158, 632, 337, 702, 10723], "temperature": 0.0, "avg_logprob": -0.14096411750430152, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.982104549824726e-05}, {"id": 307, "seek": 144984, "start": 1468.0, "end": 1473.9599999999998, "text": " it doesn't work so great on Raspberry Pi because the firmware simply has no support for jumping", "tokens": [309, 1177, 380, 589, 370, 869, 322, 41154, 17741, 570, 264, 30289, 2935, 575, 572, 1406, 337, 11233], "temperature": 0.0, "avg_logprob": -0.14096411750430152, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.982104549824726e-05}, {"id": 308, "seek": 144984, "start": 1473.9599999999998, "end": 1477.04, "text": " back to the operating system after a suspend.", "tokens": [646, 281, 264, 7447, 1185, 934, 257, 42546, 13], "temperature": 0.0, "avg_logprob": -0.14096411750430152, "compression_ratio": 1.7892561983471074, "no_speech_prob": 1.982104549824726e-05}, {"id": 309, "seek": 147704, "start": 1477.04, "end": 1480.04, "text": " So it's not a novel limitation.", "tokens": [407, 309, 311, 406, 257, 7613, 27432, 13], "temperature": 0.0, "avg_logprob": -0.15398206918135934, "compression_ratio": 1.6764705882352942, "no_speech_prob": 1.5197356333374046e-05}, {"id": 310, "seek": 147704, "start": 1480.04, "end": 1485.12, "text": " There's a new suspend feature called low power idle which we don't support yet because it", "tokens": [821, 311, 257, 777, 42546, 4111, 1219, 2295, 1347, 30650, 597, 321, 500, 380, 1406, 1939, 570, 309], "temperature": 0.0, "avg_logprob": -0.15398206918135934, "compression_ratio": 1.6764705882352942, "no_speech_prob": 1.5197356333374046e-05}, {"id": 311, "seek": 147704, "start": 1485.12, "end": 1490.48, "text": " requires way more support than just Nova basically requires powering down the GPU, powering down", "tokens": [7029, 636, 544, 1406, 813, 445, 27031, 1936, 7029, 1347, 278, 760, 264, 18407, 11, 1347, 278, 760], "temperature": 0.0, "avg_logprob": -0.15398206918135934, "compression_ratio": 1.6764705882352942, "no_speech_prob": 1.5197356333374046e-05}, {"id": 312, "seek": 147704, "start": 1490.48, "end": 1496.0, "text": " all the devices, powering down all the links so this is a concerted platform effort.", "tokens": [439, 264, 5759, 11, 1347, 278, 760, 439, 264, 6123, 370, 341, 307, 257, 8543, 292, 3663, 4630, 13], "temperature": 0.0, "avg_logprob": -0.15398206918135934, "compression_ratio": 1.6764705882352942, "no_speech_prob": 1.5197356333374046e-05}, {"id": 313, "seek": 147704, "start": 1496.0, "end": 1503.52, "text": " But from a hypercore perspective the hypercore that you would invoke to transition the platform", "tokens": [583, 490, 257, 9848, 12352, 4585, 264, 9848, 12352, 300, 291, 576, 41117, 281, 6034, 264, 3663], "temperature": 0.0, "avg_logprob": -0.15398206918135934, "compression_ratio": 1.6764705882352942, "no_speech_prob": 1.5197356333374046e-05}, {"id": 314, "seek": 150352, "start": 1503.52, "end": 1507.72, "text": " to a sleep state is called control hardware and whenever you try to invoke it with something", "tokens": [281, 257, 2817, 1785, 307, 1219, 1969, 8837, 293, 5699, 291, 853, 281, 41117, 309, 365, 746], "temperature": 0.0, "avg_logprob": -0.15875108558011342, "compression_ratio": 1.7410714285714286, "no_speech_prob": 1.2210583008709364e-05}, {"id": 315, "seek": 150352, "start": 1507.72, "end": 1512.36, "text": " that's not supported it returns bad feature and for the hypercodes that assign devices", "tokens": [300, 311, 406, 8104, 309, 11247, 1578, 4111, 293, 337, 264, 9848, 66, 4789, 300, 6269, 5759], "temperature": 0.0, "avg_logprob": -0.15875108558011342, "compression_ratio": 1.7410714285714286, "no_speech_prob": 1.2210583008709364e-05}, {"id": 316, "seek": 150352, "start": 1512.36, "end": 1520.16, "text": " or interrupts the state that the system had when you assign devices or interrupts to particular", "tokens": [420, 12729, 82, 264, 1785, 300, 264, 1185, 632, 562, 291, 6269, 5759, 420, 12729, 82, 281, 1729], "temperature": 0.0, "avg_logprob": -0.15875108558011342, "compression_ratio": 1.7410714285714286, "no_speech_prob": 1.2210583008709364e-05}, {"id": 317, "seek": 150352, "start": 1520.16, "end": 1525.8799999999999, "text": " domains will completely be preserved across the suspend, resume codes using this safety", "tokens": [25514, 486, 2584, 312, 22242, 2108, 264, 42546, 11, 15358, 14211, 1228, 341, 4514], "temperature": 0.0, "avg_logprob": -0.15875108558011342, "compression_ratio": 1.7410714285714286, "no_speech_prob": 1.2210583008709364e-05}, {"id": 318, "seek": 150352, "start": 1525.8799999999999, "end": 1529.12, "text": " high level state approach.", "tokens": [1090, 1496, 1785, 3109, 13], "temperature": 0.0, "avg_logprob": -0.15875108558011342, "compression_ratio": 1.7410714285714286, "no_speech_prob": 1.2210583008709364e-05}, {"id": 319, "seek": 152912, "start": 1529.12, "end": 1535.84, "text": " So next I'll talk about some radical API change that we made and being a micro kernel and", "tokens": [407, 958, 286, 603, 751, 466, 512, 12001, 9362, 1319, 300, 321, 1027, 293, 885, 257, 4532, 28256, 293], "temperature": 0.0, "avg_logprob": -0.1701261540676685, "compression_ratio": 1.5775193798449612, "no_speech_prob": 7.068641025398392e-06}, {"id": 320, "seek": 152912, "start": 1535.84, "end": 1540.08, "text": " not being Linux we don't have to remain backward compatible.", "tokens": [406, 885, 18734, 321, 500, 380, 362, 281, 6222, 23897, 18218, 13], "temperature": 0.0, "avg_logprob": -0.1701261540676685, "compression_ratio": 1.5775193798449612, "no_speech_prob": 7.068641025398392e-06}, {"id": 321, "seek": 152912, "start": 1540.08, "end": 1546.56, "text": " So that's one of these major API changes that took quite a lot of time to implement.", "tokens": [407, 300, 311, 472, 295, 613, 2563, 9362, 2962, 300, 1890, 1596, 257, 688, 295, 565, 281, 4445, 13], "temperature": 0.0, "avg_logprob": -0.1701261540676685, "compression_ratio": 1.5775193798449612, "no_speech_prob": 7.068641025398392e-06}, {"id": 322, "seek": 152912, "start": 1546.56, "end": 1552.8, "text": " What we had in the past was basically an interface with five kernel objects.", "tokens": [708, 321, 632, 294, 264, 1791, 390, 1936, 364, 9226, 365, 1732, 28256, 6565, 13], "temperature": 0.0, "avg_logprob": -0.1701261540676685, "compression_ratio": 1.5775193798449612, "no_speech_prob": 7.068641025398392e-06}, {"id": 323, "seek": 152912, "start": 1552.8, "end": 1557.1599999999999, "text": " Protection domains, execution context, scheduling context, portals and sum of course and every", "tokens": [25981, 25514, 11, 15058, 4319, 11, 29055, 4319, 11, 2436, 1124, 293, 2408, 295, 1164, 293, 633], "temperature": 0.0, "avg_logprob": -0.1701261540676685, "compression_ratio": 1.5775193798449612, "no_speech_prob": 7.068641025398392e-06}, {"id": 324, "seek": 155716, "start": 1557.16, "end": 1560.1200000000001, "text": " protection domain looked as shown on this slide.", "tokens": [6334, 9274, 2956, 382, 4898, 322, 341, 4137, 13], "temperature": 0.0, "avg_logprob": -0.1853610756470985, "compression_ratio": 1.748936170212766, "no_speech_prob": 2.2467334929388016e-05}, {"id": 325, "seek": 155716, "start": 1560.1200000000001, "end": 1567.48, "text": " It actually had six resource spaces built into it, an object space which hosts capabilities", "tokens": [467, 767, 632, 2309, 7684, 7673, 3094, 666, 309, 11, 364, 2657, 1901, 597, 21573, 10862], "temperature": 0.0, "avg_logprob": -0.1853610756470985, "compression_ratio": 1.748936170212766, "no_speech_prob": 2.2467334929388016e-05}, {"id": 326, "seek": 155716, "start": 1567.48, "end": 1572.76, "text": " to all the kernel objects that you have access to, a host space which represents the stage", "tokens": [281, 439, 264, 28256, 6565, 300, 291, 362, 2105, 281, 11, 257, 3975, 1901, 597, 8855, 264, 3233], "temperature": 0.0, "avg_logprob": -0.1853610756470985, "compression_ratio": 1.748936170212766, "no_speech_prob": 2.2467334929388016e-05}, {"id": 327, "seek": 155716, "start": 1572.76, "end": 1579.76, "text": " one page table, a guest space which represents the stage two guest page table, the DMA space", "tokens": [472, 3028, 3199, 11, 257, 8341, 1901, 597, 8855, 264, 3233, 732, 8341, 3028, 3199, 11, 264, 413, 9998, 1901], "temperature": 0.0, "avg_logprob": -0.1853610756470985, "compression_ratio": 1.748936170212766, "no_speech_prob": 2.2467334929388016e-05}, {"id": 328, "seek": 155716, "start": 1579.76, "end": 1586.4, "text": " for memory transactions that are remapped by the IOMU, port IO space and an MSR space.", "tokens": [337, 4675, 16856, 300, 366, 890, 20780, 538, 264, 286, 5251, 52, 11, 2436, 39839, 1901, 293, 364, 7395, 49, 1901, 13], "temperature": 0.0, "avg_logprob": -0.1853610756470985, "compression_ratio": 1.748936170212766, "no_speech_prob": 2.2467334929388016e-05}, {"id": 329, "seek": 158640, "start": 1586.4, "end": 1591.2, "text": " So all of these existed in one single instance in every protection domain and when you created", "tokens": [407, 439, 295, 613, 13135, 294, 472, 2167, 5197, 294, 633, 6334, 9274, 293, 562, 291, 2942], "temperature": 0.0, "avg_logprob": -0.12477743098166137, "compression_ratio": 1.6551724137931034, "no_speech_prob": 8.799518582236487e-06}, {"id": 330, "seek": 158640, "start": 1591.2, "end": 1596.2, "text": " a host EC, a guest EC, like a virtual CPU or device they were automatically bound to", "tokens": [257, 3975, 19081, 11, 257, 8341, 19081, 11, 411, 257, 6374, 13199, 420, 4302, 436, 645, 6772, 5472, 281], "temperature": 0.0, "avg_logprob": -0.12477743098166137, "compression_ratio": 1.6551724137931034, "no_speech_prob": 8.799518582236487e-06}, {"id": 331, "seek": 158640, "start": 1596.2, "end": 1600.3600000000001, "text": " the PD and picking up the spaces that they needed.", "tokens": [264, 10464, 293, 8867, 493, 264, 7673, 300, 436, 2978, 13], "temperature": 0.0, "avg_logprob": -0.12477743098166137, "compression_ratio": 1.6551724137931034, "no_speech_prob": 8.799518582236487e-06}, {"id": 332, "seek": 158640, "start": 1600.3600000000001, "end": 1605.8000000000002, "text": " And that is, that worked great for us for more than 10 years but it turned out to be", "tokens": [400, 300, 307, 11, 300, 2732, 869, 337, 505, 337, 544, 813, 1266, 924, 457, 309, 3574, 484, 281, 312], "temperature": 0.0, "avg_logprob": -0.12477743098166137, "compression_ratio": 1.6551724137931034, "no_speech_prob": 8.799518582236487e-06}, {"id": 333, "seek": 158640, "start": 1605.8000000000002, "end": 1610.4, "text": " suboptimal for some more advanced use cases like nested virtualization.", "tokens": [1422, 5747, 10650, 337, 512, 544, 7339, 764, 3331, 411, 15646, 292, 6374, 2144, 13], "temperature": 0.0, "avg_logprob": -0.12477743098166137, "compression_ratio": 1.6551724137931034, "no_speech_prob": 8.799518582236487e-06}, {"id": 334, "seek": 158640, "start": 1610.4, "end": 1616.3200000000002, "text": " If you run a hypervisor inside a virtual machine and that hypervisor creates multiple guests", "tokens": [759, 291, 1190, 257, 9848, 16457, 1854, 257, 6374, 3479, 293, 300, 9848, 16457, 7829, 3866, 9804], "temperature": 0.0, "avg_logprob": -0.12477743098166137, "compression_ratio": 1.6551724137931034, "no_speech_prob": 8.799518582236487e-06}, {"id": 335, "seek": 161632, "start": 1616.32, "end": 1619.96, "text": " itself then you suddenly need more than one guest space.", "tokens": [2564, 550, 291, 5800, 643, 544, 813, 472, 8341, 1901, 13], "temperature": 0.0, "avg_logprob": -0.12601253773906443, "compression_ratio": 1.9029126213592233, "no_speech_prob": 1.543780126667116e-05}, {"id": 336, "seek": 161632, "start": 1619.96, "end": 1622.56, "text": " You need one guest space per sub guest.", "tokens": [509, 643, 472, 8341, 1901, 680, 1422, 8341, 13], "temperature": 0.0, "avg_logprob": -0.12601253773906443, "compression_ratio": 1.9029126213592233, "no_speech_prob": 1.543780126667116e-05}, {"id": 337, "seek": 161632, "start": 1622.56, "end": 1629.2, "text": " So you need multiple of these yellow guest spaces or when you virtualize the SMMU and", "tokens": [407, 291, 643, 3866, 295, 613, 5566, 8341, 7673, 420, 562, 291, 6374, 1125, 264, 13115, 44, 52, 293], "temperature": 0.0, "avg_logprob": -0.12601253773906443, "compression_ratio": 1.9029126213592233, "no_speech_prob": 1.543780126667116e-05}, {"id": 338, "seek": 161632, "start": 1629.2, "end": 1634.4399999999998, "text": " the SMMU has multiple contexts and every context has its own page table then you suddenly need", "tokens": [264, 13115, 44, 52, 575, 3866, 30628, 293, 633, 4319, 575, 1080, 1065, 3028, 3199, 550, 291, 5800, 643], "temperature": 0.0, "avg_logprob": -0.12601253773906443, "compression_ratio": 1.9029126213592233, "no_speech_prob": 1.543780126667116e-05}, {"id": 339, "seek": 161632, "start": 1634.4399999999998, "end": 1636.6, "text": " more than one DMA space.", "tokens": [544, 813, 472, 413, 9998, 1901, 13], "temperature": 0.0, "avg_logprob": -0.12601253773906443, "compression_ratio": 1.9029126213592233, "no_speech_prob": 1.543780126667116e-05}, {"id": 340, "seek": 161632, "start": 1636.6, "end": 1641.32, "text": " So you need more of these blue boxes and the same can be said for port IO and MSR spaces.", "tokens": [407, 291, 643, 544, 295, 613, 3344, 9002, 293, 264, 912, 393, 312, 848, 337, 2436, 39839, 293, 7395, 49, 7673, 13], "temperature": 0.0, "avg_logprob": -0.12601253773906443, "compression_ratio": 1.9029126213592233, "no_speech_prob": 1.543780126667116e-05}, {"id": 341, "seek": 164132, "start": 1641.32, "end": 1648.12, "text": " So how do we get more than one if the protection domain has all these single instance?", "tokens": [407, 577, 360, 321, 483, 544, 813, 472, 498, 264, 6334, 9274, 575, 439, 613, 2167, 5197, 30], "temperature": 0.0, "avg_logprob": -0.12584986337801304, "compression_ratio": 1.563063063063063, "no_speech_prob": 2.4656816094648093e-05}, {"id": 342, "seek": 164132, "start": 1648.12, "end": 1655.28, "text": " So what we did and it was quite a major API in internal reshuffling is we separated these", "tokens": [407, 437, 321, 630, 293, 309, 390, 1596, 257, 2563, 9362, 294, 6920, 725, 71, 1245, 1688, 307, 321, 12005, 613], "temperature": 0.0, "avg_logprob": -0.12584986337801304, "compression_ratio": 1.563063063063063, "no_speech_prob": 2.4656816094648093e-05}, {"id": 343, "seek": 164132, "start": 1655.28, "end": 1657.12, "text": " spaces from the protection domain.", "tokens": [7673, 490, 264, 6334, 9274, 13], "temperature": 0.0, "avg_logprob": -0.12584986337801304, "compression_ratio": 1.563063063063063, "no_speech_prob": 2.4656816094648093e-05}, {"id": 344, "seek": 164132, "start": 1657.12, "end": 1658.9199999999998, "text": " They are now new first class objects.", "tokens": [814, 366, 586, 777, 700, 1508, 6565, 13], "temperature": 0.0, "avg_logprob": -0.12584986337801304, "compression_ratio": 1.563063063063063, "no_speech_prob": 2.4656816094648093e-05}, {"id": 345, "seek": 164132, "start": 1658.9199999999998, "end": 1665.84, "text": " So Nova just got six new kernel objects that when you create them you get individual capabilities", "tokens": [407, 27031, 445, 658, 2309, 777, 28256, 6565, 300, 562, 291, 1884, 552, 291, 483, 2609, 10862], "temperature": 0.0, "avg_logprob": -0.12584986337801304, "compression_ratio": 1.563063063063063, "no_speech_prob": 2.4656816094648093e-05}, {"id": 346, "seek": 166584, "start": 1665.84, "end": 1671.72, "text": " for them and you can manage them independently from the protection domain.", "tokens": [337, 552, 293, 291, 393, 3067, 552, 21761, 490, 264, 6334, 9274, 13], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 347, "seek": 166584, "start": 1671.72, "end": 1677.24, "text": " So the way that this works is first you create a protection domain with create PD then you", "tokens": [407, 264, 636, 300, 341, 1985, 307, 700, 291, 1884, 257, 6334, 9274, 365, 1884, 10464, 550, 291], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 348, "seek": 166584, "start": 1677.24, "end": 1681.28, "text": " create one or more of these spaces again with create PD.", "tokens": [1884, 472, 420, 544, 295, 613, 7673, 797, 365, 1884, 10464, 13], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 349, "seek": 166584, "start": 1681.28, "end": 1683.4399999999998, "text": " So that's a sub function of create PD.", "tokens": [407, 300, 311, 257, 1422, 2445, 295, 1884, 10464, 13], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 350, "seek": 166584, "start": 1683.4399999999998, "end": 1687.9599999999998, "text": " And then you create an EC like a host EC and it binds to those spaces that are relevant", "tokens": [400, 550, 291, 1884, 364, 19081, 411, 257, 3975, 19081, 293, 309, 41515, 281, 729, 7673, 300, 366, 7340], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 351, "seek": 166584, "start": 1687.9599999999998, "end": 1688.9599999999998, "text": " for host EC.", "tokens": [337, 3975, 19081, 13], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 352, "seek": 166584, "start": 1688.9599999999998, "end": 1695.28, "text": " So a host EC like a hypostrat needs capabilities so it needs an object space it binds to that", "tokens": [407, 257, 3975, 19081, 411, 257, 7420, 555, 4481, 2203, 10862, 370, 309, 2203, 364, 2657, 1901, 309, 41515, 281, 300], "temperature": 0.0, "avg_logprob": -0.14231833736453436, "compression_ratio": 1.9487179487179487, "no_speech_prob": 7.181872661021771e-06}, {"id": 353, "seek": 169528, "start": 1695.28, "end": 1700.08, "text": " it needs a stage one page table so it binds to that and it needs access to ports so it", "tokens": [309, 2203, 257, 3233, 472, 3028, 3199, 370, 309, 41515, 281, 300, 293, 309, 2203, 2105, 281, 18160, 370, 309], "temperature": 0.0, "avg_logprob": -0.13640662475868506, "compression_ratio": 1.6412213740458015, "no_speech_prob": 1.4282595657277852e-05}, {"id": 354, "seek": 169528, "start": 1700.08, "end": 1704.8, "text": " binds to that on x86 only because on ARM there's no such thing.", "tokens": [41515, 281, 300, 322, 2031, 22193, 787, 570, 322, 45209, 456, 311, 572, 1270, 551, 13], "temperature": 0.0, "avg_logprob": -0.13640662475868506, "compression_ratio": 1.6412213740458015, "no_speech_prob": 1.4282595657277852e-05}, {"id": 355, "seek": 169528, "start": 1704.8, "end": 1709.04, "text": " So for host thread all these assignments are static.", "tokens": [407, 337, 3975, 7207, 439, 613, 22546, 366, 13437, 13], "temperature": 0.0, "avg_logprob": -0.13640662475868506, "compression_ratio": 1.6412213740458015, "no_speech_prob": 1.4282595657277852e-05}, {"id": 356, "seek": 169528, "start": 1709.04, "end": 1712.36, "text": " We could make them flexible but we have not found a need.", "tokens": [492, 727, 652, 552, 11358, 457, 321, 362, 406, 1352, 257, 643, 13], "temperature": 0.0, "avg_logprob": -0.13640662475868506, "compression_ratio": 1.6412213740458015, "no_speech_prob": 1.4282595657277852e-05}, {"id": 357, "seek": 169528, "start": 1712.36, "end": 1718.0, "text": " Gets more interesting for a guest EC which is a virtual CPU that runs in a guest.", "tokens": [460, 1385, 544, 1880, 337, 257, 8341, 19081, 597, 307, 257, 6374, 13199, 300, 6676, 294, 257, 8341, 13], "temperature": 0.0, "avg_logprob": -0.13640662475868506, "compression_ratio": 1.6412213740458015, "no_speech_prob": 1.4282595657277852e-05}, {"id": 358, "seek": 169528, "start": 1718.0, "end": 1721.52, "text": " So again the sequence is the same you first create a protection domain then you create", "tokens": [407, 797, 264, 8310, 307, 264, 912, 291, 700, 1884, 257, 6334, 9274, 550, 291, 1884], "temperature": 0.0, "avg_logprob": -0.13640662475868506, "compression_ratio": 1.6412213740458015, "no_speech_prob": 1.4282595657277852e-05}, {"id": 359, "seek": 172152, "start": 1721.52, "end": 1727.16, "text": " one or more of these spaces and when you create the virtual CPU it binds to those spaces that", "tokens": [472, 420, 544, 295, 613, 7673, 293, 562, 291, 1884, 264, 6374, 13199, 309, 41515, 281, 729, 7673, 300], "temperature": 0.0, "avg_logprob": -0.11220734015755031, "compression_ratio": 1.6933333333333334, "no_speech_prob": 2.2819773221272044e-05}, {"id": 360, "seek": 172152, "start": 1727.16, "end": 1730.44, "text": " it urgently needs which is the object space and the host space.", "tokens": [309, 49390, 2203, 597, 307, 264, 2657, 1901, 293, 264, 3975, 1901, 13], "temperature": 0.0, "avg_logprob": -0.11220734015755031, "compression_ratio": 1.6933333333333334, "no_speech_prob": 2.2819773221272044e-05}, {"id": 361, "seek": 172152, "start": 1730.44, "end": 1735.04, "text": " It does not yet bind to any of the flexible spaces shown to the right.", "tokens": [467, 775, 406, 1939, 14786, 281, 604, 295, 264, 11358, 7673, 4898, 281, 264, 558, 13], "temperature": 0.0, "avg_logprob": -0.11220734015755031, "compression_ratio": 1.6933333333333334, "no_speech_prob": 2.2819773221272044e-05}, {"id": 362, "seek": 172152, "start": 1735.04, "end": 1742.28, "text": " And that binding is established on the startup IPC during IPC reply.", "tokens": [400, 300, 17359, 307, 7545, 322, 264, 18578, 8671, 34, 1830, 8671, 34, 16972, 13], "temperature": 0.0, "avg_logprob": -0.11220734015755031, "compression_ratio": 1.6933333333333334, "no_speech_prob": 2.2819773221272044e-05}, {"id": 363, "seek": 172152, "start": 1742.28, "end": 1747.56, "text": " You pass selectors, capability selectors to these spaces that you want to attach to", "tokens": [509, 1320, 3048, 830, 11, 13759, 3048, 830, 281, 613, 7673, 300, 291, 528, 281, 5085, 281], "temperature": 0.0, "avg_logprob": -0.11220734015755031, "compression_ratio": 1.6933333333333334, "no_speech_prob": 2.2819773221272044e-05}, {"id": 364, "seek": 174756, "start": 1747.56, "end": 1753.32, "text": " and then you flexibly bind to those spaces as denoted by these dashed lines.", "tokens": [293, 550, 291, 5896, 3545, 14786, 281, 729, 7673, 382, 1441, 23325, 538, 613, 8240, 292, 3876, 13], "temperature": 0.0, "avg_logprob": -0.1182481575012207, "compression_ratio": 1.6330645161290323, "no_speech_prob": 2.7082389351562597e-05}, {"id": 365, "seek": 174756, "start": 1753.32, "end": 1756.96, "text": " And that assignment can be changed on every event.", "tokens": [400, 300, 15187, 393, 312, 3105, 322, 633, 2280, 13], "temperature": 0.0, "avg_logprob": -0.1182481575012207, "compression_ratio": 1.6330645161290323, "no_speech_prob": 2.7082389351562597e-05}, {"id": 366, "seek": 174756, "start": 1756.96, "end": 1762.9199999999998, "text": " So every time you take a VM exit Nova synthesizers and exception IPC or architectural IPC sends", "tokens": [407, 633, 565, 291, 747, 257, 18038, 11043, 27031, 26617, 22525, 293, 11183, 8671, 34, 420, 26621, 8671, 34, 14790], "temperature": 0.0, "avg_logprob": -0.1182481575012207, "compression_ratio": 1.6330645161290323, "no_speech_prob": 2.7082389351562597e-05}, {"id": 367, "seek": 174756, "start": 1762.9199999999998, "end": 1769.44, "text": " it to the VMM for handling and when the VMM replies it can set a bit in the message transfer", "tokens": [309, 281, 264, 18038, 44, 337, 13175, 293, 562, 264, 18038, 44, 42289, 309, 393, 992, 257, 857, 294, 264, 3636, 5003], "temperature": 0.0, "avg_logprob": -0.1182481575012207, "compression_ratio": 1.6330645161290323, "no_speech_prob": 2.7082389351562597e-05}, {"id": 368, "seek": 174756, "start": 1769.44, "end": 1774.44, "text": " descriptor to say I want to change the space assignment it passes new selectors and then", "tokens": [31280, 284, 281, 584, 286, 528, 281, 1319, 264, 1901, 15187, 309, 11335, 777, 3048, 830, 293, 550], "temperature": 0.0, "avg_logprob": -0.1182481575012207, "compression_ratio": 1.6330645161290323, "no_speech_prob": 2.7082389351562597e-05}, {"id": 369, "seek": 177444, "start": 1774.44, "end": 1780.3200000000002, "text": " you can flexibly switch between those spaces and that allows us to implement for example", "tokens": [291, 393, 5896, 3545, 3679, 1296, 729, 7673, 293, 300, 4045, 505, 281, 4445, 337, 1365], "temperature": 0.0, "avg_logprob": -0.1664949417114258, "compression_ratio": 1.575, "no_speech_prob": 4.859346063312842e-06}, {"id": 370, "seek": 177444, "start": 1780.3200000000002, "end": 1782.88, "text": " nested virtualization.", "tokens": [15646, 292, 6374, 2144, 13], "temperature": 0.0, "avg_logprob": -0.1664949417114258, "compression_ratio": 1.575, "no_speech_prob": 4.859346063312842e-06}, {"id": 371, "seek": 177444, "start": 1782.88, "end": 1789.44, "text": " The same for a device which in x86 is represented by a bus device function or an arm is represented", "tokens": [440, 912, 337, 257, 4302, 597, 294, 2031, 22193, 307, 10379, 538, 257, 1255, 4302, 2445, 420, 364, 3726, 307, 10379], "temperature": 0.0, "avg_logprob": -0.1664949417114258, "compression_ratio": 1.575, "no_speech_prob": 4.859346063312842e-06}, {"id": 372, "seek": 177444, "start": 1789.44, "end": 1791.56, "text": " by a stream ID.", "tokens": [538, 257, 4309, 7348, 13], "temperature": 0.0, "avg_logprob": -0.1664949417114258, "compression_ratio": 1.575, "no_speech_prob": 4.859346063312842e-06}, {"id": 373, "seek": 177444, "start": 1791.56, "end": 1799.0800000000002, "text": " The assigned depth hypercall can flexibly rebind the device to a DMA space at any time.", "tokens": [440, 13279, 7161, 9848, 45459, 393, 5896, 3545, 12970, 471, 264, 4302, 281, 257, 413, 9998, 1901, 412, 604, 565, 13], "temperature": 0.0, "avg_logprob": -0.1664949417114258, "compression_ratio": 1.575, "no_speech_prob": 4.859346063312842e-06}, {"id": 374, "seek": 179908, "start": 1799.08, "end": 1805.08, "text": " So that took quite a while to implement but it gives us so much more flexibility and I", "tokens": [407, 300, 1890, 1596, 257, 1339, 281, 4445, 457, 309, 2709, 505, 370, 709, 544, 12635, 293, 286], "temperature": 0.0, "avg_logprob": -0.156798025574347, "compression_ratio": 1.7379032258064515, "no_speech_prob": 8.528595571988262e-06}, {"id": 375, "seek": 179908, "start": 1805.08, "end": 1809.96, "text": " heard that some of the Nova forks have come across the same problem so maybe that's something", "tokens": [2198, 300, 512, 295, 264, 27031, 337, 1694, 362, 808, 2108, 264, 912, 1154, 370, 1310, 300, 311, 746], "temperature": 0.0, "avg_logprob": -0.156798025574347, "compression_ratio": 1.7379032258064515, "no_speech_prob": 8.528595571988262e-06}, {"id": 376, "seek": 179908, "start": 1809.96, "end": 1813.28, "text": " that could work for you too.", "tokens": [300, 727, 589, 337, 291, 886, 13], "temperature": 0.0, "avg_logprob": -0.156798025574347, "compression_ratio": 1.7379032258064515, "no_speech_prob": 8.528595571988262e-06}, {"id": 377, "seek": 179908, "start": 1813.28, "end": 1818.1599999999999, "text": " So let's talk about page tables and I mentioned earlier that page tables are actually generic", "tokens": [407, 718, 311, 751, 466, 3028, 8020, 293, 286, 2835, 3071, 300, 3028, 8020, 366, 767, 19577], "temperature": 0.0, "avg_logprob": -0.156798025574347, "compression_ratio": 1.7379032258064515, "no_speech_prob": 8.528595571988262e-06}, {"id": 378, "seek": 179908, "start": 1818.1599999999999, "end": 1821.8799999999999, "text": " code which is somewhat surprising.", "tokens": [3089, 597, 307, 8344, 8830, 13], "temperature": 0.0, "avg_logprob": -0.156798025574347, "compression_ratio": 1.7379032258064515, "no_speech_prob": 8.528595571988262e-06}, {"id": 379, "seek": 179908, "start": 1821.8799999999999, "end": 1826.12, "text": " Nova manages three page tables per architecture, the stage one which is the host page table,", "tokens": [27031, 22489, 1045, 3028, 8020, 680, 9482, 11, 264, 3233, 472, 597, 307, 264, 3975, 3028, 3199, 11], "temperature": 0.0, "avg_logprob": -0.156798025574347, "compression_ratio": 1.7379032258064515, "no_speech_prob": 8.528595571988262e-06}, {"id": 380, "seek": 182612, "start": 1826.12, "end": 1831.3999999999999, "text": " the stage two which is the guest page table and a DMA page table which is used by the", "tokens": [264, 3233, 732, 597, 307, 264, 8341, 3028, 3199, 293, 257, 413, 9998, 3028, 3199, 597, 307, 1143, 538, 264], "temperature": 0.0, "avg_logprob": -0.11701786076581036, "compression_ratio": 1.7272727272727273, "no_speech_prob": 1.0613716767693404e-05}, {"id": 381, "seek": 182612, "start": 1831.3999999999999, "end": 1836.8, "text": " IOMU and these correspond to the three memory spaces that I showed in the previous slide.", "tokens": [286, 5251, 52, 293, 613, 6805, 281, 264, 1045, 4675, 7673, 300, 286, 4712, 294, 264, 3894, 4137, 13], "temperature": 0.0, "avg_logprob": -0.11701786076581036, "compression_ratio": 1.7272727272727273, "no_speech_prob": 1.0613716767693404e-05}, {"id": 382, "seek": 182612, "start": 1836.8, "end": 1842.3999999999999, "text": " And the way we made this page table code architecture independent is by using a template base class", "tokens": [400, 264, 636, 321, 1027, 341, 3028, 3199, 3089, 9482, 6695, 307, 538, 1228, 257, 12379, 3096, 1508], "temperature": 0.0, "avg_logprob": -0.11701786076581036, "compression_ratio": 1.7272727272727273, "no_speech_prob": 1.0613716767693404e-05}, {"id": 383, "seek": 182612, "start": 1842.3999999999999, "end": 1848.4799999999998, "text": " which is completely lockless so it's very scalable and the reason why it can be lockless", "tokens": [597, 307, 2584, 4017, 1832, 370, 309, 311, 588, 38481, 293, 264, 1778, 983, 309, 393, 312, 4017, 1832], "temperature": 0.0, "avg_logprob": -0.11701786076581036, "compression_ratio": 1.7272727272727273, "no_speech_prob": 1.0613716767693404e-05}, {"id": 384, "seek": 182612, "start": 1848.4799999999998, "end": 1852.6399999999999, "text": " is because the MMU doesn't honor any software locks anyway so if you put a lock around your", "tokens": [307, 570, 264, 34191, 52, 1177, 380, 5968, 604, 4722, 20703, 4033, 370, 498, 291, 829, 257, 4017, 926, 428], "temperature": 0.0, "avg_logprob": -0.11701786076581036, "compression_ratio": 1.7272727272727273, "no_speech_prob": 1.0613716767693404e-05}, {"id": 385, "seek": 185264, "start": 1852.64, "end": 1856.48, "text": " page table infrastructure the MMU wouldn't know anything about those locks so it has", "tokens": [3028, 3199, 6896, 264, 34191, 52, 2759, 380, 458, 1340, 466, 729, 20703, 370, 309, 575], "temperature": 0.0, "avg_logprob": -0.09707777840750557, "compression_ratio": 1.641732283464567, "no_speech_prob": 1.0126350389327854e-05}, {"id": 386, "seek": 185264, "start": 1856.48, "end": 1863.0800000000002, "text": " to be written in a way that it does atomic transformations anyway so that the MMU never", "tokens": [281, 312, 3720, 294, 257, 636, 300, 309, 775, 22275, 34852, 4033, 370, 300, 264, 34191, 52, 1128], "temperature": 0.0, "avg_logprob": -0.09707777840750557, "compression_ratio": 1.641732283464567, "no_speech_prob": 1.0126350389327854e-05}, {"id": 387, "seek": 185264, "start": 1863.0800000000002, "end": 1869.16, "text": " sees an inconsistent state and once you have this there's also no need to put the lock", "tokens": [8194, 364, 36891, 1785, 293, 1564, 291, 362, 341, 456, 311, 611, 572, 643, 281, 829, 264, 4017], "temperature": 0.0, "avg_logprob": -0.09707777840750557, "compression_ratio": 1.641732283464567, "no_speech_prob": 1.0126350389327854e-05}, {"id": 388, "seek": 185264, "start": 1869.16, "end": 1873.6000000000001, "text": " around it for any software updates so that's completely lock free.", "tokens": [926, 309, 337, 604, 4722, 9205, 370, 300, 311, 2584, 4017, 1737, 13], "temperature": 0.0, "avg_logprob": -0.09707777840750557, "compression_ratio": 1.641732283464567, "no_speech_prob": 1.0126350389327854e-05}, {"id": 389, "seek": 185264, "start": 1873.6000000000001, "end": 1877.6000000000001, "text": " And that architecture independent base class deals with all the complexities of allocating", "tokens": [400, 300, 9482, 6695, 3096, 1508, 11215, 365, 439, 264, 48705, 295, 12660, 990], "temperature": 0.0, "avg_logprob": -0.09707777840750557, "compression_ratio": 1.641732283464567, "no_speech_prob": 1.0126350389327854e-05}, {"id": 390, "seek": 187760, "start": 1877.6, "end": 1884.12, "text": " and deallocating page tables, splitting superpages into page tables or overmapping page tables", "tokens": [293, 368, 336, 905, 990, 3028, 8020, 11, 30348, 1687, 79, 1660, 666, 3028, 8020, 420, 670, 1696, 3759, 3028, 8020], "temperature": 0.0, "avg_logprob": -0.14041279139143698, "compression_ratio": 1.812785388127854, "no_speech_prob": 3.319395909784362e-05}, {"id": 391, "seek": 187760, "start": 1884.12, "end": 1891.48, "text": " with superpages and you can derive architecture specific subclasses from it and the subclasses", "tokens": [365, 1687, 79, 1660, 293, 291, 393, 28446, 9482, 2685, 1422, 11665, 279, 490, 309, 293, 264, 1422, 11665, 279], "temperature": 0.0, "avg_logprob": -0.14041279139143698, "compression_ratio": 1.812785388127854, "no_speech_prob": 3.319395909784362e-05}, {"id": 392, "seek": 187760, "start": 1891.48, "end": 1896.8, "text": " themselves inject themselves as a parameter to the base class that's called the curiously", "tokens": [2969, 10711, 2969, 382, 257, 13075, 281, 264, 3096, 1508, 300, 311, 1219, 264, 6369, 356], "temperature": 0.0, "avg_logprob": -0.14041279139143698, "compression_ratio": 1.812785388127854, "no_speech_prob": 3.319395909784362e-05}, {"id": 393, "seek": 187760, "start": 1896.8, "end": 1898.8799999999999, "text": " recurring template pattern.", "tokens": [32279, 12379, 5102, 13], "temperature": 0.0, "avg_logprob": -0.14041279139143698, "compression_ratio": 1.812785388127854, "no_speech_prob": 3.319395909784362e-05}, {"id": 394, "seek": 187760, "start": 1898.8799999999999, "end": 1902.9599999999998, "text": " And the subclasses then do the transformation between the high level attributes like this", "tokens": [400, 264, 1422, 11665, 279, 550, 360, 264, 9887, 1296, 264, 1090, 1496, 17212, 411, 341], "temperature": 0.0, "avg_logprob": -0.14041279139143698, "compression_ratio": 1.812785388127854, "no_speech_prob": 3.319395909784362e-05}, {"id": 395, "seek": 190296, "start": 1902.96, "end": 1908.3600000000001, "text": " page is readable, writable, user accessible, whatever into the individual bits and coding", "tokens": [3028, 307, 49857, 11, 10912, 712, 11, 4195, 9515, 11, 2035, 666, 264, 2609, 9239, 293, 17720], "temperature": 0.0, "avg_logprob": -0.09989055161623611, "compression_ratio": 1.7933884297520661, "no_speech_prob": 2.0776848032255657e-05}, {"id": 396, "seek": 190296, "start": 1908.3600000000001, "end": 1914.24, "text": " of the page table entries as that architecture needs it and also there are some coherency", "tokens": [295, 264, 3028, 3199, 23041, 382, 300, 9482, 2203, 309, 293, 611, 456, 366, 512, 26528, 3020], "temperature": 0.0, "avg_logprob": -0.09989055161623611, "compression_ratio": 1.7933884297520661, "no_speech_prob": 2.0776848032255657e-05}, {"id": 397, "seek": 190296, "start": 1914.24, "end": 1920.76, "text": " requirements on ARM and some coherency requirements between SMM use that don't snoop the caches", "tokens": [7728, 322, 45209, 293, 512, 26528, 3020, 7728, 1296, 13115, 44, 764, 300, 500, 380, 43287, 404, 264, 269, 13272], "temperature": 0.0, "avg_logprob": -0.09989055161623611, "compression_ratio": 1.7933884297520661, "no_speech_prob": 2.0776848032255657e-05}, {"id": 398, "seek": 190296, "start": 1920.76, "end": 1925.6000000000001, "text": " so these architecture specific subclasses deal with all that complexity but it allows", "tokens": [370, 613, 9482, 2685, 1422, 11665, 279, 2028, 365, 439, 300, 14024, 457, 309, 4045], "temperature": 0.0, "avg_logprob": -0.09989055161623611, "compression_ratio": 1.7933884297520661, "no_speech_prob": 2.0776848032255657e-05}, {"id": 399, "seek": 190296, "start": 1925.6000000000001, "end": 1932.64, "text": " us to share the page table class and to specify and verify it only once.", "tokens": [505, 281, 2073, 264, 3028, 3199, 1508, 293, 281, 16500, 293, 16888, 309, 787, 1564, 13], "temperature": 0.0, "avg_logprob": -0.09989055161623611, "compression_ratio": 1.7933884297520661, "no_speech_prob": 2.0776848032255657e-05}, {"id": 400, "seek": 193264, "start": 1932.64, "end": 1937.6000000000001, "text": " So let's look at page tables in a little bit more detail because there's some interesting", "tokens": [407, 718, 311, 574, 412, 3028, 8020, 294, 257, 707, 857, 544, 2607, 570, 456, 311, 512, 1880], "temperature": 0.0, "avg_logprob": -0.15650264495009675, "compression_ratio": 1.674074074074074, "no_speech_prob": 3.820959318545647e-05}, {"id": 401, "seek": 193264, "start": 1937.6000000000001, "end": 1939.6000000000001, "text": " stuff you need to do on ARM.", "tokens": [1507, 291, 643, 281, 360, 322, 45209, 13], "temperature": 0.0, "avg_logprob": -0.15650264495009675, "compression_ratio": 1.674074074074074, "no_speech_prob": 3.820959318545647e-05}, {"id": 402, "seek": 193264, "start": 1939.6000000000001, "end": 1944.24, "text": " So most of you who've been in an OS class or who've written a microconnet will have", "tokens": [407, 881, 295, 291, 567, 600, 668, 294, 364, 12731, 1508, 420, 567, 600, 3720, 257, 4532, 1671, 7129, 486, 362], "temperature": 0.0, "avg_logprob": -0.15650264495009675, "compression_ratio": 1.674074074074074, "no_speech_prob": 3.820959318545647e-05}, {"id": 403, "seek": 193264, "start": 1944.24, "end": 1949.0, "text": " come across this page table format where an input address like a host virtual or guest", "tokens": [808, 2108, 341, 3028, 3199, 7877, 689, 364, 4846, 2985, 411, 257, 3975, 6374, 420, 8341], "temperature": 0.0, "avg_logprob": -0.15650264495009675, "compression_ratio": 1.674074074074074, "no_speech_prob": 3.820959318545647e-05}, {"id": 404, "seek": 193264, "start": 1949.0, "end": 1955.4, "text": " physical address is split up into an offset portion into the final page 12 bits and then", "tokens": [4001, 2985, 307, 7472, 493, 666, 364, 18687, 8044, 666, 264, 2572, 3028, 2272, 9239, 293, 550], "temperature": 0.0, "avg_logprob": -0.15650264495009675, "compression_ratio": 1.674074074074074, "no_speech_prob": 3.820959318545647e-05}, {"id": 405, "seek": 193264, "start": 1955.4, "end": 1961.72, "text": " you have nine bits indexing into the individual levels of the page table.", "tokens": [291, 362, 4949, 9239, 8186, 278, 666, 264, 2609, 4358, 295, 264, 3028, 3199, 13], "temperature": 0.0, "avg_logprob": -0.15650264495009675, "compression_ratio": 1.674074074074074, "no_speech_prob": 3.820959318545647e-05}, {"id": 406, "seek": 196172, "start": 1961.72, "end": 1967.64, "text": " So when an address is transformed by the MMU into virtual address into physical address", "tokens": [407, 562, 364, 2985, 307, 16894, 538, 264, 34191, 52, 666, 6374, 2985, 666, 4001, 2985], "temperature": 0.0, "avg_logprob": -0.18056302804213303, "compression_ratio": 1.743801652892562, "no_speech_prob": 2.8828919312218204e-05}, {"id": 407, "seek": 196172, "start": 1967.64, "end": 1973.1200000000001, "text": " the MMU first uses bits 30 to 38 to index into the level two page table to find the", "tokens": [264, 34191, 52, 700, 4960, 9239, 2217, 281, 12843, 281, 8186, 666, 264, 1496, 732, 3028, 3199, 281, 915, 264], "temperature": 0.0, "avg_logprob": -0.18056302804213303, "compression_ratio": 1.743801652892562, "no_speech_prob": 2.8828919312218204e-05}, {"id": 408, "seek": 196172, "start": 1973.1200000000001, "end": 1978.48, "text": " level one and then to find the level zero and the walk can terminate early.", "tokens": [1496, 472, 293, 550, 281, 915, 264, 1496, 4018, 293, 264, 1792, 393, 10761, 473, 2440, 13], "temperature": 0.0, "avg_logprob": -0.18056302804213303, "compression_ratio": 1.743801652892562, "no_speech_prob": 2.8828919312218204e-05}, {"id": 409, "seek": 196172, "start": 1978.48, "end": 1982.3600000000001, "text": " You can have a leaf page at any level so it gives you one gigabyte, two megabyte or", "tokens": [509, 393, 362, 257, 10871, 3028, 412, 604, 1496, 370, 309, 2709, 291, 472, 8741, 34529, 11, 732, 10816, 34529, 420], "temperature": 0.0, "avg_logprob": -0.18056302804213303, "compression_ratio": 1.743801652892562, "no_speech_prob": 2.8828919312218204e-05}, {"id": 410, "seek": 196172, "start": 1982.3600000000001, "end": 1989.16, "text": " four k superpages and with that page table structure like this three levels you can create", "tokens": [1451, 350, 1687, 79, 1660, 293, 365, 300, 3028, 3199, 3877, 411, 341, 1045, 4358, 291, 393, 1884], "temperature": 0.0, "avg_logprob": -0.18056302804213303, "compression_ratio": 1.743801652892562, "no_speech_prob": 2.8828919312218204e-05}, {"id": 411, "seek": 198916, "start": 1989.16, "end": 1995.3600000000001, "text": " an address space of 512 gigabytes of size and that should be good enough but it turns", "tokens": [364, 2985, 1901, 295, 1025, 4762, 42741, 295, 2744, 293, 300, 820, 312, 665, 1547, 457, 309, 4523], "temperature": 0.0, "avg_logprob": -0.14667938456815832, "compression_ratio": 1.5813953488372092, "no_speech_prob": 9.970990504371002e-06}, {"id": 412, "seek": 198916, "start": 1995.3600000000001, "end": 2001.64, "text": " out we came across several ARM platforms which have an address space size of one terabyte.", "tokens": [484, 321, 1361, 2108, 2940, 45209, 9473, 597, 362, 364, 2985, 1901, 2744, 295, 472, 1796, 34529, 13], "temperature": 0.0, "avg_logprob": -0.14667938456815832, "compression_ratio": 1.5813953488372092, "no_speech_prob": 9.970990504371002e-06}, {"id": 413, "seek": 198916, "start": 2001.64, "end": 2008.96, "text": " So twice that they need one extra bit which you can't represent with 39 bits so you have", "tokens": [407, 6091, 300, 436, 643, 472, 2857, 857, 597, 291, 393, 380, 2906, 365, 15238, 9239, 370, 291, 362], "temperature": 0.0, "avg_logprob": -0.14667938456815832, "compression_ratio": 1.5813953488372092, "no_speech_prob": 9.970990504371002e-06}, {"id": 414, "seek": 198916, "start": 2008.96, "end": 2010.92, "text": " a 40 bit address space.", "tokens": [257, 3356, 857, 2985, 1901, 13], "temperature": 0.0, "avg_logprob": -0.14667938456815832, "compression_ratio": 1.5813953488372092, "no_speech_prob": 9.970990504371002e-06}, {"id": 415, "seek": 198916, "start": 2010.92, "end": 2014.48, "text": " So what would you do if you were designing a chip?", "tokens": [407, 437, 576, 291, 360, 498, 291, 645, 14685, 257, 11409, 30], "temperature": 0.0, "avg_logprob": -0.14667938456815832, "compression_ratio": 1.5813953488372092, "no_speech_prob": 9.970990504371002e-06}, {"id": 416, "seek": 201448, "start": 2014.48, "end": 2020.64, "text": " You would expect that it would just open a new level here and that you get a four level", "tokens": [509, 576, 2066, 300, 309, 576, 445, 1269, 257, 777, 1496, 510, 293, 300, 291, 483, 257, 1451, 1496], "temperature": 0.0, "avg_logprob": -0.11018264518593843, "compression_ratio": 1.7857142857142858, "no_speech_prob": 1.568307379784528e-05}, {"id": 417, "seek": 201448, "start": 2020.64, "end": 2026.52, "text": " page table but ARM decided differently because they said if I just add one bit the level", "tokens": [3028, 3199, 457, 45209, 3047, 7614, 570, 436, 848, 498, 286, 445, 909, 472, 857, 264, 1496], "temperature": 0.0, "avg_logprob": -0.11018264518593843, "compression_ratio": 1.7857142857142858, "no_speech_prob": 1.568307379784528e-05}, {"id": 418, "seek": 201448, "start": 2026.52, "end": 2031.92, "text": " three page table would have just two entries and that's not worse building basically another", "tokens": [1045, 3028, 3199, 576, 362, 445, 732, 23041, 293, 300, 311, 406, 5324, 2390, 1936, 1071], "temperature": 0.0, "avg_logprob": -0.11018264518593843, "compression_ratio": 1.7857142857142858, "no_speech_prob": 1.568307379784528e-05}, {"id": 419, "seek": 201448, "start": 2031.92, "end": 2034.32, "text": " level into it.", "tokens": [1496, 666, 309, 13], "temperature": 0.0, "avg_logprob": -0.11018264518593843, "compression_ratio": 1.7857142857142858, "no_speech_prob": 1.568307379784528e-05}, {"id": 420, "seek": 201448, "start": 2034.32, "end": 2039.76, "text": " So what they did is they came up with a concept called concatenated page table and it makes", "tokens": [407, 437, 436, 630, 307, 436, 1361, 493, 365, 257, 3410, 1219, 1588, 7186, 770, 3028, 3199, 293, 309, 1669], "temperature": 0.0, "avg_logprob": -0.11018264518593843, "compression_ratio": 1.7857142857142858, "no_speech_prob": 1.568307379784528e-05}, {"id": 421, "seek": 201448, "start": 2039.76, "end": 2044.32, "text": " the level two page table twice as large by adding another bit at the top.", "tokens": [264, 1496, 732, 3028, 3199, 6091, 382, 2416, 538, 5127, 1071, 857, 412, 264, 1192, 13], "temperature": 0.0, "avg_logprob": -0.11018264518593843, "compression_ratio": 1.7857142857142858, "no_speech_prob": 1.568307379784528e-05}, {"id": 422, "seek": 204432, "start": 2044.32, "end": 2049.2799999999997, "text": " So now suddenly the level two page table has 10 bits of indexing and the backing page", "tokens": [407, 586, 5800, 264, 1496, 732, 3028, 3199, 575, 1266, 9239, 295, 8186, 278, 293, 264, 19373, 3028], "temperature": 0.0, "avg_logprob": -0.11118163857408749, "compression_ratio": 1.7211538461538463, "no_speech_prob": 9.367397979076486e-06}, {"id": 423, "seek": 204432, "start": 2049.2799999999997, "end": 2053.44, "text": " table has 1024 entries and is 8k in size.", "tokens": [3199, 575, 1266, 7911, 23041, 293, 307, 1649, 74, 294, 2744, 13], "temperature": 0.0, "avg_logprob": -0.11118163857408749, "compression_ratio": 1.7211538461538463, "no_speech_prob": 9.367397979076486e-06}, {"id": 424, "seek": 204432, "start": 2053.44, "end": 2058.04, "text": " And this concept was extended so if you go to 41 address space again you get one additional", "tokens": [400, 341, 3410, 390, 10913, 370, 498, 291, 352, 281, 18173, 2985, 1901, 797, 291, 483, 472, 4497], "temperature": 0.0, "avg_logprob": -0.11118163857408749, "compression_ratio": 1.7211538461538463, "no_speech_prob": 9.367397979076486e-06}, {"id": 425, "seek": 204432, "start": 2058.04, "end": 2061.84, "text": " bit and the page table gets larger and this keeps going on.", "tokens": [857, 293, 264, 3028, 3199, 2170, 4833, 293, 341, 5965, 516, 322, 13], "temperature": 0.0, "avg_logprob": -0.11118163857408749, "compression_ratio": 1.7211538461538463, "no_speech_prob": 9.367397979076486e-06}, {"id": 426, "seek": 204432, "start": 2061.84, "end": 2068.4, "text": " It can extend to up to four bits that the level two page table is 64k in size.", "tokens": [467, 393, 10101, 281, 493, 281, 1451, 9239, 300, 264, 1496, 732, 3028, 3199, 307, 12145, 74, 294, 2744, 13], "temperature": 0.0, "avg_logprob": -0.11118163857408749, "compression_ratio": 1.7211538461538463, "no_speech_prob": 9.367397979076486e-06}, {"id": 427, "seek": 206840, "start": 2068.4, "end": 2076.08, "text": " And there's no way around it, the only time at which you can actually open the level three", "tokens": [400, 456, 311, 572, 636, 926, 309, 11, 264, 787, 565, 412, 597, 291, 393, 767, 1269, 264, 1496, 1045], "temperature": 0.0, "avg_logprob": -0.1061011273810204, "compression_ratio": 1.5862068965517242, "no_speech_prob": 5.25452196598053e-06}, {"id": 428, "seek": 206840, "start": 2076.08, "end": 2078.44, "text": " is when you exceed 44 bits.", "tokens": [307, 562, 291, 14048, 16408, 9239, 13], "temperature": 0.0, "avg_logprob": -0.1061011273810204, "compression_ratio": 1.5862068965517242, "no_speech_prob": 5.25452196598053e-06}, {"id": 429, "seek": 206840, "start": 2078.44, "end": 2084.56, "text": " And then when you get 44 bits you can go to a four level and it looks like this.", "tokens": [400, 550, 562, 291, 483, 16408, 9239, 291, 393, 352, 281, 257, 1451, 1496, 293, 309, 1542, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.1061011273810204, "compression_ratio": 1.5862068965517242, "no_speech_prob": 5.25452196598053e-06}, {"id": 430, "seek": 206840, "start": 2084.56, "end": 2090.2400000000002, "text": " So the functionality that we also had to add to NOVA is to comprehend this concatenated", "tokens": [407, 264, 14980, 300, 321, 611, 632, 281, 909, 281, 9146, 20914, 307, 281, 38183, 341, 1588, 7186, 770], "temperature": 0.0, "avg_logprob": -0.1061011273810204, "compression_ratio": 1.5862068965517242, "no_speech_prob": 5.25452196598053e-06}, {"id": 431, "seek": 206840, "start": 2090.2400000000002, "end": 2096.4, "text": " page table format so that we can deal with arbitrary address space sizes on ARM.", "tokens": [3028, 3199, 7877, 370, 300, 321, 393, 2028, 365, 23211, 2985, 1901, 11602, 322, 45209, 13], "temperature": 0.0, "avg_logprob": -0.1061011273810204, "compression_ratio": 1.5862068965517242, "no_speech_prob": 5.25452196598053e-06}, {"id": 432, "seek": 209640, "start": 2096.4, "end": 2101.2000000000003, "text": " And we actually had a device, I think it was a Xilin CCO one or two which had something", "tokens": [400, 321, 767, 632, 257, 4302, 11, 286, 519, 309, 390, 257, 1783, 388, 259, 383, 12322, 472, 420, 732, 597, 632, 746], "temperature": 0.0, "avg_logprob": -0.1692246259269068, "compression_ratio": 1.5787671232876712, "no_speech_prob": 1.0448410648677964e-05}, {"id": 433, "seek": 209640, "start": 2101.2000000000003, "end": 2107.52, "text": " mapped above 512 gigabytes and just below one terabyte and you can't pass that through", "tokens": [33318, 3673, 1025, 4762, 42741, 293, 445, 2507, 472, 1796, 34529, 293, 291, 393, 380, 1320, 300, 807], "temperature": 0.0, "avg_logprob": -0.1692246259269068, "compression_ratio": 1.5787671232876712, "no_speech_prob": 1.0448410648677964e-05}, {"id": 434, "seek": 209640, "start": 2107.52, "end": 2111.04, "text": " to a guest if you don't have concatenated page sheets.", "tokens": [281, 257, 8341, 498, 291, 500, 380, 362, 1588, 7186, 770, 3028, 15421, 13], "temperature": 0.0, "avg_logprob": -0.1692246259269068, "compression_ratio": 1.5787671232876712, "no_speech_prob": 1.0448410648677964e-05}, {"id": 435, "seek": 209640, "start": 2111.04, "end": 2116.52, "text": " So the generic page table cluster we have right now is so flexible that it can basically", "tokens": [407, 264, 19577, 3028, 3199, 13630, 321, 362, 558, 586, 307, 370, 11358, 300, 309, 393, 1936], "temperature": 0.0, "avg_logprob": -0.1692246259269068, "compression_ratio": 1.5787671232876712, "no_speech_prob": 1.0448410648677964e-05}, {"id": 436, "seek": 209640, "start": 2116.52, "end": 2121.12, "text": " do what's shown on this slide and the simple case is x86.", "tokens": [360, 437, 311, 4898, 322, 341, 4137, 293, 264, 2199, 1389, 307, 2031, 22193, 13], "temperature": 0.0, "avg_logprob": -0.1692246259269068, "compression_ratio": 1.5787671232876712, "no_speech_prob": 1.0448410648677964e-05}, {"id": 437, "seek": 209640, "start": 2121.12, "end": 2125.12, "text": " You have three level, four level, or five level page tables with a uniform structure", "tokens": [509, 362, 1045, 1496, 11, 1451, 1496, 11, 420, 1732, 1496, 3028, 8020, 365, 257, 9452, 3877], "temperature": 0.0, "avg_logprob": -0.1692246259269068, "compression_ratio": 1.5787671232876712, "no_speech_prob": 1.0448410648677964e-05}, {"id": 438, "seek": 212512, "start": 2125.12, "end": 2128.3199999999997, "text": " of nine bits per level and 12 offset bits.", "tokens": [295, 4949, 9239, 680, 1496, 293, 2272, 18687, 9239, 13], "temperature": 0.0, "avg_logprob": -0.15455274324159365, "compression_ratio": 1.411764705882353, "no_speech_prob": 2.3912967662909068e-05}, {"id": 439, "seek": 212512, "start": 2128.3199999999997, "end": 2133.8399999999997, "text": " 39 isn't used by the MMU but might be used by the SMMU and the MMU typically uses four", "tokens": [15238, 1943, 380, 1143, 538, 264, 34191, 52, 457, 1062, 312, 1143, 538, 264, 13115, 44, 52, 293, 264, 34191, 52, 5850, 4960, 1451], "temperature": 0.0, "avg_logprob": -0.15455274324159365, "compression_ratio": 1.411764705882353, "no_speech_prob": 2.3912967662909068e-05}, {"id": 440, "seek": 212512, "start": 2133.8399999999997, "end": 2139.88, "text": " levels and in high end boxes like servers for 57.", "tokens": [4358, 293, 294, 1090, 917, 9002, 411, 15909, 337, 21423, 13], "temperature": 0.0, "avg_logprob": -0.15455274324159365, "compression_ratio": 1.411764705882353, "no_speech_prob": 2.3912967662909068e-05}, {"id": 441, "seek": 212512, "start": 2139.88, "end": 2148.3599999999997, "text": " On ARM, depending on what type of SOC you have it either has something between 32 or", "tokens": [1282, 45209, 11, 5413, 322, 437, 2010, 295, 10621, 34, 291, 362, 309, 2139, 575, 746, 1296, 8858, 420], "temperature": 0.0, "avg_logprob": -0.15455274324159365, "compression_ratio": 1.411764705882353, "no_speech_prob": 2.3912967662909068e-05}, {"id": 442, "seek": 214836, "start": 2148.36, "end": 2156.56, "text": " up to 52 physical address bits and the table shows the page table level split, indexing", "tokens": [493, 281, 18079, 4001, 2985, 9239, 293, 264, 3199, 3110, 264, 3028, 3199, 1496, 7472, 11, 8186, 278], "temperature": 0.0, "avg_logprob": -0.11196784973144532, "compression_ratio": 1.7142857142857142, "no_speech_prob": 5.954234438831918e-06}, {"id": 443, "seek": 214836, "start": 2156.56, "end": 2162.8, "text": " split that NOVA has to do and all these colored boxes are basically instances of concatenated", "tokens": [7472, 300, 9146, 20914, 575, 281, 360, 293, 439, 613, 14332, 9002, 366, 1936, 14519, 295, 1588, 7186, 770], "temperature": 0.0, "avg_logprob": -0.11196784973144532, "compression_ratio": 1.7142857142857142, "no_speech_prob": 5.954234438831918e-06}, {"id": 444, "seek": 214836, "start": 2162.8, "end": 2164.04, "text": " page tables.", "tokens": [3028, 8020, 13], "temperature": 0.0, "avg_logprob": -0.11196784973144532, "compression_ratio": 1.7142857142857142, "no_speech_prob": 5.954234438831918e-06}, {"id": 445, "seek": 214836, "start": 2164.04, "end": 2169.8, "text": " So 42 would require three bits to be concatenated, here we have four, here we have one, here", "tokens": [407, 14034, 576, 3651, 1045, 9239, 281, 312, 1588, 7186, 770, 11, 510, 321, 362, 1451, 11, 510, 321, 362, 472, 11, 510], "temperature": 0.0, "avg_logprob": -0.11196784973144532, "compression_ratio": 1.7142857142857142, "no_speech_prob": 5.954234438831918e-06}, {"id": 446, "seek": 214836, "start": 2169.8, "end": 2174.8, "text": " we have two, so we really have to exercise all of those and we support all of those.", "tokens": [321, 362, 732, 11, 370, 321, 534, 362, 281, 5380, 439, 295, 729, 293, 321, 1406, 439, 295, 729, 13], "temperature": 0.0, "avg_logprob": -0.11196784973144532, "compression_ratio": 1.7142857142857142, "no_speech_prob": 5.954234438831918e-06}, {"id": 447, "seek": 217480, "start": 2174.8, "end": 2182.36, "text": " And unlike the past where NOVA said page tables is so many levels per so many bits, we now", "tokens": [400, 8343, 264, 1791, 689, 9146, 20914, 848, 3028, 8020, 307, 370, 867, 4358, 680, 370, 867, 9239, 11, 321, 586], "temperature": 0.0, "avg_logprob": -0.10580441826268246, "compression_ratio": 1.634020618556701, "no_speech_prob": 9.815698831516784e-06}, {"id": 448, "seek": 217480, "start": 2182.36, "end": 2188.28, "text": " have turned this around by saying the page table covers so many bits and we can compute", "tokens": [362, 3574, 341, 926, 538, 1566, 264, 3028, 3199, 10538, 370, 867, 9239, 293, 321, 393, 14722], "temperature": 0.0, "avg_logprob": -0.10580441826268246, "compression_ratio": 1.634020618556701, "no_speech_prob": 9.815698831516784e-06}, {"id": 449, "seek": 217480, "start": 2188.28, "end": 2194.92, "text": " the number of bits per level and the concatenation at the top level automatically in the code.", "tokens": [264, 1230, 295, 9239, 680, 1496, 293, 264, 1588, 7186, 399, 412, 264, 1192, 1496, 6772, 294, 264, 3089, 13], "temperature": 0.0, "avg_logprob": -0.10580441826268246, "compression_ratio": 1.634020618556701, "no_speech_prob": 9.815698831516784e-06}, {"id": 450, "seek": 217480, "start": 2194.92, "end": 2199.1200000000003, "text": " So that was another fairly invasive change.", "tokens": [407, 300, 390, 1071, 6457, 30894, 1319, 13], "temperature": 0.0, "avg_logprob": -0.10580441826268246, "compression_ratio": 1.634020618556701, "no_speech_prob": 9.815698831516784e-06}, {"id": 451, "seek": 219912, "start": 2199.12, "end": 2205.8399999999997, "text": " While we were at re-architecting all the page tables, we took advantage of a new feature", "tokens": [3987, 321, 645, 412, 319, 12, 1178, 5739, 278, 439, 264, 3028, 8020, 11, 321, 1890, 5002, 295, 257, 777, 4111], "temperature": 0.0, "avg_logprob": -0.19083132346471152, "compression_ratio": 1.6270491803278688, "no_speech_prob": 1.4734801879967563e-05}, {"id": 452, "seek": 219912, "start": 2205.8399999999997, "end": 2211.88, "text": " that Intel added to Islake servers and to all the Lake desktop platforms which is called", "tokens": [300, 19762, 3869, 281, 1119, 75, 619, 15909, 293, 281, 439, 264, 10582, 14502, 9473, 597, 307, 1219], "temperature": 0.0, "avg_logprob": -0.19083132346471152, "compression_ratio": 1.6270491803278688, "no_speech_prob": 1.4734801879967563e-05}, {"id": 453, "seek": 219912, "start": 2211.88, "end": 2215.4, "text": " total memory encryption with multiple keys.", "tokens": [3217, 4675, 29575, 365, 3866, 9317, 13], "temperature": 0.0, "avg_logprob": -0.19083132346471152, "compression_ratio": 1.6270491803278688, "no_speech_prob": 1.4734801879967563e-05}, {"id": 454, "seek": 219912, "start": 2215.4, "end": 2219.48, "text": " And what Intel did there is they repurposed certain bits of the physical address in the", "tokens": [400, 437, 19762, 630, 456, 307, 436, 1085, 20130, 1744, 1629, 9239, 295, 264, 4001, 2985, 294, 264], "temperature": 0.0, "avg_logprob": -0.19083132346471152, "compression_ratio": 1.6270491803278688, "no_speech_prob": 1.4734801879967563e-05}, {"id": 455, "seek": 219912, "start": 2219.48, "end": 2227.12, "text": " page table entry, the top bits shown here as key ID bits and so it's stealing some bits", "tokens": [3028, 3199, 8729, 11, 264, 1192, 9239, 4898, 510, 382, 2141, 7348, 9239, 293, 370, 309, 311, 19757, 512, 9239], "temperature": 0.0, "avg_logprob": -0.19083132346471152, "compression_ratio": 1.6270491803278688, "no_speech_prob": 1.4734801879967563e-05}, {"id": 456, "seek": 222712, "start": 2227.12, "end": 2235.7599999999998, "text": " from the physical address and the key ID bits index into a key programming table shown here", "tokens": [490, 264, 4001, 2985, 293, 264, 2141, 7348, 9239, 8186, 666, 257, 2141, 9410, 3199, 4898, 510], "temperature": 0.0, "avg_logprob": -0.1638663814913842, "compression_ratio": 1.6991525423728813, "no_speech_prob": 9.222414519172162e-06}, {"id": 457, "seek": 222712, "start": 2235.7599999999998, "end": 2242.72, "text": " that basically select a slot and let's say you have four key bits that gives you 16 keys,", "tokens": [300, 1936, 3048, 257, 14747, 293, 718, 311, 584, 291, 362, 1451, 2141, 9239, 300, 2709, 291, 3165, 9317, 11], "temperature": 0.0, "avg_logprob": -0.1638663814913842, "compression_ratio": 1.6991525423728813, "no_speech_prob": 9.222414519172162e-06}, {"id": 458, "seek": 222712, "start": 2242.72, "end": 2247.16, "text": " two to the power of four, so your key indexing or your key programming table would have the", "tokens": [732, 281, 264, 1347, 295, 1451, 11, 370, 428, 2141, 8186, 278, 420, 428, 2141, 9410, 3199, 576, 362, 264], "temperature": 0.0, "avg_logprob": -0.1638663814913842, "compression_ratio": 1.6991525423728813, "no_speech_prob": 9.222414519172162e-06}, {"id": 459, "seek": 222712, "start": 2247.16, "end": 2249.88, "text": " opportunity to program 16 different keys.", "tokens": [2650, 281, 1461, 3165, 819, 9317, 13], "temperature": 0.0, "avg_logprob": -0.1638663814913842, "compression_ratio": 1.6991525423728813, "no_speech_prob": 9.222414519172162e-06}, {"id": 460, "seek": 222712, "start": 2249.88, "end": 2256.0, "text": " We've also come across platforms that have six bits, it's basically flexible how many", "tokens": [492, 600, 611, 808, 2108, 9473, 300, 362, 2309, 9239, 11, 309, 311, 1936, 11358, 577, 867], "temperature": 0.0, "avg_logprob": -0.1638663814913842, "compression_ratio": 1.6991525423728813, "no_speech_prob": 9.222414519172162e-06}, {"id": 461, "seek": 225600, "start": 2256.0, "end": 2261.72, "text": " bits are stolen from the physical address can vary per platform depending on how many", "tokens": [9239, 366, 15900, 490, 264, 4001, 2985, 393, 10559, 680, 3663, 5413, 322, 577, 867], "temperature": 0.0, "avg_logprob": -0.10878683271862212, "compression_ratio": 1.7309417040358743, "no_speech_prob": 4.092437393410364e-06}, {"id": 462, "seek": 225600, "start": 2261.72, "end": 2266.44, "text": " keys are supported and those keys are used by a component called the memory encryption", "tokens": [9317, 366, 8104, 293, 729, 9317, 366, 1143, 538, 257, 6542, 1219, 264, 4675, 29575], "temperature": 0.0, "avg_logprob": -0.10878683271862212, "compression_ratio": 1.7309417040358743, "no_speech_prob": 4.092437393410364e-06}, {"id": 463, "seek": 225600, "start": 2266.44, "end": 2267.44, "text": " engine.", "tokens": [2848, 13], "temperature": 0.0, "avg_logprob": -0.10878683271862212, "compression_ratio": 1.7309417040358743, "no_speech_prob": 4.092437393410364e-06}, {"id": 464, "seek": 225600, "start": 2267.44, "end": 2275.48, "text": " The memory encryption engine sits at the perimeter of the package or the socket, basically at", "tokens": [440, 4675, 29575, 2848, 12696, 412, 264, 32404, 295, 264, 7372, 420, 264, 19741, 11, 1936, 412], "temperature": 0.0, "avg_logprob": -0.10878683271862212, "compression_ratio": 1.7309417040358743, "no_speech_prob": 4.092437393410364e-06}, {"id": 465, "seek": 225600, "start": 2275.48, "end": 2281.8, "text": " the boundary where data leaves the chip that you plug in the socket and enters the interconnect", "tokens": [264, 12866, 689, 1412, 5510, 264, 11409, 300, 291, 5452, 294, 264, 19741, 293, 18780, 264, 26253], "temperature": 0.0, "avg_logprob": -0.10878683271862212, "compression_ratio": 1.7309417040358743, "no_speech_prob": 4.092437393410364e-06}, {"id": 466, "seek": 225600, "start": 2281.8, "end": 2283.28, "text": " and enters RAM.", "tokens": [293, 18780, 14561, 13], "temperature": 0.0, "avg_logprob": -0.10878683271862212, "compression_ratio": 1.7309417040358743, "no_speech_prob": 4.092437393410364e-06}, {"id": 467, "seek": 228328, "start": 2283.28, "end": 2289.2000000000003, "text": " So inside this green area which is inside the SOC, everything is unencrypted in the", "tokens": [407, 1854, 341, 3092, 1859, 597, 307, 1854, 264, 10621, 34, 11, 1203, 307, 517, 22660, 627, 25383, 294, 264], "temperature": 0.0, "avg_logprob": -0.13883188792637416, "compression_ratio": 1.7462686567164178, "no_speech_prob": 4.356341378297657e-06}, {"id": 468, "seek": 228328, "start": 2289.2000000000003, "end": 2294.1600000000003, "text": " cores, in the caches, in the internal data structure, but as it leaves the die and moves", "tokens": [24826, 11, 294, 264, 269, 13272, 11, 294, 264, 6920, 1412, 3877, 11, 457, 382, 309, 5510, 264, 978, 293, 6067], "temperature": 0.0, "avg_logprob": -0.13883188792637416, "compression_ratio": 1.7462686567164178, "no_speech_prob": 4.356341378297657e-06}, {"id": 469, "seek": 228328, "start": 2294.1600000000003, "end": 2298.96, "text": " out to the interconnect, it gets encrypted automatically by the memory encryption engine", "tokens": [484, 281, 264, 26253, 11, 309, 2170, 36663, 6772, 538, 264, 4675, 29575, 2848], "temperature": 0.0, "avg_logprob": -0.13883188792637416, "compression_ratio": 1.7462686567164178, "no_speech_prob": 4.356341378297657e-06}, {"id": 470, "seek": 228328, "start": 2298.96, "end": 2305.0, "text": " with the key and this example shows a separate key being used for each virtual machine which", "tokens": [365, 264, 2141, 293, 341, 1365, 3110, 257, 4994, 2141, 885, 1143, 337, 1184, 6374, 3479, 597], "temperature": 0.0, "avg_logprob": -0.13883188792637416, "compression_ratio": 1.7462686567164178, "no_speech_prob": 4.356341378297657e-06}, {"id": 471, "seek": 228328, "start": 2305.0, "end": 2309.4, "text": " is a typical use case but it's actually very more flexible than that, you can select the", "tokens": [307, 257, 7476, 764, 1389, 457, 309, 311, 767, 588, 544, 11358, 813, 300, 11, 291, 393, 3048, 264], "temperature": 0.0, "avg_logprob": -0.13883188792637416, "compression_ratio": 1.7462686567164178, "no_speech_prob": 4.356341378297657e-06}, {"id": 472, "seek": 228328, "start": 2309.4, "end": 2311.7200000000003, "text": " key on a per page basis.", "tokens": [2141, 322, 257, 680, 3028, 5143, 13], "temperature": 0.0, "avg_logprob": -0.13883188792637416, "compression_ratio": 1.7462686567164178, "no_speech_prob": 4.356341378297657e-06}, {"id": 473, "seek": 231172, "start": 2311.72, "end": 2316.9199999999996, "text": " So you could even say if there was a need for these two VMs to share some memory that", "tokens": [407, 291, 727, 754, 584, 498, 456, 390, 257, 643, 337, 613, 732, 18038, 82, 281, 2073, 512, 4675, 300], "temperature": 0.0, "avg_logprob": -0.12786623147817758, "compression_ratio": 1.7470817120622568, "no_speech_prob": 8.137278200592846e-06}, {"id": 474, "seek": 231172, "start": 2316.9199999999996, "end": 2323.04, "text": " some blue pages would appear here and some yellow pages would appear here, that's possible.", "tokens": [512, 3344, 7183, 576, 4204, 510, 293, 512, 5566, 7183, 576, 4204, 510, 11, 300, 311, 1944, 13], "temperature": 0.0, "avg_logprob": -0.12786623147817758, "compression_ratio": 1.7470817120622568, "no_speech_prob": 8.137278200592846e-06}, {"id": 475, "seek": 231172, "start": 2323.04, "end": 2328.72, "text": " So we added support in the page tables for encoding these key ID bits, we added support", "tokens": [407, 321, 3869, 1406, 294, 264, 3028, 8020, 337, 43430, 613, 2141, 7348, 9239, 11, 321, 3869, 1406], "temperature": 0.0, "avg_logprob": -0.12786623147817758, "compression_ratio": 1.7470817120622568, "no_speech_prob": 8.137278200592846e-06}, {"id": 476, "seek": 231172, "start": 2328.72, "end": 2335.7999999999997, "text": " for using the P-config instruction for programming keys into the memory encryption engine and", "tokens": [337, 1228, 264, 430, 12, 1671, 20646, 10951, 337, 9410, 9317, 666, 264, 4675, 29575, 2848, 293], "temperature": 0.0, "avg_logprob": -0.12786623147817758, "compression_ratio": 1.7470817120622568, "no_speech_prob": 8.137278200592846e-06}, {"id": 477, "seek": 231172, "start": 2335.7999999999997, "end": 2340.16, "text": " the keys can come in two forms, you can either randomly generate them, in which case Nova", "tokens": [264, 9317, 393, 808, 294, 732, 6422, 11, 291, 393, 2139, 16979, 8460, 552, 11, 294, 597, 1389, 27031], "temperature": 0.0, "avg_logprob": -0.12786623147817758, "compression_ratio": 1.7470817120622568, "no_speech_prob": 8.137278200592846e-06}, {"id": 478, "seek": 234016, "start": 2340.16, "end": 2345.48, "text": " will also drive the digital random number generator to generate entropy or you can program", "tokens": [486, 611, 3332, 264, 4562, 4974, 1230, 19265, 281, 8460, 30867, 420, 291, 393, 1461], "temperature": 0.0, "avg_logprob": -0.1168175922350937, "compression_ratio": 1.6291666666666667, "no_speech_prob": 8.266039912996348e-06}, {"id": 479, "seek": 234016, "start": 2345.48, "end": 2346.64, "text": " tenant keys.", "tokens": [31000, 9317, 13], "temperature": 0.0, "avg_logprob": -0.1168175922350937, "compression_ratio": 1.6291666666666667, "no_speech_prob": 8.266039912996348e-06}, {"id": 480, "seek": 234016, "start": 2346.64, "end": 2351.6, "text": " So you can say I want to use this particular AS key for encrypting the memory and that's", "tokens": [407, 291, 393, 584, 286, 528, 281, 764, 341, 1729, 7469, 2141, 337, 17972, 662, 278, 264, 4675, 293, 300, 311], "temperature": 0.0, "avg_logprob": -0.1168175922350937, "compression_ratio": 1.6291666666666667, "no_speech_prob": 8.266039912996348e-06}, {"id": 481, "seek": 234016, "start": 2351.6, "end": 2357.0, "text": " useful for things like VM migration where you want to take an encrypted VM and move", "tokens": [4420, 337, 721, 411, 18038, 17011, 689, 291, 528, 281, 747, 364, 36663, 18038, 293, 1286], "temperature": 0.0, "avg_logprob": -0.1168175922350937, "compression_ratio": 1.6291666666666667, "no_speech_prob": 8.266039912996348e-06}, {"id": 482, "seek": 234016, "start": 2357.0, "end": 2360.64, "text": " it from one machine to another.", "tokens": [309, 490, 472, 3479, 281, 1071, 13], "temperature": 0.0, "avg_logprob": -0.1168175922350937, "compression_ratio": 1.6291666666666667, "no_speech_prob": 8.266039912996348e-06}, {"id": 483, "seek": 234016, "start": 2360.64, "end": 2365.16, "text": " And the reason why Intel introduced this feature is for confidential computing but", "tokens": [400, 264, 1778, 983, 19762, 7268, 341, 4111, 307, 337, 27054, 15866, 457], "temperature": 0.0, "avg_logprob": -0.1168175922350937, "compression_ratio": 1.6291666666666667, "no_speech_prob": 8.266039912996348e-06}, {"id": 484, "seek": 236516, "start": 2365.16, "end": 2373.04, "text": " also because DRAM is slowly moving towards non-volatile RAM and offline either made a", "tokens": [611, 570, 12118, 2865, 307, 5692, 2684, 3030, 2107, 12, 9646, 17445, 14561, 293, 21857, 2139, 1027, 257], "temperature": 0.0, "avg_logprob": -0.138311578872356, "compression_ratio": 1.632034632034632, "no_speech_prob": 1.4734398064319976e-05}, {"id": 485, "seek": 236516, "start": 2373.04, "end": 2378.7999999999997, "text": " tag or so where somebody unplugged your RAM or takes your non-volatile RAM and then looks", "tokens": [6162, 420, 370, 689, 2618, 39456, 3004, 428, 14561, 420, 2516, 428, 2107, 12, 9646, 17445, 14561, 293, 550, 1542], "temperature": 0.0, "avg_logprob": -0.138311578872356, "compression_ratio": 1.632034632034632, "no_speech_prob": 1.4734398064319976e-05}, {"id": 486, "seek": 236516, "start": 2378.7999999999997, "end": 2383.16, "text": " at it in another computer is a big problem and they can still unplug your RAM but they", "tokens": [412, 309, 294, 1071, 3820, 307, 257, 955, 1154, 293, 436, 393, 920, 39456, 428, 14561, 457, 436], "temperature": 0.0, "avg_logprob": -0.138311578872356, "compression_ratio": 1.632034632034632, "no_speech_prob": 1.4734398064319976e-05}, {"id": 487, "seek": 236516, "start": 2383.16, "end": 2386.8399999999997, "text": " would only see ciphertext.", "tokens": [576, 787, 536, 269, 21240, 25111, 13], "temperature": 0.0, "avg_logprob": -0.138311578872356, "compression_ratio": 1.632034632034632, "no_speech_prob": 1.4734398064319976e-05}, {"id": 488, "seek": 236516, "start": 2386.8399999999997, "end": 2393.92, "text": " So next thing we looked at was, so this was more of a confidentiality improvement, next", "tokens": [407, 958, 551, 321, 2956, 412, 390, 11, 370, 341, 390, 544, 295, 257, 27054, 507, 10444, 11, 958], "temperature": 0.0, "avg_logprob": -0.138311578872356, "compression_ratio": 1.632034632034632, "no_speech_prob": 1.4734398064319976e-05}, {"id": 489, "seek": 239392, "start": 2393.92, "end": 2403.48, "text": " thing we looked at is improving the availability and we added some support for dealing with", "tokens": [551, 321, 2956, 412, 307, 11470, 264, 17945, 293, 321, 3869, 512, 1406, 337, 6260, 365], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 490, "seek": 239392, "start": 2403.48, "end": 2405.16, "text": " noisy neighbor domains.", "tokens": [24518, 5987, 25514, 13], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 491, "seek": 239392, "start": 2405.16, "end": 2407.12, "text": " So what are noisy neighbor domains?", "tokens": [407, 437, 366, 24518, 5987, 25514, 30], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 492, "seek": 239392, "start": 2407.12, "end": 2411.84, "text": " Let's say you have a quad core system as shown on this slide and you have a bunch of virtual", "tokens": [961, 311, 584, 291, 362, 257, 10787, 4965, 1185, 382, 4898, 322, 341, 4137, 293, 291, 362, 257, 3840, 295, 6374], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 493, "seek": 239392, "start": 2411.84, "end": 2413.8, "text": " machines as shown at the top.", "tokens": [8379, 382, 4898, 412, 264, 1192, 13], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 494, "seek": 239392, "start": 2413.8, "end": 2419.0, "text": " On some cores you may over provision the cores run more than one VM like on core zero and", "tokens": [1282, 512, 24826, 291, 815, 670, 17225, 264, 24826, 1190, 544, 813, 472, 18038, 411, 322, 4965, 4018, 293], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 495, "seek": 239392, "start": 2419.0, "end": 2420.6, "text": " core one.", "tokens": [4965, 472, 13], "temperature": 0.0, "avg_logprob": -0.14830203722882015, "compression_ratio": 1.6696428571428572, "no_speech_prob": 1.592508670000825e-05}, {"id": 496, "seek": 242060, "start": 2420.6, "end": 2425.44, "text": " For some use cases you might want to run a single VM on a core only like a real time", "tokens": [1171, 512, 764, 3331, 291, 1062, 528, 281, 1190, 257, 2167, 18038, 322, 257, 4965, 787, 411, 257, 957, 565], "temperature": 0.0, "avg_logprob": -0.11588472586411697, "compression_ratio": 1.7389558232931728, "no_speech_prob": 1.4278411072154995e-05}, {"id": 497, "seek": 242060, "start": 2425.44, "end": 2433.12, "text": " VM which is exclusively assigned to core two but then on some cores like shown on far right", "tokens": [18038, 597, 307, 20638, 13279, 281, 4965, 732, 457, 550, 322, 512, 24826, 411, 4898, 322, 1400, 558], "temperature": 0.0, "avg_logprob": -0.11588472586411697, "compression_ratio": 1.7389558232931728, "no_speech_prob": 1.4278411072154995e-05}, {"id": 498, "seek": 242060, "start": 2433.12, "end": 2439.04, "text": " you may have a VM that's somewhat misbehaving and somewhat misbehaving means it uses excessive", "tokens": [291, 815, 362, 257, 18038, 300, 311, 8344, 3346, 29437, 6152, 293, 8344, 3346, 29437, 6152, 1355, 309, 4960, 22704], "temperature": 0.0, "avg_logprob": -0.11588472586411697, "compression_ratio": 1.7389558232931728, "no_speech_prob": 1.4278411072154995e-05}, {"id": 499, "seek": 242060, "start": 2439.04, "end": 2443.7599999999998, "text": " amounts of memory and basically evicts everybody else out of the cache.", "tokens": [11663, 295, 4675, 293, 1936, 1073, 985, 82, 2201, 1646, 484, 295, 264, 19459, 13], "temperature": 0.0, "avg_logprob": -0.11588472586411697, "compression_ratio": 1.7389558232931728, "no_speech_prob": 1.4278411072154995e-05}, {"id": 500, "seek": 242060, "start": 2443.7599999999998, "end": 2449.2799999999997, "text": " So if you look at the last level cache portion here, the amount of cache that is assigned", "tokens": [407, 498, 291, 574, 412, 264, 1036, 1496, 19459, 8044, 510, 11, 264, 2372, 295, 19459, 300, 307, 13279], "temperature": 0.0, "avg_logprob": -0.11588472586411697, "compression_ratio": 1.7389558232931728, "no_speech_prob": 1.4278411072154995e-05}, {"id": 501, "seek": 244928, "start": 2449.28, "end": 2454.96, "text": " to the noisy VM is very disproportionate to the amount of cache given to the other VM", "tokens": [281, 264, 24518, 18038, 307, 588, 28734, 473, 281, 264, 2372, 295, 19459, 2212, 281, 264, 661, 18038], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 502, "seek": 244928, "start": 2454.96, "end": 2458.5600000000004, "text": " simply because this is trampling all over memory.", "tokens": [2935, 570, 341, 307, 25749, 11970, 439, 670, 4675, 13], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 503, "seek": 244928, "start": 2458.5600000000004, "end": 2465.1600000000003, "text": " And this is very undesirable from a predictability perspective especially if you have a VM like", "tokens": [400, 341, 307, 588, 45667, 21493, 490, 257, 6069, 2310, 4585, 2318, 498, 291, 362, 257, 18038, 411], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 504, "seek": 244928, "start": 2465.1600000000003, "end": 2470.2400000000002, "text": " the green one that's real time which may want to have most of its working set in the cache.", "tokens": [264, 3092, 472, 300, 311, 957, 565, 597, 815, 528, 281, 362, 881, 295, 1080, 1364, 992, 294, 264, 19459, 13], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 505, "seek": 244928, "start": 2470.2400000000002, "end": 2472.7200000000003, "text": " So is there something we can do about it?", "tokens": [407, 307, 456, 746, 321, 393, 360, 466, 309, 30], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 506, "seek": 244928, "start": 2472.7200000000003, "end": 2474.5600000000004, "text": " And yes there is.", "tokens": [400, 2086, 456, 307, 13], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 507, "seek": 244928, "start": 2474.5600000000004, "end": 2477.28, "text": " It's called cat.", "tokens": [467, 311, 1219, 3857, 13], "temperature": 0.0, "avg_logprob": -0.15668817168300592, "compression_ratio": 1.606425702811245, "no_speech_prob": 2.246400799776893e-05}, {"id": 508, "seek": 247728, "start": 2477.28, "end": 2483.92, "text": " Cat is Intel's acronym for cache allocation technology and what they added in the hardware", "tokens": [9565, 307, 19762, 311, 39195, 337, 19459, 27599, 2899, 293, 437, 436, 3869, 294, 264, 8837], "temperature": 0.0, "avg_logprob": -0.1434510276431129, "compression_ratio": 1.8421052631578947, "no_speech_prob": 1.9213201085221954e-05}, {"id": 509, "seek": 247728, "start": 2483.92, "end": 2486.32, "text": " is a concept called class of service.", "tokens": [307, 257, 3410, 1219, 1508, 295, 2643, 13], "temperature": 0.0, "avg_logprob": -0.1434510276431129, "compression_ratio": 1.8421052631578947, "no_speech_prob": 1.9213201085221954e-05}, {"id": 510, "seek": 247728, "start": 2486.32, "end": 2490.84, "text": " And you can think of class of service as a number and again like the key idea is there's", "tokens": [400, 291, 393, 519, 295, 1508, 295, 2643, 382, 257, 1230, 293, 797, 411, 264, 2141, 1558, 307, 456, 311], "temperature": 0.0, "avg_logprob": -0.1434510276431129, "compression_ratio": 1.8421052631578947, "no_speech_prob": 1.9213201085221954e-05}, {"id": 511, "seek": 247728, "start": 2490.84, "end": 2497.0400000000004, "text": " a limited number of classes of service available like four or sixteen and you can assign this", "tokens": [257, 5567, 1230, 295, 5359, 295, 2643, 2435, 411, 1451, 420, 27847, 293, 291, 393, 6269, 341], "temperature": 0.0, "avg_logprob": -0.1434510276431129, "compression_ratio": 1.8421052631578947, "no_speech_prob": 1.9213201085221954e-05}, {"id": 512, "seek": 247728, "start": 2497.0400000000004, "end": 2500.32, "text": " class of service number to each entity that shares the cache.", "tokens": [1508, 295, 2643, 1230, 281, 1184, 13977, 300, 12182, 264, 19459, 13], "temperature": 0.0, "avg_logprob": -0.1434510276431129, "compression_ratio": 1.8421052631578947, "no_speech_prob": 1.9213201085221954e-05}, {"id": 513, "seek": 247728, "start": 2500.32, "end": 2505.76, "text": " So you could make it a property of a protection domain or a property of a thread.", "tokens": [407, 291, 727, 652, 309, 257, 4707, 295, 257, 6334, 9274, 420, 257, 4707, 295, 257, 7207, 13], "temperature": 0.0, "avg_logprob": -0.1434510276431129, "compression_ratio": 1.8421052631578947, "no_speech_prob": 1.9213201085221954e-05}, {"id": 514, "seek": 250576, "start": 2505.76, "end": 2511.6800000000003, "text": " And for each of the classes of service you can program a capacity bit mask which says", "tokens": [400, 337, 1184, 295, 264, 5359, 295, 2643, 291, 393, 1461, 257, 6042, 857, 6094, 597, 1619], "temperature": 0.0, "avg_logprob": -0.15554628094423165, "compression_ratio": 1.7211155378486056, "no_speech_prob": 9.366926860820968e-06}, {"id": 515, "seek": 250576, "start": 2511.6800000000003, "end": 2515.92, "text": " what proportion of the cache can this class of service use?", "tokens": [437, 16068, 295, 264, 19459, 393, 341, 1508, 295, 2643, 764, 30], "temperature": 0.0, "avg_logprob": -0.15554628094423165, "compression_ratio": 1.7211155378486056, "no_speech_prob": 9.366926860820968e-06}, {"id": 516, "seek": 250576, "start": 2515.92, "end": 2519.84, "text": " Can it use 20%, 50% and even which portion?", "tokens": [1664, 309, 764, 945, 8923, 2625, 4, 293, 754, 597, 8044, 30], "temperature": 0.0, "avg_logprob": -0.15554628094423165, "compression_ratio": 1.7211155378486056, "no_speech_prob": 9.366926860820968e-06}, {"id": 517, "seek": 250576, "start": 2519.84, "end": 2525.48, "text": " There are some limitations like the bit mask must be contiguous but they can overlap for", "tokens": [821, 366, 512, 15705, 411, 264, 857, 6094, 1633, 312, 660, 30525, 457, 436, 393, 19959, 337], "temperature": 0.0, "avg_logprob": -0.15554628094423165, "compression_ratio": 1.7211155378486056, "no_speech_prob": 9.366926860820968e-06}, {"id": 518, "seek": 250576, "start": 2525.48, "end": 2532.4, "text": " sharing and there's a model specific register which is not cheap to program where you can", "tokens": [5414, 293, 456, 311, 257, 2316, 2685, 7280, 597, 307, 406, 7084, 281, 1461, 689, 291, 393], "temperature": 0.0, "avg_logprob": -0.15554628094423165, "compression_ratio": 1.7211155378486056, "no_speech_prob": 9.366926860820968e-06}, {"id": 519, "seek": 250576, "start": 2532.4, "end": 2535.28, "text": " say this is the active class of service on this core right now.", "tokens": [584, 341, 307, 264, 4967, 1508, 295, 2643, 322, 341, 4965, 558, 586, 13], "temperature": 0.0, "avg_logprob": -0.15554628094423165, "compression_ratio": 1.7211155378486056, "no_speech_prob": 9.366926860820968e-06}, {"id": 520, "seek": 253528, "start": 2535.28, "end": 2539.36, "text": " So this is something you would have to contact switch to say I'm now using something else.", "tokens": [407, 341, 307, 746, 291, 576, 362, 281, 3385, 3679, 281, 584, 286, 478, 586, 1228, 746, 1646, 13], "temperature": 0.0, "avg_logprob": -0.10767454629415994, "compression_ratio": 1.6392156862745098, "no_speech_prob": 2.354179014218971e-05}, {"id": 521, "seek": 253528, "start": 2539.36, "end": 2545.32, "text": " And when you use this it improves the predictability like the worst case execution time quite nicely", "tokens": [400, 562, 291, 764, 341, 309, 24771, 264, 6069, 2310, 411, 264, 5855, 1389, 15058, 565, 1596, 9594], "temperature": 0.0, "avg_logprob": -0.10767454629415994, "compression_ratio": 1.6392156862745098, "no_speech_prob": 2.354179014218971e-05}, {"id": 522, "seek": 253528, "start": 2545.32, "end": 2547.6000000000004, "text": " and that's what it was originally designed for.", "tokens": [293, 300, 311, 437, 309, 390, 7993, 4761, 337, 13], "temperature": 0.0, "avg_logprob": -0.10767454629415994, "compression_ratio": 1.6392156862745098, "no_speech_prob": 2.354179014218971e-05}, {"id": 523, "seek": 253528, "start": 2547.6000000000004, "end": 2553.76, "text": " But it turns out it also helps tremendously with dealing with cache side channel attacks", "tokens": [583, 309, 4523, 484, 309, 611, 3665, 27985, 365, 6260, 365, 19459, 1252, 2269, 8122], "temperature": 0.0, "avg_logprob": -0.10767454629415994, "compression_ratio": 1.6392156862745098, "no_speech_prob": 2.354179014218971e-05}, {"id": 524, "seek": 253528, "start": 2553.76, "end": 2559.6000000000004, "text": " because if you can partition your cache in such a way that your attacker doesn't allocate", "tokens": [570, 498, 291, 393, 24808, 428, 19459, 294, 1270, 257, 636, 300, 428, 35871, 1177, 380, 35713], "temperature": 0.0, "avg_logprob": -0.10767454629415994, "compression_ratio": 1.6392156862745098, "no_speech_prob": 2.354179014218971e-05}, {"id": 525, "seek": 255960, "start": 2559.6, "end": 2566.44, "text": " into the same ways as the VM you're trying to protect then all the flush and reload attacks", "tokens": [666, 264, 912, 2098, 382, 264, 18038, 291, 434, 1382, 281, 2371, 550, 439, 264, 19568, 293, 25628, 8122], "temperature": 0.0, "avg_logprob": -0.10360705491268274, "compression_ratio": 1.4709302325581395, "no_speech_prob": 1.0286024007655215e-05}, {"id": 526, "seek": 255960, "start": 2566.44, "end": 2568.2, "text": " simply don't work.", "tokens": [2935, 500, 380, 589, 13], "temperature": 0.0, "avg_logprob": -0.10360705491268274, "compression_ratio": 1.4709302325581395, "no_speech_prob": 1.0286024007655215e-05}, {"id": 527, "seek": 255960, "start": 2568.2, "end": 2575.7999999999997, "text": " So here's an example for how this works and to the right I've shown an example number", "tokens": [407, 510, 311, 364, 1365, 337, 577, 341, 1985, 293, 281, 264, 558, 286, 600, 4898, 364, 1365, 1230], "temperature": 0.0, "avg_logprob": -0.10360705491268274, "compression_ratio": 1.4709302325581395, "no_speech_prob": 1.0286024007655215e-05}, {"id": 528, "seek": 255960, "start": 2575.7999999999997, "end": 2585.6, "text": " of six classes of service and a cache which has 20 ways.", "tokens": [295, 2309, 5359, 295, 2643, 293, 257, 19459, 597, 575, 945, 2098, 13], "temperature": 0.0, "avg_logprob": -0.10360705491268274, "compression_ratio": 1.4709302325581395, "no_speech_prob": 1.0286024007655215e-05}, {"id": 529, "seek": 258560, "start": 2585.6, "end": 2589.7999999999997, "text": " And you can program and this is again just an example you can program the capacity bit", "tokens": [400, 291, 393, 1461, 293, 341, 307, 797, 445, 364, 1365, 291, 393, 1461, 264, 6042, 857], "temperature": 0.0, "avg_logprob": -0.15170094339471113, "compression_ratio": 1.7937219730941705, "no_speech_prob": 1.1298999197606463e-05}, {"id": 530, "seek": 258560, "start": 2589.7999999999997, "end": 2595.44, "text": " mask for each class of service for example to create full isolation so you could say", "tokens": [6094, 337, 1184, 1508, 295, 2643, 337, 1365, 281, 1884, 1577, 16001, 370, 291, 727, 584], "temperature": 0.0, "avg_logprob": -0.15170094339471113, "compression_ratio": 1.7937219730941705, "no_speech_prob": 1.1298999197606463e-05}, {"id": 531, "seek": 258560, "start": 2595.44, "end": 2603.24, "text": " class of service gets 40% of the cache, weighs 0 to 7 and class of service 1 gets 20% and", "tokens": [1508, 295, 2643, 2170, 3356, 4, 295, 264, 19459, 11, 24911, 1958, 281, 1614, 293, 1508, 295, 2643, 502, 2170, 945, 4, 293], "temperature": 0.0, "avg_logprob": -0.15170094339471113, "compression_ratio": 1.7937219730941705, "no_speech_prob": 1.1298999197606463e-05}, {"id": 532, "seek": 258560, "start": 2603.24, "end": 2608.44, "text": " everybody else gets 10% and these capacity bit masks don't overlap at all which means", "tokens": [2201, 1646, 2170, 1266, 4, 293, 613, 6042, 857, 11830, 500, 380, 19959, 412, 439, 597, 1355], "temperature": 0.0, "avg_logprob": -0.15170094339471113, "compression_ratio": 1.7937219730941705, "no_speech_prob": 1.1298999197606463e-05}, {"id": 533, "seek": 258560, "start": 2608.44, "end": 2612.36, "text": " you get zero interference through the level 3 cache.", "tokens": [291, 483, 4018, 24497, 807, 264, 1496, 805, 19459, 13], "temperature": 0.0, "avg_logprob": -0.15170094339471113, "compression_ratio": 1.7937219730941705, "no_speech_prob": 1.1298999197606463e-05}, {"id": 534, "seek": 261236, "start": 2612.36, "end": 2617.04, "text": " You could also program them to overlap.", "tokens": [509, 727, 611, 1461, 552, 281, 19959, 13], "temperature": 0.0, "avg_logprob": -0.11172618446769295, "compression_ratio": 1.6794871794871795, "no_speech_prob": 9.079006304091308e-06}, {"id": 535, "seek": 261236, "start": 2617.04, "end": 2622.8, "text": " There's another mode which is called CDP code and data prioritization which splits the number", "tokens": [821, 311, 1071, 4391, 597, 307, 1219, 6743, 47, 3089, 293, 1412, 14846, 2144, 597, 37741, 264, 1230], "temperature": 0.0, "avg_logprob": -0.11172618446769295, "compression_ratio": 1.6794871794871795, "no_speech_prob": 9.079006304091308e-06}, {"id": 536, "seek": 261236, "start": 2622.8, "end": 2628.7200000000003, "text": " of classes of service in half and basically redefines the meaning of the bit mask to say", "tokens": [295, 5359, 295, 2643, 294, 1922, 293, 1936, 38818, 1652, 264, 3620, 295, 264, 857, 6094, 281, 584], "temperature": 0.0, "avg_logprob": -0.11172618446769295, "compression_ratio": 1.6794871794871795, "no_speech_prob": 9.079006304091308e-06}, {"id": 537, "seek": 261236, "start": 2628.7200000000003, "end": 2632.8, "text": " those with an even number are for data and those with an odd number are for code.", "tokens": [729, 365, 364, 754, 1230, 366, 337, 1412, 293, 729, 365, 364, 7401, 1230, 366, 337, 3089, 13], "temperature": 0.0, "avg_logprob": -0.11172618446769295, "compression_ratio": 1.6794871794871795, "no_speech_prob": 9.079006304091308e-06}, {"id": 538, "seek": 261236, "start": 2632.8, "end": 2637.4, "text": " So you can even discriminate how the cache is being used between code and data and gives", "tokens": [407, 291, 393, 754, 47833, 577, 264, 19459, 307, 885, 1143, 1296, 3089, 293, 1412, 293, 2709], "temperature": 0.0, "avg_logprob": -0.11172618446769295, "compression_ratio": 1.6794871794871795, "no_speech_prob": 9.079006304091308e-06}, {"id": 539, "seek": 263740, "start": 2637.4, "end": 2644.84, "text": " you more fine-grained control and the NOVA API forces users to declare upfront whether", "tokens": [291, 544, 2489, 12, 20735, 2001, 1969, 293, 264, 9146, 20914, 9362, 5874, 5022, 281, 19710, 30264, 1968], "temperature": 0.0, "avg_logprob": -0.1582850861823422, "compression_ratio": 1.4691358024691359, "no_speech_prob": 3.64598490705248e-05}, {"id": 540, "seek": 263740, "start": 2644.84, "end": 2650.7200000000003, "text": " they want to use CAT or CDP to partition their cache and only after you've made that decision", "tokens": [436, 528, 281, 764, 41192, 420, 6743, 47, 281, 24808, 641, 19459, 293, 787, 934, 291, 600, 1027, 300, 3537], "temperature": 0.0, "avg_logprob": -0.1582850861823422, "compression_ratio": 1.4691358024691359, "no_speech_prob": 3.64598490705248e-05}, {"id": 541, "seek": 263740, "start": 2650.7200000000003, "end": 2653.36, "text": " can you actually configure the capacity bit masks.", "tokens": [393, 291, 767, 22162, 264, 6042, 857, 11830, 13], "temperature": 0.0, "avg_logprob": -0.1582850861823422, "compression_ratio": 1.4691358024691359, "no_speech_prob": 3.64598490705248e-05}, {"id": 542, "seek": 263740, "start": 2653.36, "end": 2655.56, "text": " So with CDP it would look like this.", "tokens": [407, 365, 6743, 47, 309, 576, 574, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.1582850861823422, "compression_ratio": 1.4691358024691359, "no_speech_prob": 3.64598490705248e-05}, {"id": 543, "seek": 263740, "start": 2655.56, "end": 2661.56, "text": " You get three classes of service instead of six, distinguished between D and C, data and", "tokens": [509, 483, 1045, 5359, 295, 2643, 2602, 295, 2309, 11, 21702, 1296, 413, 293, 383, 11, 1412, 293], "temperature": 0.0, "avg_logprob": -0.1582850861823422, "compression_ratio": 1.4691358024691359, "no_speech_prob": 3.64598490705248e-05}, {"id": 544, "seek": 266156, "start": 2661.56, "end": 2668.84, "text": " code and you could for example say class of service 1 as shown on the right gets 20% of", "tokens": [3089, 293, 291, 727, 337, 1365, 584, 1508, 295, 2643, 502, 382, 4898, 322, 264, 558, 2170, 945, 4, 295], "temperature": 0.0, "avg_logprob": -0.13506081700325012, "compression_ratio": 1.8302752293577982, "no_speech_prob": 3.588767140172422e-05}, {"id": 545, "seek": 266156, "start": 2668.84, "end": 2675.92, "text": " the cache for data, 30% of cache for the code, so 50% of the capacity in total exclusively", "tokens": [264, 19459, 337, 1412, 11, 2217, 4, 295, 19459, 337, 264, 3089, 11, 370, 2625, 4, 295, 264, 6042, 294, 3217, 20638], "temperature": 0.0, "avg_logprob": -0.13506081700325012, "compression_ratio": 1.8302752293577982, "no_speech_prob": 3.588767140172422e-05}, {"id": 546, "seek": 266156, "start": 2675.92, "end": 2681.04, "text": " assigned to anybody who's class of service 1 and the rest shares capacity bit masks and", "tokens": [13279, 281, 4472, 567, 311, 1508, 295, 2643, 502, 293, 264, 1472, 12182, 6042, 857, 11830, 293], "temperature": 0.0, "avg_logprob": -0.13506081700325012, "compression_ratio": 1.8302752293577982, "no_speech_prob": 3.588767140172422e-05}, {"id": 547, "seek": 266156, "start": 2681.04, "end": 2685.68, "text": " here you see an example of how the bit masks can overlap and wherever they overlap the cache", "tokens": [510, 291, 536, 364, 1365, 295, 577, 264, 857, 11830, 393, 19959, 293, 8660, 436, 19959, 264, 19459], "temperature": 0.0, "avg_logprob": -0.13506081700325012, "compression_ratio": 1.8302752293577982, "no_speech_prob": 3.588767140172422e-05}, {"id": 548, "seek": 266156, "start": 2685.68, "end": 2689.36, "text": " capacity is being competitively shared.", "tokens": [6042, 307, 885, 10043, 356, 5507, 13], "temperature": 0.0, "avg_logprob": -0.13506081700325012, "compression_ratio": 1.8302752293577982, "no_speech_prob": 3.588767140172422e-05}, {"id": 549, "seek": 268936, "start": 2689.36, "end": 2692.88, "text": " So that's also a new feature that we support right now.", "tokens": [407, 300, 311, 611, 257, 777, 4111, 300, 321, 1406, 558, 586, 13], "temperature": 0.0, "avg_logprob": -0.11967080953169842, "compression_ratio": 1.7563025210084033, "no_speech_prob": 8.136173164530192e-06}, {"id": 550, "seek": 268936, "start": 2692.88, "end": 2699.0, "text": " Now the question is class of service is something you need to assign to cache sharing entities.", "tokens": [823, 264, 1168, 307, 1508, 295, 2643, 307, 746, 291, 643, 281, 6269, 281, 19459, 5414, 16667, 13], "temperature": 0.0, "avg_logprob": -0.11967080953169842, "compression_ratio": 1.7563025210084033, "no_speech_prob": 8.136173164530192e-06}, {"id": 551, "seek": 268936, "start": 2699.0, "end": 2702.2400000000002, "text": " To what type of object do you assign that?", "tokens": [1407, 437, 2010, 295, 2657, 360, 291, 6269, 300, 30], "temperature": 0.0, "avg_logprob": -0.11967080953169842, "compression_ratio": 1.7563025210084033, "no_speech_prob": 8.136173164530192e-06}, {"id": 552, "seek": 268936, "start": 2702.2400000000002, "end": 2704.44, "text": " And you could assign that to a protection domain.", "tokens": [400, 291, 727, 6269, 300, 281, 257, 6334, 9274, 13], "temperature": 0.0, "avg_logprob": -0.11967080953169842, "compression_ratio": 1.7563025210084033, "no_speech_prob": 8.136173164530192e-06}, {"id": 553, "seek": 268936, "start": 2704.44, "end": 2710.28, "text": " You could say every box on the architecture slide gets assigned a certain class of service", "tokens": [509, 727, 584, 633, 2424, 322, 264, 9482, 4137, 2170, 13279, 257, 1629, 1508, 295, 2643], "temperature": 0.0, "avg_logprob": -0.11967080953169842, "compression_ratio": 1.7563025210084033, "no_speech_prob": 8.136173164530192e-06}, {"id": 554, "seek": 268936, "start": 2710.28, "end": 2715.92, "text": " and the question is then what do you assign to a server that has multiple clients?", "tokens": [293, 264, 1168, 307, 550, 437, 360, 291, 6269, 281, 257, 7154, 300, 575, 3866, 6982, 30], "temperature": 0.0, "avg_logprob": -0.11967080953169842, "compression_ratio": 1.7563025210084033, "no_speech_prob": 8.136173164530192e-06}, {"id": 555, "seek": 271592, "start": 2715.92, "end": 2720.2000000000003, "text": " It's really unfortunate and what also means is if you have a protection domain that spends", "tokens": [467, 311, 534, 17843, 293, 437, 611, 1355, 307, 498, 291, 362, 257, 6334, 9274, 300, 25620], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 556, "seek": 271592, "start": 2720.2000000000003, "end": 2725.52, "text": " multiple cores and you say I want this protection domain to use 40% of the cache, you have to", "tokens": [3866, 24826, 293, 291, 584, 286, 528, 341, 6334, 9274, 281, 764, 3356, 4, 295, 264, 19459, 11, 291, 362, 281], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 557, "seek": 271592, "start": 2725.52, "end": 2729.84, "text": " program the class of service settings on all cores the same way.", "tokens": [1461, 264, 1508, 295, 2643, 6257, 322, 439, 24826, 264, 912, 636, 13], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 558, "seek": 271592, "start": 2729.84, "end": 2731.96, "text": " So it's really a loss of flexibility.", "tokens": [407, 309, 311, 534, 257, 4470, 295, 12635, 13], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 559, "seek": 271592, "start": 2731.96, "end": 2736.48, "text": " So that wasn't our favorite choice and we said maybe we should assign class of service", "tokens": [407, 300, 2067, 380, 527, 2954, 3922, 293, 321, 848, 1310, 321, 820, 6269, 1508, 295, 2643], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 560, "seek": 271592, "start": 2736.48, "end": 2738.8, "text": " to execution contexts instead.", "tokens": [281, 15058, 30628, 2602, 13], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 561, "seek": 271592, "start": 2738.8, "end": 2743.28, "text": " And again the question is what class of service do you assign to a server execution context", "tokens": [400, 797, 264, 1168, 307, 437, 1508, 295, 2643, 360, 291, 6269, 281, 257, 7154, 15058, 4319], "temperature": 0.0, "avg_logprob": -0.12706929082455842, "compression_ratio": 1.8272058823529411, "no_speech_prob": 5.506835350388428e-06}, {"id": 562, "seek": 274328, "start": 2743.28, "end": 2748.6000000000004, "text": " that does work on behalf of clients and the actual killer argument was that you would", "tokens": [300, 775, 589, 322, 9490, 295, 6982, 293, 264, 3539, 13364, 6770, 390, 300, 291, 576], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 563, "seek": 274328, "start": 2748.6000000000004, "end": 2753.2400000000002, "text": " need to set the class of service in this model specific register again during each context", "tokens": [643, 281, 992, 264, 1508, 295, 2643, 294, 341, 2316, 2685, 7280, 797, 1830, 1184, 4319], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 564, "seek": 274328, "start": 2753.2400000000002, "end": 2756.5600000000004, "text": " switch which is really bad for performance.", "tokens": [3679, 597, 307, 534, 1578, 337, 3389, 13], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 565, "seek": 274328, "start": 2756.5600000000004, "end": 2760.1600000000003, "text": " So even option two is not what we went for.", "tokens": [407, 754, 3614, 732, 307, 406, 437, 321, 1437, 337, 13], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 566, "seek": 274328, "start": 2760.1600000000003, "end": 2764.6800000000003, "text": " Instead we made the class of service a property of the scheduling context and that has very", "tokens": [7156, 321, 1027, 264, 1508, 295, 2643, 257, 4707, 295, 264, 29055, 4319, 293, 300, 575, 588], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 567, "seek": 274328, "start": 2764.6800000000003, "end": 2765.92, "text": " nice properties.", "tokens": [1481, 7221, 13], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 568, "seek": 274328, "start": 2765.92, "end": 2770.44, "text": " We only need to context switch it during scheduling decisions so the cost of reprogramming that", "tokens": [492, 787, 643, 281, 4319, 3679, 309, 1830, 29055, 5327, 370, 264, 2063, 295, 35257, 1342, 2810, 300], "temperature": 0.0, "avg_logprob": -0.1356624784923735, "compression_ratio": 1.763157894736842, "no_speech_prob": 3.5554521673475392e-06}, {"id": 569, "seek": 277044, "start": 2770.44, "end": 2777.44, "text": " MSR is really not relevant anymore and it extends the already existing model of time", "tokens": [7395, 49, 307, 534, 406, 7340, 3602, 293, 309, 26448, 264, 1217, 6741, 2316, 295, 565], "temperature": 0.0, "avg_logprob": -0.13035860515776135, "compression_ratio": 1.8547008547008548, "no_speech_prob": 9.22169510886306e-06}, {"id": 570, "seek": 277044, "start": 2777.44, "end": 2780.88, "text": " and priority donation with class of service donation.", "tokens": [293, 9365, 19724, 365, 1508, 295, 2643, 19724, 13], "temperature": 0.0, "avg_logprob": -0.13035860515776135, "compression_ratio": 1.8547008547008548, "no_speech_prob": 9.22169510886306e-06}, {"id": 571, "seek": 277044, "start": 2780.88, "end": 2785.36, "text": " So a server does not need to have a class of service assigned to it at all.", "tokens": [407, 257, 7154, 775, 406, 643, 281, 362, 257, 1508, 295, 2643, 13279, 281, 309, 412, 439, 13], "temperature": 0.0, "avg_logprob": -0.13035860515776135, "compression_ratio": 1.8547008547008548, "no_speech_prob": 9.22169510886306e-06}, {"id": 572, "seek": 277044, "start": 2785.36, "end": 2787.2400000000002, "text": " It uses the class of service of its client.", "tokens": [467, 4960, 264, 1508, 295, 2643, 295, 1080, 6423, 13], "temperature": 0.0, "avg_logprob": -0.13035860515776135, "compression_ratio": 1.8547008547008548, "no_speech_prob": 9.22169510886306e-06}, {"id": 573, "seek": 277044, "start": 2787.2400000000002, "end": 2794.8, "text": " So if let's say your server implements some file system or so, then the amount of cache", "tokens": [407, 498, 718, 311, 584, 428, 7154, 704, 17988, 512, 3991, 1185, 420, 370, 11, 550, 264, 2372, 295, 19459], "temperature": 0.0, "avg_logprob": -0.13035860515776135, "compression_ratio": 1.8547008547008548, "no_speech_prob": 9.22169510886306e-06}, {"id": 574, "seek": 277044, "start": 2794.8, "end": 2798.88, "text": " it can use depends on whether your client can use a lot of cache or whether your client", "tokens": [309, 393, 764, 5946, 322, 1968, 428, 6423, 393, 764, 257, 688, 295, 19459, 420, 1968, 428, 6423], "temperature": 0.0, "avg_logprob": -0.13035860515776135, "compression_ratio": 1.8547008547008548, "no_speech_prob": 9.22169510886306e-06}, {"id": 575, "seek": 279888, "start": 2798.88, "end": 2800.56, "text": " cannot use a lot of cache.", "tokens": [2644, 764, 257, 688, 295, 19459, 13], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 576, "seek": 279888, "start": 2800.56, "end": 2805.2000000000003, "text": " So it's a nice extension of an existing feature and the additional benefit is that the classes", "tokens": [407, 309, 311, 257, 1481, 10320, 295, 364, 6741, 4111, 293, 264, 4497, 5121, 307, 300, 264, 5359], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 577, "seek": 279888, "start": 2805.2000000000003, "end": 2808.88, "text": " of service can be programmed differently per core.", "tokens": [295, 2643, 393, 312, 31092, 7614, 680, 4965, 13], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 578, "seek": 279888, "start": 2808.88, "end": 2814.7200000000003, "text": " So 8 cores times 6 classes of service gives you 48 classes of service in total instead", "tokens": [407, 1649, 24826, 1413, 1386, 5359, 295, 2643, 2709, 291, 11174, 5359, 295, 2643, 294, 3217, 2602], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 579, "seek": 279888, "start": 2814.7200000000003, "end": 2818.2000000000003, "text": " of 6.", "tokens": [295, 1386, 13], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 580, "seek": 279888, "start": 2818.2000000000003, "end": 2821.52, "text": " So that was a feature for availability.", "tokens": [407, 300, 390, 257, 4111, 337, 17945, 13], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 581, "seek": 279888, "start": 2821.52, "end": 2826.7200000000003, "text": " We also added some features for integrity and if you look at the history, there's a", "tokens": [492, 611, 3869, 512, 4122, 337, 16000, 293, 498, 291, 574, 412, 264, 2503, 11, 456, 311, 257], "temperature": 0.0, "avg_logprob": -0.12159810463587443, "compression_ratio": 1.7212389380530972, "no_speech_prob": 3.2883754101931117e-06}, {"id": 582, "seek": 282672, "start": 2826.72, "end": 2832.4399999999996, "text": " long history of features being added to paging that improve the integrity of code against", "tokens": [938, 2503, 295, 4122, 885, 3869, 281, 280, 3568, 300, 3470, 264, 16000, 295, 3089, 1970], "temperature": 0.0, "avg_logprob": -0.1467777027803309, "compression_ratio": 1.5676855895196506, "no_speech_prob": 1.3628041415358894e-05}, {"id": 583, "seek": 282672, "start": 2832.4399999999996, "end": 2833.9199999999996, "text": " injection attacks.", "tokens": [22873, 8122, 13], "temperature": 0.0, "avg_logprob": -0.1467777027803309, "compression_ratio": 1.5676855895196506, "no_speech_prob": 1.3628041415358894e-05}, {"id": 584, "seek": 282672, "start": 2833.9199999999996, "end": 2840.8399999999997, "text": " And it all started out many years ago with these 64-bit architecture where you could", "tokens": [400, 309, 439, 1409, 484, 867, 924, 2057, 365, 613, 12145, 12, 5260, 9482, 689, 291, 727], "temperature": 0.0, "avg_logprob": -0.1467777027803309, "compression_ratio": 1.5676855895196506, "no_speech_prob": 1.3628041415358894e-05}, {"id": 585, "seek": 282672, "start": 2840.8399999999997, "end": 2848.64, "text": " mark pages non-executable and you could basically enforce that pages are either writable or", "tokens": [1491, 7183, 2107, 12, 3121, 3045, 32148, 293, 291, 727, 1936, 24825, 300, 7183, 366, 2139, 10912, 712, 420], "temperature": 0.0, "avg_logprob": -0.1467777027803309, "compression_ratio": 1.5676855895196506, "no_speech_prob": 1.3628041415358894e-05}, {"id": 586, "seek": 282672, "start": 2848.64, "end": 2850.64, "text": " executable but never both.", "tokens": [7568, 712, 457, 1128, 1293, 13], "temperature": 0.0, "avg_logprob": -0.1467777027803309, "compression_ratio": 1.5676855895196506, "no_speech_prob": 1.3628041415358894e-05}, {"id": 587, "seek": 282672, "start": 2850.64, "end": 2853.72, "text": " So there's no confusion between data and code.", "tokens": [407, 456, 311, 572, 15075, 1296, 1412, 293, 3089, 13], "temperature": 0.0, "avg_logprob": -0.1467777027803309, "compression_ratio": 1.5676855895196506, "no_speech_prob": 1.3628041415358894e-05}, {"id": 588, "seek": 285372, "start": 2853.72, "end": 2858.68, "text": " And then over the years, more features were added like supervisor mode execution prevention", "tokens": [400, 550, 670, 264, 924, 11, 544, 4122, 645, 3869, 411, 24610, 4391, 15058, 14630], "temperature": 0.0, "avg_logprob": -0.11785520206798207, "compression_ratio": 1.8198198198198199, "no_speech_prob": 7.64528704166878e-06}, {"id": 589, "seek": 285372, "start": 2858.68, "end": 2865.3999999999996, "text": " where if you use that feature, kernel code can never jump into a user page and be confused", "tokens": [689, 498, 291, 764, 300, 4111, 11, 28256, 3089, 393, 1128, 3012, 666, 257, 4195, 3028, 293, 312, 9019], "temperature": 0.0, "avg_logprob": -0.11785520206798207, "compression_ratio": 1.8198198198198199, "no_speech_prob": 7.64528704166878e-06}, {"id": 590, "seek": 285372, "start": 2865.3999999999996, "end": 2867.9599999999996, "text": " as executing some user code.", "tokens": [382, 32368, 512, 4195, 3089, 13], "temperature": 0.0, "avg_logprob": -0.11785520206798207, "compression_ratio": 1.8198198198198199, "no_speech_prob": 7.64528704166878e-06}, {"id": 591, "seek": 285372, "start": 2867.9599999999996, "end": 2871.7999999999997, "text": " And then there's another feature called supervisor mode access prevention which even says kernel", "tokens": [400, 550, 456, 311, 1071, 4111, 1219, 24610, 4391, 2105, 14630, 597, 754, 1619, 28256], "temperature": 0.0, "avg_logprob": -0.11785520206798207, "compression_ratio": 1.8198198198198199, "no_speech_prob": 7.64528704166878e-06}, {"id": 592, "seek": 285372, "start": 2871.7999999999997, "end": 2877.68, "text": " code can never without explicitly declaring that it wants to do that, read some user data", "tokens": [3089, 393, 1128, 1553, 20803, 40374, 300, 309, 2738, 281, 360, 300, 11, 1401, 512, 4195, 1412], "temperature": 0.0, "avg_logprob": -0.11785520206798207, "compression_ratio": 1.8198198198198199, "no_speech_prob": 7.64528704166878e-06}, {"id": 593, "seek": 285372, "start": 2877.68, "end": 2879.68, "text": " page.", "tokens": [3028, 13], "temperature": 0.0, "avg_logprob": -0.11785520206798207, "compression_ratio": 1.8198198198198199, "no_speech_prob": 7.64528704166878e-06}, {"id": 594, "seek": 287968, "start": 2879.68, "end": 2884.56, "text": " So all of these tighten the security and naturally Nova supports them.", "tokens": [407, 439, 295, 613, 17041, 264, 3825, 293, 8195, 27031, 9346, 552, 13], "temperature": 0.0, "avg_logprob": -0.1429842168634588, "compression_ratio": 1.6887966804979253, "no_speech_prob": 8.937711754697375e-06}, {"id": 595, "seek": 287968, "start": 2884.56, "end": 2890.0, "text": " There's a new one called mode-based execution control which is only relevant for guest page", "tokens": [821, 311, 257, 777, 472, 1219, 4391, 12, 6032, 15058, 1969, 597, 307, 787, 7340, 337, 8341, 3028], "temperature": 0.0, "avg_logprob": -0.1429842168634588, "compression_ratio": 1.6887966804979253, "no_speech_prob": 8.937711754697375e-06}, {"id": 596, "seek": 287968, "start": 2890.0, "end": 2894.16, "text": " tables or stage two which gives you two separate execution bits.", "tokens": [8020, 420, 3233, 732, 597, 2709, 291, 732, 4994, 15058, 9239, 13], "temperature": 0.0, "avg_logprob": -0.1429842168634588, "compression_ratio": 1.6887966804979253, "no_speech_prob": 8.937711754697375e-06}, {"id": 597, "seek": 287968, "start": 2894.16, "end": 2895.8399999999997, "text": " So there's not a single X bit.", "tokens": [407, 456, 311, 406, 257, 2167, 1783, 857, 13], "temperature": 0.0, "avg_logprob": -0.1429842168634588, "compression_ratio": 1.6887966804979253, "no_speech_prob": 8.937711754697375e-06}, {"id": 598, "seek": 287968, "start": 2895.8399999999997, "end": 2901.04, "text": " There's now executable for user and executable for super user.", "tokens": [821, 311, 586, 7568, 712, 337, 4195, 293, 7568, 712, 337, 1687, 4195, 13], "temperature": 0.0, "avg_logprob": -0.1429842168634588, "compression_ratio": 1.6887966804979253, "no_speech_prob": 8.937711754697375e-06}, {"id": 599, "seek": 287968, "start": 2901.04, "end": 2905.7599999999998, "text": " And that is a feature that ultra security can, for example, use where we can say even", "tokens": [400, 300, 307, 257, 4111, 300, 14808, 3825, 393, 11, 337, 1365, 11, 764, 689, 321, 393, 584, 754], "temperature": 0.0, "avg_logprob": -0.1429842168634588, "compression_ratio": 1.6887966804979253, "no_speech_prob": 8.937711754697375e-06}, {"id": 600, "seek": 290576, "start": 2905.76, "end": 2910.6800000000003, "text": " if the guest screws up its page tables, it's stage one page tables, the stage two page", "tokens": [498, 264, 8341, 13050, 493, 1080, 3028, 8020, 11, 309, 311, 3233, 472, 3028, 8020, 11, 264, 3233, 732, 3028], "temperature": 0.0, "avg_logprob": -0.14799231173945407, "compression_ratio": 1.8626609442060085, "no_speech_prob": 6.437945557991043e-06}, {"id": 601, "seek": 290576, "start": 2910.6800000000003, "end": 2919.0, "text": " tables can still say Linux user applications or Linux kernel code can never execute Linux", "tokens": [8020, 393, 920, 584, 18734, 4195, 5821, 420, 18734, 28256, 3089, 393, 1128, 14483, 18734], "temperature": 0.0, "avg_logprob": -0.14799231173945407, "compression_ratio": 1.8626609442060085, "no_speech_prob": 6.437945557991043e-06}, {"id": 602, "seek": 290576, "start": 2919.0, "end": 2924.2400000000002, "text": " user application code if it's marked as XS in the stage two page table.", "tokens": [4195, 3861, 3089, 498, 309, 311, 12658, 382, 1783, 50, 294, 264, 3233, 732, 3028, 3199, 13], "temperature": 0.0, "avg_logprob": -0.14799231173945407, "compression_ratio": 1.8626609442060085, "no_speech_prob": 6.437945557991043e-06}, {"id": 603, "seek": 290576, "start": 2924.2400000000002, "end": 2928.6800000000003, "text": " So it's again a feature that can tighten the security of guest operating systems from the", "tokens": [407, 309, 311, 797, 257, 4111, 300, 393, 17041, 264, 3825, 295, 8341, 7447, 3652, 490, 264], "temperature": 0.0, "avg_logprob": -0.14799231173945407, "compression_ratio": 1.8626609442060085, "no_speech_prob": 6.437945557991043e-06}, {"id": 604, "seek": 290576, "start": 2928.6800000000003, "end": 2929.96, "text": " host.", "tokens": [3975, 13], "temperature": 0.0, "avg_logprob": -0.14799231173945407, "compression_ratio": 1.8626609442060085, "no_speech_prob": 6.437945557991043e-06}, {"id": 605, "seek": 290576, "start": 2929.96, "end": 2935.1600000000003, "text": " But even if you have all that, there are still opportunities for code injection and these", "tokens": [583, 754, 498, 291, 362, 439, 300, 11, 456, 366, 920, 4786, 337, 3089, 22873, 293, 613], "temperature": 0.0, "avg_logprob": -0.14799231173945407, "compression_ratio": 1.8626609442060085, "no_speech_prob": 6.437945557991043e-06}, {"id": 606, "seek": 293516, "start": 2935.16, "end": 2939.96, "text": " classes of attacks basically reuse existing code snippets and chain them together in interesting", "tokens": [5359, 295, 8122, 1936, 26225, 6741, 3089, 35623, 1385, 293, 5021, 552, 1214, 294, 1880], "temperature": 0.0, "avg_logprob": -0.1496662980034238, "compression_ratio": 1.7882882882882882, "no_speech_prob": 2.627066533023026e-05}, {"id": 607, "seek": 293516, "start": 2939.96, "end": 2944.7999999999997, "text": " ways using control flow hijacking like Rob attacks.", "tokens": [2098, 1228, 1969, 3095, 10625, 14134, 411, 5424, 8122, 13], "temperature": 0.0, "avg_logprob": -0.1496662980034238, "compression_ratio": 1.7882882882882882, "no_speech_prob": 2.627066533023026e-05}, {"id": 608, "seek": 293516, "start": 2944.7999999999997, "end": 2950.3599999999997, "text": " And I'm not sure who's familiar with Rob attacks is basically you create a call stack", "tokens": [400, 286, 478, 406, 988, 567, 311, 4963, 365, 5424, 8122, 307, 1936, 291, 1884, 257, 818, 8630], "temperature": 0.0, "avg_logprob": -0.1496662980034238, "compression_ratio": 1.7882882882882882, "no_speech_prob": 2.627066533023026e-05}, {"id": 609, "seek": 293516, "start": 2950.3599999999997, "end": 2955.12, "text": " with lots of return addresses that chain together simple code snippets like add this register", "tokens": [365, 3195, 295, 2736, 16862, 300, 5021, 1214, 2199, 3089, 35623, 1385, 411, 909, 341, 7280], "temperature": 0.0, "avg_logprob": -0.1496662980034238, "compression_ratio": 1.7882882882882882, "no_speech_prob": 2.627066533023026e-05}, {"id": 610, "seek": 293516, "start": 2955.12, "end": 2960.08, "text": " return, multiply this register return, jump to this function return.", "tokens": [2736, 11, 12972, 341, 7280, 2736, 11, 3012, 281, 341, 2445, 2736, 13], "temperature": 0.0, "avg_logprob": -0.1496662980034238, "compression_ratio": 1.7882882882882882, "no_speech_prob": 2.627066533023026e-05}, {"id": 611, "seek": 296008, "start": 2960.08, "end": 2965.3199999999997, "text": " And by chaining them all together, you can build programs out of existing code snippets", "tokens": [400, 538, 417, 3686, 552, 439, 1214, 11, 291, 393, 1322, 4268, 484, 295, 6741, 3089, 35623, 1385], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 612, "seek": 296008, "start": 2965.3199999999997, "end": 2966.3199999999997, "text": " that do what the attacker wants.", "tokens": [300, 360, 437, 264, 35871, 2738, 13], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 613, "seek": 296008, "start": 2966.3199999999997, "end": 2967.68, "text": " You don't have to inject any code.", "tokens": [509, 500, 380, 362, 281, 10711, 604, 3089, 13], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 614, "seek": 296008, "start": 2967.68, "end": 2972.7999999999997, "text": " You simply find snippets in existing code that do what you what you want.", "tokens": [509, 2935, 915, 35623, 1385, 294, 6741, 3089, 300, 360, 437, 291, 437, 291, 528, 13], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 615, "seek": 296008, "start": 2972.7999999999997, "end": 2974.96, "text": " And this doesn't work so well on arm.", "tokens": [400, 341, 1177, 380, 589, 370, 731, 322, 3726, 13], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 616, "seek": 296008, "start": 2974.96, "end": 2979.84, "text": " It still works on arm, but on arm, the instruction length is flex is fixed to four bytes.", "tokens": [467, 920, 1985, 322, 3726, 11, 457, 322, 3726, 11, 264, 10951, 4641, 307, 5896, 307, 6806, 281, 1451, 36088, 13], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 617, "seek": 296008, "start": 2979.84, "end": 2982.44, "text": " So you can't jump into the middle of instructions.", "tokens": [407, 291, 393, 380, 3012, 666, 264, 2808, 295, 9415, 13], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 618, "seek": 296008, "start": 2982.44, "end": 2989.2, "text": " But on x86 with a flexible instruction size, you can even jump into the middle of instructions", "tokens": [583, 322, 2031, 22193, 365, 257, 11358, 10951, 2744, 11, 291, 393, 754, 3012, 666, 264, 2808, 295, 9415], "temperature": 0.0, "avg_logprob": -0.13948109353235524, "compression_ratio": 1.8698884758364311, "no_speech_prob": 1.0128935173270293e-05}, {"id": 619, "seek": 298920, "start": 2989.2, "end": 2993.3599999999997, "text": " and completely reinterpret what existing code looks like.", "tokens": [293, 2584, 319, 41935, 437, 6741, 3089, 1542, 411, 13], "temperature": 0.0, "avg_logprob": -0.133574878468233, "compression_ratio": 1.740909090909091, "no_speech_prob": 8.26615905680228e-06}, {"id": 620, "seek": 298920, "start": 2993.3599999999997, "end": 2995.3199999999997, "text": " And that's quite unfortunate.", "tokens": [400, 300, 311, 1596, 17843, 13], "temperature": 0.0, "avg_logprob": -0.133574878468233, "compression_ratio": 1.740909090909091, "no_speech_prob": 8.26615905680228e-06}, {"id": 621, "seek": 298920, "start": 2995.3199999999997, "end": 3001.9199999999996, "text": " So there's feature that tightens the security around that and it's called control flow enforcement", "tokens": [407, 456, 311, 4111, 300, 4524, 694, 264, 3825, 926, 300, 293, 309, 311, 1219, 1969, 3095, 11475], "temperature": 0.0, "avg_logprob": -0.133574878468233, "compression_ratio": 1.740909090909091, "no_speech_prob": 8.26615905680228e-06}, {"id": 622, "seek": 298920, "start": 3001.9199999999996, "end": 3004.64, "text": " technology or CT.", "tokens": [2899, 420, 19529, 13], "temperature": 0.0, "avg_logprob": -0.133574878468233, "compression_ratio": 1.740909090909091, "no_speech_prob": 8.26615905680228e-06}, {"id": 623, "seek": 298920, "start": 3004.64, "end": 3011.08, "text": " And that feature adds integrity to the control flow graph, both to the forward edge and to", "tokens": [400, 300, 4111, 10860, 16000, 281, 264, 1969, 3095, 4295, 11, 1293, 281, 264, 2128, 4691, 293, 281], "temperature": 0.0, "avg_logprob": -0.133574878468233, "compression_ratio": 1.740909090909091, "no_speech_prob": 8.26615905680228e-06}, {"id": 624, "seek": 298920, "start": 3011.08, "end": 3016.7599999999998, "text": " the backward edge and forward edge basically means you protect jumps or calls that jump", "tokens": [264, 23897, 4691, 293, 2128, 4691, 1936, 1355, 291, 2371, 16704, 420, 5498, 300, 3012], "temperature": 0.0, "avg_logprob": -0.133574878468233, "compression_ratio": 1.740909090909091, "no_speech_prob": 8.26615905680228e-06}, {"id": 625, "seek": 301676, "start": 3016.76, "end": 3019.6000000000004, "text": " from one location forward to somewhere else.", "tokens": [490, 472, 4914, 2128, 281, 4079, 1646, 13], "temperature": 0.0, "avg_logprob": -0.10335657643336876, "compression_ratio": 1.7983539094650205, "no_speech_prob": 1.3627312000608072e-05}, {"id": 626, "seek": 301676, "start": 3019.6000000000004, "end": 3025.32, "text": " And the way that this works is that the legitimate jump destination where you want the jump to", "tokens": [400, 264, 636, 300, 341, 1985, 307, 300, 264, 17956, 3012, 12236, 689, 291, 528, 264, 3012, 281], "temperature": 0.0, "avg_logprob": -0.10335657643336876, "compression_ratio": 1.7983539094650205, "no_speech_prob": 1.3627312000608072e-05}, {"id": 627, "seek": 301676, "start": 3025.32, "end": 3030.48, "text": " land, this landing pad, must have a specific end branch instruction placed there.", "tokens": [2117, 11, 341, 11202, 6887, 11, 1633, 362, 257, 2685, 917, 9819, 10951, 7074, 456, 13], "temperature": 0.0, "avg_logprob": -0.10335657643336876, "compression_ratio": 1.7983539094650205, "no_speech_prob": 1.3627312000608072e-05}, {"id": 628, "seek": 301676, "start": 3030.48, "end": 3034.92, "text": " And if you try to jump to a place which doesn't have an end branch landing pad, then you get", "tokens": [400, 498, 291, 853, 281, 3012, 281, 257, 1081, 597, 1177, 380, 362, 364, 917, 9819, 11202, 6887, 11, 550, 291, 483], "temperature": 0.0, "avg_logprob": -0.10335657643336876, "compression_ratio": 1.7983539094650205, "no_speech_prob": 1.3627312000608072e-05}, {"id": 629, "seek": 301676, "start": 3034.92, "end": 3037.6400000000003, "text": " a control flow violation exception.", "tokens": [257, 1969, 3095, 22840, 11183, 13], "temperature": 0.0, "avg_logprob": -0.10335657643336876, "compression_ratio": 1.7983539094650205, "no_speech_prob": 1.3627312000608072e-05}, {"id": 630, "seek": 301676, "start": 3037.6400000000003, "end": 3042.6400000000003, "text": " So you need the help of the compiler to put that landing pad at the beginning of every", "tokens": [407, 291, 643, 264, 854, 295, 264, 31958, 281, 829, 300, 11202, 6887, 412, 264, 2863, 295, 633], "temperature": 0.0, "avg_logprob": -0.10335657643336876, "compression_ratio": 1.7983539094650205, "no_speech_prob": 1.3627312000608072e-05}, {"id": 631, "seek": 304264, "start": 3042.64, "end": 3048.48, "text": " legitimate function and luckily GCC and other compilers have had that support for quite", "tokens": [17956, 2445, 293, 22880, 460, 11717, 293, 661, 715, 388, 433, 362, 632, 300, 1406, 337, 1596], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 632, "seek": 304264, "start": 3048.48, "end": 3049.48, "text": " a while.", "tokens": [257, 1339, 13], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 633, "seek": 304264, "start": 3049.48, "end": 3052.48, "text": " So GCC sends eight and we are now at 12.", "tokens": [407, 460, 11717, 14790, 3180, 293, 321, 366, 586, 412, 2272, 13], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 634, "seek": 304264, "start": 3052.48, "end": 3054.64, "text": " So that works for forward edges.", "tokens": [407, 300, 1985, 337, 2128, 8819, 13], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 635, "seek": 304264, "start": 3054.64, "end": 3058.08, "text": " For backward edges, there's another feature called shadow stack.", "tokens": [1171, 23897, 8819, 11, 456, 311, 1071, 4111, 1219, 8576, 8630, 13], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 636, "seek": 304264, "start": 3058.08, "end": 3064.12, "text": " And that protects the return addresses on your stack and we'll have an example later.", "tokens": [400, 300, 22583, 264, 2736, 16862, 322, 428, 8630, 293, 321, 603, 362, 364, 1365, 1780, 13], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 637, "seek": 304264, "start": 3064.12, "end": 3069.6, "text": " And it basically has a shadow call stack which you can't write to.", "tokens": [400, 309, 1936, 575, 257, 8576, 818, 8630, 597, 291, 393, 380, 2464, 281, 13], "temperature": 0.0, "avg_logprob": -0.1307512822777334, "compression_ratio": 1.6099585062240664, "no_speech_prob": 1.2801748198398855e-05}, {"id": 638, "seek": 306960, "start": 3069.6, "end": 3076.88, "text": " It's protected by paging and if it's writable, then it won't be usable as a shadow stack.", "tokens": [467, 311, 10594, 538, 280, 3568, 293, 498, 309, 311, 10912, 712, 11, 550, 309, 1582, 380, 312, 29975, 382, 257, 8576, 8630, 13], "temperature": 0.0, "avg_logprob": -0.14482310685244473, "compression_ratio": 1.5921052631578947, "no_speech_prob": 9.367084203404374e-06}, {"id": 639, "seek": 306960, "start": 3076.88, "end": 3083.6, "text": " And you can independently compile Nova with branch protection, with return address protection", "tokens": [400, 291, 393, 21761, 31413, 27031, 365, 9819, 6334, 11, 365, 2736, 2985, 6334], "temperature": 0.0, "avg_logprob": -0.14482310685244473, "compression_ratio": 1.5921052631578947, "no_speech_prob": 9.367084203404374e-06}, {"id": 640, "seek": 306960, "start": 3083.6, "end": 3085.7599999999998, "text": " or both.", "tokens": [420, 1293, 13], "temperature": 0.0, "avg_logprob": -0.14482310685244473, "compression_ratio": 1.5921052631578947, "no_speech_prob": 9.367084203404374e-06}, {"id": 641, "seek": 306960, "start": 3085.7599999999998, "end": 3090.3199999999997, "text": " So let's look at indirect branch tracking and I try to come up with a good example and", "tokens": [407, 718, 311, 574, 412, 19523, 9819, 11603, 293, 286, 853, 281, 808, 493, 365, 257, 665, 1365, 293], "temperature": 0.0, "avg_logprob": -0.14482310685244473, "compression_ratio": 1.5921052631578947, "no_speech_prob": 9.367084203404374e-06}, {"id": 642, "seek": 306960, "start": 3090.3199999999997, "end": 3095.44, "text": " I actually found a function in Nova which is suitable to explaining how this works.", "tokens": [286, 767, 1352, 257, 2445, 294, 27031, 597, 307, 12873, 281, 13468, 577, 341, 1985, 13], "temperature": 0.0, "avg_logprob": -0.14482310685244473, "compression_ratio": 1.5921052631578947, "no_speech_prob": 9.367084203404374e-06}, {"id": 643, "seek": 309544, "start": 3095.44, "end": 3102.28, "text": " Nova has a body allocator that can allocate contiguous chunks of memory and that body", "tokens": [27031, 575, 257, 1772, 12660, 1639, 300, 393, 35713, 660, 30525, 24004, 295, 4675, 293, 300, 1772], "temperature": 0.0, "avg_logprob": -0.10972375136155349, "compression_ratio": 1.7606177606177607, "no_speech_prob": 2.317647886229679e-05}, {"id": 644, "seek": 309544, "start": 3102.28, "end": 3107.92, "text": " allocator has a free function where you basically return an address and say free this block.", "tokens": [12660, 1639, 575, 257, 1737, 2445, 689, 291, 1936, 2736, 364, 2985, 293, 584, 1737, 341, 3461, 13], "temperature": 0.0, "avg_logprob": -0.10972375136155349, "compression_ratio": 1.7606177606177607, "no_speech_prob": 2.317647886229679e-05}, {"id": 645, "seek": 309544, "start": 3107.92, "end": 3113.12, "text": " And the function is really as simple as shown there, it just consists of these few instructions", "tokens": [400, 264, 2445, 307, 534, 382, 2199, 382, 4898, 456, 11, 309, 445, 14689, 295, 613, 1326, 9415], "temperature": 0.0, "avg_logprob": -0.10972375136155349, "compression_ratio": 1.7606177606177607, "no_speech_prob": 2.317647886229679e-05}, {"id": 646, "seek": 309544, "start": 3113.12, "end": 3117.88, "text": " because it's a tail call that jumps to some coalescing function here later and you don't", "tokens": [570, 309, 311, 257, 6838, 818, 300, 16704, 281, 512, 598, 4229, 2175, 2445, 510, 1780, 293, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.10972375136155349, "compression_ratio": 1.7606177606177607, "no_speech_prob": 2.317647886229679e-05}, {"id": 647, "seek": 309544, "start": 3117.88, "end": 3123.44, "text": " have to understand all the complicated assembler but suffice it to say that there's a little", "tokens": [362, 281, 1223, 439, 264, 6179, 8438, 1918, 457, 3889, 573, 309, 281, 584, 300, 456, 311, 257, 707], "temperature": 0.0, "avg_logprob": -0.10972375136155349, "compression_ratio": 1.7606177606177607, "no_speech_prob": 2.317647886229679e-05}, {"id": 648, "seek": 312344, "start": 3123.44, "end": 3129.16, "text": " test here of these two instructions which performs some meaningful check and you know", "tokens": [1500, 510, 295, 613, 732, 9415, 597, 26213, 512, 10995, 1520, 293, 291, 458], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 649, "seek": 312344, "start": 3129.16, "end": 3131.52, "text": " that you can't free a null pointer.", "tokens": [300, 291, 393, 380, 1737, 257, 18184, 23918, 13], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 650, "seek": 312344, "start": 3131.52, "end": 3135.96, "text": " So this test checks if the address passed as the first parameter is a null pointer and", "tokens": [407, 341, 1500, 13834, 498, 264, 2985, 4678, 382, 264, 700, 13075, 307, 257, 18184, 23918, 293], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 651, "seek": 312344, "start": 3135.96, "end": 3138.44, "text": " if so it jumps out right here.", "tokens": [498, 370, 309, 16704, 484, 558, 510, 13], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 652, "seek": 312344, "start": 3138.44, "end": 3142.96, "text": " So basically the function does nothing, does no harm, it's basically a knob.", "tokens": [407, 1936, 264, 2445, 775, 1825, 11, 775, 572, 6491, 11, 309, 311, 1936, 257, 26759, 13], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 653, "seek": 312344, "start": 3142.96, "end": 3147.7200000000003, "text": " Let's say an attacker actually wanted to compromise memory and instead of jumping to the beginning", "tokens": [961, 311, 584, 364, 35871, 767, 1415, 281, 18577, 4675, 293, 2602, 295, 11233, 281, 264, 2863], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 654, "seek": 312344, "start": 3147.7200000000003, "end": 3152.64, "text": " of this function, it wanted to jump past that check to this red instruction to bypass the", "tokens": [295, 341, 2445, 11, 309, 1415, 281, 3012, 1791, 300, 1520, 281, 341, 2182, 10951, 281, 24996, 264], "temperature": 0.0, "avg_logprob": -0.1200542532164475, "compression_ratio": 1.816546762589928, "no_speech_prob": 1.363022511213785e-05}, {"id": 655, "seek": 315264, "start": 3152.64, "end": 3154.92, "text": " check and then corrupt memory.", "tokens": [1520, 293, 550, 17366, 4675, 13], "temperature": 0.0, "avg_logprob": -0.12898030573008012, "compression_ratio": 1.7165354330708662, "no_speech_prob": 3.6117564832238713e-06}, {"id": 656, "seek": 315264, "start": 3154.92, "end": 3159.2, "text": " Without control flow enforcement that would be possible if the attacker could gain execution", "tokens": [9129, 1969, 3095, 11475, 300, 576, 312, 1944, 498, 264, 35871, 727, 6052, 15058], "temperature": 0.0, "avg_logprob": -0.12898030573008012, "compression_ratio": 1.7165354330708662, "no_speech_prob": 3.6117564832238713e-06}, {"id": 657, "seek": 315264, "start": 3159.2, "end": 3165.2, "text": " but with control flow it wouldn't work because when you do a call or a jump you have to land", "tokens": [457, 365, 1969, 3095, 309, 2759, 380, 589, 570, 562, 291, 360, 257, 818, 420, 257, 3012, 291, 362, 281, 2117], "temperature": 0.0, "avg_logprob": -0.12898030573008012, "compression_ratio": 1.7165354330708662, "no_speech_prob": 3.6117564832238713e-06}, {"id": 658, "seek": 315264, "start": 3165.2, "end": 3168.92, "text": " on an end branch instruction and the compiler has put that instruction there.", "tokens": [322, 364, 917, 9819, 10951, 293, 264, 31958, 575, 829, 300, 10951, 456, 13], "temperature": 0.0, "avg_logprob": -0.12898030573008012, "compression_ratio": 1.7165354330708662, "no_speech_prob": 3.6117564832238713e-06}, {"id": 659, "seek": 315264, "start": 3168.92, "end": 3173.8399999999997, "text": " So if an attacker managed to get control and tried to jump to a vtable or some indirect", "tokens": [407, 498, 364, 35871, 6453, 281, 483, 1969, 293, 3031, 281, 3012, 281, 257, 371, 23811, 420, 512, 19523], "temperature": 0.0, "avg_logprob": -0.12898030573008012, "compression_ratio": 1.7165354330708662, "no_speech_prob": 3.6117564832238713e-06}, {"id": 660, "seek": 315264, "start": 3173.8399999999997, "end": 3179.3599999999997, "text": " pointer to this address, you would immediately crash.", "tokens": [23918, 281, 341, 2985, 11, 291, 576, 4258, 8252, 13], "temperature": 0.0, "avg_logprob": -0.12898030573008012, "compression_ratio": 1.7165354330708662, "no_speech_prob": 3.6117564832238713e-06}, {"id": 661, "seek": 317936, "start": 3179.36, "end": 3183.56, "text": " So this is how indirect branch tracking works.", "tokens": [407, 341, 307, 577, 19523, 9819, 11603, 1985, 13], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 662, "seek": 317936, "start": 3183.56, "end": 3186.7200000000003, "text": " Shadow stacks work like this.", "tokens": [19036, 30792, 589, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 663, "seek": 317936, "start": 3186.7200000000003, "end": 3190.48, "text": " With a normal data stack you have your local variables on your stack, you have the parameters", "tokens": [2022, 257, 2710, 1412, 8630, 291, 362, 428, 2654, 9102, 322, 428, 8630, 11, 291, 362, 264, 9834], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 664, "seek": 317936, "start": 3190.48, "end": 3194.2400000000002, "text": " for the next function on the stack, so the green function wants to call the blue function", "tokens": [337, 264, 958, 2445, 322, 264, 8630, 11, 370, 264, 3092, 2445, 2738, 281, 818, 264, 3344, 2445], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 665, "seek": 317936, "start": 3194.2400000000002, "end": 3198.0, "text": " and then when you do the call instruction the return address gets put on your stack.", "tokens": [293, 550, 562, 291, 360, 264, 818, 10951, 264, 2736, 2985, 2170, 829, 322, 428, 8630, 13], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 666, "seek": 317936, "start": 3198.0, "end": 3202.4, "text": " Then the blue function puts its local variables on a stack, wants to call the yellow function,", "tokens": [1396, 264, 3344, 2445, 8137, 1080, 2654, 9102, 322, 257, 8630, 11, 2738, 281, 818, 264, 5566, 2445, 11], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 667, "seek": 317936, "start": 3202.4, "end": 3205.8, "text": " puts the parameters for the yellow function on the stack, calls the yellow function so", "tokens": [8137, 264, 9834, 337, 264, 5566, 2445, 322, 264, 8630, 11, 5498, 264, 5566, 2445, 370], "temperature": 0.0, "avg_logprob": -0.11794620802422531, "compression_ratio": 2.2142857142857144, "no_speech_prob": 1.6536214388906956e-06}, {"id": 668, "seek": 320580, "start": 3205.8, "end": 3209.4, "text": " the return address for the blue function gets put on a stack.", "tokens": [264, 2736, 2985, 337, 264, 3344, 2445, 2170, 829, 322, 257, 8630, 13], "temperature": 0.0, "avg_logprob": -0.1527650264593271, "compression_ratio": 1.788, "no_speech_prob": 5.593808964476921e-06}, {"id": 669, "seek": 320580, "start": 3209.4, "end": 3213.84, "text": " And you see in the stack grows downward and you see that the return address always lives", "tokens": [400, 291, 536, 294, 264, 8630, 13156, 24805, 293, 291, 536, 300, 264, 2736, 2985, 1009, 2909], "temperature": 0.0, "avg_logprob": -0.1527650264593271, "compression_ratio": 1.788, "no_speech_prob": 5.593808964476921e-06}, {"id": 670, "seek": 320580, "start": 3213.84, "end": 3215.32, "text": " above the local variables.", "tokens": [3673, 264, 2654, 9102, 13], "temperature": 0.0, "avg_logprob": -0.1527650264593271, "compression_ratio": 1.788, "no_speech_prob": 5.593808964476921e-06}, {"id": 671, "seek": 320580, "start": 3215.32, "end": 3220.6000000000004, "text": " So if your local variables, if you allocate an array on a stack and you don't have proper", "tokens": [407, 498, 428, 2654, 9102, 11, 498, 291, 35713, 364, 10225, 322, 257, 8630, 293, 291, 500, 380, 362, 2296], "temperature": 0.0, "avg_logprob": -0.1527650264593271, "compression_ratio": 1.788, "no_speech_prob": 5.593808964476921e-06}, {"id": 672, "seek": 320580, "start": 3220.6000000000004, "end": 3225.1200000000003, "text": " bounds checking, it's possible to override the return address by writing past the array", "tokens": [29905, 8568, 11, 309, 311, 1944, 281, 42321, 264, 2736, 2985, 538, 3579, 1791, 264, 10225], "temperature": 0.0, "avg_logprob": -0.1527650264593271, "compression_ratio": 1.788, "no_speech_prob": 5.593808964476921e-06}, {"id": 673, "seek": 320580, "start": 3225.1200000000003, "end": 3230.8, "text": " and this is a popular attack technique, buffer overflow exploits that you find in the wild.", "tokens": [293, 341, 307, 257, 3743, 2690, 6532, 11, 21762, 37772, 12382, 1208, 300, 291, 915, 294, 264, 4868, 13], "temperature": 0.0, "avg_logprob": -0.1527650264593271, "compression_ratio": 1.788, "no_speech_prob": 5.593808964476921e-06}, {"id": 674, "seek": 323080, "start": 3230.8, "end": 3239.1600000000003, "text": " So if you have code that is potentially susceptible to these kind of return address overrides,", "tokens": [407, 498, 291, 362, 3089, 300, 307, 7263, 31249, 281, 613, 733, 295, 2736, 2985, 670, 81, 1875, 11], "temperature": 0.0, "avg_logprob": -0.13203486829701036, "compression_ratio": 1.7786561264822134, "no_speech_prob": 4.936501227348344e-06}, {"id": 675, "seek": 323080, "start": 3239.1600000000003, "end": 3241.32, "text": " then you could benefit from shadow stacks.", "tokens": [550, 291, 727, 5121, 490, 8576, 30792, 13], "temperature": 0.0, "avg_logprob": -0.13203486829701036, "compression_ratio": 1.7786561264822134, "no_speech_prob": 4.936501227348344e-06}, {"id": 676, "seek": 323080, "start": 3241.32, "end": 3247.2400000000002, "text": " And the way that this works is there's a separate stack, this shadow stack, which is protected", "tokens": [400, 264, 636, 300, 341, 1985, 307, 456, 311, 257, 4994, 8630, 11, 341, 8576, 8630, 11, 597, 307, 10594], "temperature": 0.0, "avg_logprob": -0.13203486829701036, "compression_ratio": 1.7786561264822134, "no_speech_prob": 4.936501227348344e-06}, {"id": 677, "seek": 323080, "start": 3247.2400000000002, "end": 3251.36, "text": " by paging so you can't write to it with any ordinary memory instructions, it's basically", "tokens": [538, 280, 3568, 370, 291, 393, 380, 2464, 281, 309, 365, 604, 10547, 4675, 9415, 11, 309, 311, 1936], "temperature": 0.0, "avg_logprob": -0.13203486829701036, "compression_ratio": 1.7786561264822134, "no_speech_prob": 4.936501227348344e-06}, {"id": 678, "seek": 323080, "start": 3251.36, "end": 3256.84, "text": " invisible and the only instructions that can write to it are call and read instructions", "tokens": [14603, 293, 264, 787, 9415, 300, 393, 2464, 281, 309, 366, 818, 293, 1401, 9415], "temperature": 0.0, "avg_logprob": -0.13203486829701036, "compression_ratio": 1.7786561264822134, "no_speech_prob": 4.936501227348344e-06}, {"id": 679, "seek": 323080, "start": 3256.84, "end": 3259.2000000000003, "text": " and some shadow management instructions.", "tokens": [293, 512, 8576, 4592, 9415, 13], "temperature": 0.0, "avg_logprob": -0.13203486829701036, "compression_ratio": 1.7786561264822134, "no_speech_prob": 4.936501227348344e-06}, {"id": 680, "seek": 325920, "start": 3259.2, "end": 3262.8399999999997, "text": " And when the green function calls the blue function, the return address will not just", "tokens": [400, 562, 264, 3092, 2445, 5498, 264, 3344, 2445, 11, 264, 2736, 2985, 486, 406, 445], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 681, "seek": 325920, "start": 3262.8399999999997, "end": 3267.6, "text": " be put on the ordinary data stack, but will additionally be put on the shadow stack and", "tokens": [312, 829, 322, 264, 10547, 1412, 8630, 11, 457, 486, 43181, 312, 829, 322, 264, 8576, 8630, 293], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 682, "seek": 325920, "start": 3267.6, "end": 3269.96, "text": " likewise with the blue and the yellow return address.", "tokens": [32407, 365, 264, 3344, 293, 264, 5566, 2736, 2985, 13], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 683, "seek": 325920, "start": 3269.96, "end": 3274.56, "text": " And whenever you execute a return instruction, the hardware will compare the two return addresses", "tokens": [400, 5699, 291, 14483, 257, 2736, 10951, 11, 264, 8837, 486, 6794, 264, 732, 2736, 16862], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 684, "seek": 325920, "start": 3274.56, "end": 3278.8799999999997, "text": " that it pops off the two stacks and if they don't match, you again get a control flow", "tokens": [300, 309, 16795, 766, 264, 732, 30792, 293, 498, 436, 500, 380, 2995, 11, 291, 797, 483, 257, 1969, 3095], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 685, "seek": 325920, "start": 3278.8799999999997, "end": 3280.8799999999997, "text": " violation.", "tokens": [22840, 13], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 686, "seek": 325920, "start": 3280.8799999999997, "end": 3286.68, "text": " So that way, you can protect the backward edge of the control flow graph also using", "tokens": [407, 300, 636, 11, 291, 393, 2371, 264, 23897, 4691, 295, 264, 1969, 3095, 4295, 611, 1228], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 687, "seek": 325920, "start": 3286.68, "end": 3287.68, "text": " shadow stacks.", "tokens": [8576, 30792, 13], "temperature": 0.0, "avg_logprob": -0.11203304131825766, "compression_ratio": 1.9225092250922509, "no_speech_prob": 4.784657903655898e-06}, {"id": 688, "seek": 328768, "start": 3287.68, "end": 3292.16, "text": " There's a feature that NOVA uses on Tiger Lake and all the lake and platforms beyond", "tokens": [821, 311, 257, 4111, 300, 9146, 20914, 4960, 322, 22025, 10582, 293, 439, 264, 11001, 293, 9473, 4399], "temperature": 0.0, "avg_logprob": -0.1916879553543894, "compression_ratio": 1.728448275862069, "no_speech_prob": 1.9521412468748167e-05}, {"id": 689, "seek": 328768, "start": 3292.16, "end": 3295.96, "text": " that that have this feature.", "tokens": [300, 300, 362, 341, 4111, 13], "temperature": 0.0, "avg_logprob": -0.1916879553543894, "compression_ratio": 1.728448275862069, "no_speech_prob": 1.9521412468748167e-05}, {"id": 690, "seek": 328768, "start": 3295.96, "end": 3296.96, "text": " But there's a problem.", "tokens": [583, 456, 311, 257, 1154, 13], "temperature": 0.0, "avg_logprob": -0.1916879553543894, "compression_ratio": 1.728448275862069, "no_speech_prob": 1.9521412468748167e-05}, {"id": 691, "seek": 328768, "start": 3296.96, "end": 3305.8799999999997, "text": " And the problem is that using shadow stack instructions is possible on newer CPUs that", "tokens": [400, 264, 1154, 307, 300, 1228, 8576, 8630, 9415, 307, 1944, 322, 17628, 13199, 82, 300], "temperature": 0.0, "avg_logprob": -0.1916879553543894, "compression_ratio": 1.728448275862069, "no_speech_prob": 1.9521412468748167e-05}, {"id": 692, "seek": 328768, "start": 3305.8799999999997, "end": 3310.2799999999997, "text": " have these instructions, that basically have this ISA extension, but if you have a binary", "tokens": [362, 613, 9415, 11, 300, 1936, 362, 341, 6205, 32, 10320, 11, 457, 498, 291, 362, 257, 17434], "temperature": 0.0, "avg_logprob": -0.1916879553543894, "compression_ratio": 1.728448275862069, "no_speech_prob": 1.9521412468748167e-05}, {"id": 693, "seek": 328768, "start": 3310.2799999999997, "end": 3316.24, "text": " containing those instructions, it would crash on older CPUs that don't comprehend that.", "tokens": [19273, 729, 9415, 11, 309, 576, 8252, 322, 4906, 13199, 82, 300, 500, 380, 38183, 300, 13], "temperature": 0.0, "avg_logprob": -0.1916879553543894, "compression_ratio": 1.728448275862069, "no_speech_prob": 1.9521412468748167e-05}, {"id": 694, "seek": 331624, "start": 3316.24, "end": 3320.8399999999997, "text": " And luckily, Intel defined the end branch instruction to be a knob, but some shadow stack", "tokens": [400, 22880, 11, 19762, 7642, 264, 917, 9819, 10951, 281, 312, 257, 26759, 11, 457, 512, 8576, 8630], "temperature": 0.0, "avg_logprob": -0.16982815113473446, "compression_ratio": 1.5238095238095237, "no_speech_prob": 1.0128508620255161e-05}, {"id": 695, "seek": 331624, "start": 3320.8399999999997, "end": 3322.68, "text": " instructions are not knobs.", "tokens": [9415, 366, 406, 46999, 13], "temperature": 0.0, "avg_logprob": -0.16982815113473446, "compression_ratio": 1.5238095238095237, "no_speech_prob": 1.0128508620255161e-05}, {"id": 696, "seek": 331624, "start": 3322.68, "end": 3331.9199999999996, "text": " So if you try to execute a CET and able NOVA binary on something older without other effort,", "tokens": [407, 498, 291, 853, 281, 14483, 257, 383, 4850, 293, 1075, 9146, 20914, 17434, 322, 746, 4906, 1553, 661, 4630, 11], "temperature": 0.0, "avg_logprob": -0.16982815113473446, "compression_ratio": 1.5238095238095237, "no_speech_prob": 1.0128508620255161e-05}, {"id": 697, "seek": 331624, "start": 3331.9199999999996, "end": 3332.9199999999996, "text": " it might crash.", "tokens": [309, 1062, 8252, 13], "temperature": 0.0, "avg_logprob": -0.16982815113473446, "compression_ratio": 1.5238095238095237, "no_speech_prob": 1.0128508620255161e-05}, {"id": 698, "seek": 331624, "start": 3332.9199999999996, "end": 3335.02, "text": " So obviously, we don't want that.", "tokens": [407, 2745, 11, 321, 500, 380, 528, 300, 13], "temperature": 0.0, "avg_logprob": -0.16982815113473446, "compression_ratio": 1.5238095238095237, "no_speech_prob": 1.0128508620255161e-05}, {"id": 699, "seek": 331624, "start": 3335.02, "end": 3344.04, "text": " So what NOVA does instead, it detects at runtime whether CET is supported and if CET is not", "tokens": [407, 437, 9146, 20914, 775, 2602, 11, 309, 5531, 82, 412, 34474, 1968, 383, 4850, 307, 8104, 293, 498, 383, 4850, 307, 406], "temperature": 0.0, "avg_logprob": -0.16982815113473446, "compression_ratio": 1.5238095238095237, "no_speech_prob": 1.0128508620255161e-05}, {"id": 700, "seek": 334404, "start": 3344.04, "end": 3352.0, "text": " supported, it patches out all these CET instructions in the existing binary to turn them into knobs.", "tokens": [8104, 11, 309, 26531, 484, 439, 613, 383, 4850, 9415, 294, 264, 6741, 17434, 281, 1261, 552, 666, 46999, 13], "temperature": 0.0, "avg_logprob": -0.1308311974560773, "compression_ratio": 1.73992673992674, "no_speech_prob": 2.2120602807262912e-05}, {"id": 701, "seek": 334404, "start": 3352.0, "end": 3355.96, "text": " And obviously, being a microkernel, we try to generalize the mechanism.", "tokens": [400, 2745, 11, 885, 257, 4532, 74, 1248, 338, 11, 321, 853, 281, 2674, 1125, 264, 7513, 13], "temperature": 0.0, "avg_logprob": -0.1308311974560773, "compression_ratio": 1.73992673992674, "no_speech_prob": 2.2120602807262912e-05}, {"id": 702, "seek": 334404, "start": 3355.96, "end": 3360.2799999999997, "text": " So we generalize that mechanism to be able to rewrite arbitrary assembler snippets from", "tokens": [407, 321, 2674, 1125, 300, 7513, 281, 312, 1075, 281, 28132, 23211, 8438, 1918, 35623, 1385, 490], "temperature": 0.0, "avg_logprob": -0.1308311974560773, "compression_ratio": 1.73992673992674, "no_speech_prob": 2.2120602807262912e-05}, {"id": 703, "seek": 334404, "start": 3360.2799999999997, "end": 3362.48, "text": " one version to another version.", "tokens": [472, 3037, 281, 1071, 3037, 13], "temperature": 0.0, "avg_logprob": -0.1308311974560773, "compression_ratio": 1.73992673992674, "no_speech_prob": 2.2120602807262912e-05}, {"id": 704, "seek": 334404, "start": 3362.48, "end": 3366.48, "text": " And there's other examples for newer instructions that do better work than older instructions", "tokens": [400, 456, 311, 661, 5110, 337, 17628, 9415, 300, 360, 1101, 589, 813, 4906, 9415], "temperature": 0.0, "avg_logprob": -0.1308311974560773, "compression_ratio": 1.73992673992674, "no_speech_prob": 2.2120602807262912e-05}, {"id": 705, "seek": 334404, "start": 3366.48, "end": 3371.7599999999998, "text": " like the Xsave feature set, which can save supervisor state or save floating point state", "tokens": [411, 264, 1783, 82, 946, 4111, 992, 11, 597, 393, 3155, 24610, 1785, 420, 3155, 12607, 935, 1785], "temperature": 0.0, "avg_logprob": -0.1308311974560773, "compression_ratio": 1.73992673992674, "no_speech_prob": 2.2120602807262912e-05}, {"id": 706, "seek": 337176, "start": 3371.76, "end": 3373.96, "text": " in a compact format.", "tokens": [294, 257, 14679, 7877, 13], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 707, "seek": 337176, "start": 3373.96, "end": 3380.48, "text": " And the binary, as you build it originally, always uses the most sophisticated version.", "tokens": [400, 264, 17434, 11, 382, 291, 1322, 309, 7993, 11, 1009, 4960, 264, 881, 16950, 3037, 13], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 708, "seek": 337176, "start": 3380.48, "end": 3383.5600000000004, "text": " So it uses the most advanced instruction that you can find.", "tokens": [407, 309, 4960, 264, 881, 7339, 10951, 300, 291, 393, 915, 13], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 709, "seek": 337176, "start": 3383.5600000000004, "end": 3388.4, "text": " And if we run that on some CPU, which doesn't support the instruction or which supports", "tokens": [400, 498, 321, 1190, 300, 322, 512, 13199, 11, 597, 1177, 380, 1406, 264, 10951, 420, 597, 9346], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 710, "seek": 337176, "start": 3388.4, "end": 3393.44, "text": " some older instruction, then we use code patching to rewrite the newer instruction into the", "tokens": [512, 4906, 10951, 11, 550, 321, 764, 3089, 9972, 278, 281, 28132, 264, 17628, 10951, 666, 264], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 711, "seek": 337176, "start": 3393.44, "end": 3394.44, "text": " older one.", "tokens": [4906, 472, 13], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 712, "seek": 337176, "start": 3394.44, "end": 3400.2400000000002, "text": " So the binary automatically adjusts to the feature set of the underlying hardware.", "tokens": [407, 264, 17434, 6772, 4369, 82, 281, 264, 4111, 992, 295, 264, 14217, 8837, 13], "temperature": 0.0, "avg_logprob": -0.09763967643663721, "compression_ratio": 1.768, "no_speech_prob": 1.112401150749065e-05}, {"id": 713, "seek": 340024, "start": 3400.24, "end": 3405.52, "text": " The newer your CPU, the less patching occurs, but it works quite well.", "tokens": [440, 17628, 428, 13199, 11, 264, 1570, 9972, 278, 11843, 11, 457, 309, 1985, 1596, 731, 13], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 714, "seek": 340024, "start": 3405.52, "end": 3409.4799999999996, "text": " And the reason we chose this approach, because the alternatives aren't actually great.", "tokens": [400, 264, 1778, 321, 5111, 341, 3109, 11, 570, 264, 20478, 3212, 380, 767, 869, 13], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 715, "seek": 340024, "start": 3409.4799999999996, "end": 3413.7999999999997, "text": " So the alternatives would have been that you put some if-defs in your code and you say,", "tokens": [407, 264, 20478, 576, 362, 668, 300, 291, 829, 512, 498, 12, 1479, 16883, 294, 428, 3089, 293, 291, 584, 11], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 716, "seek": 340024, "start": 3413.7999999999997, "end": 3417.24, "text": " if they've CET, use the CET instructions, and otherwise don't.", "tokens": [498, 436, 600, 383, 4850, 11, 764, 264, 383, 4850, 9415, 11, 293, 5911, 500, 380, 13], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 717, "seek": 340024, "start": 3417.24, "end": 3421.3599999999997, "text": " And then you force your customers or your community to always compile the binary the", "tokens": [400, 550, 291, 3464, 428, 4581, 420, 428, 1768, 281, 1009, 31413, 264, 17434, 264], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 718, "seek": 340024, "start": 3421.3599999999997, "end": 3424.08, "text": " right way, and that doesn't scale.", "tokens": [558, 636, 11, 293, 300, 1177, 380, 4373, 13], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 719, "seek": 340024, "start": 3424.08, "end": 3429.2799999999997, "text": " The other option could have been that you put some if-then-else, you say, if CET is supported,", "tokens": [440, 661, 3614, 727, 362, 668, 300, 291, 829, 512, 498, 12, 19096, 12, 44408, 11, 291, 584, 11, 498, 383, 4850, 307, 8104, 11], "temperature": 0.0, "avg_logprob": -0.15200206812690287, "compression_ratio": 1.7849829351535835, "no_speech_prob": 1.3209058124630246e-05}, {"id": 720, "seek": 342928, "start": 3429.28, "end": 3431.4, "text": " do this, otherwise do that.", "tokens": [360, 341, 11, 5911, 360, 300, 13], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 721, "seek": 342928, "start": 3431.4, "end": 3434.0400000000004, "text": " And that would be a runtime check every time.", "tokens": [400, 300, 576, 312, 257, 34474, 1520, 633, 565, 13], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 722, "seek": 342928, "start": 3434.0400000000004, "end": 3439.2000000000003, "text": " And that runtime check is prohibitive in certain code paths, like NT paths, where you simply", "tokens": [400, 300, 34474, 1520, 307, 16015, 2187, 294, 1629, 3089, 14518, 11, 411, 43452, 14518, 11, 689, 291, 2935], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 723, "seek": 342928, "start": 3439.2000000000003, "end": 3444.0400000000004, "text": " don't have any register-free for doing this check because you have to save them all.", "tokens": [500, 380, 362, 604, 7280, 12, 10792, 337, 884, 341, 1520, 570, 291, 362, 281, 3155, 552, 439, 13], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 724, "seek": 342928, "start": 3444.0400000000004, "end": 3449.0800000000004, "text": " But in order to save them, you already need to know whether Shadows.Tex are supported", "tokens": [583, 294, 1668, 281, 3155, 552, 11, 291, 1217, 643, 281, 458, 1968, 1160, 33480, 13, 51, 3121, 366, 8104], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 725, "seek": 342928, "start": 3449.0800000000004, "end": 3450.0800000000004, "text": " or not.", "tokens": [420, 406, 13], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 726, "seek": 342928, "start": 3450.0800000000004, "end": 3456.2400000000002, "text": " So doing this feature check at boot time and rewriting the binary to the suitable instruction", "tokens": [407, 884, 341, 4111, 1520, 412, 11450, 565, 293, 319, 19868, 264, 17434, 281, 264, 12873, 10951], "temperature": 0.0, "avg_logprob": -0.1627119425180796, "compression_ratio": 1.71484375, "no_speech_prob": 1.183954555017408e-05}, {"id": 727, "seek": 345624, "start": 3456.24, "end": 3459.54, "text": " is what we do, and that works great.", "tokens": [307, 437, 321, 360, 11, 293, 300, 1985, 869, 13], "temperature": 0.0, "avg_logprob": -0.16068391345796132, "compression_ratio": 1.608695652173913, "no_speech_prob": 1.2603931281773839e-05}, {"id": 728, "seek": 345624, "start": 3459.54, "end": 3466.08, "text": " So the way it works is you declare some assembler snippets, like Xsave S is the preferred version.", "tokens": [407, 264, 636, 309, 1985, 307, 291, 19710, 512, 8438, 1918, 35623, 1385, 11, 411, 1783, 82, 946, 318, 307, 264, 16494, 3037, 13], "temperature": 0.0, "avg_logprob": -0.16068391345796132, "compression_ratio": 1.608695652173913, "no_speech_prob": 1.2603931281773839e-05}, {"id": 729, "seek": 345624, "start": 3466.08, "end": 3472.24, "text": " If Xsave S is not supported, the snippet gets rewritten to Xsave, or a Shadows.Tex instruction", "tokens": [759, 1783, 82, 946, 318, 307, 406, 8104, 11, 264, 35623, 302, 2170, 319, 26859, 281, 1783, 82, 946, 11, 420, 257, 1160, 33480, 13, 51, 3121, 10951], "temperature": 0.0, "avg_logprob": -0.16068391345796132, "compression_ratio": 1.608695652173913, "no_speech_prob": 1.2603931281773839e-05}, {"id": 730, "seek": 345624, "start": 3472.24, "end": 3476.56, "text": " gets rewritten to a knob.", "tokens": [2170, 319, 26859, 281, 257, 26759, 13], "temperature": 0.0, "avg_logprob": -0.16068391345796132, "compression_ratio": 1.608695652173913, "no_speech_prob": 1.2603931281773839e-05}, {"id": 731, "seek": 345624, "start": 3476.56, "end": 3481.4399999999996, "text": " We don't need to patch any high-level C++ functions because they never compile to those", "tokens": [492, 500, 380, 643, 281, 9972, 604, 1090, 12, 12418, 383, 25472, 6828, 570, 436, 1128, 31413, 281, 729], "temperature": 0.0, "avg_logprob": -0.16068391345796132, "compression_ratio": 1.608695652173913, "no_speech_prob": 1.2603931281773839e-05}, {"id": 732, "seek": 345624, "start": 3481.4399999999996, "end": 3483.8399999999997, "text": " complicated instructions.", "tokens": [6179, 9415, 13], "temperature": 0.0, "avg_logprob": -0.16068391345796132, "compression_ratio": 1.608695652173913, "no_speech_prob": 1.2603931281773839e-05}, {"id": 733, "seek": 348384, "start": 3483.84, "end": 3489.7400000000002, "text": " And yeah, we basically have a binary that automatically adjusts.", "tokens": [400, 1338, 11, 321, 1936, 362, 257, 17434, 300, 6772, 4369, 82, 13], "temperature": 0.0, "avg_logprob": -0.12537947665439564, "compression_ratio": 1.5321888412017168, "no_speech_prob": 2.2104610252426937e-05}, {"id": 734, "seek": 348384, "start": 3489.7400000000002, "end": 3496.32, "text": " So finally, let's take a look at performance because IPC performance is still a relevant", "tokens": [407, 2721, 11, 718, 311, 747, 257, 574, 412, 3389, 570, 8671, 34, 3389, 307, 920, 257, 7340], "temperature": 0.0, "avg_logprob": -0.12537947665439564, "compression_ratio": 1.5321888412017168, "no_speech_prob": 2.2104610252426937e-05}, {"id": 735, "seek": 348384, "start": 3496.32, "end": 3501.08, "text": " metric if you want to be not just small but also fast.", "tokens": [20678, 498, 291, 528, 281, 312, 406, 445, 1359, 457, 611, 2370, 13], "temperature": 0.0, "avg_logprob": -0.12537947665439564, "compression_ratio": 1.5321888412017168, "no_speech_prob": 2.2104610252426937e-05}, {"id": 736, "seek": 348384, "start": 3501.08, "end": 3507.52, "text": " And the blue bars here in the slide show Nova's baseline performance on modern Intel", "tokens": [400, 264, 3344, 10228, 510, 294, 264, 4137, 855, 27031, 311, 20518, 3389, 322, 4363, 19762], "temperature": 0.0, "avg_logprob": -0.12537947665439564, "compression_ratio": 1.5321888412017168, "no_speech_prob": 2.2104610252426937e-05}, {"id": 737, "seek": 348384, "start": 3507.52, "end": 3512.36, "text": " platforms like NUC12 with Alder Lake and NUC11 with Tiger Lake.", "tokens": [9473, 411, 426, 23967, 4762, 365, 24031, 260, 10582, 293, 426, 23967, 5348, 365, 22025, 10582, 13], "temperature": 0.0, "avg_logprob": -0.12537947665439564, "compression_ratio": 1.5321888412017168, "no_speech_prob": 2.2104610252426937e-05}, {"id": 738, "seek": 351236, "start": 3512.36, "end": 3517.2400000000002, "text": " And you can see that if you do an IPC between two threads in the same address space, it's", "tokens": [400, 291, 393, 536, 300, 498, 291, 360, 364, 8671, 34, 1296, 732, 19314, 294, 264, 912, 2985, 1901, 11, 309, 311], "temperature": 0.0, "avg_logprob": -0.12198183829324287, "compression_ratio": 1.6433823529411764, "no_speech_prob": 1.044895270752022e-05}, {"id": 739, "seek": 351236, "start": 3517.2400000000002, "end": 3521.36, "text": " really in the low nanosecond range, like 200 and some cycles.", "tokens": [534, 294, 264, 2295, 14067, 541, 18882, 3613, 11, 411, 2331, 293, 512, 17796, 13], "temperature": 0.0, "avg_logprob": -0.12198183829324287, "compression_ratio": 1.6433823529411764, "no_speech_prob": 1.044895270752022e-05}, {"id": 740, "seek": 351236, "start": 3521.36, "end": 3525.88, "text": " If you cross address spaces, you have to switch page tables, you have to maybe switch class", "tokens": [759, 291, 3278, 2985, 7673, 11, 291, 362, 281, 3679, 3028, 8020, 11, 291, 362, 281, 1310, 3679, 1508], "temperature": 0.0, "avg_logprob": -0.12198183829324287, "compression_ratio": 1.6433823529411764, "no_speech_prob": 1.044895270752022e-05}, {"id": 741, "seek": 351236, "start": 3525.88, "end": 3531.76, "text": " of service, then it takes 536 cycles.", "tokens": [295, 2643, 11, 550, 309, 2516, 1025, 11309, 17796, 13], "temperature": 0.0, "avg_logprob": -0.12198183829324287, "compression_ratio": 1.6433823529411764, "no_speech_prob": 1.044895270752022e-05}, {"id": 742, "seek": 351236, "start": 3531.76, "end": 3535.52, "text": " And it's comparable on other micro-architectures, but the interesting thing that I want to", "tokens": [400, 309, 311, 25323, 322, 661, 4532, 12, 1178, 5739, 1303, 11, 457, 264, 1880, 551, 300, 286, 528, 281], "temperature": 0.0, "avg_logprob": -0.12198183829324287, "compression_ratio": 1.6433823529411764, "no_speech_prob": 1.044895270752022e-05}, {"id": 743, "seek": 351236, "start": 3535.52, "end": 3541.28, "text": " show with this slide is that there's overhead for control flow protection.", "tokens": [855, 365, 341, 4137, 307, 300, 456, 311, 19922, 337, 1969, 3095, 6334, 13], "temperature": 0.0, "avg_logprob": -0.12198183829324287, "compression_ratio": 1.6433823529411764, "no_speech_prob": 1.044895270752022e-05}, {"id": 744, "seek": 354128, "start": 3541.28, "end": 3550.2000000000003, "text": " So if you just enable indirect branch tracking, the performance overhead is some 13% to 15%.", "tokens": [407, 498, 291, 445, 9528, 19523, 9819, 11603, 11, 264, 3389, 19922, 307, 512, 3705, 4, 281, 2119, 6856], "temperature": 0.0, "avg_logprob": -0.13782414146091626, "compression_ratio": 1.771551724137931, "no_speech_prob": 6.143163773231208e-06}, {"id": 745, "seek": 354128, "start": 3550.2000000000003, "end": 3555.52, "text": " If you enable shadow stacks, the performance overhead is increased some more.", "tokens": [759, 291, 9528, 8576, 30792, 11, 264, 3389, 19922, 307, 6505, 512, 544, 13], "temperature": 0.0, "avg_logprob": -0.13782414146091626, "compression_ratio": 1.771551724137931, "no_speech_prob": 6.143163773231208e-06}, {"id": 746, "seek": 354128, "start": 3555.52, "end": 3561.0400000000004, "text": " And if you enable the full control flow protection, the performance overhead is in the relevant", "tokens": [400, 498, 291, 9528, 264, 1577, 1969, 3095, 6334, 11, 264, 3389, 19922, 307, 294, 264, 7340], "temperature": 0.0, "avg_logprob": -0.13782414146091626, "compression_ratio": 1.771551724137931, "no_speech_prob": 6.143163773231208e-06}, {"id": 747, "seek": 354128, "start": 3561.0400000000004, "end": 3565.0, "text": " case, which is the cross address space case, it's up to 30%.", "tokens": [1389, 11, 597, 307, 264, 3278, 2985, 1901, 1389, 11, 309, 311, 493, 281, 2217, 6856], "temperature": 0.0, "avg_logprob": -0.13782414146091626, "compression_ratio": 1.771551724137931, "no_speech_prob": 6.143163773231208e-06}, {"id": 748, "seek": 354128, "start": 3565.0, "end": 3569.6400000000003, "text": " So users can freely choose through these compile time options what level of control", "tokens": [407, 5022, 393, 16433, 2826, 807, 613, 31413, 565, 3956, 437, 1496, 295, 1969], "temperature": 0.0, "avg_logprob": -0.13782414146091626, "compression_ratio": 1.771551724137931, "no_speech_prob": 6.143163773231208e-06}, {"id": 749, "seek": 356964, "start": 3569.64, "end": 3575.2, "text": " flow protection they are willing to trade for what in decrease in performance.", "tokens": [3095, 6334, 436, 366, 4950, 281, 4923, 337, 437, 294, 11514, 294, 3389, 13], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 750, "seek": 356964, "start": 3575.2, "end": 3581.04, "text": " So the numbers are basically just ballpark figures to give people feeling for if I use", "tokens": [407, 264, 3547, 366, 1936, 445, 2594, 31239, 9624, 281, 976, 561, 2633, 337, 498, 286, 764], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 751, "seek": 356964, "start": 3581.04, "end": 3584.8799999999997, "text": " this feature, how much IPC performance do I lose?", "tokens": [341, 4111, 11, 577, 709, 8671, 34, 3389, 360, 286, 3624, 30], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 752, "seek": 356964, "start": 3584.8799999999997, "end": 3587.04, "text": " So with that, I'm at the end of my talk.", "tokens": [407, 365, 300, 11, 286, 478, 412, 264, 917, 295, 452, 751, 13], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 753, "seek": 356964, "start": 3587.04, "end": 3591.64, "text": " There are some links here where you can download releases, where you can find more information.", "tokens": [821, 366, 512, 6123, 510, 689, 291, 393, 5484, 16952, 11, 689, 291, 393, 915, 544, 1589, 13], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 754, "seek": 356964, "start": 3591.64, "end": 3594.0, "text": " And now I'll open it up for questions.", "tokens": [400, 586, 286, 603, 1269, 309, 493, 337, 1651, 13], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 755, "seek": 356964, "start": 3594.0, "end": 3597.0, "text": " Thank you so much, Udon.", "tokens": [1044, 291, 370, 709, 11, 624, 13966, 13], "temperature": 0.0, "avg_logprob": -0.21179960392139577, "compression_ratio": 1.5877862595419847, "no_speech_prob": 0.00018611516861710697}, {"id": 756, "seek": 359700, "start": 3597.0, "end": 3601.2, "text": " So we have time for some questions.", "tokens": [407, 321, 362, 565, 337, 512, 1651, 13], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 757, "seek": 359700, "start": 3601.2, "end": 3602.2, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 758, "seek": 359700, "start": 3602.2, "end": 3603.96, "text": " And then you're partying.", "tokens": [400, 550, 291, 434, 644, 1840, 13], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 759, "seek": 359700, "start": 3603.96, "end": 3604.96, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 760, "seek": 359700, "start": 3604.96, "end": 3614.88, "text": " It was really, really nice talk with us to see how many new things are in Nova.", "tokens": [467, 390, 534, 11, 534, 1481, 751, 365, 505, 281, 536, 577, 867, 777, 721, 366, 294, 27031, 13], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 761, "seek": 359700, "start": 3614.88, "end": 3621.4, "text": " One thing I would like to ask is you mentioned that page table code is formally verified", "tokens": [1485, 551, 286, 576, 411, 281, 1029, 307, 291, 2835, 300, 3028, 3199, 3089, 307, 25983, 31197], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 762, "seek": 359700, "start": 3621.4, "end": 3623.92, "text": " and that it's also lock free.", "tokens": [293, 300, 309, 311, 611, 4017, 1737, 13], "temperature": 0.0, "avg_logprob": -0.37709650993347166, "compression_ratio": 1.4427083333333333, "no_speech_prob": 0.0035510784946382046}, {"id": 763, "seek": 362392, "start": 3623.92, "end": 3630.36, "text": " What tools did you use for formal verification, especially in regards of memory model for", "tokens": [708, 3873, 630, 291, 764, 337, 9860, 30206, 11, 2318, 294, 14258, 295, 4675, 2316, 337], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 764, "seek": 362392, "start": 3630.36, "end": 3631.36, "text": " verification?", "tokens": [30206, 30], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 765, "seek": 362392, "start": 3631.36, "end": 3632.36, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 766, "seek": 362392, "start": 3632.36, "end": 3636.56, "text": " So I must say that I'm not a formal verification expert, but I obviously have regular meetings", "tokens": [407, 286, 1633, 584, 300, 286, 478, 406, 257, 9860, 30206, 5844, 11, 457, 286, 2745, 362, 3890, 8410], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 767, "seek": 362392, "start": 3636.56, "end": 3638.52, "text": " and discussions with all the people.", "tokens": [293, 11088, 365, 439, 264, 561, 13], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 768, "seek": 362392, "start": 3638.52, "end": 3644.8, "text": " And the tools that we are using is the Koch theorem for basically doing the proofs.", "tokens": [400, 264, 3873, 300, 321, 366, 1228, 307, 264, 40401, 20904, 337, 1936, 884, 264, 8177, 82, 13], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 769, "seek": 362392, "start": 3644.8, "end": 3651.04, "text": " But for concurrent verification, there's a tool called iris that implements separation", "tokens": [583, 337, 37702, 30206, 11, 456, 311, 257, 2290, 1219, 3418, 271, 300, 704, 17988, 14634], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 770, "seek": 362392, "start": 3651.04, "end": 3652.04, "text": " logic.", "tokens": [9952, 13], "temperature": 0.0, "avg_logprob": -0.2425843040541847, "compression_ratio": 1.669291338582677, "no_speech_prob": 0.00038352893898263574}, {"id": 771, "seek": 365204, "start": 3652.04, "end": 3660.96, "text": " Well, the memory model that we verify depends on whether you're talking about x86 or ARM.", "tokens": [1042, 11, 264, 4675, 2316, 300, 321, 16888, 5946, 322, 1968, 291, 434, 1417, 466, 2031, 22193, 420, 45209, 13], "temperature": 0.0, "avg_logprob": -0.22402088293868505, "compression_ratio": 1.4748858447488584, "no_speech_prob": 0.00016962907102424651}, {"id": 772, "seek": 365204, "start": 3660.96, "end": 3665.92, "text": " For ARM, we're using multi-copy atomic memory model.", "tokens": [1171, 45209, 11, 321, 434, 1228, 4825, 12, 13084, 88, 22275, 4675, 2316, 13], "temperature": 0.0, "avg_logprob": -0.22402088293868505, "compression_ratio": 1.4748858447488584, "no_speech_prob": 0.00016962907102424651}, {"id": 773, "seek": 365204, "start": 3665.92, "end": 3670.68, "text": " Also, thanks for the talk.", "tokens": [2743, 11, 3231, 337, 264, 751, 13], "temperature": 0.0, "avg_logprob": -0.22402088293868505, "compression_ratio": 1.4748858447488584, "no_speech_prob": 0.00016962907102424651}, {"id": 774, "seek": 365204, "start": 3670.68, "end": 3673.92, "text": " And it's great to see such a nice progress.", "tokens": [400, 309, 311, 869, 281, 536, 1270, 257, 1481, 4205, 13], "temperature": 0.0, "avg_logprob": -0.22402088293868505, "compression_ratio": 1.4748858447488584, "no_speech_prob": 0.00016962907102424651}, {"id": 775, "seek": 365204, "start": 3673.92, "end": 3674.92, "text": " Just a quick question.", "tokens": [1449, 257, 1702, 1168, 13], "temperature": 0.0, "avg_logprob": -0.22402088293868505, "compression_ratio": 1.4748858447488584, "no_speech_prob": 0.00016962907102424651}, {"id": 776, "seek": 365204, "start": 3674.92, "end": 3679.16, "text": " In the beginning of the talk, you said that you have this command line option to clamp", "tokens": [682, 264, 2863, 295, 264, 751, 11, 291, 848, 300, 291, 362, 341, 5622, 1622, 3614, 281, 17690], "temperature": 0.0, "avg_logprob": -0.22402088293868505, "compression_ratio": 1.4748858447488584, "no_speech_prob": 0.00016962907102424651}, {"id": 777, "seek": 367916, "start": 3679.16, "end": 3684.44, "text": " the CPU frequency to disable the turbo boosting.", "tokens": [264, 13199, 7893, 281, 28362, 264, 20902, 43117, 13], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 778, "seek": 367916, "start": 3684.44, "end": 3686.2, "text": " Why can't you do that at runtime?", "tokens": [1545, 393, 380, 291, 360, 300, 412, 34474, 30], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 779, "seek": 367916, "start": 3686.2, "end": 3688.44, "text": " Why can't you configure it at runtime?", "tokens": [1545, 393, 380, 291, 22162, 309, 412, 34474, 30], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 780, "seek": 367916, "start": 3688.44, "end": 3693.56, "text": " We could configure it at runtime too, but we haven't added an API yet because the code", "tokens": [492, 727, 22162, 309, 412, 34474, 886, 11, 457, 321, 2378, 380, 3869, 364, 9362, 1939, 570, 264, 3089], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 781, "seek": 367916, "start": 3693.56, "end": 3696.68, "text": " that would have to do that simply doesn't exist yet.", "tokens": [300, 576, 362, 281, 360, 300, 2935, 1177, 380, 2514, 1939, 13], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 782, "seek": 367916, "start": 3696.68, "end": 3704.6, "text": " But there's no technical reason for why userland couldn't control the CPU frequency at arbitrary", "tokens": [583, 456, 311, 572, 6191, 1778, 337, 983, 4195, 1661, 2809, 380, 1969, 264, 13199, 7893, 412, 23211], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 783, "seek": 367916, "start": 3704.6, "end": 3705.6, "text": " points in time.", "tokens": [2793, 294, 565, 13], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 784, "seek": 367916, "start": 3705.6, "end": 3706.6, "text": " Okay, wonderful.", "tokens": [1033, 11, 3715, 13], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 785, "seek": 367916, "start": 3706.6, "end": 3707.6, "text": " Thanks.", "tokens": [2561, 13], "temperature": 0.0, "avg_logprob": -0.17496877346398695, "compression_ratio": 1.6764705882352942, "no_speech_prob": 5.553680603043176e-05}, {"id": 786, "seek": 370760, "start": 3707.6, "end": 3715.6, "text": " I was going to ask you about the verification aspect of this.", "tokens": [286, 390, 516, 281, 1029, 291, 466, 264, 30206, 4171, 295, 341, 13], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 787, "seek": 370760, "start": 3715.6, "end": 3716.6, "text": " Okay, got you.", "tokens": [1033, 11, 658, 291, 13], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 788, "seek": 370760, "start": 3716.6, "end": 3717.6, "text": " Any other questions?", "tokens": [2639, 661, 1651, 30], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 789, "seek": 370760, "start": 3717.6, "end": 3718.6, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 790, "seek": 370760, "start": 3718.6, "end": 3722.6, "text": " Can you just say, sorry, Jonathan, it's going to be a lot too.", "tokens": [1664, 291, 445, 584, 11, 2597, 11, 15471, 11, 309, 311, 516, 281, 312, 257, 688, 886, 13], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 791, "seek": 370760, "start": 3722.6, "end": 3728.6, "text": " Yeah, just to clarify, on the point of the DMA attack, were you talking about protecting", "tokens": [865, 11, 445, 281, 17594, 11, 322, 264, 935, 295, 264, 413, 9998, 2690, 11, 645, 291, 1417, 466, 12316], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 792, "seek": 370760, "start": 3728.6, "end": 3733.36, "text": " the guests or the host or the DMA attack?", "tokens": [264, 9804, 420, 264, 3975, 420, 264, 413, 9998, 2690, 30], "temperature": 0.0, "avg_logprob": -0.3766137026668934, "compression_ratio": 1.563157894736842, "no_speech_prob": 0.0005947708268649876}, {"id": 793, "seek": 373336, "start": 3733.36, "end": 3739.08, "text": " So the question was for the DMA attack that I showed in this slide here, and you'll find", "tokens": [407, 264, 1168, 390, 337, 264, 413, 9998, 2690, 300, 286, 4712, 294, 341, 4137, 510, 11, 293, 291, 603, 915], "temperature": 0.0, "avg_logprob": -0.1750093752199465, "compression_ratio": 1.6893617021276597, "no_speech_prob": 2.5853421902866103e-05}, {"id": 794, "seek": 373336, "start": 3739.08, "end": 3742.6400000000003, "text": " the slides online after the talk.", "tokens": [264, 9788, 2950, 934, 264, 751, 13], "temperature": 0.0, "avg_logprob": -0.1750093752199465, "compression_ratio": 1.6893617021276597, "no_speech_prob": 2.5853421902866103e-05}, {"id": 795, "seek": 373336, "start": 3742.6400000000003, "end": 3746.6400000000003, "text": " This is not a DMA attack of guest versus host, this is a boot time DMA attack.", "tokens": [639, 307, 406, 257, 413, 9998, 2690, 295, 8341, 5717, 3975, 11, 341, 307, 257, 11450, 565, 413, 9998, 2690, 13], "temperature": 0.0, "avg_logprob": -0.1750093752199465, "compression_ratio": 1.6893617021276597, "no_speech_prob": 2.5853421902866103e-05}, {"id": 796, "seek": 373336, "start": 3746.6400000000003, "end": 3751.56, "text": " So this is, you can really think of this as a timeline, firmware starts, boot loader starts,", "tokens": [407, 341, 307, 11, 291, 393, 534, 519, 295, 341, 382, 257, 12933, 11, 30289, 3719, 11, 11450, 3677, 260, 3719, 11], "temperature": 0.0, "avg_logprob": -0.1750093752199465, "compression_ratio": 1.6893617021276597, "no_speech_prob": 2.5853421902866103e-05}, {"id": 797, "seek": 373336, "start": 3751.56, "end": 3752.56, "text": " Nova starts.", "tokens": [27031, 3719, 13], "temperature": 0.0, "avg_logprob": -0.1750093752199465, "compression_ratio": 1.6893617021276597, "no_speech_prob": 2.5853421902866103e-05}, {"id": 798, "seek": 373336, "start": 3752.56, "end": 3759.1600000000003, "text": " And at the time that Nova turns on the IOMU, both guests and hosts will be DMA protected.", "tokens": [400, 412, 264, 565, 300, 27031, 4523, 322, 264, 286, 5251, 52, 11, 1293, 9804, 293, 21573, 486, 312, 413, 9998, 10594, 13], "temperature": 0.0, "avg_logprob": -0.1750093752199465, "compression_ratio": 1.6893617021276597, "no_speech_prob": 2.5853421902866103e-05}, {"id": 799, "seek": 375916, "start": 3759.16, "end": 3764.6, "text": " But Nova itself could be susceptible to DMA attack if we didn't disable bus master simply", "tokens": [583, 27031, 2564, 727, 312, 31249, 281, 413, 9998, 2690, 498, 321, 994, 380, 28362, 1255, 4505, 2935], "temperature": 0.0, "avg_logprob": -0.2066511266371783, "compression_ratio": 1.5916030534351144, "no_speech_prob": 5.057968519395217e-05}, {"id": 800, "seek": 375916, "start": 3764.6, "end": 3770.8399999999997, "text": " because the firmware does this legacy backward compatible shenanigans that we don't like.", "tokens": [570, 264, 30289, 775, 341, 11711, 23897, 18218, 402, 45008, 49088, 300, 321, 500, 380, 411, 13], "temperature": 0.0, "avg_logprob": -0.2066511266371783, "compression_ratio": 1.5916030534351144, "no_speech_prob": 5.057968519395217e-05}, {"id": 801, "seek": 375916, "start": 3770.8399999999997, "end": 3775.96, "text": " And I bet a lot of other microcalls are susceptible to problems like this too, and the fix would", "tokens": [400, 286, 778, 257, 688, 295, 661, 4532, 66, 39655, 366, 31249, 281, 2740, 411, 341, 886, 11, 293, 264, 3191, 576], "temperature": 0.0, "avg_logprob": -0.2066511266371783, "compression_ratio": 1.5916030534351144, "no_speech_prob": 5.057968519395217e-05}, {"id": 802, "seek": 375916, "start": 3775.96, "end": 3777.96, "text": " work for them as well.", "tokens": [589, 337, 552, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2066511266371783, "compression_ratio": 1.5916030534351144, "no_speech_prob": 5.057968519395217e-05}, {"id": 803, "seek": 375916, "start": 3777.96, "end": 3780.52, "text": " Thanks, Udo, for the talk.", "tokens": [2561, 11, 624, 2595, 11, 337, 264, 751, 13], "temperature": 0.0, "avg_logprob": -0.2066511266371783, "compression_ratio": 1.5916030534351144, "no_speech_prob": 5.057968519395217e-05}, {"id": 804, "seek": 375916, "start": 3780.52, "end": 3787.7599999999998, "text": " I would like to know, can you approximate how much percentage of the architecture specific", "tokens": [286, 576, 411, 281, 458, 11, 393, 291, 30874, 577, 709, 9668, 295, 264, 9482, 2685], "temperature": 0.0, "avg_logprob": -0.2066511266371783, "compression_ratio": 1.5916030534351144, "no_speech_prob": 5.057968519395217e-05}, {"id": 805, "seek": 378776, "start": 3787.76, "end": 3798.8, "text": " code is now added because of the security measures?", "tokens": [3089, 307, 586, 3869, 570, 295, 264, 3825, 8000, 30], "temperature": 0.0, "avg_logprob": -0.10213926755464994, "compression_ratio": 1.4971098265895955, "no_speech_prob": 8.083360444288701e-05}, {"id": 806, "seek": 378776, "start": 3798.8, "end": 3806.48, "text": " So most of the security measures that I talked about are x86 specific, and ARM has similar", "tokens": [407, 881, 295, 264, 3825, 8000, 300, 286, 2825, 466, 366, 2031, 22193, 2685, 11, 293, 45209, 575, 2531], "temperature": 0.0, "avg_logprob": -0.10213926755464994, "compression_ratio": 1.4971098265895955, "no_speech_prob": 8.083360444288701e-05}, {"id": 807, "seek": 378776, "start": 3806.48, "end": 3811.2000000000003, "text": " features like they have a guarded control stack specified in ARM v9, but I don't think", "tokens": [4122, 411, 436, 362, 257, 44157, 1969, 8630, 22206, 294, 45209, 371, 24, 11, 457, 286, 500, 380, 519], "temperature": 0.0, "avg_logprob": -0.10213926755464994, "compression_ratio": 1.4971098265895955, "no_speech_prob": 8.083360444288701e-05}, {"id": 808, "seek": 378776, "start": 3811.2000000000003, "end": 3813.0400000000004, "text": " you can buy any hardware yet.", "tokens": [291, 393, 2256, 604, 8837, 1939, 13], "temperature": 0.0, "avg_logprob": -0.10213926755464994, "compression_ratio": 1.4971098265895955, "no_speech_prob": 8.083360444288701e-05}, {"id": 809, "seek": 381304, "start": 3813.04, "end": 3820.16, "text": " You can take the difference between x86 and ARX64 as a rough ballpark figure, but it's", "tokens": [509, 393, 747, 264, 2649, 1296, 2031, 22193, 293, 8943, 55, 19395, 382, 257, 5903, 2594, 31239, 2573, 11, 457, 309, 311], "temperature": 0.0, "avg_logprob": -0.16024090972127794, "compression_ratio": 1.433179723502304, "no_speech_prob": 2.390139525232371e-05}, {"id": 810, "seek": 381304, "start": 3820.16, "end": 3825.52, "text": " really not all that much the, for example, the multi key total memory encryption.", "tokens": [534, 406, 439, 300, 709, 264, 11, 337, 1365, 11, 264, 4825, 2141, 3217, 4675, 29575, 13], "temperature": 0.0, "avg_logprob": -0.16024090972127794, "compression_ratio": 1.433179723502304, "no_speech_prob": 2.390139525232371e-05}, {"id": 811, "seek": 381304, "start": 3825.52, "end": 3831.04, "text": " That's just a few lines of code added to the x86 specific pitch table class because it", "tokens": [663, 311, 445, 257, 1326, 3876, 295, 3089, 3869, 281, 264, 2031, 22193, 2685, 7293, 3199, 1508, 570, 309], "temperature": 0.0, "avg_logprob": -0.16024090972127794, "compression_ratio": 1.433179723502304, "no_speech_prob": 2.390139525232371e-05}, {"id": 812, "seek": 381304, "start": 3831.04, "end": 3834.88, "text": " was already built into the generic class to begin with.", "tokens": [390, 1217, 3094, 666, 264, 19577, 1508, 281, 1841, 365, 13], "temperature": 0.0, "avg_logprob": -0.16024090972127794, "compression_ratio": 1.433179723502304, "no_speech_prob": 2.390139525232371e-05}, {"id": 813, "seek": 383488, "start": 3834.88, "end": 3844.84, "text": " Code flow enforcement is probably 400 lines of assembler code in entry, pass, and the switching.", "tokens": [15549, 3095, 11475, 307, 1391, 8423, 3876, 295, 8438, 1918, 3089, 294, 8729, 11, 1320, 11, 293, 264, 16493, 13], "temperature": 0.0, "avg_logprob": -0.1431393311402508, "compression_ratio": 1.6223021582733812, "no_speech_prob": 1.6959667846094817e-05}, {"id": 814, "seek": 383488, "start": 3844.84, "end": 3849.4, "text": " I did a quick test as to how many end branch instructions a compiler would actually inject", "tokens": [286, 630, 257, 1702, 1500, 382, 281, 577, 867, 917, 9819, 9415, 257, 31958, 576, 767, 10711], "temperature": 0.0, "avg_logprob": -0.1431393311402508, "compression_ratio": 1.6223021582733812, "no_speech_prob": 1.6959667846094817e-05}, {"id": 815, "seek": 383488, "start": 3849.4, "end": 3850.4, "text": " into the code.", "tokens": [666, 264, 3089, 13], "temperature": 0.0, "avg_logprob": -0.1431393311402508, "compression_ratio": 1.6223021582733812, "no_speech_prob": 1.6959667846094817e-05}, {"id": 816, "seek": 383488, "start": 3850.4, "end": 3855.0, "text": " It's like 500 or so because you get one for every interrupt entry and then one for every", "tokens": [467, 311, 411, 5923, 420, 370, 570, 291, 483, 472, 337, 633, 12729, 8729, 293, 550, 472, 337, 633], "temperature": 0.0, "avg_logprob": -0.1431393311402508, "compression_ratio": 1.6223021582733812, "no_speech_prob": 1.6959667846094817e-05}, {"id": 817, "seek": 383488, "start": 3855.0, "end": 3859.12, "text": " function, and it also inflates the size of the binary a bit, but not much.", "tokens": [2445, 11, 293, 309, 611, 9922, 1024, 264, 2744, 295, 264, 17434, 257, 857, 11, 457, 406, 709, 13], "temperature": 0.0, "avg_logprob": -0.1431393311402508, "compression_ratio": 1.6223021582733812, "no_speech_prob": 1.6959667846094817e-05}, {"id": 818, "seek": 383488, "start": 3859.12, "end": 3862.88, "text": " And the performance decrease for indirect branch checking, among other things, comes", "tokens": [400, 264, 3389, 11514, 337, 19523, 9819, 8568, 11, 3654, 661, 721, 11, 1487], "temperature": 0.0, "avg_logprob": -0.1431393311402508, "compression_ratio": 1.6223021582733812, "no_speech_prob": 1.6959667846094817e-05}, {"id": 819, "seek": 386288, "start": 3862.88, "end": 3867.04, "text": " from the fact that the code gets inflated and it's not as dense anymore.", "tokens": [490, 264, 1186, 300, 264, 3089, 2170, 9922, 770, 293, 309, 311, 406, 382, 18011, 3602, 13], "temperature": 0.0, "avg_logprob": -0.41447244688521984, "compression_ratio": 1.50990099009901, "no_speech_prob": 0.0003779784601647407}, {"id": 820, "seek": 386288, "start": 3867.04, "end": 3868.04, "text": " Okay.", "tokens": [1033, 13], "temperature": 0.0, "avg_logprob": -0.41447244688521984, "compression_ratio": 1.50990099009901, "no_speech_prob": 0.0003779784601647407}, {"id": 821, "seek": 386288, "start": 3868.04, "end": 3872.04, "text": " Yeah, final question, please, because red is one of the, yeah.", "tokens": [865, 11, 2572, 1168, 11, 1767, 11, 570, 2182, 307, 472, 295, 264, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.41447244688521984, "compression_ratio": 1.50990099009901, "no_speech_prob": 0.0003779784601647407}, {"id": 822, "seek": 386288, "start": 3872.04, "end": 3879.04, "text": " You were saying that you were able to achieve an L binary without rotations.", "tokens": [509, 645, 1566, 300, 291, 645, 1075, 281, 4584, 364, 441, 17434, 1553, 44796, 13], "temperature": 0.0, "avg_logprob": -0.41447244688521984, "compression_ratio": 1.50990099009901, "no_speech_prob": 0.0003779784601647407}, {"id": 823, "seek": 386288, "start": 3879.04, "end": 3880.04, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.41447244688521984, "compression_ratio": 1.50990099009901, "no_speech_prob": 0.0003779784601647407}, {"id": 824, "seek": 386288, "start": 3880.04, "end": 3886.6, "text": " Can you elaborate a little bit on how did you do that, which linker did you use?", "tokens": [1664, 291, 20945, 257, 707, 857, 322, 577, 630, 291, 360, 300, 11, 597, 2113, 260, 630, 291, 764, 30], "temperature": 0.0, "avg_logprob": -0.41447244688521984, "compression_ratio": 1.50990099009901, "no_speech_prob": 0.0003779784601647407}, {"id": 825, "seek": 388660, "start": 3886.6, "end": 3894.24, "text": " So it's the normal GNU-LD, but you could also use gold or mold or any of the normal linkers.", "tokens": [407, 309, 311, 264, 2710, 46411, 52, 12, 23704, 11, 457, 291, 727, 611, 764, 3821, 420, 11102, 420, 604, 295, 264, 2710, 2113, 433, 13], "temperature": 0.0, "avg_logprob": -0.12953740982782272, "compression_ratio": 1.8206278026905829, "no_speech_prob": 1.3629458408104256e-05}, {"id": 826, "seek": 388660, "start": 3894.24, "end": 3900.92, "text": " So the reason for why no relocation is needed is for the page code, as long as you put the", "tokens": [407, 264, 1778, 337, 983, 572, 26981, 399, 307, 2978, 307, 337, 264, 3028, 3089, 11, 382, 938, 382, 291, 829, 264], "temperature": 0.0, "avg_logprob": -0.12953740982782272, "compression_ratio": 1.8206278026905829, "no_speech_prob": 1.3629458408104256e-05}, {"id": 827, "seek": 388660, "start": 3900.92, "end": 3905.64, "text": " right physical address in your page table, the virtual address is always the same.", "tokens": [558, 4001, 2985, 294, 428, 3028, 3199, 11, 264, 6374, 2985, 307, 1009, 264, 912, 13], "temperature": 0.0, "avg_logprob": -0.12953740982782272, "compression_ratio": 1.8206278026905829, "no_speech_prob": 1.3629458408104256e-05}, {"id": 828, "seek": 388660, "start": 3905.64, "end": 3910.04, "text": " So virtual memory is some form of relocation where you say no matter where I run in physical", "tokens": [407, 6374, 4675, 307, 512, 1254, 295, 26981, 399, 689, 291, 584, 572, 1871, 689, 286, 1190, 294, 4001], "temperature": 0.0, "avg_logprob": -0.12953740982782272, "compression_ratio": 1.8206278026905829, "no_speech_prob": 1.3629458408104256e-05}, {"id": 829, "seek": 388660, "start": 3910.04, "end": 3912.36, "text": " memory, the virtual memory is always the same.", "tokens": [4675, 11, 264, 6374, 4675, 307, 1009, 264, 912, 13], "temperature": 0.0, "avg_logprob": -0.12953740982782272, "compression_ratio": 1.8206278026905829, "no_speech_prob": 1.3629458408104256e-05}, {"id": 830, "seek": 391236, "start": 3912.36, "end": 3918.8, "text": " For the unpaged code, which doesn't know at which physical address it was actually launched,", "tokens": [1171, 264, 20994, 2980, 3089, 11, 597, 1177, 380, 458, 412, 597, 4001, 2985, 309, 390, 767, 8730, 11], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 831, "seek": 391236, "start": 3918.8, "end": 3922.6, "text": " you have to use position independent code, basically say I don't care at which physical", "tokens": [291, 362, 281, 764, 2535, 6695, 3089, 11, 1936, 584, 286, 500, 380, 1127, 412, 597, 4001], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 832, "seek": 391236, "start": 3922.6, "end": 3929.44, "text": " address I run, I can run it in arbitrary address because all my data structures are addressed", "tokens": [2985, 286, 1190, 11, 286, 393, 1190, 309, 294, 23211, 2985, 570, 439, 452, 1412, 9227, 366, 13847], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 833, "seek": 391236, "start": 3929.44, "end": 3931.2400000000002, "text": " with relative or something like that.", "tokens": [365, 4972, 420, 746, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 834, "seek": 391236, "start": 3931.2400000000002, "end": 3934.7200000000003, "text": " And at some point you need to know what the offset is between where you want it to run", "tokens": [400, 412, 512, 935, 291, 643, 281, 458, 437, 264, 18687, 307, 1296, 689, 291, 528, 309, 281, 1190], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 835, "seek": 391236, "start": 3934.7200000000003, "end": 3936.96, "text": " and where you do actually run, but that's simple.", "tokens": [293, 689, 291, 360, 767, 1190, 11, 457, 300, 311, 2199, 13], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 836, "seek": 391236, "start": 3936.96, "end": 3940.56, "text": " It's like you call your next instruction, you pop the return address of the stack, you", "tokens": [467, 311, 411, 291, 818, 428, 958, 10951, 11, 291, 1665, 264, 2736, 2985, 295, 264, 8630, 11, 291], "temperature": 0.0, "avg_logprob": -0.16492242888202818, "compression_ratio": 1.8047138047138047, "no_speech_prob": 2.1108473447384313e-05}, {"id": 837, "seek": 394056, "start": 3940.56, "end": 3943.72, "text": " compute the difference and then you know.", "tokens": [14722, 264, 2649, 293, 550, 291, 458, 13], "temperature": 0.0, "avg_logprob": -0.341181999597794, "compression_ratio": 1.2755102040816326, "no_speech_prob": 0.0018398677930235863}, {"id": 838, "seek": 394056, "start": 3943.72, "end": 3944.72, "text": " Thank you so much, Udo.", "tokens": [1044, 291, 370, 709, 11, 624, 2595, 13], "temperature": 0.0, "avg_logprob": -0.341181999597794, "compression_ratio": 1.2755102040816326, "no_speech_prob": 0.0018398677930235863}, {"id": 839, "seek": 394056, "start": 3944.72, "end": 3945.72, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.341181999597794, "compression_ratio": 1.2755102040816326, "no_speech_prob": 0.0018398677930235863}, {"id": 840, "seek": 394572, "start": 3945.72, "end": 3974.72, "text": " So the slides are online, the recording as well.", "tokens": [50364, 407, 264, 9788, 366, 2950, 11, 264, 6613, 382, 731, 13, 51814], "temperature": 0.0, "avg_logprob": -0.5760538237435477, "compression_ratio": 0.9056603773584906, "no_speech_prob": 0.011384650133550167}], "language": "en"}