{"text": " At our final talk for this session, we have Pierre here. He's going to discuss about Loup, a tool that he and we have been using to measure compatibility for different OSs. Pierre, you have the floor. Thank you, Resvan, and thanks everyone for attending my talk. This is joint work with a bunch of colleagues and students, including Hugo, my PhD student. He's a key player behind his work. I'm just, you know, getting all the medialization, but he has built all this stuff, so all the credits go to him. So in this brief talk, I want to speak a bit about application compatibility for custom operating systems. So I guess most of you don't need to be convinced that we still need custom operating systems today. When I say custom, I mean both, like research operating systems and prototypes operating systems from the industry, right? The thinking that Linux has solved everything is not true, in my opinion. We still need things like Unicraft if you want to go fast, or if you want to specialize like crazy, we still need things like Rusty-Armet if you want security, or SEL4, so we still need custom operating systems, and the thing is with these operating systems, they're only as good as the application that they can run, right? So compatibility is key. Compatibility with existing application is extremely important. If you want to build a community, you want your user to go to your website, compile your custom OS, and then try some of their favorite applications, or try some of the highly popular applications in a given application domain like Enginings or Redis for cloud, if you want to attract sponsors or investors, or even if you, like me, are scientists, you want to gather some early numbers to make a publication, well, you need to do that on standard applications, right? So compatibility is important, and another argument would be like how many times did you hear the one POSIX spoken today, right? There were some slides, there was POSIX like three or four times written in a single slide. So compatibility is important, and it can be achieved in a few different ways as we have seen with Simon. But one important thing to note is, in my opinion, porting is not sustainable. So porting is what many of us do. We build a custom operating system, and then we take Redis, and obviously it doesn't work as is with our operating system, so we modify Redis a bit, we disable some features because we know that they make our OS crash, and then we have Redis like a version customized for our operating system. This is not sustainable because you can't maintain like a branch of Redis for every operating system out there, right? In the long term, it doesn't work so well. So porting also basically means that you as a OS developer, you ask the users of your application to make some effort to the application developers, they need to make some effort to be compatible with your operating system. This doesn't work, nobody is ready to make that kind of effort. Maybe if you give them 10x performance speed up, but this is unrealistic. So what you want to do is, once again, in my opinion, as an OS developer, you want to provide compatibility as transparently as possible. And this means you emulate a popular operating system, for example Linux, or a popular abstraction like POSIX or the standard C library, and then you can be compatible at three different levels. The first level is source level or API level compatibility. So you ask the users to compile their application code against the sources of your kernel, in the case of a unique kernel. So this is, you're still asking some effort from the users, right? In many scenarios, you don't have access to sources, right? If you have proprietary binary or pre-compiled binaries, well, you can't have source level compatibility. So it's not perfect and binary compatibility is generally a more, let's say, pure version of compatibility. And there are many two ways to achieve it. You can do that at the level of the standard C library, like OSV. So you will dynamically link your kernel plus a standard C library against your application, compile as a position independent executable or as a shared library itself. This is great, but if the application is making directly system calls to the kernel without going through the standard C library, well, once again, it doesn't work, right? And as a matter of fact, I have counted more than 500 executables in the Debian repository that contain the C score instruction, right? So they make C scores directly to the kernel. They don't go through the C library. Go, for example, is making most of its C score, put directly to the kernel and not through the C library. So what you want to do is to be compatible at the level of the system calls. So your kernel needs to emulate the C score API that Linux is providing. This is the most transparent way of achieving compatibility. Now, this is scary, right? Linux has more than 350 system calls. Do we need to implement them all? Will we be and aren't we going to reimplement Linux by doing so? And some of them are extremely scary by themselves, right? You have like hundreds of IO controls and each of them probably require its own implementation. The Linux API even goes beyond system calls. You have things like slash proc slash devs that are, you know, used by many applications. Like the first thing a muscle binary does when it runs is to look in, I believe it's slash proc or slash this to get the size of the terminal, right? So you need to have emulation for this part of the API too. And this, because it seems like a big engineering effort, this creates, it hinders the development of custom operating systems. So this is inspired by the keynote by Timati Roscoe at ATC and OSDI 2021. We looked at all the papers. So these are top tier operating systems conferences. And we look over the past 10 years, over a total of more than 1,000 papers, how many were about proposing a new operating system as opposed to things like security or machine learning. And among them, how many were just hacking Linux versus proposing an actual operating system implemented from scratch. And the numbers are similar to what we saw earlier, right? You have just a very, very, very few papers proposing a new operating system because it's a significant engineering effort. And part of the effort is to be providing compatibility to an application like Apache already to get a few numbers at the end of the paper, right? So this is the problem. Now, the particular problem that I want to talk about is how I'm sure several people in this forum have attempted to build some form of compatibility layer for an operating systems. And we are all kind of working on the same thing in parallel with some form of ad hoc processes that may benefit from some optimization. So I've just listed here a few projects that have a Cisco level binary compatibility layers, but actually there are many more. And from what I understand, it is a very organic process. So first of all, it is application driven, right? People have a few sets of application in mind that they want to support. If you are doing cloud, you want to support the user's suspect, ready, Apache, whatever. And the process basically looks like that. You take an app, you try to run it on top of your operating system. Obviously, it fails. You investigate. You're like, oh, I'm missing the implementation for this system code. So you implement whatever operating system features are required to fix that particular issue, rinse and repeat until the app is working. And then you go to the next app. So it's a very intuitive and organic process. So when I built the Armitage, this is exactly what I was doing. So something that comes to mind is, can't we have some form of generic compatibility layers that we could plug? Like something a bit like New Lib that would provide a generic interface. And I believe it's not really possible because most of this implementation to support the system code is very specific to whatever operating system you are using. And it's not clear if a generic compatibility layer can be achieved. But can we still somehow optimize that process? Some have tried static analysis. So they take the binary of the application they want to support and they look, okay, so what are the system codes that are made by these applications? So this has been done in the best paper in Eurosis 2016, analyzed all the binaries from Ubuntu, I believe it was 14 or four repositories. And they concluded that every Ubuntu installation, including the smallest one, require more than 200 system codes and 200 IO controls, five controls, and PRCTL codes, and hundreds of 2.0 files. So this doesn't help. It is still quite scary. It still represents a gigantic engineering effort. But do we want full compatibility with Ubuntu installation? In the end, especially in the early stage of the development of an operating system, you just want to get a few applications up and running. And do you even 100% compatibility? When I write a paper, I don't really care if everything is stable. I just want to get some numbers. So isn't there a better way? And obviously, maybe you think about, yeah, let's do dynamic analysis. Let's run the applications that we want to support. We send them some input that we want to support, like I'm running engineering and I'm submitting some HTTP for something like that. And then we trace the system codes that are done. So this is going to give us a subset of the system codes that can be identified through static analysis that has a tendency to overestimate. So with this trace, the engineering effort to support an application and a set of input is a bit lower. But it's still not a panacea because it's not taking into account two things that we do when we implement compatibility layers. So this is my code. Don't judge me. One thing that I did with Hermitux was at some point, it was an app that was calling MNCore to check if some page of memory wasn't swapped or not. It has actually, you know, there is no swap in most unique kernels. So it really didn't matter to implement this. So you know this means operation not supported. So stopping a system code is just saying, yeah, we don't support it. And you cross your finger that the application has some kind of fallback path to do something else if the system code fails. And it works in some cases. And then we can do something even more nasty. Don't judge me again. You can fake the success of a system code, right? Surprisingly, in some situation, returning a success code, even if the system code doesn't have any implementation in your operating system, it's going to work in some cases. You know, I'll tell a bit more about why this works sometimes. So stubbing and faking lets you implement even less system calls than what you would trace with it trace. So in the end, you know, if you want to support an app or a set of application in your custom operating system, the amount of system calls that you actually need to implement. So obviously, it's smaller than the entire Linux SQL API. Static binary analysis will, on the binaries of the applications you want to support, will identify a subset of that. Still pretty big. It's an overestimate. Source analysis gets you more precise results. But it is pretty hard to achieve. And it is still overestimating. S trace will give you, once again, a subset. Things start to look better. And among these trace by S trace, you actually don't need to implement everything. You can stub and fake some of this SQL. So can we measure that? Yes, with loop. So loop means magnifying glass in French. It's a tool that was built by Hugo, my student, and it's some kind of super S trace that is measuring the system calls that are required to support an application. And that can also tell you which one you can stub and which one you can fake. So we used it to build a database of measurements for a relatively large set of applications. And with loop, if you give me a description of your operating system, basically the list of system calls that you already support, and you give me the list of applications that you would like to support, we run them through loop and loop can derive a support plan, which basically will tell you, okay, for this set of target application. And given the set of system calls that you already support, what is the optimized order of system calls to implement to support as many applications as soon as possible? Okay, so I will give you an example of support plan by the end of the presentation. So from the user point of view, loop needs two things to perform its measurement on a given application. You give it a Docker file that is describing how you want to build and run the application for which you want to measure the system calls needed. And optionally, you may need an input workload. Think about a web server. It's not going to call many system calls until you actually start to send requests to it. Loop will instantiate the application, launch it on a, you know, standard Linux kernel and analyze the system calls that are done and with a few tricks we'll be able to know which ones can be faked or stubbed. The results are, it's basically just a CSV file for each system call that is made by the application. Can it be faked? Can it be stubbed? Or does it require a full implementation? We start that in a database and later, so, you know, we populate the database with as many measurements as possible. And this database can given the list of these calls that is already supported by your operating systems, give you like some form of optimized super plan given which of the applications you want to support. Okay, so how does it work? When loop runs the application, first it does a quick pass of S-Trace to measure all the system calls that are done by the application and then for each system call that we identify, we use SecComp to hook into the execution of each of the system calls and rather than actually executing them through the Linux kernel, we emulate the fact that the Cisco is stubbed, so we just return EnoSys without executing the Cisco. We can also emulate the fact that the Cisco is faked, we return zero. And then we check if the application works or not following the stubbing or the faking of this particular Cisco. And then we do that for each system call that we have identified with S-Trace. How do we actually check for the success of the execution of the application? So we identified two types of apps. Some we call them run to completion. There'll be something like FIO when you know you start FIO, it runs for one minute and then it exits outputting some kind of some stuff on the standard output. So with run to completion apps, we run the app instrumented with loop, we check its exit code. If it's different from zero, we consider that the run was a failure, could have been killed by a signal or things like that. And we can also run a script optionally in addition to that after each run of the application to check its standard output. We can grab for error values, we can grab for success printing, something like, you know, 50 requests per second have been achieved. The files that may have been created by the application and so on. And then another type of application is client servers. So with client servers, we run the app instrumented by loop and in parallel we run a workload, could be WRK, HTT path, the Redis benchmark for Redis and so on. And we check the success of both, we check that the app doesn't crash, generally servers are not supposed to exit. So we check that it doesn't crash and we check the success of the workload. Like, you know, if Redis benchmark returns something different than zero, probably something went wrong. And then we are able to see, okay, so I'm currently trying to stub the read system call, is the application succeeded or not? So really the database, let me check the time, okay. And we analyzed the results. So these results are made on a relatively small database of about 12 highly popular, sorry, 15 highly popular cloud applications. So this is just a subset. So what you have on the y-axis is a number of system calls that are identified by static analysis in purple on the binary, on the sources in yellow. And then dynamic analysis. And we run for each of these applications, both the standard benchmarks, that will be Redis benchmark for Redis, WRK for engineering, and so on. And we also run the entire test suite. So the key idea with the test suite is if you, you know, support, I mean, if you measure what's going on during the entire test suite, you get a very good idea of what are all the possible system calls that could be done by the application. Obviously, you need to assume that the test suite has a good coverage, but it is the case with these very popular applications. And, and what we see is, first of all, you know, static analysis overestimates. This is not very surprising. The amount of system calls that is identified by static analysis is relatively high compared to what we get with dynamic analysis. And if something interesting, too, is that the amount of system calls that can be stirred or faked, so the grain bits on the dynamic analysis pass, it is actually quite non-negligible, right? So, so what this means is that if you want to support Redis with a Redis benchmark, where binary level static analysis tells you that you should implement 100 system calls, if you just want to run the Redis benchmark to get, you know, performance numbers for your paper, you actually need to implement just 20, right? So that's what, like, divided by five, right? And if you want to pass the entire test suite of Redis, you need to implement about 40. It's still like half what static analysis is telling you. So it's kind of a message of hope, right, for building compatibility layers and for developing custom operating systems in general. So, yes, static analysis overestimates a lot of the engineering effort to support an app. And even naive dynamic analysis does measure much more these calls than what is actually required if you know that you can stop and fake these calls. Another view at these results can be seen here. So for each of the system calls, you know, zero is read, one is write, two is open, I guess, and so on, among our dataset of about 15 apps, how many of these apps require the implementation of the system calling question, right? And then so you have here the result for static analysis at the binary level. At the source level, this is S trace without counting which system calls you can stop or fake. And this is what is actually required. So if you consider that you will not implement what you stop or fake, this is what you actually need to implement. And as you can see, you know, it's much, much, much, much less engineering effort versus what static analysis is telling. And why does stopping and faking work? So here you get some code snippet from Redis. So if you stop, get our limit, the C library wrapper will return minus one. And as you can see, Redis will actually fall back on some kind of safe value, you know, so I'm not able to understand the maximum number of files that I can open. So I'm going to fall back on 100, sorry, 1000. And the fact that faking works is actually that you have quite a bunch of system calls. So this is for each system call and each app in our dataset, what is the percentage of apps that are actually checking the return value of the system calls. And some system calls are almost never checked the return value. It kind of makes sense, right, when you see this, why check the return value of close. And this is why, you know, faking work in many cases. Another question that we asked is, okay, so when you speak about providing binary compatibility and you don't do porting anymore, basically, all the effort of supporting apps is on you, the operating system developer. And this is how it should be, in my opinion, but how much effort does that mean in the long term, right? So we had a look at versions of Redis and Jennings and Apache over the last 10 years and what, you know, what are these calls that actually needs to be implemented in purple. And we saw that this number does not change very much, right? So once you make an app and you make it work, it actually means that you need to keep up to date with the most recent version of this app that are coming up, but it doesn't necessarily mean a very big engineering effort either. And these are the support plans. So we had a look at Unicraft, Fushia, which are some operating systems that have already a relatively good support for a good number of system calls. And we look at Kerala, so Kerala is another Unicernel written in Rust. And it's very, I wouldn't say immature, but it doesn't have support for a lot of system calls. And for a set of 15 apps that we had in the database, we derive a support plan. So for Unicraft, for example, in its current state, it's already supporting most of the apps of our data set. If you want to support an additional app, what you need to do is to implement system call number 290 and stop these, and then you'll get memcached. And next, if you implement this syscall, you get H2O, and then you need to implement these two syscalls, and then you stop that, and you get MongoDB. So same thing for Fushia and Kerala. Obviously, it's a bit more interesting because this one doesn't support many applications out of the box. And I believe I have time to do a quick demo. I'm going to do it real quick. So I'm going to do a test with LS, which is like the simplest test because we don't have a lot of time. In the Docker file, I just copy a test that I'm going to show you, and then I call like the, this is kind of the top level script of loop with a few options that don't matter that much. And I say, okay, the binary that we are going to instrument is slash bin slash LS, and this is the parameter. So I'm going to do LS slash, and we are going to check if it works or not with every possible syscalls that can be invoked by LS. And the test, which should be there, the test that we are going to run after each execution of LS to see if things have worked. So this share script will take the standard output of LS as parameters, and to make things simple, I'm just checking that LS actually outputs something, right? I'm doing LS slash, so something should be outputted. If nothing is output, there is a problem. And keep in mind that loop is also checking the return value of LS itself. So, okay, so I'm launching loop like this, so it should work. So what happens under the hood is that we build the container that we've seen the Docker file for. We are starting two containers in parallel. Each one is running a full set of tests trying to stop and fake all the system calls. And we use this to check for differences between the replicas in case there is a problem. Most of the time, there is no differences. So it takes a bit of time. And then, okay, it's done. So, if we go to the database, so we have now much more than 12 apps. And if we go to LS, the most interesting result is this CSV file, which contains, for HCC call, 0 being read, 1 being write. Is it called by LS or not? Can we fake it? Can we stop it? Or can we both fake and stop it? Or it's more like, does the application works when it's fake? Does it works when it's stubbed? And does it work when it's both fake and stubbed? And as you can see, some CSV calls, like 11, I don't know which one it is, can be both stub and fake, same thing for 12, same thing for 16. Some CSV calls, like this is read, for example, it is called, but you can't stop or take it, which kind of makes sense. LS wouldn't work if it can read. And yeah, that's pretty much it. So briefly, what we are currently working on is some more fine-grained measurements. Some system calls have kind of sub features, like a lot of programs require at least a map anonymous for a map to allocate memory, but not really to map a file. So we are looking at, you know, checking which flags can be stubbed or fake and things like that. And we are also looking at the virtual file system API. That's it. So building compatibility layers is important for custom operating system. It seems a bit scary, but actually, it's not that much engineering effort.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 9.92, "text": " At our final talk for this session, we have Pierre here. He's going to discuss about", "tokens": [1711, 527, 2572, 751, 337, 341, 5481, 11, 321, 362, 28461, 510, 13, 634, 311, 516, 281, 2248, 466], "temperature": 0.0, "avg_logprob": -0.3073099435093891, "compression_ratio": 1.4954954954954955, "no_speech_prob": 0.483916699886322}, {"id": 1, "seek": 0, "start": 9.92, "end": 16.4, "text": " Loup, a tool that he and we have been using to measure compatibility for different OSs.", "tokens": [441, 1250, 11, 257, 2290, 300, 415, 293, 321, 362, 668, 1228, 281, 3481, 34237, 337, 819, 12731, 82, 13], "temperature": 0.0, "avg_logprob": -0.3073099435093891, "compression_ratio": 1.4954954954954955, "no_speech_prob": 0.483916699886322}, {"id": 2, "seek": 0, "start": 16.4, "end": 20.0, "text": " Pierre, you have the floor. Thank you, Resvan, and thanks everyone for", "tokens": [28461, 11, 291, 362, 264, 4123, 13, 1044, 291, 11, 5015, 9768, 11, 293, 3231, 1518, 337], "temperature": 0.0, "avg_logprob": -0.3073099435093891, "compression_ratio": 1.4954954954954955, "no_speech_prob": 0.483916699886322}, {"id": 3, "seek": 0, "start": 20.0, "end": 26.240000000000002, "text": " attending my talk. This is joint work with a bunch of colleagues and students, including", "tokens": [15862, 452, 751, 13, 639, 307, 7225, 589, 365, 257, 3840, 295, 7734, 293, 1731, 11, 3009], "temperature": 0.0, "avg_logprob": -0.3073099435093891, "compression_ratio": 1.4954954954954955, "no_speech_prob": 0.483916699886322}, {"id": 4, "seek": 2624, "start": 26.24, "end": 31.52, "text": " Hugo, my PhD student. He's a key player behind his work. I'm just, you know, getting all the", "tokens": [32504, 11, 452, 14476, 3107, 13, 634, 311, 257, 2141, 4256, 2261, 702, 589, 13, 286, 478, 445, 11, 291, 458, 11, 1242, 439, 264], "temperature": 0.0, "avg_logprob": -0.14913429611030665, "compression_ratio": 1.472972972972973, "no_speech_prob": 0.00016533158486709}, {"id": 5, "seek": 2624, "start": 32.8, "end": 37.28, "text": " medialization, but he has built all this stuff, so all the credits go to him.", "tokens": [1205, 831, 2144, 11, 457, 415, 575, 3094, 439, 341, 1507, 11, 370, 439, 264, 16816, 352, 281, 796, 13], "temperature": 0.0, "avg_logprob": -0.14913429611030665, "compression_ratio": 1.472972972972973, "no_speech_prob": 0.00016533158486709}, {"id": 6, "seek": 2624, "start": 37.839999999999996, "end": 44.0, "text": " So in this brief talk, I want to speak a bit about application", "tokens": [407, 294, 341, 5353, 751, 11, 286, 528, 281, 1710, 257, 857, 466, 3861], "temperature": 0.0, "avg_logprob": -0.14913429611030665, "compression_ratio": 1.472972972972973, "no_speech_prob": 0.00016533158486709}, {"id": 7, "seek": 2624, "start": 44.56, "end": 51.92, "text": " compatibility for custom operating systems. So I guess most of you don't need to be convinced", "tokens": [34237, 337, 2375, 7447, 3652, 13, 407, 286, 2041, 881, 295, 291, 500, 380, 643, 281, 312, 12561], "temperature": 0.0, "avg_logprob": -0.14913429611030665, "compression_ratio": 1.472972972972973, "no_speech_prob": 0.00016533158486709}, {"id": 8, "seek": 5192, "start": 51.92, "end": 58.0, "text": " that we still need custom operating systems today. When I say custom, I mean both, like", "tokens": [300, 321, 920, 643, 2375, 7447, 3652, 965, 13, 1133, 286, 584, 2375, 11, 286, 914, 1293, 11, 411], "temperature": 0.0, "avg_logprob": -0.13348481795367073, "compression_ratio": 1.7607655502392345, "no_speech_prob": 0.00013839162420481443}, {"id": 9, "seek": 5192, "start": 58.0, "end": 63.760000000000005, "text": " research operating systems and prototypes operating systems from the industry, right?", "tokens": [2132, 7447, 3652, 293, 42197, 7447, 3652, 490, 264, 3518, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.13348481795367073, "compression_ratio": 1.7607655502392345, "no_speech_prob": 0.00013839162420481443}, {"id": 10, "seek": 5192, "start": 65.6, "end": 74.24000000000001, "text": " The thinking that Linux has solved everything is not true, in my opinion. We still need things", "tokens": [440, 1953, 300, 18734, 575, 13041, 1203, 307, 406, 2074, 11, 294, 452, 4800, 13, 492, 920, 643, 721], "temperature": 0.0, "avg_logprob": -0.13348481795367073, "compression_ratio": 1.7607655502392345, "no_speech_prob": 0.00013839162420481443}, {"id": 11, "seek": 5192, "start": 74.24000000000001, "end": 79.44, "text": " like Unicraft if you want to go fast, or if you want to specialize like crazy, we still need things", "tokens": [411, 1156, 299, 4469, 498, 291, 528, 281, 352, 2370, 11, 420, 498, 291, 528, 281, 37938, 411, 3219, 11, 321, 920, 643, 721], "temperature": 0.0, "avg_logprob": -0.13348481795367073, "compression_ratio": 1.7607655502392345, "no_speech_prob": 0.00013839162420481443}, {"id": 12, "seek": 7944, "start": 79.44, "end": 85.6, "text": " like Rusty-Armet if you want security, or SEL4, so we still need custom operating systems,", "tokens": [411, 34952, 88, 12, 10683, 5537, 498, 291, 528, 3825, 11, 420, 318, 3158, 19, 11, 370, 321, 920, 643, 2375, 7447, 3652, 11], "temperature": 0.0, "avg_logprob": -0.19118553400039673, "compression_ratio": 1.6610169491525424, "no_speech_prob": 3.553945862222463e-05}, {"id": 13, "seek": 7944, "start": 86.56, "end": 92.96, "text": " and the thing is with these operating systems, they're only as good as the application that they", "tokens": [293, 264, 551, 307, 365, 613, 7447, 3652, 11, 436, 434, 787, 382, 665, 382, 264, 3861, 300, 436], "temperature": 0.0, "avg_logprob": -0.19118553400039673, "compression_ratio": 1.6610169491525424, "no_speech_prob": 3.553945862222463e-05}, {"id": 14, "seek": 7944, "start": 92.96, "end": 102.72, "text": " can run, right? So compatibility is key. Compatibility with existing application is extremely important.", "tokens": [393, 1190, 11, 558, 30, 407, 34237, 307, 2141, 13, 6620, 267, 2841, 365, 6741, 3861, 307, 4664, 1021, 13], "temperature": 0.0, "avg_logprob": -0.19118553400039673, "compression_ratio": 1.6610169491525424, "no_speech_prob": 3.553945862222463e-05}, {"id": 15, "seek": 7944, "start": 102.72, "end": 108.56, "text": " If you want to build a community, you want your user to go to your website, compile your custom OS,", "tokens": [759, 291, 528, 281, 1322, 257, 1768, 11, 291, 528, 428, 4195, 281, 352, 281, 428, 3144, 11, 31413, 428, 2375, 12731, 11], "temperature": 0.0, "avg_logprob": -0.19118553400039673, "compression_ratio": 1.6610169491525424, "no_speech_prob": 3.553945862222463e-05}, {"id": 16, "seek": 10856, "start": 108.56, "end": 115.12, "text": " and then try some of their favorite applications, or try some of the highly popular applications", "tokens": [293, 550, 853, 512, 295, 641, 2954, 5821, 11, 420, 853, 512, 295, 264, 5405, 3743, 5821], "temperature": 0.0, "avg_logprob": -0.1533041219601686, "compression_ratio": 1.7523809523809524, "no_speech_prob": 3.425764953135513e-05}, {"id": 17, "seek": 10856, "start": 115.12, "end": 120.72, "text": " in a given application domain like Enginings or Redis for cloud, if you want to attract", "tokens": [294, 257, 2212, 3861, 9274, 411, 2469, 259, 1109, 420, 4477, 271, 337, 4588, 11, 498, 291, 528, 281, 5049], "temperature": 0.0, "avg_logprob": -0.1533041219601686, "compression_ratio": 1.7523809523809524, "no_speech_prob": 3.425764953135513e-05}, {"id": 18, "seek": 10856, "start": 120.72, "end": 127.12, "text": " sponsors or investors, or even if you, like me, are scientists, you want to gather some early", "tokens": [22593, 420, 11519, 11, 420, 754, 498, 291, 11, 411, 385, 11, 366, 7708, 11, 291, 528, 281, 5448, 512, 2440], "temperature": 0.0, "avg_logprob": -0.1533041219601686, "compression_ratio": 1.7523809523809524, "no_speech_prob": 3.425764953135513e-05}, {"id": 19, "seek": 10856, "start": 127.12, "end": 132.4, "text": " numbers to make a publication, well, you need to do that on standard applications, right?", "tokens": [3547, 281, 652, 257, 19953, 11, 731, 11, 291, 643, 281, 360, 300, 322, 3832, 5821, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.1533041219601686, "compression_ratio": 1.7523809523809524, "no_speech_prob": 3.425764953135513e-05}, {"id": 20, "seek": 13240, "start": 132.4, "end": 142.56, "text": " So compatibility is important, and another argument would be like how many times did you hear the", "tokens": [407, 34237, 307, 1021, 11, 293, 1071, 6770, 576, 312, 411, 577, 867, 1413, 630, 291, 1568, 264], "temperature": 0.0, "avg_logprob": -0.15790680476597377, "compression_ratio": 1.5923913043478262, "no_speech_prob": 7.49033861211501e-05}, {"id": 21, "seek": 13240, "start": 142.56, "end": 148.8, "text": " one POSIX spoken today, right? There were some slides, there was POSIX like three or four times", "tokens": [472, 430, 4367, 21124, 10759, 965, 11, 558, 30, 821, 645, 512, 9788, 11, 456, 390, 430, 4367, 21124, 411, 1045, 420, 1451, 1413], "temperature": 0.0, "avg_logprob": -0.15790680476597377, "compression_ratio": 1.5923913043478262, "no_speech_prob": 7.49033861211501e-05}, {"id": 22, "seek": 13240, "start": 148.8, "end": 158.4, "text": " written in a single slide. So compatibility is important, and it can be achieved in a few different", "tokens": [3720, 294, 257, 2167, 4137, 13, 407, 34237, 307, 1021, 11, 293, 309, 393, 312, 11042, 294, 257, 1326, 819], "temperature": 0.0, "avg_logprob": -0.15790680476597377, "compression_ratio": 1.5923913043478262, "no_speech_prob": 7.49033861211501e-05}, {"id": 23, "seek": 15840, "start": 158.4, "end": 166.16, "text": " ways as we have seen with Simon. But one important thing to note is, in my opinion, porting is not", "tokens": [2098, 382, 321, 362, 1612, 365, 13193, 13, 583, 472, 1021, 551, 281, 3637, 307, 11, 294, 452, 4800, 11, 2436, 278, 307, 406], "temperature": 0.0, "avg_logprob": -0.12990801405198504, "compression_ratio": 1.668103448275862, "no_speech_prob": 4.5964570745127276e-05}, {"id": 24, "seek": 15840, "start": 166.16, "end": 172.48000000000002, "text": " sustainable. So porting is what many of us do. We build a custom operating system, and then we take", "tokens": [11235, 13, 407, 2436, 278, 307, 437, 867, 295, 505, 360, 13, 492, 1322, 257, 2375, 7447, 1185, 11, 293, 550, 321, 747], "temperature": 0.0, "avg_logprob": -0.12990801405198504, "compression_ratio": 1.668103448275862, "no_speech_prob": 4.5964570745127276e-05}, {"id": 25, "seek": 15840, "start": 172.48000000000002, "end": 178.88, "text": " Redis, and obviously it doesn't work as is with our operating system, so we modify Redis a bit,", "tokens": [4477, 271, 11, 293, 2745, 309, 1177, 380, 589, 382, 307, 365, 527, 7447, 1185, 11, 370, 321, 16927, 4477, 271, 257, 857, 11], "temperature": 0.0, "avg_logprob": -0.12990801405198504, "compression_ratio": 1.668103448275862, "no_speech_prob": 4.5964570745127276e-05}, {"id": 26, "seek": 15840, "start": 178.88, "end": 184.24, "text": " we disable some features because we know that they make our OS crash, and then we have Redis", "tokens": [321, 28362, 512, 4122, 570, 321, 458, 300, 436, 652, 527, 12731, 8252, 11, 293, 550, 321, 362, 4477, 271], "temperature": 0.0, "avg_logprob": -0.12990801405198504, "compression_ratio": 1.668103448275862, "no_speech_prob": 4.5964570745127276e-05}, {"id": 27, "seek": 18424, "start": 184.24, "end": 188.88, "text": " like a version customized for our operating system. This is not sustainable because you can't", "tokens": [411, 257, 3037, 30581, 337, 527, 7447, 1185, 13, 639, 307, 406, 11235, 570, 291, 393, 380], "temperature": 0.0, "avg_logprob": -0.10281177929469518, "compression_ratio": 1.6017699115044248, "no_speech_prob": 5.157473060535267e-05}, {"id": 28, "seek": 18424, "start": 188.88, "end": 194.48000000000002, "text": " maintain like a branch of Redis for every operating system out there, right? In the long", "tokens": [6909, 411, 257, 9819, 295, 4477, 271, 337, 633, 7447, 1185, 484, 456, 11, 558, 30, 682, 264, 938], "temperature": 0.0, "avg_logprob": -0.10281177929469518, "compression_ratio": 1.6017699115044248, "no_speech_prob": 5.157473060535267e-05}, {"id": 29, "seek": 18424, "start": 194.48000000000002, "end": 204.08, "text": " term, it doesn't work so well. So porting also basically means that you as a OS developer,", "tokens": [1433, 11, 309, 1177, 380, 589, 370, 731, 13, 407, 2436, 278, 611, 1936, 1355, 300, 291, 382, 257, 12731, 10754, 11], "temperature": 0.0, "avg_logprob": -0.10281177929469518, "compression_ratio": 1.6017699115044248, "no_speech_prob": 5.157473060535267e-05}, {"id": 30, "seek": 18424, "start": 204.08, "end": 210.56, "text": " you ask the users of your application to make some effort to the application developers,", "tokens": [291, 1029, 264, 5022, 295, 428, 3861, 281, 652, 512, 4630, 281, 264, 3861, 8849, 11], "temperature": 0.0, "avg_logprob": -0.10281177929469518, "compression_ratio": 1.6017699115044248, "no_speech_prob": 5.157473060535267e-05}, {"id": 31, "seek": 21056, "start": 210.56, "end": 214.64000000000001, "text": " they need to make some effort to be compatible with your operating system. This doesn't work,", "tokens": [436, 643, 281, 652, 512, 4630, 281, 312, 18218, 365, 428, 7447, 1185, 13, 639, 1177, 380, 589, 11], "temperature": 0.0, "avg_logprob": -0.11321848492289699, "compression_ratio": 1.5486725663716814, "no_speech_prob": 3.9766131521901116e-05}, {"id": 32, "seek": 21056, "start": 214.64000000000001, "end": 221.44, "text": " nobody is ready to make that kind of effort. Maybe if you give them 10x performance speed up,", "tokens": [5079, 307, 1919, 281, 652, 300, 733, 295, 4630, 13, 2704, 498, 291, 976, 552, 1266, 87, 3389, 3073, 493, 11], "temperature": 0.0, "avg_logprob": -0.11321848492289699, "compression_ratio": 1.5486725663716814, "no_speech_prob": 3.9766131521901116e-05}, {"id": 33, "seek": 21056, "start": 221.44, "end": 228.64000000000001, "text": " but this is unrealistic. So what you want to do is, once again, in my opinion,", "tokens": [457, 341, 307, 42867, 13, 407, 437, 291, 528, 281, 360, 307, 11, 1564, 797, 11, 294, 452, 4800, 11], "temperature": 0.0, "avg_logprob": -0.11321848492289699, "compression_ratio": 1.5486725663716814, "no_speech_prob": 3.9766131521901116e-05}, {"id": 34, "seek": 21056, "start": 230.0, "end": 235.12, "text": " as an OS developer, you want to provide compatibility as transparently as possible.", "tokens": [382, 364, 12731, 10754, 11, 291, 528, 281, 2893, 34237, 382, 7132, 6420, 382, 1944, 13], "temperature": 0.0, "avg_logprob": -0.11321848492289699, "compression_ratio": 1.5486725663716814, "no_speech_prob": 3.9766131521901116e-05}, {"id": 35, "seek": 23512, "start": 235.12, "end": 245.04, "text": " And this means you emulate a popular operating system, for example Linux, or a popular abstraction", "tokens": [400, 341, 1355, 291, 45497, 257, 3743, 7447, 1185, 11, 337, 1365, 18734, 11, 420, 257, 3743, 37765], "temperature": 0.0, "avg_logprob": -0.12777153895451474, "compression_ratio": 1.4973821989528795, "no_speech_prob": 4.748009450850077e-05}, {"id": 36, "seek": 23512, "start": 245.04, "end": 253.20000000000002, "text": " like POSIX or the standard C library, and then you can be compatible at three different levels.", "tokens": [411, 430, 4367, 21124, 420, 264, 3832, 383, 6405, 11, 293, 550, 291, 393, 312, 18218, 412, 1045, 819, 4358, 13], "temperature": 0.0, "avg_logprob": -0.12777153895451474, "compression_ratio": 1.4973821989528795, "no_speech_prob": 4.748009450850077e-05}, {"id": 37, "seek": 23512, "start": 253.20000000000002, "end": 262.24, "text": " The first level is source level or API level compatibility. So you ask the users to compile", "tokens": [440, 700, 1496, 307, 4009, 1496, 420, 9362, 1496, 34237, 13, 407, 291, 1029, 264, 5022, 281, 31413], "temperature": 0.0, "avg_logprob": -0.12777153895451474, "compression_ratio": 1.4973821989528795, "no_speech_prob": 4.748009450850077e-05}, {"id": 38, "seek": 26224, "start": 262.24, "end": 271.04, "text": " their application code against the sources of your kernel, in the case of a unique kernel.", "tokens": [641, 3861, 3089, 1970, 264, 7139, 295, 428, 28256, 11, 294, 264, 1389, 295, 257, 3845, 28256, 13], "temperature": 0.0, "avg_logprob": -0.11207912184975365, "compression_ratio": 1.6465116279069767, "no_speech_prob": 3.888373248628341e-05}, {"id": 39, "seek": 26224, "start": 271.04, "end": 276.88, "text": " So this is, you're still asking some effort from the users, right? In many scenarios,", "tokens": [407, 341, 307, 11, 291, 434, 920, 3365, 512, 4630, 490, 264, 5022, 11, 558, 30, 682, 867, 15077, 11], "temperature": 0.0, "avg_logprob": -0.11207912184975365, "compression_ratio": 1.6465116279069767, "no_speech_prob": 3.888373248628341e-05}, {"id": 40, "seek": 26224, "start": 276.88, "end": 281.28000000000003, "text": " you don't have access to sources, right? If you have proprietary binary or pre-compiled", "tokens": [291, 500, 380, 362, 2105, 281, 7139, 11, 558, 30, 759, 291, 362, 38992, 17434, 420, 659, 12, 21541, 7292], "temperature": 0.0, "avg_logprob": -0.11207912184975365, "compression_ratio": 1.6465116279069767, "no_speech_prob": 3.888373248628341e-05}, {"id": 41, "seek": 26224, "start": 281.28000000000003, "end": 288.64, "text": " binaries, well, you can't have source level compatibility. So it's not perfect and binary", "tokens": [5171, 4889, 11, 731, 11, 291, 393, 380, 362, 4009, 1496, 34237, 13, 407, 309, 311, 406, 2176, 293, 17434], "temperature": 0.0, "avg_logprob": -0.11207912184975365, "compression_ratio": 1.6465116279069767, "no_speech_prob": 3.888373248628341e-05}, {"id": 42, "seek": 28864, "start": 288.64, "end": 295.12, "text": " compatibility is generally a more, let's say, pure version of compatibility. And there are many", "tokens": [34237, 307, 5101, 257, 544, 11, 718, 311, 584, 11, 6075, 3037, 295, 34237, 13, 400, 456, 366, 867], "temperature": 0.0, "avg_logprob": -0.12251204338626585, "compression_ratio": 1.5, "no_speech_prob": 4.245277523295954e-05}, {"id": 43, "seek": 28864, "start": 295.12, "end": 301.84, "text": " two ways to achieve it. You can do that at the level of the standard C library, like OSV. So you", "tokens": [732, 2098, 281, 4584, 309, 13, 509, 393, 360, 300, 412, 264, 1496, 295, 264, 3832, 383, 6405, 11, 411, 12731, 53, 13, 407, 291], "temperature": 0.0, "avg_logprob": -0.12251204338626585, "compression_ratio": 1.5, "no_speech_prob": 4.245277523295954e-05}, {"id": 44, "seek": 28864, "start": 301.84, "end": 312.8, "text": " will dynamically link your kernel plus a standard C library against your application, compile as a", "tokens": [486, 43492, 2113, 428, 28256, 1804, 257, 3832, 383, 6405, 1970, 428, 3861, 11, 31413, 382, 257], "temperature": 0.0, "avg_logprob": -0.12251204338626585, "compression_ratio": 1.5, "no_speech_prob": 4.245277523295954e-05}, {"id": 45, "seek": 31280, "start": 312.8, "end": 321.04, "text": " position independent executable or as a shared library itself. This is great, but if the application", "tokens": [2535, 6695, 7568, 712, 420, 382, 257, 5507, 6405, 2564, 13, 639, 307, 869, 11, 457, 498, 264, 3861], "temperature": 0.0, "avg_logprob": -0.12736788817814418, "compression_ratio": 1.6666666666666667, "no_speech_prob": 5.177565981284715e-05}, {"id": 46, "seek": 31280, "start": 321.04, "end": 326.48, "text": " is making directly system calls to the kernel without going through the standard C library,", "tokens": [307, 1455, 3838, 1185, 5498, 281, 264, 28256, 1553, 516, 807, 264, 3832, 383, 6405, 11], "temperature": 0.0, "avg_logprob": -0.12736788817814418, "compression_ratio": 1.6666666666666667, "no_speech_prob": 5.177565981284715e-05}, {"id": 47, "seek": 31280, "start": 326.48, "end": 331.12, "text": " well, once again, it doesn't work, right? And as a matter of fact, I have counted", "tokens": [731, 11, 1564, 797, 11, 309, 1177, 380, 589, 11, 558, 30, 400, 382, 257, 1871, 295, 1186, 11, 286, 362, 20150], "temperature": 0.0, "avg_logprob": -0.12736788817814418, "compression_ratio": 1.6666666666666667, "no_speech_prob": 5.177565981284715e-05}, {"id": 48, "seek": 31280, "start": 331.12, "end": 336.72, "text": " more than 500 executables in the Debian repository that contain the C score instruction, right? So", "tokens": [544, 813, 5923, 7568, 2965, 294, 264, 1346, 20196, 25841, 300, 5304, 264, 383, 6175, 10951, 11, 558, 30, 407], "temperature": 0.0, "avg_logprob": -0.12736788817814418, "compression_ratio": 1.6666666666666667, "no_speech_prob": 5.177565981284715e-05}, {"id": 49, "seek": 31280, "start": 336.72, "end": 342.72, "text": " they make C scores directly to the kernel. They don't go through the C library. Go, for example,", "tokens": [436, 652, 383, 13444, 3838, 281, 264, 28256, 13, 814, 500, 380, 352, 807, 264, 383, 6405, 13, 1037, 11, 337, 1365, 11], "temperature": 0.0, "avg_logprob": -0.12736788817814418, "compression_ratio": 1.6666666666666667, "no_speech_prob": 5.177565981284715e-05}, {"id": 50, "seek": 34272, "start": 342.72, "end": 348.72, "text": " is making most of its C score, put directly to the kernel and not through the C library. So what", "tokens": [307, 1455, 881, 295, 1080, 383, 6175, 11, 829, 3838, 281, 264, 28256, 293, 406, 807, 264, 383, 6405, 13, 407, 437], "temperature": 0.0, "avg_logprob": -0.10818604500063005, "compression_ratio": 1.5684647302904564, "no_speech_prob": 4.8149933718377724e-05}, {"id": 51, "seek": 34272, "start": 348.72, "end": 354.8, "text": " you want to do is to be compatible at the level of the system calls. So your kernel needs to", "tokens": [291, 528, 281, 360, 307, 281, 312, 18218, 412, 264, 1496, 295, 264, 1185, 5498, 13, 407, 428, 28256, 2203, 281], "temperature": 0.0, "avg_logprob": -0.10818604500063005, "compression_ratio": 1.5684647302904564, "no_speech_prob": 4.8149933718377724e-05}, {"id": 52, "seek": 34272, "start": 354.8, "end": 361.44000000000005, "text": " emulate the C score API that Linux is providing. This is the most transparent way of achieving", "tokens": [45497, 264, 383, 6175, 9362, 300, 18734, 307, 6530, 13, 639, 307, 264, 881, 12737, 636, 295, 19626], "temperature": 0.0, "avg_logprob": -0.10818604500063005, "compression_ratio": 1.5684647302904564, "no_speech_prob": 4.8149933718377724e-05}, {"id": 53, "seek": 34272, "start": 361.44000000000005, "end": 370.48, "text": " compatibility. Now, this is scary, right? Linux has more than 350 system calls. Do we need to", "tokens": [34237, 13, 823, 11, 341, 307, 6958, 11, 558, 30, 18734, 575, 544, 813, 18065, 1185, 5498, 13, 1144, 321, 643, 281], "temperature": 0.0, "avg_logprob": -0.10818604500063005, "compression_ratio": 1.5684647302904564, "no_speech_prob": 4.8149933718377724e-05}, {"id": 54, "seek": 37048, "start": 370.48, "end": 378.16, "text": " implement them all? Will we be and aren't we going to reimplement Linux by doing so? And some of them", "tokens": [4445, 552, 439, 30, 3099, 321, 312, 293, 3212, 380, 321, 516, 281, 33433, 43704, 18734, 538, 884, 370, 30, 400, 512, 295, 552], "temperature": 0.0, "avg_logprob": -0.1385156289855046, "compression_ratio": 1.4619289340101522, "no_speech_prob": 8.188794163288549e-05}, {"id": 55, "seek": 37048, "start": 378.16, "end": 384.0, "text": " are extremely scary by themselves, right? You have like hundreds of IO controls and each of", "tokens": [366, 4664, 6958, 538, 2969, 11, 558, 30, 509, 362, 411, 6779, 295, 39839, 9003, 293, 1184, 295], "temperature": 0.0, "avg_logprob": -0.1385156289855046, "compression_ratio": 1.4619289340101522, "no_speech_prob": 8.188794163288549e-05}, {"id": 56, "seek": 37048, "start": 384.0, "end": 392.48, "text": " them probably require its own implementation. The Linux API even goes beyond system calls. You", "tokens": [552, 1391, 3651, 1080, 1065, 11420, 13, 440, 18734, 9362, 754, 1709, 4399, 1185, 5498, 13, 509], "temperature": 0.0, "avg_logprob": -0.1385156289855046, "compression_ratio": 1.4619289340101522, "no_speech_prob": 8.188794163288549e-05}, {"id": 57, "seek": 39248, "start": 392.48, "end": 400.72, "text": " have things like slash proc slash devs that are, you know, used by many applications. Like the", "tokens": [362, 721, 411, 17330, 9510, 17330, 1905, 82, 300, 366, 11, 291, 458, 11, 1143, 538, 867, 5821, 13, 1743, 264], "temperature": 0.0, "avg_logprob": -0.18014744630793936, "compression_ratio": 1.588235294117647, "no_speech_prob": 2.407366810075473e-05}, {"id": 58, "seek": 39248, "start": 400.72, "end": 409.12, "text": " first thing a muscle binary does when it runs is to look in, I believe it's slash proc or slash", "tokens": [700, 551, 257, 8679, 17434, 775, 562, 309, 6676, 307, 281, 574, 294, 11, 286, 1697, 309, 311, 17330, 9510, 420, 17330], "temperature": 0.0, "avg_logprob": -0.18014744630793936, "compression_ratio": 1.588235294117647, "no_speech_prob": 2.407366810075473e-05}, {"id": 59, "seek": 39248, "start": 409.12, "end": 413.68, "text": " this to get the size of the terminal, right? So you need to have emulation for this part of the", "tokens": [341, 281, 483, 264, 2744, 295, 264, 14709, 11, 558, 30, 407, 291, 643, 281, 362, 846, 2776, 337, 341, 644, 295, 264], "temperature": 0.0, "avg_logprob": -0.18014744630793936, "compression_ratio": 1.588235294117647, "no_speech_prob": 2.407366810075473e-05}, {"id": 60, "seek": 39248, "start": 413.68, "end": 421.84000000000003, "text": " API too. And this, because it seems like a big engineering effort, this creates, it hinders", "tokens": [9362, 886, 13, 400, 341, 11, 570, 309, 2544, 411, 257, 955, 7043, 4630, 11, 341, 7829, 11, 309, 20138, 433], "temperature": 0.0, "avg_logprob": -0.18014744630793936, "compression_ratio": 1.588235294117647, "no_speech_prob": 2.407366810075473e-05}, {"id": 61, "seek": 42184, "start": 421.84, "end": 429.35999999999996, "text": " the development of custom operating systems. So this is inspired by the keynote by Timati Roscoe", "tokens": [264, 3250, 295, 2375, 7447, 3652, 13, 407, 341, 307, 7547, 538, 264, 33896, 538, 7172, 6908, 11144, 1291, 68], "temperature": 0.0, "avg_logprob": -0.1715854879927962, "compression_ratio": 1.4680851063829787, "no_speech_prob": 9.130217949859798e-05}, {"id": 62, "seek": 42184, "start": 429.35999999999996, "end": 437.67999999999995, "text": " at ATC and OSDI 2021. We looked at all the papers. So these are top tier operating systems", "tokens": [412, 8872, 34, 293, 12731, 3085, 7201, 13, 492, 2956, 412, 439, 264, 10577, 13, 407, 613, 366, 1192, 12362, 7447, 3652], "temperature": 0.0, "avg_logprob": -0.1715854879927962, "compression_ratio": 1.4680851063829787, "no_speech_prob": 9.130217949859798e-05}, {"id": 63, "seek": 42184, "start": 437.67999999999995, "end": 445.76, "text": " conferences. And we look over the past 10 years, over a total of more than 1,000 papers,", "tokens": [13765, 2667, 13, 400, 321, 574, 670, 264, 1791, 1266, 924, 11, 670, 257, 3217, 295, 544, 813, 502, 11, 1360, 10577, 11], "temperature": 0.0, "avg_logprob": -0.1715854879927962, "compression_ratio": 1.4680851063829787, "no_speech_prob": 9.130217949859798e-05}, {"id": 64, "seek": 44576, "start": 445.76, "end": 451.68, "text": " how many were about proposing a new operating system as opposed to things like security or", "tokens": [577, 867, 645, 466, 29939, 257, 777, 7447, 1185, 382, 8851, 281, 721, 411, 3825, 420], "temperature": 0.0, "avg_logprob": -0.15221960333329213, "compression_ratio": 1.7582938388625593, "no_speech_prob": 1.971416531887371e-05}, {"id": 65, "seek": 44576, "start": 451.68, "end": 458.24, "text": " machine learning. And among them, how many were just hacking Linux versus proposing an actual", "tokens": [3479, 2539, 13, 400, 3654, 552, 11, 577, 867, 645, 445, 31422, 18734, 5717, 29939, 364, 3539], "temperature": 0.0, "avg_logprob": -0.15221960333329213, "compression_ratio": 1.7582938388625593, "no_speech_prob": 1.971416531887371e-05}, {"id": 66, "seek": 44576, "start": 458.24, "end": 465.36, "text": " operating system implemented from scratch. And the numbers are similar to what we saw earlier,", "tokens": [7447, 1185, 12270, 490, 8459, 13, 400, 264, 3547, 366, 2531, 281, 437, 321, 1866, 3071, 11], "temperature": 0.0, "avg_logprob": -0.15221960333329213, "compression_ratio": 1.7582938388625593, "no_speech_prob": 1.971416531887371e-05}, {"id": 67, "seek": 44576, "start": 465.36, "end": 471.52, "text": " right? You have just a very, very, very few papers proposing a new operating system because", "tokens": [558, 30, 509, 362, 445, 257, 588, 11, 588, 11, 588, 1326, 10577, 29939, 257, 777, 7447, 1185, 570], "temperature": 0.0, "avg_logprob": -0.15221960333329213, "compression_ratio": 1.7582938388625593, "no_speech_prob": 1.971416531887371e-05}, {"id": 68, "seek": 47152, "start": 471.52, "end": 478.79999999999995, "text": " it's a significant engineering effort. And part of the effort is to be providing compatibility", "tokens": [309, 311, 257, 4776, 7043, 4630, 13, 400, 644, 295, 264, 4630, 307, 281, 312, 6530, 34237], "temperature": 0.0, "avg_logprob": -0.15805203740189716, "compression_ratio": 1.5814977973568283, "no_speech_prob": 2.0517680241027847e-05}, {"id": 69, "seek": 47152, "start": 478.79999999999995, "end": 484.24, "text": " to an application like Apache already to get a few numbers at the end of the paper, right?", "tokens": [281, 364, 3861, 411, 46597, 1217, 281, 483, 257, 1326, 3547, 412, 264, 917, 295, 264, 3035, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.15805203740189716, "compression_ratio": 1.5814977973568283, "no_speech_prob": 2.0517680241027847e-05}, {"id": 70, "seek": 47152, "start": 484.24, "end": 492.71999999999997, "text": " So this is the problem. Now, the particular problem that I want to talk about is how", "tokens": [407, 341, 307, 264, 1154, 13, 823, 11, 264, 1729, 1154, 300, 286, 528, 281, 751, 466, 307, 577], "temperature": 0.0, "avg_logprob": -0.15805203740189716, "compression_ratio": 1.5814977973568283, "no_speech_prob": 2.0517680241027847e-05}, {"id": 71, "seek": 47152, "start": 494.56, "end": 499.59999999999997, "text": " I'm sure several people in this forum have attempted to build some form of compatibility", "tokens": [286, 478, 988, 2940, 561, 294, 341, 17542, 362, 18997, 281, 1322, 512, 1254, 295, 34237], "temperature": 0.0, "avg_logprob": -0.15805203740189716, "compression_ratio": 1.5814977973568283, "no_speech_prob": 2.0517680241027847e-05}, {"id": 72, "seek": 49960, "start": 499.6, "end": 506.0, "text": " layer for an operating systems. And we are all kind of working on the same thing in parallel", "tokens": [4583, 337, 364, 7447, 3652, 13, 400, 321, 366, 439, 733, 295, 1364, 322, 264, 912, 551, 294, 8952], "temperature": 0.0, "avg_logprob": -0.1482754647731781, "compression_ratio": 1.4595959595959596, "no_speech_prob": 4.489308412303217e-05}, {"id": 73, "seek": 49960, "start": 506.56, "end": 513.6800000000001, "text": " with some form of ad hoc processes that may benefit from some optimization. So I've just listed", "tokens": [365, 512, 1254, 295, 614, 16708, 7555, 300, 815, 5121, 490, 512, 19618, 13, 407, 286, 600, 445, 10052], "temperature": 0.0, "avg_logprob": -0.1482754647731781, "compression_ratio": 1.4595959595959596, "no_speech_prob": 4.489308412303217e-05}, {"id": 74, "seek": 49960, "start": 513.6800000000001, "end": 520.96, "text": " here a few projects that have a Cisco level binary compatibility layers, but actually there are many", "tokens": [510, 257, 1326, 4455, 300, 362, 257, 38528, 1496, 17434, 34237, 7914, 11, 457, 767, 456, 366, 867], "temperature": 0.0, "avg_logprob": -0.1482754647731781, "compression_ratio": 1.4595959595959596, "no_speech_prob": 4.489308412303217e-05}, {"id": 75, "seek": 52096, "start": 520.96, "end": 530.1600000000001, "text": " more. And from what I understand, it is a very organic process. So first of all, it is application", "tokens": [544, 13, 400, 490, 437, 286, 1223, 11, 309, 307, 257, 588, 10220, 1399, 13, 407, 700, 295, 439, 11, 309, 307, 3861], "temperature": 0.0, "avg_logprob": -0.11605633521566586, "compression_ratio": 1.5884773662551441, "no_speech_prob": 1.6188199879252352e-05}, {"id": 76, "seek": 52096, "start": 530.1600000000001, "end": 536.48, "text": " driven, right? People have a few sets of application in mind that they want to support. If you are", "tokens": [9555, 11, 558, 30, 3432, 362, 257, 1326, 6352, 295, 3861, 294, 1575, 300, 436, 528, 281, 1406, 13, 759, 291, 366], "temperature": 0.0, "avg_logprob": -0.11605633521566586, "compression_ratio": 1.5884773662551441, "no_speech_prob": 1.6188199879252352e-05}, {"id": 77, "seek": 52096, "start": 536.48, "end": 542.4000000000001, "text": " doing cloud, you want to support the user's suspect, ready, Apache, whatever. And the process", "tokens": [884, 4588, 11, 291, 528, 281, 1406, 264, 4195, 311, 9091, 11, 1919, 11, 46597, 11, 2035, 13, 400, 264, 1399], "temperature": 0.0, "avg_logprob": -0.11605633521566586, "compression_ratio": 1.5884773662551441, "no_speech_prob": 1.6188199879252352e-05}, {"id": 78, "seek": 52096, "start": 542.4000000000001, "end": 550.32, "text": " basically looks like that. You take an app, you try to run it on top of your operating system.", "tokens": [1936, 1542, 411, 300, 13, 509, 747, 364, 724, 11, 291, 853, 281, 1190, 309, 322, 1192, 295, 428, 7447, 1185, 13], "temperature": 0.0, "avg_logprob": -0.11605633521566586, "compression_ratio": 1.5884773662551441, "no_speech_prob": 1.6188199879252352e-05}, {"id": 79, "seek": 55032, "start": 550.32, "end": 556.96, "text": " Obviously, it fails. You investigate. You're like, oh, I'm missing the implementation for this system", "tokens": [7580, 11, 309, 18199, 13, 509, 15013, 13, 509, 434, 411, 11, 1954, 11, 286, 478, 5361, 264, 11420, 337, 341, 1185], "temperature": 0.0, "avg_logprob": -0.1462014989649996, "compression_ratio": 1.564516129032258, "no_speech_prob": 2.5827255740296096e-05}, {"id": 80, "seek": 55032, "start": 556.96, "end": 562.6400000000001, "text": " code. So you implement whatever operating system features are required to fix that particular", "tokens": [3089, 13, 407, 291, 4445, 2035, 7447, 1185, 4122, 366, 4739, 281, 3191, 300, 1729], "temperature": 0.0, "avg_logprob": -0.1462014989649996, "compression_ratio": 1.564516129032258, "no_speech_prob": 2.5827255740296096e-05}, {"id": 81, "seek": 55032, "start": 562.6400000000001, "end": 569.84, "text": " issue, rinse and repeat until the app is working. And then you go to the next app. So it's a very", "tokens": [2734, 11, 27026, 293, 7149, 1826, 264, 724, 307, 1364, 13, 400, 550, 291, 352, 281, 264, 958, 724, 13, 407, 309, 311, 257, 588], "temperature": 0.0, "avg_logprob": -0.1462014989649996, "compression_ratio": 1.564516129032258, "no_speech_prob": 2.5827255740296096e-05}, {"id": 82, "seek": 55032, "start": 570.6400000000001, "end": 575.84, "text": " intuitive and organic process. So when I built the Armitage, this is exactly what I was doing.", "tokens": [21769, 293, 10220, 1399, 13, 407, 562, 286, 3094, 264, 1587, 3508, 609, 11, 341, 307, 2293, 437, 286, 390, 884, 13], "temperature": 0.0, "avg_logprob": -0.1462014989649996, "compression_ratio": 1.564516129032258, "no_speech_prob": 2.5827255740296096e-05}, {"id": 83, "seek": 57584, "start": 575.84, "end": 586.72, "text": " So something that comes to mind is, can't we have some form of generic compatibility layers", "tokens": [407, 746, 300, 1487, 281, 1575, 307, 11, 393, 380, 321, 362, 512, 1254, 295, 19577, 34237, 7914], "temperature": 0.0, "avg_logprob": -0.2097054296924222, "compression_ratio": 1.4764397905759161, "no_speech_prob": 2.6215844627586193e-05}, {"id": 84, "seek": 57584, "start": 586.72, "end": 594.64, "text": " that we could plug? Like something a bit like New Lib that would provide a generic interface.", "tokens": [300, 321, 727, 5452, 30, 1743, 746, 257, 857, 411, 1873, 15834, 300, 576, 2893, 257, 19577, 9226, 13], "temperature": 0.0, "avg_logprob": -0.2097054296924222, "compression_ratio": 1.4764397905759161, "no_speech_prob": 2.6215844627586193e-05}, {"id": 85, "seek": 57584, "start": 595.2800000000001, "end": 600.88, "text": " And I believe it's not really possible because most of this implementation to support the system", "tokens": [400, 286, 1697, 309, 311, 406, 534, 1944, 570, 881, 295, 341, 11420, 281, 1406, 264, 1185], "temperature": 0.0, "avg_logprob": -0.2097054296924222, "compression_ratio": 1.4764397905759161, "no_speech_prob": 2.6215844627586193e-05}, {"id": 86, "seek": 60088, "start": 600.88, "end": 606.64, "text": " code is very specific to whatever operating system you are using. And it's not clear if a", "tokens": [3089, 307, 588, 2685, 281, 2035, 7447, 1185, 291, 366, 1228, 13, 400, 309, 311, 406, 1850, 498, 257], "temperature": 0.0, "avg_logprob": -0.12160665232960771, "compression_ratio": 1.5844155844155845, "no_speech_prob": 2.3505037461291067e-05}, {"id": 87, "seek": 60088, "start": 606.64, "end": 615.12, "text": " generic compatibility layer can be achieved. But can we still somehow optimize that process?", "tokens": [19577, 34237, 4583, 393, 312, 11042, 13, 583, 393, 321, 920, 6063, 19719, 300, 1399, 30], "temperature": 0.0, "avg_logprob": -0.12160665232960771, "compression_ratio": 1.5844155844155845, "no_speech_prob": 2.3505037461291067e-05}, {"id": 88, "seek": 60088, "start": 616.88, "end": 625.28, "text": " Some have tried static analysis. So they take the binary of the application they want to support", "tokens": [2188, 362, 3031, 13437, 5215, 13, 407, 436, 747, 264, 17434, 295, 264, 3861, 436, 528, 281, 1406], "temperature": 0.0, "avg_logprob": -0.12160665232960771, "compression_ratio": 1.5844155844155845, "no_speech_prob": 2.3505037461291067e-05}, {"id": 89, "seek": 60088, "start": 625.28, "end": 628.72, "text": " and they look, okay, so what are the system codes that are made by these applications?", "tokens": [293, 436, 574, 11, 1392, 11, 370, 437, 366, 264, 1185, 14211, 300, 366, 1027, 538, 613, 5821, 30], "temperature": 0.0, "avg_logprob": -0.12160665232960771, "compression_ratio": 1.5844155844155845, "no_speech_prob": 2.3505037461291067e-05}, {"id": 90, "seek": 62872, "start": 628.72, "end": 638.08, "text": " So this has been done in the best paper in Eurosis 2016, analyzed all the binaries from", "tokens": [407, 341, 575, 668, 1096, 294, 264, 1151, 3035, 294, 462, 374, 8211, 6549, 11, 28181, 439, 264, 5171, 4889, 490], "temperature": 0.0, "avg_logprob": -0.197582316042772, "compression_ratio": 1.4093264248704662, "no_speech_prob": 4.814675776287913e-05}, {"id": 91, "seek": 62872, "start": 638.08, "end": 646.08, "text": " Ubuntu, I believe it was 14 or four repositories. And they concluded that every Ubuntu installation,", "tokens": [30230, 45605, 11, 286, 1697, 309, 390, 3499, 420, 1451, 22283, 2083, 13, 400, 436, 22960, 300, 633, 30230, 45605, 13260, 11], "temperature": 0.0, "avg_logprob": -0.197582316042772, "compression_ratio": 1.4093264248704662, "no_speech_prob": 4.814675776287913e-05}, {"id": 92, "seek": 62872, "start": 646.08, "end": 653.36, "text": " including the smallest one, require more than 200 system codes and 200 IO controls,", "tokens": [3009, 264, 16998, 472, 11, 3651, 544, 813, 2331, 1185, 14211, 293, 2331, 39839, 9003, 11], "temperature": 0.0, "avg_logprob": -0.197582316042772, "compression_ratio": 1.4093264248704662, "no_speech_prob": 4.814675776287913e-05}, {"id": 93, "seek": 65336, "start": 653.36, "end": 660.64, "text": " five controls, and PRCTL codes, and hundreds of 2.0 files. So this doesn't help. It is still", "tokens": [1732, 9003, 11, 293, 11568, 10259, 43, 14211, 11, 293, 6779, 295, 568, 13, 15, 7098, 13, 407, 341, 1177, 380, 854, 13, 467, 307, 920], "temperature": 0.0, "avg_logprob": -0.2220304489135742, "compression_ratio": 1.400990099009901, "no_speech_prob": 6.979896716075018e-05}, {"id": 94, "seek": 65336, "start": 660.64, "end": 673.52, "text": " quite scary. It still represents a gigantic engineering effort. But do we want full compatibility", "tokens": [1596, 6958, 13, 467, 920, 8855, 257, 26800, 7043, 4630, 13, 583, 360, 321, 528, 1577, 34237], "temperature": 0.0, "avg_logprob": -0.2220304489135742, "compression_ratio": 1.400990099009901, "no_speech_prob": 6.979896716075018e-05}, {"id": 95, "seek": 65336, "start": 673.52, "end": 682.16, "text": " with Ubuntu installation? In the end, especially in the early stage of the development of an", "tokens": [365, 30230, 45605, 13260, 30, 682, 264, 917, 11, 2318, 294, 264, 2440, 3233, 295, 264, 3250, 295, 364], "temperature": 0.0, "avg_logprob": -0.2220304489135742, "compression_ratio": 1.400990099009901, "no_speech_prob": 6.979896716075018e-05}, {"id": 96, "seek": 68216, "start": 682.16, "end": 688.64, "text": " operating system, you just want to get a few applications up and running. And do you even", "tokens": [7447, 1185, 11, 291, 445, 528, 281, 483, 257, 1326, 5821, 493, 293, 2614, 13, 400, 360, 291, 754], "temperature": 0.0, "avg_logprob": -0.1298552492390508, "compression_ratio": 1.5427350427350428, "no_speech_prob": 6.934363045729697e-05}, {"id": 97, "seek": 68216, "start": 688.64, "end": 694.16, "text": " 100% compatibility? When I write a paper, I don't really care if everything is stable. I just want", "tokens": [2319, 4, 34237, 30, 1133, 286, 2464, 257, 3035, 11, 286, 500, 380, 534, 1127, 498, 1203, 307, 8351, 13, 286, 445, 528], "temperature": 0.0, "avg_logprob": -0.1298552492390508, "compression_ratio": 1.5427350427350428, "no_speech_prob": 6.934363045729697e-05}, {"id": 98, "seek": 68216, "start": 694.16, "end": 704.0, "text": " to get some numbers. So isn't there a better way? And obviously, maybe you think about, yeah,", "tokens": [281, 483, 512, 3547, 13, 407, 1943, 380, 456, 257, 1101, 636, 30, 400, 2745, 11, 1310, 291, 519, 466, 11, 1338, 11], "temperature": 0.0, "avg_logprob": -0.1298552492390508, "compression_ratio": 1.5427350427350428, "no_speech_prob": 6.934363045729697e-05}, {"id": 99, "seek": 68216, "start": 704.0, "end": 708.8, "text": " let's do dynamic analysis. Let's run the applications that we want to support.", "tokens": [718, 311, 360, 8546, 5215, 13, 961, 311, 1190, 264, 5821, 300, 321, 528, 281, 1406, 13], "temperature": 0.0, "avg_logprob": -0.1298552492390508, "compression_ratio": 1.5427350427350428, "no_speech_prob": 6.934363045729697e-05}, {"id": 100, "seek": 70880, "start": 708.8, "end": 713.5999999999999, "text": " We send them some input that we want to support, like I'm running", "tokens": [492, 2845, 552, 512, 4846, 300, 321, 528, 281, 1406, 11, 411, 286, 478, 2614], "temperature": 0.0, "avg_logprob": -0.21125845475630325, "compression_ratio": 1.7300380228136882, "no_speech_prob": 5.202044121688232e-05}, {"id": 101, "seek": 70880, "start": 713.5999999999999, "end": 718.8, "text": " engineering and I'm submitting some HTTP for something like that. And then we trace the system", "tokens": [7043, 293, 286, 478, 31836, 512, 33283, 337, 746, 411, 300, 13, 400, 550, 321, 13508, 264, 1185], "temperature": 0.0, "avg_logprob": -0.21125845475630325, "compression_ratio": 1.7300380228136882, "no_speech_prob": 5.202044121688232e-05}, {"id": 102, "seek": 70880, "start": 718.8, "end": 724.8, "text": " codes that are done. So this is going to give us a subset of the system codes that can be identified", "tokens": [14211, 300, 366, 1096, 13, 407, 341, 307, 516, 281, 976, 505, 257, 25993, 295, 264, 1185, 14211, 300, 393, 312, 9234], "temperature": 0.0, "avg_logprob": -0.21125845475630325, "compression_ratio": 1.7300380228136882, "no_speech_prob": 5.202044121688232e-05}, {"id": 103, "seek": 70880, "start": 724.8, "end": 731.5999999999999, "text": " through static analysis that has a tendency to overestimate. So with this trace, the engineering", "tokens": [807, 13437, 5215, 300, 575, 257, 18187, 281, 670, 377, 2905, 13, 407, 365, 341, 13508, 11, 264, 7043], "temperature": 0.0, "avg_logprob": -0.21125845475630325, "compression_ratio": 1.7300380228136882, "no_speech_prob": 5.202044121688232e-05}, {"id": 104, "seek": 70880, "start": 731.5999999999999, "end": 737.5999999999999, "text": " effort to support an application and a set of input is a bit lower. But it's still not a panacea", "tokens": [4630, 281, 1406, 364, 3861, 293, 257, 992, 295, 4846, 307, 257, 857, 3126, 13, 583, 309, 311, 920, 406, 257, 2462, 617, 64], "temperature": 0.0, "avg_logprob": -0.21125845475630325, "compression_ratio": 1.7300380228136882, "no_speech_prob": 5.202044121688232e-05}, {"id": 105, "seek": 73760, "start": 737.6, "end": 743.6, "text": " because it's not taking into account two things that we do when we implement compatibility layers.", "tokens": [570, 309, 311, 406, 1940, 666, 2696, 732, 721, 300, 321, 360, 562, 321, 4445, 34237, 7914, 13], "temperature": 0.0, "avg_logprob": -0.21359169006347656, "compression_ratio": 1.5537190082644627, "no_speech_prob": 6.0896749346284196e-05}, {"id": 106, "seek": 73760, "start": 743.6, "end": 752.32, "text": " So this is my code. Don't judge me. One thing that I did with Hermitux was at some point,", "tokens": [407, 341, 307, 452, 3089, 13, 1468, 380, 6995, 385, 13, 1485, 551, 300, 286, 630, 365, 21842, 270, 2449, 390, 412, 512, 935, 11], "temperature": 0.0, "avg_logprob": -0.21359169006347656, "compression_ratio": 1.5537190082644627, "no_speech_prob": 6.0896749346284196e-05}, {"id": 107, "seek": 73760, "start": 752.32, "end": 758.08, "text": " it was an app that was calling MNCore to check if some page of memory wasn't swapped or not.", "tokens": [309, 390, 364, 724, 300, 390, 5141, 376, 45, 34, 418, 281, 1520, 498, 512, 3028, 295, 4675, 2067, 380, 50011, 420, 406, 13], "temperature": 0.0, "avg_logprob": -0.21359169006347656, "compression_ratio": 1.5537190082644627, "no_speech_prob": 6.0896749346284196e-05}, {"id": 108, "seek": 73760, "start": 758.08, "end": 763.84, "text": " It has actually, you know, there is no swap in most unique kernels. So it really didn't matter", "tokens": [467, 575, 767, 11, 291, 458, 11, 456, 307, 572, 18135, 294, 881, 3845, 23434, 1625, 13, 407, 309, 534, 994, 380, 1871], "temperature": 0.0, "avg_logprob": -0.21359169006347656, "compression_ratio": 1.5537190082644627, "no_speech_prob": 6.0896749346284196e-05}, {"id": 109, "seek": 76384, "start": 763.84, "end": 770.88, "text": " to implement this. So you know this means operation not supported. So stopping a system", "tokens": [281, 4445, 341, 13, 407, 291, 458, 341, 1355, 6916, 406, 8104, 13, 407, 12767, 257, 1185], "temperature": 0.0, "avg_logprob": -0.15175142393007382, "compression_ratio": 1.6327433628318584, "no_speech_prob": 2.9519862437155098e-05}, {"id": 110, "seek": 76384, "start": 770.88, "end": 775.44, "text": " code is just saying, yeah, we don't support it. And you cross your finger that the application", "tokens": [3089, 307, 445, 1566, 11, 1338, 11, 321, 500, 380, 1406, 309, 13, 400, 291, 3278, 428, 5984, 300, 264, 3861], "temperature": 0.0, "avg_logprob": -0.15175142393007382, "compression_ratio": 1.6327433628318584, "no_speech_prob": 2.9519862437155098e-05}, {"id": 111, "seek": 76384, "start": 775.44, "end": 781.0400000000001, "text": " has some kind of fallback path to do something else if the system code fails. And it works", "tokens": [575, 512, 733, 295, 2100, 3207, 3100, 281, 360, 746, 1646, 498, 264, 1185, 3089, 18199, 13, 400, 309, 1985], "temperature": 0.0, "avg_logprob": -0.15175142393007382, "compression_ratio": 1.6327433628318584, "no_speech_prob": 2.9519862437155098e-05}, {"id": 112, "seek": 76384, "start": 781.0400000000001, "end": 787.12, "text": " in some cases. And then we can do something even more nasty. Don't judge me again. You can fake", "tokens": [294, 512, 3331, 13, 400, 550, 321, 393, 360, 746, 754, 544, 17923, 13, 1468, 380, 6995, 385, 797, 13, 509, 393, 7592], "temperature": 0.0, "avg_logprob": -0.15175142393007382, "compression_ratio": 1.6327433628318584, "no_speech_prob": 2.9519862437155098e-05}, {"id": 113, "seek": 78712, "start": 787.12, "end": 795.68, "text": " the success of a system code, right? Surprisingly, in some situation, returning a success code,", "tokens": [264, 2245, 295, 257, 1185, 3089, 11, 558, 30, 49908, 11, 294, 512, 2590, 11, 12678, 257, 2245, 3089, 11], "temperature": 0.0, "avg_logprob": -0.14924979209899902, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.3931509784015361e-05}, {"id": 114, "seek": 78712, "start": 796.88, "end": 801.84, "text": " even if the system code doesn't have any implementation in your operating system,", "tokens": [754, 498, 264, 1185, 3089, 1177, 380, 362, 604, 11420, 294, 428, 7447, 1185, 11], "temperature": 0.0, "avg_logprob": -0.14924979209899902, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.3931509784015361e-05}, {"id": 115, "seek": 78712, "start": 801.84, "end": 807.12, "text": " it's going to work in some cases. You know, I'll tell a bit more about why this works sometimes.", "tokens": [309, 311, 516, 281, 589, 294, 512, 3331, 13, 509, 458, 11, 286, 603, 980, 257, 857, 544, 466, 983, 341, 1985, 2171, 13], "temperature": 0.0, "avg_logprob": -0.14924979209899902, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.3931509784015361e-05}, {"id": 116, "seek": 78712, "start": 807.12, "end": 812.8, "text": " So stubbing and faking lets you implement even less system calls than what you would trace with", "tokens": [407, 20266, 4324, 293, 283, 2456, 6653, 291, 4445, 754, 1570, 1185, 5498, 813, 437, 291, 576, 13508, 365], "temperature": 0.0, "avg_logprob": -0.14924979209899902, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.3931509784015361e-05}, {"id": 117, "seek": 81280, "start": 812.8, "end": 819.52, "text": " it trace. So in the end, you know, if you want to support an app or a set of application in your", "tokens": [309, 13508, 13, 407, 294, 264, 917, 11, 291, 458, 11, 498, 291, 528, 281, 1406, 364, 724, 420, 257, 992, 295, 3861, 294, 428], "temperature": 0.0, "avg_logprob": -0.1678348927015669, "compression_ratio": 1.6484018264840183, "no_speech_prob": 1.4925828509149142e-05}, {"id": 118, "seek": 81280, "start": 819.52, "end": 824.56, "text": " custom operating system, the amount of system calls that you actually need to implement.", "tokens": [2375, 7447, 1185, 11, 264, 2372, 295, 1185, 5498, 300, 291, 767, 643, 281, 4445, 13], "temperature": 0.0, "avg_logprob": -0.1678348927015669, "compression_ratio": 1.6484018264840183, "no_speech_prob": 1.4925828509149142e-05}, {"id": 119, "seek": 81280, "start": 826.0, "end": 831.8399999999999, "text": " So obviously, it's smaller than the entire Linux SQL API. Static binary analysis will,", "tokens": [407, 2745, 11, 309, 311, 4356, 813, 264, 2302, 18734, 19200, 9362, 13, 745, 2399, 17434, 5215, 486, 11], "temperature": 0.0, "avg_logprob": -0.1678348927015669, "compression_ratio": 1.6484018264840183, "no_speech_prob": 1.4925828509149142e-05}, {"id": 120, "seek": 81280, "start": 833.04, "end": 836.9599999999999, "text": " on the binaries of the applications you want to support, will identify a subset of that.", "tokens": [322, 264, 5171, 4889, 295, 264, 5821, 291, 528, 281, 1406, 11, 486, 5876, 257, 25993, 295, 300, 13], "temperature": 0.0, "avg_logprob": -0.1678348927015669, "compression_ratio": 1.6484018264840183, "no_speech_prob": 1.4925828509149142e-05}, {"id": 121, "seek": 83696, "start": 836.96, "end": 842.96, "text": " Still pretty big. It's an overestimate. Source analysis gets you more precise results.", "tokens": [8291, 1238, 955, 13, 467, 311, 364, 670, 377, 2905, 13, 29629, 5215, 2170, 291, 544, 13600, 3542, 13], "temperature": 0.0, "avg_logprob": -0.12900624067887015, "compression_ratio": 1.537117903930131, "no_speech_prob": 7.637646922376007e-05}, {"id": 122, "seek": 83696, "start": 843.84, "end": 851.6800000000001, "text": " But it is pretty hard to achieve. And it is still overestimating. S trace will give you,", "tokens": [583, 309, 307, 1238, 1152, 281, 4584, 13, 400, 309, 307, 920, 670, 377, 332, 990, 13, 318, 13508, 486, 976, 291, 11], "temperature": 0.0, "avg_logprob": -0.12900624067887015, "compression_ratio": 1.537117903930131, "no_speech_prob": 7.637646922376007e-05}, {"id": 123, "seek": 83696, "start": 851.6800000000001, "end": 857.36, "text": " once again, a subset. Things start to look better. And among these trace by S trace,", "tokens": [1564, 797, 11, 257, 25993, 13, 9514, 722, 281, 574, 1101, 13, 400, 3654, 613, 13508, 538, 318, 13508, 11], "temperature": 0.0, "avg_logprob": -0.12900624067887015, "compression_ratio": 1.537117903930131, "no_speech_prob": 7.637646922376007e-05}, {"id": 124, "seek": 83696, "start": 857.36, "end": 862.64, "text": " you actually don't need to implement everything. You can stub and fake some of this SQL. So", "tokens": [291, 767, 500, 380, 643, 281, 4445, 1203, 13, 509, 393, 20266, 293, 7592, 512, 295, 341, 19200, 13, 407], "temperature": 0.0, "avg_logprob": -0.12900624067887015, "compression_ratio": 1.537117903930131, "no_speech_prob": 7.637646922376007e-05}, {"id": 125, "seek": 86264, "start": 862.64, "end": 872.24, "text": " can we measure that? Yes, with loop. So loop means magnifying glass in French. It's a tool", "tokens": [393, 321, 3481, 300, 30, 1079, 11, 365, 6367, 13, 407, 6367, 1355, 4944, 5489, 4276, 294, 5522, 13, 467, 311, 257, 2290], "temperature": 0.0, "avg_logprob": -0.1166585183912708, "compression_ratio": 1.5948275862068966, "no_speech_prob": 3.7825546314707026e-05}, {"id": 126, "seek": 86264, "start": 872.24, "end": 877.12, "text": " that was built by Hugo, my student, and it's some kind of super S trace that is measuring", "tokens": [300, 390, 3094, 538, 32504, 11, 452, 3107, 11, 293, 309, 311, 512, 733, 295, 1687, 318, 13508, 300, 307, 13389], "temperature": 0.0, "avg_logprob": -0.1166585183912708, "compression_ratio": 1.5948275862068966, "no_speech_prob": 3.7825546314707026e-05}, {"id": 127, "seek": 86264, "start": 877.12, "end": 882.08, "text": " the system calls that are required to support an application. And that can also tell you which", "tokens": [264, 1185, 5498, 300, 366, 4739, 281, 1406, 364, 3861, 13, 400, 300, 393, 611, 980, 291, 597], "temperature": 0.0, "avg_logprob": -0.1166585183912708, "compression_ratio": 1.5948275862068966, "no_speech_prob": 3.7825546314707026e-05}, {"id": 128, "seek": 86264, "start": 882.08, "end": 891.04, "text": " one you can stub and which one you can fake. So we used it to build a database of measurements", "tokens": [472, 291, 393, 20266, 293, 597, 472, 291, 393, 7592, 13, 407, 321, 1143, 309, 281, 1322, 257, 8149, 295, 15383], "temperature": 0.0, "avg_logprob": -0.1166585183912708, "compression_ratio": 1.5948275862068966, "no_speech_prob": 3.7825546314707026e-05}, {"id": 129, "seek": 89104, "start": 891.04, "end": 899.52, "text": " for a relatively large set of applications. And with loop, if you give me a description", "tokens": [337, 257, 7226, 2416, 992, 295, 5821, 13, 400, 365, 6367, 11, 498, 291, 976, 385, 257, 3855], "temperature": 0.0, "avg_logprob": -0.09643761129940258, "compression_ratio": 1.812807881773399, "no_speech_prob": 5.1312297728145495e-05}, {"id": 130, "seek": 89104, "start": 899.52, "end": 903.92, "text": " of your operating system, basically the list of system calls that you already support,", "tokens": [295, 428, 7447, 1185, 11, 1936, 264, 1329, 295, 1185, 5498, 300, 291, 1217, 1406, 11], "temperature": 0.0, "avg_logprob": -0.09643761129940258, "compression_ratio": 1.812807881773399, "no_speech_prob": 5.1312297728145495e-05}, {"id": 131, "seek": 89104, "start": 903.92, "end": 908.8, "text": " and you give me the list of applications that you would like to support, we run them through loop", "tokens": [293, 291, 976, 385, 264, 1329, 295, 5821, 300, 291, 576, 411, 281, 1406, 11, 321, 1190, 552, 807, 6367], "temperature": 0.0, "avg_logprob": -0.09643761129940258, "compression_ratio": 1.812807881773399, "no_speech_prob": 5.1312297728145495e-05}, {"id": 132, "seek": 89104, "start": 908.8, "end": 914.48, "text": " and loop can derive a support plan, which basically will tell you, okay, for this set of target", "tokens": [293, 6367, 393, 28446, 257, 1406, 1393, 11, 597, 1936, 486, 980, 291, 11, 1392, 11, 337, 341, 992, 295, 3779], "temperature": 0.0, "avg_logprob": -0.09643761129940258, "compression_ratio": 1.812807881773399, "no_speech_prob": 5.1312297728145495e-05}, {"id": 133, "seek": 91448, "start": 914.48, "end": 921.76, "text": " application. And given the set of system calls that you already support, what is the optimized", "tokens": [3861, 13, 400, 2212, 264, 992, 295, 1185, 5498, 300, 291, 1217, 1406, 11, 437, 307, 264, 26941], "temperature": 0.0, "avg_logprob": -0.08612414685691275, "compression_ratio": 1.6574074074074074, "no_speech_prob": 1.8767137589748017e-05}, {"id": 134, "seek": 91448, "start": 921.76, "end": 927.28, "text": " order of system calls to implement to support as many applications as soon as possible? Okay,", "tokens": [1668, 295, 1185, 5498, 281, 4445, 281, 1406, 382, 867, 5821, 382, 2321, 382, 1944, 30, 1033, 11], "temperature": 0.0, "avg_logprob": -0.08612414685691275, "compression_ratio": 1.6574074074074074, "no_speech_prob": 1.8767137589748017e-05}, {"id": 135, "seek": 91448, "start": 927.28, "end": 931.36, "text": " so I will give you an example of support plan by the end of the presentation.", "tokens": [370, 286, 486, 976, 291, 364, 1365, 295, 1406, 1393, 538, 264, 917, 295, 264, 5860, 13], "temperature": 0.0, "avg_logprob": -0.08612414685691275, "compression_ratio": 1.6574074074074074, "no_speech_prob": 1.8767137589748017e-05}, {"id": 136, "seek": 91448, "start": 932.88, "end": 938.08, "text": " So from the user point of view, loop needs two things to perform its measurement on a given", "tokens": [407, 490, 264, 4195, 935, 295, 1910, 11, 6367, 2203, 732, 721, 281, 2042, 1080, 13160, 322, 257, 2212], "temperature": 0.0, "avg_logprob": -0.08612414685691275, "compression_ratio": 1.6574074074074074, "no_speech_prob": 1.8767137589748017e-05}, {"id": 137, "seek": 93808, "start": 938.08, "end": 945.2800000000001, "text": " application. You give it a Docker file that is describing how you want to build and run the", "tokens": [3861, 13, 509, 976, 309, 257, 33772, 3991, 300, 307, 16141, 577, 291, 528, 281, 1322, 293, 1190, 264], "temperature": 0.0, "avg_logprob": -0.10180295451303546, "compression_ratio": 1.632034632034632, "no_speech_prob": 2.62285193457501e-05}, {"id": 138, "seek": 93808, "start": 945.2800000000001, "end": 951.9200000000001, "text": " application for which you want to measure the system calls needed. And optionally, you may need", "tokens": [3861, 337, 597, 291, 528, 281, 3481, 264, 1185, 5498, 2978, 13, 400, 3614, 379, 11, 291, 815, 643], "temperature": 0.0, "avg_logprob": -0.10180295451303546, "compression_ratio": 1.632034632034632, "no_speech_prob": 2.62285193457501e-05}, {"id": 139, "seek": 93808, "start": 951.9200000000001, "end": 956.5600000000001, "text": " an input workload. Think about a web server. It's not going to call many system calls until you", "tokens": [364, 4846, 20139, 13, 6557, 466, 257, 3670, 7154, 13, 467, 311, 406, 516, 281, 818, 867, 1185, 5498, 1826, 291], "temperature": 0.0, "avg_logprob": -0.10180295451303546, "compression_ratio": 1.632034632034632, "no_speech_prob": 2.62285193457501e-05}, {"id": 140, "seek": 93808, "start": 956.5600000000001, "end": 963.44, "text": " actually start to send requests to it. Loop will instantiate the application, launch it on a,", "tokens": [767, 722, 281, 2845, 12475, 281, 309, 13, 45660, 486, 9836, 13024, 264, 3861, 11, 4025, 309, 322, 257, 11], "temperature": 0.0, "avg_logprob": -0.10180295451303546, "compression_ratio": 1.632034632034632, "no_speech_prob": 2.62285193457501e-05}, {"id": 141, "seek": 96344, "start": 963.44, "end": 969.6, "text": " you know, standard Linux kernel and analyze the system calls that are done and with a few tricks", "tokens": [291, 458, 11, 3832, 18734, 28256, 293, 12477, 264, 1185, 5498, 300, 366, 1096, 293, 365, 257, 1326, 11733], "temperature": 0.0, "avg_logprob": -0.14722873003054887, "compression_ratio": 1.5051020408163265, "no_speech_prob": 2.086733002215624e-05}, {"id": 142, "seek": 96344, "start": 969.6, "end": 977.9200000000001, "text": " we'll be able to know which ones can be faked or stubbed. The results are, it's basically just a", "tokens": [321, 603, 312, 1075, 281, 458, 597, 2306, 393, 312, 283, 7301, 420, 20266, 2883, 13, 440, 3542, 366, 11, 309, 311, 1936, 445, 257], "temperature": 0.0, "avg_logprob": -0.14722873003054887, "compression_ratio": 1.5051020408163265, "no_speech_prob": 2.086733002215624e-05}, {"id": 143, "seek": 96344, "start": 977.9200000000001, "end": 986.6400000000001, "text": " CSV file for each system call that is made by the application. Can it be faked? Can it be stubbed? Or", "tokens": [48814, 3991, 337, 1184, 1185, 818, 300, 307, 1027, 538, 264, 3861, 13, 1664, 309, 312, 283, 7301, 30, 1664, 309, 312, 20266, 2883, 30, 1610], "temperature": 0.0, "avg_logprob": -0.14722873003054887, "compression_ratio": 1.5051020408163265, "no_speech_prob": 2.086733002215624e-05}, {"id": 144, "seek": 98664, "start": 986.64, "end": 994.0, "text": " does it require a full implementation? We start that in a database and later, so, you know,", "tokens": [775, 309, 3651, 257, 1577, 11420, 30, 492, 722, 300, 294, 257, 8149, 293, 1780, 11, 370, 11, 291, 458, 11], "temperature": 0.0, "avg_logprob": -0.15745648042655286, "compression_ratio": 1.6409090909090909, "no_speech_prob": 1.2863455594924744e-05}, {"id": 145, "seek": 98664, "start": 994.0, "end": 1000.0, "text": " we populate the database with as many measurements as possible. And this database can", "tokens": [321, 1665, 5256, 264, 8149, 365, 382, 867, 15383, 382, 1944, 13, 400, 341, 8149, 393], "temperature": 0.0, "avg_logprob": -0.15745648042655286, "compression_ratio": 1.6409090909090909, "no_speech_prob": 1.2863455594924744e-05}, {"id": 146, "seek": 98664, "start": 1000.96, "end": 1005.52, "text": " given the list of these calls that is already supported by your operating systems, give you", "tokens": [2212, 264, 1329, 295, 613, 5498, 300, 307, 1217, 8104, 538, 428, 7447, 3652, 11, 976, 291], "temperature": 0.0, "avg_logprob": -0.15745648042655286, "compression_ratio": 1.6409090909090909, "no_speech_prob": 1.2863455594924744e-05}, {"id": 147, "seek": 98664, "start": 1005.52, "end": 1010.8, "text": " like some form of optimized super plan given which of the applications you want to support.", "tokens": [411, 512, 1254, 295, 26941, 1687, 1393, 2212, 597, 295, 264, 5821, 291, 528, 281, 1406, 13], "temperature": 0.0, "avg_logprob": -0.15745648042655286, "compression_ratio": 1.6409090909090909, "no_speech_prob": 1.2863455594924744e-05}, {"id": 148, "seek": 101080, "start": 1010.8, "end": 1020.7199999999999, "text": " Okay, so how does it work? When loop runs the application, first it does a quick pass of S-Trace", "tokens": [1033, 11, 370, 577, 775, 309, 589, 30, 1133, 6367, 6676, 264, 3861, 11, 700, 309, 775, 257, 1702, 1320, 295, 318, 12, 14252, 617], "temperature": 0.0, "avg_logprob": -0.21542530589633518, "compression_ratio": 1.6079545454545454, "no_speech_prob": 4.220288246870041e-05}, {"id": 149, "seek": 101080, "start": 1021.4399999999999, "end": 1026.96, "text": " to measure all the system calls that are done by the application and then for each system call", "tokens": [281, 3481, 439, 264, 1185, 5498, 300, 366, 1096, 538, 264, 3861, 293, 550, 337, 1184, 1185, 818], "temperature": 0.0, "avg_logprob": -0.21542530589633518, "compression_ratio": 1.6079545454545454, "no_speech_prob": 4.220288246870041e-05}, {"id": 150, "seek": 101080, "start": 1026.96, "end": 1034.6399999999999, "text": " that we identify, we use SecComp to hook into the execution of each of the system calls and", "tokens": [300, 321, 5876, 11, 321, 764, 3306, 34, 8586, 281, 6328, 666, 264, 15058, 295, 1184, 295, 264, 1185, 5498, 293], "temperature": 0.0, "avg_logprob": -0.21542530589633518, "compression_ratio": 1.6079545454545454, "no_speech_prob": 4.220288246870041e-05}, {"id": 151, "seek": 103464, "start": 1034.64, "end": 1044.24, "text": " rather than actually executing them through the Linux kernel, we emulate the fact that", "tokens": [2831, 813, 767, 32368, 552, 807, 264, 18734, 28256, 11, 321, 45497, 264, 1186, 300], "temperature": 0.0, "avg_logprob": -0.1975084583411056, "compression_ratio": 1.7718446601941749, "no_speech_prob": 4.0631355659570545e-05}, {"id": 152, "seek": 103464, "start": 1044.24, "end": 1049.76, "text": " the Cisco is stubbed, so we just return EnoSys without executing the Cisco. We can also emulate", "tokens": [264, 38528, 307, 20266, 2883, 11, 370, 321, 445, 2736, 462, 1771, 50, 749, 1553, 32368, 264, 38528, 13, 492, 393, 611, 45497], "temperature": 0.0, "avg_logprob": -0.1975084583411056, "compression_ratio": 1.7718446601941749, "no_speech_prob": 4.0631355659570545e-05}, {"id": 153, "seek": 103464, "start": 1049.76, "end": 1055.68, "text": " the fact that the Cisco is faked, we return zero. And then we check if the application", "tokens": [264, 1186, 300, 264, 38528, 307, 283, 7301, 11, 321, 2736, 4018, 13, 400, 550, 321, 1520, 498, 264, 3861], "temperature": 0.0, "avg_logprob": -0.1975084583411056, "compression_ratio": 1.7718446601941749, "no_speech_prob": 4.0631355659570545e-05}, {"id": 154, "seek": 103464, "start": 1057.5200000000002, "end": 1063.5200000000002, "text": " works or not following the stubbing or the faking of this particular Cisco. And then we do that", "tokens": [1985, 420, 406, 3480, 264, 20266, 4324, 420, 264, 283, 2456, 295, 341, 1729, 38528, 13, 400, 550, 321, 360, 300], "temperature": 0.0, "avg_logprob": -0.1975084583411056, "compression_ratio": 1.7718446601941749, "no_speech_prob": 4.0631355659570545e-05}, {"id": 155, "seek": 106352, "start": 1063.52, "end": 1070.56, "text": " for each system call that we have identified with S-Trace. How do we actually check for the success", "tokens": [337, 1184, 1185, 818, 300, 321, 362, 9234, 365, 318, 12, 14252, 617, 13, 1012, 360, 321, 767, 1520, 337, 264, 2245], "temperature": 0.0, "avg_logprob": -0.1483312305651213, "compression_ratio": 1.606694560669456, "no_speech_prob": 4.173110210103914e-05}, {"id": 156, "seek": 106352, "start": 1070.56, "end": 1077.44, "text": " of the execution of the application? So we identified two types of apps. Some we call them", "tokens": [295, 264, 15058, 295, 264, 3861, 30, 407, 321, 9234, 732, 3467, 295, 7733, 13, 2188, 321, 818, 552], "temperature": 0.0, "avg_logprob": -0.1483312305651213, "compression_ratio": 1.606694560669456, "no_speech_prob": 4.173110210103914e-05}, {"id": 157, "seek": 106352, "start": 1077.44, "end": 1082.16, "text": " run to completion. There'll be something like FIO when you know you start FIO, it runs for one", "tokens": [1190, 281, 19372, 13, 821, 603, 312, 746, 411, 479, 15167, 562, 291, 458, 291, 722, 479, 15167, 11, 309, 6676, 337, 472], "temperature": 0.0, "avg_logprob": -0.1483312305651213, "compression_ratio": 1.606694560669456, "no_speech_prob": 4.173110210103914e-05}, {"id": 158, "seek": 106352, "start": 1082.16, "end": 1089.2, "text": " minute and then it exits outputting some kind of some stuff on the standard output. So with run to", "tokens": [3456, 293, 550, 309, 44183, 5598, 783, 512, 733, 295, 512, 1507, 322, 264, 3832, 5598, 13, 407, 365, 1190, 281], "temperature": 0.0, "avg_logprob": -0.1483312305651213, "compression_ratio": 1.606694560669456, "no_speech_prob": 4.173110210103914e-05}, {"id": 159, "seek": 108920, "start": 1089.2, "end": 1095.92, "text": " completion apps, we run the app instrumented with loop, we check its exit code. If it's different", "tokens": [19372, 7733, 11, 321, 1190, 264, 724, 7198, 292, 365, 6367, 11, 321, 1520, 1080, 11043, 3089, 13, 759, 309, 311, 819], "temperature": 0.0, "avg_logprob": -0.11449153297825863, "compression_ratio": 1.6401673640167365, "no_speech_prob": 3.752077464014292e-05}, {"id": 160, "seek": 108920, "start": 1095.92, "end": 1100.48, "text": " from zero, we consider that the run was a failure, could have been killed by a signal or things like", "tokens": [490, 4018, 11, 321, 1949, 300, 264, 1190, 390, 257, 7763, 11, 727, 362, 668, 4652, 538, 257, 6358, 420, 721, 411], "temperature": 0.0, "avg_logprob": -0.11449153297825863, "compression_ratio": 1.6401673640167365, "no_speech_prob": 3.752077464014292e-05}, {"id": 161, "seek": 108920, "start": 1100.48, "end": 1108.48, "text": " that. And we can also run a script optionally in addition to that after each run of the application", "tokens": [300, 13, 400, 321, 393, 611, 1190, 257, 5755, 3614, 379, 294, 4500, 281, 300, 934, 1184, 1190, 295, 264, 3861], "temperature": 0.0, "avg_logprob": -0.11449153297825863, "compression_ratio": 1.6401673640167365, "no_speech_prob": 3.752077464014292e-05}, {"id": 162, "seek": 108920, "start": 1108.48, "end": 1115.68, "text": " to check its standard output. We can grab for error values, we can grab for success printing,", "tokens": [281, 1520, 1080, 3832, 5598, 13, 492, 393, 4444, 337, 6713, 4190, 11, 321, 393, 4444, 337, 2245, 14699, 11], "temperature": 0.0, "avg_logprob": -0.11449153297825863, "compression_ratio": 1.6401673640167365, "no_speech_prob": 3.752077464014292e-05}, {"id": 163, "seek": 111568, "start": 1115.68, "end": 1122.0800000000002, "text": " something like, you know, 50 requests per second have been achieved. The files that may have been", "tokens": [746, 411, 11, 291, 458, 11, 2625, 12475, 680, 1150, 362, 668, 11042, 13, 440, 7098, 300, 815, 362, 668], "temperature": 0.0, "avg_logprob": -0.16799804142543248, "compression_ratio": 1.6382978723404256, "no_speech_prob": 4.3906515202252194e-05}, {"id": 164, "seek": 111568, "start": 1122.0800000000002, "end": 1128.64, "text": " created by the application and so on. And then another type of application is client servers.", "tokens": [2942, 538, 264, 3861, 293, 370, 322, 13, 400, 550, 1071, 2010, 295, 3861, 307, 6423, 15909, 13], "temperature": 0.0, "avg_logprob": -0.16799804142543248, "compression_ratio": 1.6382978723404256, "no_speech_prob": 4.3906515202252194e-05}, {"id": 165, "seek": 111568, "start": 1129.2, "end": 1135.52, "text": " So with client servers, we run the app instrumented by loop and in parallel we run a workload,", "tokens": [407, 365, 6423, 15909, 11, 321, 1190, 264, 724, 7198, 292, 538, 6367, 293, 294, 8952, 321, 1190, 257, 20139, 11], "temperature": 0.0, "avg_logprob": -0.16799804142543248, "compression_ratio": 1.6382978723404256, "no_speech_prob": 4.3906515202252194e-05}, {"id": 166, "seek": 111568, "start": 1135.52, "end": 1142.5600000000002, "text": " could be WRK, HTT path, the Redis benchmark for Redis and so on. And we check the success of both,", "tokens": [727, 312, 343, 49, 42, 11, 11751, 51, 3100, 11, 264, 4477, 271, 18927, 337, 4477, 271, 293, 370, 322, 13, 400, 321, 1520, 264, 2245, 295, 1293, 11], "temperature": 0.0, "avg_logprob": -0.16799804142543248, "compression_ratio": 1.6382978723404256, "no_speech_prob": 4.3906515202252194e-05}, {"id": 167, "seek": 114256, "start": 1142.56, "end": 1148.0, "text": " we check that the app doesn't crash, generally servers are not supposed to exit. So we check that", "tokens": [321, 1520, 300, 264, 724, 1177, 380, 8252, 11, 5101, 15909, 366, 406, 3442, 281, 11043, 13, 407, 321, 1520, 300], "temperature": 0.0, "avg_logprob": -0.2155254117904171, "compression_ratio": 1.6125, "no_speech_prob": 2.8631548047997057e-05}, {"id": 168, "seek": 114256, "start": 1148.0, "end": 1153.04, "text": " it doesn't crash and we check the success of the workload. Like, you know, if Redis benchmark returns", "tokens": [309, 1177, 380, 8252, 293, 321, 1520, 264, 2245, 295, 264, 20139, 13, 1743, 11, 291, 458, 11, 498, 4477, 271, 18927, 11247], "temperature": 0.0, "avg_logprob": -0.2155254117904171, "compression_ratio": 1.6125, "no_speech_prob": 2.8631548047997057e-05}, {"id": 169, "seek": 114256, "start": 1153.04, "end": 1159.12, "text": " something different than zero, probably something went wrong. And then we are able to see, okay,", "tokens": [746, 819, 813, 4018, 11, 1391, 746, 1437, 2085, 13, 400, 550, 321, 366, 1075, 281, 536, 11, 1392, 11], "temperature": 0.0, "avg_logprob": -0.2155254117904171, "compression_ratio": 1.6125, "no_speech_prob": 2.8631548047997057e-05}, {"id": 170, "seek": 114256, "start": 1159.12, "end": 1164.6399999999999, "text": " so I'm currently trying to stub the read system call, is the application succeeded or not?", "tokens": [370, 286, 478, 4362, 1382, 281, 20266, 264, 1401, 1185, 818, 11, 307, 264, 3861, 20263, 420, 406, 30], "temperature": 0.0, "avg_logprob": -0.2155254117904171, "compression_ratio": 1.6125, "no_speech_prob": 2.8631548047997057e-05}, {"id": 171, "seek": 116464, "start": 1164.64, "end": 1178.48, "text": " So really the database, let me check the time, okay. And we analyzed the results. So these results", "tokens": [407, 534, 264, 8149, 11, 718, 385, 1520, 264, 565, 11, 1392, 13, 400, 321, 28181, 264, 3542, 13, 407, 613, 3542], "temperature": 0.0, "avg_logprob": -0.18836384603421982, "compression_ratio": 1.5416666666666667, "no_speech_prob": 3.449119321885519e-05}, {"id": 172, "seek": 116464, "start": 1178.48, "end": 1185.2, "text": " are made on a relatively small database of about 12 highly popular, sorry, 15 highly popular cloud", "tokens": [366, 1027, 322, 257, 7226, 1359, 8149, 295, 466, 2272, 5405, 3743, 11, 2597, 11, 2119, 5405, 3743, 4588], "temperature": 0.0, "avg_logprob": -0.18836384603421982, "compression_ratio": 1.5416666666666667, "no_speech_prob": 3.449119321885519e-05}, {"id": 173, "seek": 116464, "start": 1185.2, "end": 1193.5200000000002, "text": " applications. So this is just a subset. So what you have on the y-axis is a number of system calls", "tokens": [5821, 13, 407, 341, 307, 445, 257, 25993, 13, 407, 437, 291, 362, 322, 264, 288, 12, 24633, 307, 257, 1230, 295, 1185, 5498], "temperature": 0.0, "avg_logprob": -0.18836384603421982, "compression_ratio": 1.5416666666666667, "no_speech_prob": 3.449119321885519e-05}, {"id": 174, "seek": 119352, "start": 1193.52, "end": 1204.8, "text": " that are identified by static analysis in purple on the binary, on the sources in yellow. And then", "tokens": [300, 366, 9234, 538, 13437, 5215, 294, 9656, 322, 264, 17434, 11, 322, 264, 7139, 294, 5566, 13, 400, 550], "temperature": 0.0, "avg_logprob": -0.2218452044895717, "compression_ratio": 1.5698324022346368, "no_speech_prob": 4.061638537677936e-05}, {"id": 175, "seek": 119352, "start": 1204.8, "end": 1210.96, "text": " dynamic analysis. And we run for each of these applications, both the standard benchmarks,", "tokens": [8546, 5215, 13, 400, 321, 1190, 337, 1184, 295, 613, 5821, 11, 1293, 264, 3832, 43751, 11], "temperature": 0.0, "avg_logprob": -0.2218452044895717, "compression_ratio": 1.5698324022346368, "no_speech_prob": 4.061638537677936e-05}, {"id": 176, "seek": 119352, "start": 1210.96, "end": 1217.44, "text": " that will be Redis benchmark for Redis, WRK for engineering, and so on. And we also run the", "tokens": [300, 486, 312, 4477, 271, 18927, 337, 4477, 271, 11, 343, 49, 42, 337, 7043, 11, 293, 370, 322, 13, 400, 321, 611, 1190, 264], "temperature": 0.0, "avg_logprob": -0.2218452044895717, "compression_ratio": 1.5698324022346368, "no_speech_prob": 4.061638537677936e-05}, {"id": 177, "seek": 121744, "start": 1217.44, "end": 1225.04, "text": " entire test suite. So the key idea with the test suite is if you, you know, support, I mean,", "tokens": [2302, 1500, 14205, 13, 407, 264, 2141, 1558, 365, 264, 1500, 14205, 307, 498, 291, 11, 291, 458, 11, 1406, 11, 286, 914, 11], "temperature": 0.0, "avg_logprob": -0.08176663549322831, "compression_ratio": 1.751131221719457, "no_speech_prob": 3.1730884074931964e-05}, {"id": 178, "seek": 121744, "start": 1225.04, "end": 1230.72, "text": " if you measure what's going on during the entire test suite, you get a very good idea of what are", "tokens": [498, 291, 3481, 437, 311, 516, 322, 1830, 264, 2302, 1500, 14205, 11, 291, 483, 257, 588, 665, 1558, 295, 437, 366], "temperature": 0.0, "avg_logprob": -0.08176663549322831, "compression_ratio": 1.751131221719457, "no_speech_prob": 3.1730884074931964e-05}, {"id": 179, "seek": 121744, "start": 1230.72, "end": 1235.6000000000001, "text": " all the possible system calls that could be done by the application. Obviously, you need to assume", "tokens": [439, 264, 1944, 1185, 5498, 300, 727, 312, 1096, 538, 264, 3861, 13, 7580, 11, 291, 643, 281, 6552], "temperature": 0.0, "avg_logprob": -0.08176663549322831, "compression_ratio": 1.751131221719457, "no_speech_prob": 3.1730884074931964e-05}, {"id": 180, "seek": 121744, "start": 1235.6000000000001, "end": 1241.1200000000001, "text": " that the test suite has a good coverage, but it is the case with these very popular applications.", "tokens": [300, 264, 1500, 14205, 575, 257, 665, 9645, 11, 457, 309, 307, 264, 1389, 365, 613, 588, 3743, 5821, 13], "temperature": 0.0, "avg_logprob": -0.08176663549322831, "compression_ratio": 1.751131221719457, "no_speech_prob": 3.1730884074931964e-05}, {"id": 181, "seek": 124112, "start": 1241.12, "end": 1249.04, "text": " And, and what we see is, first of all, you know, static analysis overestimates. This is not very", "tokens": [400, 11, 293, 437, 321, 536, 307, 11, 700, 295, 439, 11, 291, 458, 11, 13437, 5215, 670, 377, 332, 1024, 13, 639, 307, 406, 588], "temperature": 0.0, "avg_logprob": -0.19262091668097528, "compression_ratio": 1.7887323943661972, "no_speech_prob": 2.1272800950100645e-05}, {"id": 182, "seek": 124112, "start": 1249.04, "end": 1253.36, "text": " surprising. The amount of system calls that is identified by static analysis is relatively high", "tokens": [8830, 13, 440, 2372, 295, 1185, 5498, 300, 307, 9234, 538, 13437, 5215, 307, 7226, 1090], "temperature": 0.0, "avg_logprob": -0.19262091668097528, "compression_ratio": 1.7887323943661972, "no_speech_prob": 2.1272800950100645e-05}, {"id": 183, "seek": 124112, "start": 1253.36, "end": 1259.6799999999998, "text": " compared to what we get with dynamic analysis. And if something interesting, too, is that the", "tokens": [5347, 281, 437, 321, 483, 365, 8546, 5215, 13, 400, 498, 746, 1880, 11, 886, 11, 307, 300, 264], "temperature": 0.0, "avg_logprob": -0.19262091668097528, "compression_ratio": 1.7887323943661972, "no_speech_prob": 2.1272800950100645e-05}, {"id": 184, "seek": 124112, "start": 1259.6799999999998, "end": 1266.1599999999999, "text": " amount of system calls that can be stirred or faked, so the grain bits on the dynamic analysis", "tokens": [2372, 295, 1185, 5498, 300, 393, 312, 49409, 420, 283, 7301, 11, 370, 264, 12837, 9239, 322, 264, 8546, 5215], "temperature": 0.0, "avg_logprob": -0.19262091668097528, "compression_ratio": 1.7887323943661972, "no_speech_prob": 2.1272800950100645e-05}, {"id": 185, "seek": 126616, "start": 1266.16, "end": 1272.16, "text": " pass, it is actually quite non-negligible, right? So, so what this means is that if you want to", "tokens": [1320, 11, 309, 307, 767, 1596, 2107, 12, 28561, 5073, 964, 11, 558, 30, 407, 11, 370, 437, 341, 1355, 307, 300, 498, 291, 528, 281], "temperature": 0.0, "avg_logprob": -0.16165623222429729, "compression_ratio": 1.6652173913043478, "no_speech_prob": 3.091578764724545e-05}, {"id": 186, "seek": 126616, "start": 1272.16, "end": 1278.3200000000002, "text": " support Redis with a Redis benchmark, where binary level static analysis tells you that you", "tokens": [1406, 4477, 271, 365, 257, 4477, 271, 18927, 11, 689, 17434, 1496, 13437, 5215, 5112, 291, 300, 291], "temperature": 0.0, "avg_logprob": -0.16165623222429729, "compression_ratio": 1.6652173913043478, "no_speech_prob": 3.091578764724545e-05}, {"id": 187, "seek": 126616, "start": 1278.3200000000002, "end": 1284.3200000000002, "text": " should implement 100 system calls, if you just want to run the Redis benchmark to get, you know,", "tokens": [820, 4445, 2319, 1185, 5498, 11, 498, 291, 445, 528, 281, 1190, 264, 4477, 271, 18927, 281, 483, 11, 291, 458, 11], "temperature": 0.0, "avg_logprob": -0.16165623222429729, "compression_ratio": 1.6652173913043478, "no_speech_prob": 3.091578764724545e-05}, {"id": 188, "seek": 126616, "start": 1284.3200000000002, "end": 1290.0, "text": " performance numbers for your paper, you actually need to implement just 20, right? So that's what,", "tokens": [3389, 3547, 337, 428, 3035, 11, 291, 767, 643, 281, 4445, 445, 945, 11, 558, 30, 407, 300, 311, 437, 11], "temperature": 0.0, "avg_logprob": -0.16165623222429729, "compression_ratio": 1.6652173913043478, "no_speech_prob": 3.091578764724545e-05}, {"id": 189, "seek": 129000, "start": 1290.0, "end": 1297.2, "text": " like, divided by five, right? And if you want to pass the entire test suite of Redis, you need", "tokens": [411, 11, 6666, 538, 1732, 11, 558, 30, 400, 498, 291, 528, 281, 1320, 264, 2302, 1500, 14205, 295, 4477, 271, 11, 291, 643], "temperature": 0.0, "avg_logprob": -0.10443886557778159, "compression_ratio": 1.5523012552301256, "no_speech_prob": 2.7729089197237045e-05}, {"id": 190, "seek": 129000, "start": 1297.2, "end": 1303.92, "text": " to implement about 40. It's still like half what static analysis is telling you. So it's kind", "tokens": [281, 4445, 466, 3356, 13, 467, 311, 920, 411, 1922, 437, 13437, 5215, 307, 3585, 291, 13, 407, 309, 311, 733], "temperature": 0.0, "avg_logprob": -0.10443886557778159, "compression_ratio": 1.5523012552301256, "no_speech_prob": 2.7729089197237045e-05}, {"id": 191, "seek": 129000, "start": 1303.92, "end": 1309.2, "text": " of a message of hope, right, for building compatibility layers and for developing custom", "tokens": [295, 257, 3636, 295, 1454, 11, 558, 11, 337, 2390, 34237, 7914, 293, 337, 6416, 2375], "temperature": 0.0, "avg_logprob": -0.10443886557778159, "compression_ratio": 1.5523012552301256, "no_speech_prob": 2.7729089197237045e-05}, {"id": 192, "seek": 129000, "start": 1309.2, "end": 1314.64, "text": " operating systems in general. So, yes, static analysis overestimates a lot of the engineering", "tokens": [7447, 3652, 294, 2674, 13, 407, 11, 2086, 11, 13437, 5215, 670, 377, 332, 1024, 257, 688, 295, 264, 7043], "temperature": 0.0, "avg_logprob": -0.10443886557778159, "compression_ratio": 1.5523012552301256, "no_speech_prob": 2.7729089197237045e-05}, {"id": 193, "seek": 131464, "start": 1314.64, "end": 1321.1200000000001, "text": " effort to support an app. And even naive dynamic analysis does measure much more these calls", "tokens": [4630, 281, 1406, 364, 724, 13, 400, 754, 29052, 8546, 5215, 775, 3481, 709, 544, 613, 5498], "temperature": 0.0, "avg_logprob": -0.15748783946037292, "compression_ratio": 1.5397727272727273, "no_speech_prob": 3.653697785921395e-05}, {"id": 194, "seek": 131464, "start": 1321.1200000000001, "end": 1327.44, "text": " than what is actually required if you know that you can stop and fake these calls.", "tokens": [813, 437, 307, 767, 4739, 498, 291, 458, 300, 291, 393, 1590, 293, 7592, 613, 5498, 13], "temperature": 0.0, "avg_logprob": -0.15748783946037292, "compression_ratio": 1.5397727272727273, "no_speech_prob": 3.653697785921395e-05}, {"id": 195, "seek": 131464, "start": 1328.88, "end": 1335.1200000000001, "text": " Another view at these results can be seen here. So for each of the system calls, you know, zero", "tokens": [3996, 1910, 412, 613, 3542, 393, 312, 1612, 510, 13, 407, 337, 1184, 295, 264, 1185, 5498, 11, 291, 458, 11, 4018], "temperature": 0.0, "avg_logprob": -0.15748783946037292, "compression_ratio": 1.5397727272727273, "no_speech_prob": 3.653697785921395e-05}, {"id": 196, "seek": 133512, "start": 1335.12, "end": 1345.1999999999998, "text": " is read, one is write, two is open, I guess, and so on, among our dataset of about 15 apps,", "tokens": [307, 1401, 11, 472, 307, 2464, 11, 732, 307, 1269, 11, 286, 2041, 11, 293, 370, 322, 11, 3654, 527, 28872, 295, 466, 2119, 7733, 11], "temperature": 0.0, "avg_logprob": -0.1245649800156102, "compression_ratio": 1.449438202247191, "no_speech_prob": 2.726680031628348e-05}, {"id": 197, "seek": 133512, "start": 1345.1999999999998, "end": 1350.8799999999999, "text": " how many of these apps require the implementation of the system calling question, right?", "tokens": [577, 867, 295, 613, 7733, 3651, 264, 11420, 295, 264, 1185, 5141, 1168, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.1245649800156102, "compression_ratio": 1.449438202247191, "no_speech_prob": 2.726680031628348e-05}, {"id": 198, "seek": 133512, "start": 1352.3999999999999, "end": 1356.56, "text": " And then so you have here the result for static analysis at the binary level.", "tokens": [400, 550, 370, 291, 362, 510, 264, 1874, 337, 13437, 5215, 412, 264, 17434, 1496, 13], "temperature": 0.0, "avg_logprob": -0.1245649800156102, "compression_ratio": 1.449438202247191, "no_speech_prob": 2.726680031628348e-05}, {"id": 199, "seek": 135656, "start": 1356.56, "end": 1366.24, "text": " At the source level, this is S trace without counting which system calls you can stop or fake.", "tokens": [1711, 264, 4009, 1496, 11, 341, 307, 318, 13508, 1553, 13251, 597, 1185, 5498, 291, 393, 1590, 420, 7592, 13], "temperature": 0.0, "avg_logprob": -0.13333841959635417, "compression_ratio": 1.7619047619047619, "no_speech_prob": 1.876108581200242e-05}, {"id": 200, "seek": 135656, "start": 1366.96, "end": 1371.84, "text": " And this is what is actually required. So if you consider that you will not implement what you", "tokens": [400, 341, 307, 437, 307, 767, 4739, 13, 407, 498, 291, 1949, 300, 291, 486, 406, 4445, 437, 291], "temperature": 0.0, "avg_logprob": -0.13333841959635417, "compression_ratio": 1.7619047619047619, "no_speech_prob": 1.876108581200242e-05}, {"id": 201, "seek": 135656, "start": 1371.84, "end": 1376.24, "text": " stop or fake, this is what you actually need to implement. And as you can see, you know,", "tokens": [1590, 420, 7592, 11, 341, 307, 437, 291, 767, 643, 281, 4445, 13, 400, 382, 291, 393, 536, 11, 291, 458, 11], "temperature": 0.0, "avg_logprob": -0.13333841959635417, "compression_ratio": 1.7619047619047619, "no_speech_prob": 1.876108581200242e-05}, {"id": 202, "seek": 135656, "start": 1376.24, "end": 1381.84, "text": " it's much, much, much, much less engineering effort versus what static analysis is telling.", "tokens": [309, 311, 709, 11, 709, 11, 709, 11, 709, 1570, 7043, 4630, 5717, 437, 13437, 5215, 307, 3585, 13], "temperature": 0.0, "avg_logprob": -0.13333841959635417, "compression_ratio": 1.7619047619047619, "no_speech_prob": 1.876108581200242e-05}, {"id": 203, "seek": 138184, "start": 1381.84, "end": 1390.1599999999999, "text": " And why does stopping and faking work? So here you get some code snippet from Redis.", "tokens": [400, 983, 775, 12767, 293, 283, 2456, 589, 30, 407, 510, 291, 483, 512, 3089, 35623, 302, 490, 4477, 271, 13], "temperature": 0.0, "avg_logprob": -0.1529407501220703, "compression_ratio": 1.5221238938053097, "no_speech_prob": 4.1561150283087045e-05}, {"id": 204, "seek": 138184, "start": 1391.36, "end": 1399.36, "text": " So if you stop, get our limit, the C library wrapper will return minus one.", "tokens": [407, 498, 291, 1590, 11, 483, 527, 4948, 11, 264, 383, 6405, 46906, 486, 2736, 3175, 472, 13], "temperature": 0.0, "avg_logprob": -0.1529407501220703, "compression_ratio": 1.5221238938053097, "no_speech_prob": 4.1561150283087045e-05}, {"id": 205, "seek": 138184, "start": 1399.36, "end": 1404.9599999999998, "text": " And as you can see, Redis will actually fall back on some kind of safe value, you know,", "tokens": [400, 382, 291, 393, 536, 11, 4477, 271, 486, 767, 2100, 646, 322, 512, 733, 295, 3273, 2158, 11, 291, 458, 11], "temperature": 0.0, "avg_logprob": -0.1529407501220703, "compression_ratio": 1.5221238938053097, "no_speech_prob": 4.1561150283087045e-05}, {"id": 206, "seek": 138184, "start": 1404.9599999999998, "end": 1410.72, "text": " so I'm not able to understand the maximum number of files that I can open. So I'm going to fall", "tokens": [370, 286, 478, 406, 1075, 281, 1223, 264, 6674, 1230, 295, 7098, 300, 286, 393, 1269, 13, 407, 286, 478, 516, 281, 2100], "temperature": 0.0, "avg_logprob": -0.1529407501220703, "compression_ratio": 1.5221238938053097, "no_speech_prob": 4.1561150283087045e-05}, {"id": 207, "seek": 141072, "start": 1410.72, "end": 1423.2, "text": " back on 100, sorry, 1000. And the fact that faking works is actually that you have quite a bunch", "tokens": [646, 322, 2319, 11, 2597, 11, 9714, 13, 400, 264, 1186, 300, 283, 2456, 1985, 307, 767, 300, 291, 362, 1596, 257, 3840], "temperature": 0.0, "avg_logprob": -0.14835188729422433, "compression_ratio": 1.625, "no_speech_prob": 4.481275755097158e-05}, {"id": 208, "seek": 141072, "start": 1423.2, "end": 1429.3600000000001, "text": " of system calls. So this is for each system call and each app in our dataset, what is the", "tokens": [295, 1185, 5498, 13, 407, 341, 307, 337, 1184, 1185, 818, 293, 1184, 724, 294, 527, 28872, 11, 437, 307, 264], "temperature": 0.0, "avg_logprob": -0.14835188729422433, "compression_ratio": 1.625, "no_speech_prob": 4.481275755097158e-05}, {"id": 209, "seek": 141072, "start": 1429.3600000000001, "end": 1437.92, "text": " percentage of apps that are actually checking the return value of the system calls. And some system", "tokens": [9668, 295, 7733, 300, 366, 767, 8568, 264, 2736, 2158, 295, 264, 1185, 5498, 13, 400, 512, 1185], "temperature": 0.0, "avg_logprob": -0.14835188729422433, "compression_ratio": 1.625, "no_speech_prob": 4.481275755097158e-05}, {"id": 210, "seek": 143792, "start": 1437.92, "end": 1443.8400000000001, "text": " calls are almost never checked the return value. It kind of makes sense, right, when you see this,", "tokens": [5498, 366, 1920, 1128, 10033, 264, 2736, 2158, 13, 467, 733, 295, 1669, 2020, 11, 558, 11, 562, 291, 536, 341, 11], "temperature": 0.0, "avg_logprob": -0.1706792720849963, "compression_ratio": 1.5574712643678161, "no_speech_prob": 1.5492329112021253e-05}, {"id": 211, "seek": 143792, "start": 1444.48, "end": 1452.5600000000002, "text": " why check the return value of close. And this is why, you know, faking work in many cases.", "tokens": [983, 1520, 264, 2736, 2158, 295, 1998, 13, 400, 341, 307, 983, 11, 291, 458, 11, 283, 2456, 589, 294, 867, 3331, 13], "temperature": 0.0, "avg_logprob": -0.1706792720849963, "compression_ratio": 1.5574712643678161, "no_speech_prob": 1.5492329112021253e-05}, {"id": 212, "seek": 143792, "start": 1455.3600000000001, "end": 1462.4, "text": " Another question that we asked is, okay, so when you speak about providing binary", "tokens": [3996, 1168, 300, 321, 2351, 307, 11, 1392, 11, 370, 562, 291, 1710, 466, 6530, 17434], "temperature": 0.0, "avg_logprob": -0.1706792720849963, "compression_ratio": 1.5574712643678161, "no_speech_prob": 1.5492329112021253e-05}, {"id": 213, "seek": 146240, "start": 1462.4, "end": 1468.48, "text": " compatibility and you don't do porting anymore, basically, all the effort of supporting apps", "tokens": [34237, 293, 291, 500, 380, 360, 2436, 278, 3602, 11, 1936, 11, 439, 264, 4630, 295, 7231, 7733], "temperature": 0.0, "avg_logprob": -0.15672157165852, "compression_ratio": 1.592274678111588, "no_speech_prob": 8.204509504139423e-05}, {"id": 214, "seek": 146240, "start": 1468.48, "end": 1474.0, "text": " is on you, the operating system developer. And this is how it should be, in my opinion, but how", "tokens": [307, 322, 291, 11, 264, 7447, 1185, 10754, 13, 400, 341, 307, 577, 309, 820, 312, 11, 294, 452, 4800, 11, 457, 577], "temperature": 0.0, "avg_logprob": -0.15672157165852, "compression_ratio": 1.592274678111588, "no_speech_prob": 8.204509504139423e-05}, {"id": 215, "seek": 146240, "start": 1476.24, "end": 1481.8400000000001, "text": " much effort does that mean in the long term, right? So we had a look at versions of Redis", "tokens": [709, 4630, 775, 300, 914, 294, 264, 938, 1433, 11, 558, 30, 407, 321, 632, 257, 574, 412, 9606, 295, 4477, 271], "temperature": 0.0, "avg_logprob": -0.15672157165852, "compression_ratio": 1.592274678111588, "no_speech_prob": 8.204509504139423e-05}, {"id": 216, "seek": 146240, "start": 1481.8400000000001, "end": 1488.4, "text": " and Jennings and Apache over the last 10 years and what, you know, what are these calls that", "tokens": [293, 9228, 24451, 293, 46597, 670, 264, 1036, 1266, 924, 293, 437, 11, 291, 458, 11, 437, 366, 613, 5498, 300], "temperature": 0.0, "avg_logprob": -0.15672157165852, "compression_ratio": 1.592274678111588, "no_speech_prob": 8.204509504139423e-05}, {"id": 217, "seek": 148840, "start": 1488.4, "end": 1494.72, "text": " actually needs to be implemented in purple. And we saw that this number does not change very much,", "tokens": [767, 2203, 281, 312, 12270, 294, 9656, 13, 400, 321, 1866, 300, 341, 1230, 775, 406, 1319, 588, 709, 11], "temperature": 0.0, "avg_logprob": -0.11826303270128039, "compression_ratio": 1.617391304347826, "no_speech_prob": 2.2625747078564018e-05}, {"id": 218, "seek": 148840, "start": 1494.72, "end": 1503.1200000000001, "text": " right? So once you make an app and you make it work, it actually means that you need to", "tokens": [558, 30, 407, 1564, 291, 652, 364, 724, 293, 291, 652, 309, 589, 11, 309, 767, 1355, 300, 291, 643, 281], "temperature": 0.0, "avg_logprob": -0.11826303270128039, "compression_ratio": 1.617391304347826, "no_speech_prob": 2.2625747078564018e-05}, {"id": 219, "seek": 148840, "start": 1503.1200000000001, "end": 1509.1200000000001, "text": " keep up to date with the most recent version of this app that are coming up, but it doesn't", "tokens": [1066, 493, 281, 4002, 365, 264, 881, 5162, 3037, 295, 341, 724, 300, 366, 1348, 493, 11, 457, 309, 1177, 380], "temperature": 0.0, "avg_logprob": -0.11826303270128039, "compression_ratio": 1.617391304347826, "no_speech_prob": 2.2625747078564018e-05}, {"id": 220, "seek": 148840, "start": 1509.1200000000001, "end": 1516.88, "text": " necessarily mean a very big engineering effort either. And these are the support plans. So we", "tokens": [4725, 914, 257, 588, 955, 7043, 4630, 2139, 13, 400, 613, 366, 264, 1406, 5482, 13, 407, 321], "temperature": 0.0, "avg_logprob": -0.11826303270128039, "compression_ratio": 1.617391304347826, "no_speech_prob": 2.2625747078564018e-05}, {"id": 221, "seek": 151688, "start": 1516.88, "end": 1525.0400000000002, "text": " had a look at Unicraft, Fushia, which are some operating systems that have already a", "tokens": [632, 257, 574, 412, 1156, 299, 4469, 11, 479, 1498, 654, 11, 597, 366, 512, 7447, 3652, 300, 362, 1217, 257], "temperature": 0.0, "avg_logprob": -0.12953768836127388, "compression_ratio": 1.6009174311926606, "no_speech_prob": 2.8247764930711128e-05}, {"id": 222, "seek": 151688, "start": 1525.0400000000002, "end": 1529.2, "text": " relatively good support for a good number of system calls. And we look at Kerala,", "tokens": [7226, 665, 1406, 337, 257, 665, 1230, 295, 1185, 5498, 13, 400, 321, 574, 412, 591, 2790, 64, 11], "temperature": 0.0, "avg_logprob": -0.12953768836127388, "compression_ratio": 1.6009174311926606, "no_speech_prob": 2.8247764930711128e-05}, {"id": 223, "seek": 151688, "start": 1529.2, "end": 1534.72, "text": " so Kerala is another Unicernel written in Rust. And it's very, I wouldn't say immature,", "tokens": [370, 591, 2790, 64, 307, 1071, 1156, 299, 1248, 338, 3720, 294, 34952, 13, 400, 309, 311, 588, 11, 286, 2759, 380, 584, 49539, 11], "temperature": 0.0, "avg_logprob": -0.12953768836127388, "compression_ratio": 1.6009174311926606, "no_speech_prob": 2.8247764930711128e-05}, {"id": 224, "seek": 151688, "start": 1534.72, "end": 1540.3200000000002, "text": " but it doesn't have support for a lot of system calls. And for a set of 15 apps that we had in", "tokens": [457, 309, 1177, 380, 362, 1406, 337, 257, 688, 295, 1185, 5498, 13, 400, 337, 257, 992, 295, 2119, 7733, 300, 321, 632, 294], "temperature": 0.0, "avg_logprob": -0.12953768836127388, "compression_ratio": 1.6009174311926606, "no_speech_prob": 2.8247764930711128e-05}, {"id": 225, "seek": 154032, "start": 1540.32, "end": 1547.6799999999998, "text": " the database, we derive a support plan. So for Unicraft, for example, in its current state,", "tokens": [264, 8149, 11, 321, 28446, 257, 1406, 1393, 13, 407, 337, 1156, 299, 4469, 11, 337, 1365, 11, 294, 1080, 2190, 1785, 11], "temperature": 0.0, "avg_logprob": -0.1632230832026555, "compression_ratio": 1.6536796536796536, "no_speech_prob": 2.1527088392758742e-05}, {"id": 226, "seek": 154032, "start": 1547.6799999999998, "end": 1553.76, "text": " it's already supporting most of the apps of our data set. If you want to support an additional", "tokens": [309, 311, 1217, 7231, 881, 295, 264, 7733, 295, 527, 1412, 992, 13, 759, 291, 528, 281, 1406, 364, 4497], "temperature": 0.0, "avg_logprob": -0.1632230832026555, "compression_ratio": 1.6536796536796536, "no_speech_prob": 2.1527088392758742e-05}, {"id": 227, "seek": 154032, "start": 1553.76, "end": 1561.04, "text": " app, what you need to do is to implement system call number 290 and stop these, and then you'll", "tokens": [724, 11, 437, 291, 643, 281, 360, 307, 281, 4445, 1185, 818, 1230, 568, 7771, 293, 1590, 613, 11, 293, 550, 291, 603], "temperature": 0.0, "avg_logprob": -0.1632230832026555, "compression_ratio": 1.6536796536796536, "no_speech_prob": 2.1527088392758742e-05}, {"id": 228, "seek": 154032, "start": 1561.04, "end": 1568.0, "text": " get memcached. And next, if you implement this syscall, you get H2O, and then you need to implement", "tokens": [483, 1334, 66, 15095, 13, 400, 958, 11, 498, 291, 4445, 341, 262, 749, 45459, 11, 291, 483, 389, 17, 46, 11, 293, 550, 291, 643, 281, 4445], "temperature": 0.0, "avg_logprob": -0.1632230832026555, "compression_ratio": 1.6536796536796536, "no_speech_prob": 2.1527088392758742e-05}, {"id": 229, "seek": 156800, "start": 1568.0, "end": 1574.88, "text": " these two syscalls, and then you stop that, and you get MongoDB. So same thing for Fushia and", "tokens": [613, 732, 262, 749, 66, 39655, 11, 293, 550, 291, 1590, 300, 11, 293, 291, 483, 48380, 27735, 13, 407, 912, 551, 337, 479, 1498, 654, 293], "temperature": 0.0, "avg_logprob": -0.12172360773439761, "compression_ratio": 1.5655737704918034, "no_speech_prob": 7.629655738128349e-05}, {"id": 230, "seek": 156800, "start": 1574.88, "end": 1579.44, "text": " Kerala. Obviously, it's a bit more interesting because this one doesn't support many applications", "tokens": [591, 2790, 64, 13, 7580, 11, 309, 311, 257, 857, 544, 1880, 570, 341, 472, 1177, 380, 1406, 867, 5821], "temperature": 0.0, "avg_logprob": -0.12172360773439761, "compression_ratio": 1.5655737704918034, "no_speech_prob": 7.629655738128349e-05}, {"id": 231, "seek": 156800, "start": 1580.08, "end": 1587.2, "text": " out of the box. And I believe I have time to do a quick demo. I'm going to do it real quick.", "tokens": [484, 295, 264, 2424, 13, 400, 286, 1697, 286, 362, 565, 281, 360, 257, 1702, 10723, 13, 286, 478, 516, 281, 360, 309, 957, 1702, 13], "temperature": 0.0, "avg_logprob": -0.12172360773439761, "compression_ratio": 1.5655737704918034, "no_speech_prob": 7.629655738128349e-05}, {"id": 232, "seek": 156800, "start": 1591.84, "end": 1596.72, "text": " So I'm going to do a test with LS, which is like the simplest test because we don't have a lot of", "tokens": [407, 286, 478, 516, 281, 360, 257, 1500, 365, 36657, 11, 597, 307, 411, 264, 22811, 1500, 570, 321, 500, 380, 362, 257, 688, 295], "temperature": 0.0, "avg_logprob": -0.12172360773439761, "compression_ratio": 1.5655737704918034, "no_speech_prob": 7.629655738128349e-05}, {"id": 233, "seek": 159672, "start": 1596.72, "end": 1607.2, "text": " time. In the Docker file, I just copy a test that I'm going to show you, and then I call like the,", "tokens": [565, 13, 682, 264, 33772, 3991, 11, 286, 445, 5055, 257, 1500, 300, 286, 478, 516, 281, 855, 291, 11, 293, 550, 286, 818, 411, 264, 11], "temperature": 0.0, "avg_logprob": -0.1375833367401699, "compression_ratio": 1.685589519650655, "no_speech_prob": 8.051899931160733e-05}, {"id": 234, "seek": 159672, "start": 1607.2, "end": 1613.68, "text": " this is kind of the top level script of loop with a few options that don't matter that much. And I", "tokens": [341, 307, 733, 295, 264, 1192, 1496, 5755, 295, 6367, 365, 257, 1326, 3956, 300, 500, 380, 1871, 300, 709, 13, 400, 286], "temperature": 0.0, "avg_logprob": -0.1375833367401699, "compression_ratio": 1.685589519650655, "no_speech_prob": 8.051899931160733e-05}, {"id": 235, "seek": 159672, "start": 1613.68, "end": 1619.52, "text": " say, okay, the binary that we are going to instrument is slash bin slash LS, and this is the", "tokens": [584, 11, 1392, 11, 264, 17434, 300, 321, 366, 516, 281, 7198, 307, 17330, 5171, 17330, 36657, 11, 293, 341, 307, 264], "temperature": 0.0, "avg_logprob": -0.1375833367401699, "compression_ratio": 1.685589519650655, "no_speech_prob": 8.051899931160733e-05}, {"id": 236, "seek": 159672, "start": 1619.52, "end": 1625.3600000000001, "text": " parameter. So I'm going to do LS slash, and we are going to check if it works or not with every", "tokens": [13075, 13, 407, 286, 478, 516, 281, 360, 36657, 17330, 11, 293, 321, 366, 516, 281, 1520, 498, 309, 1985, 420, 406, 365, 633], "temperature": 0.0, "avg_logprob": -0.1375833367401699, "compression_ratio": 1.685589519650655, "no_speech_prob": 8.051899931160733e-05}, {"id": 237, "seek": 162536, "start": 1625.36, "end": 1634.4799999999998, "text": " possible syscalls that can be invoked by LS. And the test, which should be there, the test that", "tokens": [1944, 262, 749, 66, 39655, 300, 393, 312, 1048, 9511, 538, 36657, 13, 400, 264, 1500, 11, 597, 820, 312, 456, 11, 264, 1500, 300], "temperature": 0.0, "avg_logprob": -0.09381365289493483, "compression_ratio": 1.634453781512605, "no_speech_prob": 1.999376945605036e-05}, {"id": 238, "seek": 162536, "start": 1634.4799999999998, "end": 1640.8799999999999, "text": " we are going to run after each execution of LS to see if things have worked. So this share script", "tokens": [321, 366, 516, 281, 1190, 934, 1184, 15058, 295, 36657, 281, 536, 498, 721, 362, 2732, 13, 407, 341, 2073, 5755], "temperature": 0.0, "avg_logprob": -0.09381365289493483, "compression_ratio": 1.634453781512605, "no_speech_prob": 1.999376945605036e-05}, {"id": 239, "seek": 162536, "start": 1640.8799999999999, "end": 1647.6799999999998, "text": " will take the standard output of LS as parameters, and to make things simple, I'm just checking that", "tokens": [486, 747, 264, 3832, 5598, 295, 36657, 382, 9834, 11, 293, 281, 652, 721, 2199, 11, 286, 478, 445, 8568, 300], "temperature": 0.0, "avg_logprob": -0.09381365289493483, "compression_ratio": 1.634453781512605, "no_speech_prob": 1.999376945605036e-05}, {"id": 240, "seek": 162536, "start": 1647.6799999999998, "end": 1653.04, "text": " LS actually outputs something, right? I'm doing LS slash, so something should be outputted. If", "tokens": [36657, 767, 23930, 746, 11, 558, 30, 286, 478, 884, 36657, 17330, 11, 370, 746, 820, 312, 5598, 14727, 13, 759], "temperature": 0.0, "avg_logprob": -0.09381365289493483, "compression_ratio": 1.634453781512605, "no_speech_prob": 1.999376945605036e-05}, {"id": 241, "seek": 165304, "start": 1653.04, "end": 1658.48, "text": " nothing is output, there is a problem. And keep in mind that loop is also checking the return", "tokens": [1825, 307, 5598, 11, 456, 307, 257, 1154, 13, 400, 1066, 294, 1575, 300, 6367, 307, 611, 8568, 264, 2736], "temperature": 0.0, "avg_logprob": -0.12842504398242846, "compression_ratio": 1.4871794871794872, "no_speech_prob": 2.074676740448922e-05}, {"id": 242, "seek": 165304, "start": 1658.48, "end": 1670.24, "text": " value of LS itself. So, okay, so I'm launching loop like this, so it should work. So what happens", "tokens": [2158, 295, 36657, 2564, 13, 407, 11, 1392, 11, 370, 286, 478, 18354, 6367, 411, 341, 11, 370, 309, 820, 589, 13, 407, 437, 2314], "temperature": 0.0, "avg_logprob": -0.12842504398242846, "compression_ratio": 1.4871794871794872, "no_speech_prob": 2.074676740448922e-05}, {"id": 243, "seek": 165304, "start": 1670.24, "end": 1676.48, "text": " under the hood is that we build the container that we've seen the Docker file for. We are starting", "tokens": [833, 264, 13376, 307, 300, 321, 1322, 264, 10129, 300, 321, 600, 1612, 264, 33772, 3991, 337, 13, 492, 366, 2891], "temperature": 0.0, "avg_logprob": -0.12842504398242846, "compression_ratio": 1.4871794871794872, "no_speech_prob": 2.074676740448922e-05}, {"id": 244, "seek": 167648, "start": 1676.48, "end": 1683.68, "text": " two containers in parallel. Each one is running a full set of tests trying to stop and fake all", "tokens": [732, 17089, 294, 8952, 13, 6947, 472, 307, 2614, 257, 1577, 992, 295, 6921, 1382, 281, 1590, 293, 7592, 439], "temperature": 0.0, "avg_logprob": -0.10215958621766832, "compression_ratio": 1.5635359116022098, "no_speech_prob": 3.15811594191473e-05}, {"id": 245, "seek": 167648, "start": 1683.68, "end": 1692.16, "text": " the system calls. And we use this to check for differences between the replicas in case there", "tokens": [264, 1185, 5498, 13, 400, 321, 764, 341, 281, 1520, 337, 7300, 1296, 264, 3248, 9150, 294, 1389, 456], "temperature": 0.0, "avg_logprob": -0.10215958621766832, "compression_ratio": 1.5635359116022098, "no_speech_prob": 3.15811594191473e-05}, {"id": 246, "seek": 167648, "start": 1692.16, "end": 1698.64, "text": " is a problem. Most of the time, there is no differences. So it takes a bit of time. And then,", "tokens": [307, 257, 1154, 13, 4534, 295, 264, 565, 11, 456, 307, 572, 7300, 13, 407, 309, 2516, 257, 857, 295, 565, 13, 400, 550, 11], "temperature": 0.0, "avg_logprob": -0.10215958621766832, "compression_ratio": 1.5635359116022098, "no_speech_prob": 3.15811594191473e-05}, {"id": 247, "seek": 169864, "start": 1698.64, "end": 1711.5200000000002, "text": " okay, it's done. So, if we go to the database, so we have now much more than 12 apps. And if we go", "tokens": [1392, 11, 309, 311, 1096, 13, 407, 11, 498, 321, 352, 281, 264, 8149, 11, 370, 321, 362, 586, 709, 544, 813, 2272, 7733, 13, 400, 498, 321, 352], "temperature": 0.0, "avg_logprob": -0.24106667405467921, "compression_ratio": 1.308724832214765, "no_speech_prob": 8.70896692504175e-05}, {"id": 248, "seek": 169864, "start": 1711.5200000000002, "end": 1723.6000000000001, "text": " to LS, the most interesting result is this CSV file, which contains, for HCC call, 0 being read,", "tokens": [281, 36657, 11, 264, 881, 1880, 1874, 307, 341, 48814, 3991, 11, 597, 8306, 11, 337, 389, 11717, 818, 11, 1958, 885, 1401, 11], "temperature": 0.0, "avg_logprob": -0.24106667405467921, "compression_ratio": 1.308724832214765, "no_speech_prob": 8.70896692504175e-05}, {"id": 249, "seek": 172360, "start": 1723.6, "end": 1733.4399999999998, "text": " 1 being write. Is it called by LS or not? Can we fake it? Can we stop it? Or can we", "tokens": [502, 885, 2464, 13, 1119, 309, 1219, 538, 36657, 420, 406, 30, 1664, 321, 7592, 309, 30, 1664, 321, 1590, 309, 30, 1610, 393, 321], "temperature": 0.0, "avg_logprob": -0.13907837286228086, "compression_ratio": 1.7151898734177216, "no_speech_prob": 4.990426532458514e-05}, {"id": 250, "seek": 172360, "start": 1735.28, "end": 1740.32, "text": " both fake and stop it? Or it's more like, does the application works when it's fake? Does it", "tokens": [1293, 7592, 293, 1590, 309, 30, 1610, 309, 311, 544, 411, 11, 775, 264, 3861, 1985, 562, 309, 311, 7592, 30, 4402, 309], "temperature": 0.0, "avg_logprob": -0.13907837286228086, "compression_ratio": 1.7151898734177216, "no_speech_prob": 4.990426532458514e-05}, {"id": 251, "seek": 172360, "start": 1740.32, "end": 1746.0, "text": " works when it's stubbed? And does it work when it's both fake and stubbed? And as you can see,", "tokens": [1985, 562, 309, 311, 20266, 2883, 30, 400, 775, 309, 589, 562, 309, 311, 1293, 7592, 293, 20266, 2883, 30, 400, 382, 291, 393, 536, 11], "temperature": 0.0, "avg_logprob": -0.13907837286228086, "compression_ratio": 1.7151898734177216, "no_speech_prob": 4.990426532458514e-05}, {"id": 252, "seek": 174600, "start": 1746.0, "end": 1753.68, "text": " some CSV calls, like 11, I don't know which one it is, can be both stub and fake, same thing for", "tokens": [512, 48814, 5498, 11, 411, 2975, 11, 286, 500, 380, 458, 597, 472, 309, 307, 11, 393, 312, 1293, 20266, 293, 7592, 11, 912, 551, 337], "temperature": 0.0, "avg_logprob": -0.1587268655950373, "compression_ratio": 1.598360655737705, "no_speech_prob": 4.0473831177223474e-05}, {"id": 253, "seek": 174600, "start": 1753.68, "end": 1759.2, "text": " 12, same thing for 16. Some CSV calls, like this is read, for example, it is called, but you can't", "tokens": [2272, 11, 912, 551, 337, 3165, 13, 2188, 48814, 5498, 11, 411, 341, 307, 1401, 11, 337, 1365, 11, 309, 307, 1219, 11, 457, 291, 393, 380], "temperature": 0.0, "avg_logprob": -0.1587268655950373, "compression_ratio": 1.598360655737705, "no_speech_prob": 4.0473831177223474e-05}, {"id": 254, "seek": 174600, "start": 1759.2, "end": 1765.68, "text": " stop or take it, which kind of makes sense. LS wouldn't work if it can read. And yeah, that's", "tokens": [1590, 420, 747, 309, 11, 597, 733, 295, 1669, 2020, 13, 36657, 2759, 380, 589, 498, 309, 393, 1401, 13, 400, 1338, 11, 300, 311], "temperature": 0.0, "avg_logprob": -0.1587268655950373, "compression_ratio": 1.598360655737705, "no_speech_prob": 4.0473831177223474e-05}, {"id": 255, "seek": 174600, "start": 1765.68, "end": 1771.76, "text": " pretty much it. So briefly, what we are currently working on is some more fine-grained measurements.", "tokens": [1238, 709, 309, 13, 407, 10515, 11, 437, 321, 366, 4362, 1364, 322, 307, 512, 544, 2489, 12, 20735, 2001, 15383, 13], "temperature": 0.0, "avg_logprob": -0.1587268655950373, "compression_ratio": 1.598360655737705, "no_speech_prob": 4.0473831177223474e-05}, {"id": 256, "seek": 177176, "start": 1771.76, "end": 1779.36, "text": " Some system calls have kind of sub features, like a lot of programs require at least a map anonymous", "tokens": [2188, 1185, 5498, 362, 733, 295, 1422, 4122, 11, 411, 257, 688, 295, 4268, 3651, 412, 1935, 257, 4471, 24932], "temperature": 0.0, "avg_logprob": -0.21331938453342603, "compression_ratio": 1.5655737704918034, "no_speech_prob": 5.390776277636178e-05}, {"id": 257, "seek": 177176, "start": 1779.36, "end": 1785.28, "text": " for a map to allocate memory, but not really to map a file. So we are looking at, you know,", "tokens": [337, 257, 4471, 281, 35713, 4675, 11, 457, 406, 534, 281, 4471, 257, 3991, 13, 407, 321, 366, 1237, 412, 11, 291, 458, 11], "temperature": 0.0, "avg_logprob": -0.21331938453342603, "compression_ratio": 1.5655737704918034, "no_speech_prob": 5.390776277636178e-05}, {"id": 258, "seek": 177176, "start": 1785.28, "end": 1790.08, "text": " checking which flags can be stubbed or fake and things like that. And we are also looking at the", "tokens": [8568, 597, 23265, 393, 312, 20266, 2883, 420, 7592, 293, 721, 411, 300, 13, 400, 321, 366, 611, 1237, 412, 264], "temperature": 0.0, "avg_logprob": -0.21331938453342603, "compression_ratio": 1.5655737704918034, "no_speech_prob": 5.390776277636178e-05}, {"id": 259, "seek": 177176, "start": 1790.08, "end": 1797.92, "text": " virtual file system API. That's it. So building compatibility layers is important for custom", "tokens": [6374, 3991, 1185, 9362, 13, 663, 311, 309, 13, 407, 2390, 34237, 7914, 307, 1021, 337, 2375], "temperature": 0.0, "avg_logprob": -0.21331938453342603, "compression_ratio": 1.5655737704918034, "no_speech_prob": 5.390776277636178e-05}, {"id": 260, "seek": 179792, "start": 1797.92, "end": 1804.0800000000002, "text": " operating system. It seems a bit scary, but actually, it's not that much engineering effort.", "tokens": [50364, 7447, 1185, 13, 467, 2544, 257, 857, 6958, 11, 457, 767, 11, 309, 311, 406, 300, 709, 7043, 4630, 13, 50672], "temperature": 0.0, "avg_logprob": -0.22545839392620584, "compression_ratio": 1.0823529411764705, "no_speech_prob": 8.927925955504179e-05}], "language": "en"}