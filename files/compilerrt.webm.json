{"text": " Good afternoon, everyone. I'm Mamta. I work as a software engineer at Leica Geosystems and I work mostly in embedded domain. So this is the outline of my talk. So just to keep everyone on the same page, I'll be giving a brief introduction about LLVM and Clank and so that the terminologies next I'm using are clear. Then I'll talk about compiler RT sanitizers, what they are, how you can build them and how exactly they work and then my final thoughts about sanitizers. So this is a typical compiler pipeline which most of you are aware of and they call it as a textbook diagram as well. So whenever you write a source or a code in any language to produce a binary executable for your machine it has to go through multiple stages. So mostly the most important ones are the front end, middle end and the back end and the front end actually does all the lexical analysis, semantic analysis, it checks the syntax and then it generates an intermediate representation. Then it is passed to the middle end which does optimizations independent of the target and then it is passed to the back end which generates executable and it has more optimizations depending on the target you are building it for and sometimes if there are multiple object files then comes in the picture linker. So how does LLVM fits in our pipeline? So basically the same, it is a modular and useable compiler framework and it provides front end, back end and LLVM core which is the LLVM optimizer. So if we map it to our compiling pipeline, so for depending on the language you are trying to build or use this compiling tool chain you have compile sorry you have LLVM front end that is the clang for C languages and Rust, Rust C for Rust and then depending upon the target it will use the target as x86, 32 bit or 64 and the main part which is most reusable from the LLVM perspective it is the LLVM optimizer and the core. So if I have to develop a new compiler tool chain I can easily reuse LLVM I just have to write my own front end and if there is a new hardware back end maybe. So in short I can say LLVM is like a Lego of compiler tool chains. Next focusing a bit more on one of the LLVM front end clang which is for targeting mostly C, C++ and C like languages. And here it whenever you provide your source code it performs some lexical analysis generates tokens for parsing then it does semantic analysis and generates abstract syntax tree and the end goal should be LLVM intermediary presentation. So just to summarize LLVM is a collection of all modular and reusable compiler technologies and there is much more to it because it provides now with static analyzers, sanitizers and more libraries so it comes under an umbrella project as LLVM.org and clang is a compiler front end which is mostly for C, C++ and C like languages but when we say clang executable it is more than a front end. So when you build LLVM you have clang executable as well and it is like a compiler driver. So for example if you have a static compiler and we have to tell it which directives to use or to use this hyphen i option where is the standard library path for example for C, C++. So clang as a driver does most of the housekeeping for all this task and it helps this compiling pipeline to tell you where to look for the libraries and also provide some OS related features and how your OS is. So that was just a brief introduction about clang and LLVM. So now I will talk about compiler RT sanitizers it is one of the sub projects in LLVM but before that I will highlight about the runtimes. So LLVM comes with compiler RT runtimes it is pretty much equivalent of libGCC for LLVM pipeline and it provides target specific support for some low level functionalities which hardware itself cannot do. So it consists of three main components built-ins, sanitizer runtimes and profilers. So built-ins provide implementation for target specific hooks which hardware itself cannot do. So just to simplify it a bit more for example if the 32 bit system cannot do 64 bit division so here you can see a code snippet and if I try to compile it using clang. So first we do a normal compilation on x86 machine which is a 64 bit and here on left you can see it directly calls this diff cube which means it performs the division itself but when I use hyphen m32 which is I am forcing it to compile for 32 bit machine it depends on another call it actually calls this udiff i3 which is basically a built-in implementation in compiler RT. So this is an overall picture of compiler RT runtimes. So talking about the sanitizers, sanitizers are like runtime checks which it is like adding a code probe in your code to verify if there are any memory bugs or to sanitize the code or to find any security flaws. So in case of LLVM it is provided by compiler RT and called as compiler RT sanitizers and there are multiple kind of sanitizers available. First is address sanitizer which you can use to detect use after free buffer overflow and memory leaks as well. Then you have undefined behavior sanitizers, memory sanitizers to identify if there is some uninitialized memory and threat sanitizer to detect some race conditions and dead locks. So here it is just an example of how sanitizer looks. So here is a very simple code where I am allocating some memory in heap and then I am trying to I am freeing it and then I am trying to access it after free. So if you build this code with your sanitizer flag on and try to run it immediately it will complain that you are trying to access some memory after free. So that is how it looks like when it is built with address sanitizer and I will talk in more detail about how what goes behind the scene. But before that how to build compiler RT sanitizers. So there are lot of documentation around as well and it is very easy to follow as well but sometimes it works, sometimes it does not. So you can build first compiler RT with LLVM it is easy you can directly enable it with LLVM enable projects when you are building your complete LLVM tool chain and you can do a separate build as well if you have your LLVM config and use generator of your choice. To enable the sanitizers so if I am doing a build along with the complete LLVM tool chain I just have to use this flag compiler RT build sanitizers to on and when you do this and here I am using Ninja as a generator you can see we get a config out of CMake and you can see it is enabling different sanitizers as address sanitizer, leak sanitizers, memory sanitizer, thread and undefined behavior. And same you can do for and after sorry after the installation and build you can get these set of libraries. You can do the same for the standalone build as well with the same similar flag and this is the config generated when I am doing a compiler RT standalone build and then it is also possible to cross compile RT sanitizers you have to provide lot of flags and you need to have your arms this route as well and I personally do not prefer this way but there is a talk today in the end from Peter about building embedded tool chain using LLVM. So, to make it a bit easier for all the embedded developers there is a in Yachto project there is an open embedded layer called Meta Clang. It makes it bit easy because it provides everything for building your tool chain and you just have to include this layer if people are aware of Yachto builds. And just few configurations are needed like you have to enable the SDK, you have to use LLVM runtimes and then either you can write in your package groups or in local conf to include compiler RT and compiler RT sanitizers. And this actually generates a SDK and it is very easy to distribute this SDK to other developers or like in our case I used to send it to the application team so that they can use this and the people who are developing C++ code they can run their code they can compile their code and run sanitizers on it. So this was actually while contributing to Meta Clang I came to became more aware about compiler RT sanitizers and also now it is available for arm 32 bit and arm 64 bit and x86 of course and you can easily test it also on KMU arm as well just specifying your sys route and running your test code to see how it behaves on your actual target. So that was all about what is compiler RT sanitizers, how we build it but what exactly goes behind the scene. So here I am using an example of address sanitizer to use and here is a very basic code where we are taking some arguments and converting into integer but here you can see we are using argument counter and the value for this can be very large as well. So first time when I try to compile it with Clang it compiles and when you run it after like as you can see easily and it is very easy to spot here I have defined the size of buffer to be just 2 and if I provide input more than 2 it should fail actually that is the case but it is very the crux here is like it is difficult for some machine it will fail for 3 and for some machine it will fail with the 4 input and leads to the segmentation fault and we do not know what happened exactly behind the scene. Second when you try to build it with address sanitizer enabled or link it with compiler RT and with your address sanitizer flag as well and the output is actually a bit large this is the first part of it. So it can easily spot that there was a stack overflow stack buffer overflow and it also points out if you build it with hyphen g option it also points out at work line it is failing but what exactly led to generation of this kind of error. So in very simple term when address sanitizers adding sanitizer is like adding an additional code to your actual code to just check when it is going to fail and report the error. So here it looks very easy okay if my buffer size is more than 2 or sorry if the input size for the buffer is more than 2 just notify it is an error but behind the scene for address sanitizer it is much more and it can adopt multiple strategies to implement it. So here address sanitizer uses memory mapping so memory that should not be accessed is called as poisoned memory. So behind the scene it is implemented like to check whether this is getting poisoned or not so here poison means either it is referring to some deallocated memory or some already allocated memory or there is getting some overflow or not and just report the error but there is much more how this memory is mapped. So for any code built with any application that you build the virtual address space is divided into two kind of memories one is shadow memory and one is application memory. So for address sanitizer it is more important to implement this is poisoned and report error in a very compact and fast way then talking about shadow memory and the application memory. So application memory is the main memory of the code and shadow memory is a copy of application memory but here 8 bytes of your application map memory is mapped as 1 byte in shadow memory and when the sanitizer checks whether this memory is poisoned or not it is mapped to either 0 or 1. So here it is a small portion of shadow memory of our example and you can see the memory which is accessible and which is in good condition is marked as 0. But here when we are allocating we are checking the buffer here you can see after it is marked as so the memory which is like more when we are trying to access more than the allocated buffer size it is marked as 1 and these and here you can see in the square brackets it is it is marking that hello this here you are supposed not to access this it is getting out of the range of the buffer. So that is how this application memory and shadow memory is used and then you can see here we restrict it as the red zones. So if you have anything greater than these than the allocated one so that one gets marked as 1 and you can see f 1 f 3 around and so that is how the address sanitizer works by using this shadow memory and application memory and knowing about your shadow memory and whenever it spots it is 1 then it says okay there is a problem. So that is all about the address sanitizer and how it works. So here are my final thoughts about using sanitizers it is a very great tool to find bugs and memory issues and in run time for complex applications. So by using sanitizers you can improve your development and you can spot the errors very quickly and since we had a very simple example but when the code gets more complex it is more difficult to find what is the problem. And though with the sanitizers it is more like a tool to check not to be used in your production it increases the code size but the sanitizers are comparatively more faster than Valgrind the existing one and still there are not all the architectures are supported uniformly like for example for arm 32 we do not have threat sanitizer completely implemented so I hope we see a better implementation later and it supports threat sanitization on 32 bit machines as well questions. Yes it works sorry the question here is like I am using the optimization flag for building with address sanitizer enabled yes it can be enabled to up to 3 as well and you get similar kind of log. So the question is where I am placing the instrumentation to identify whether my buffer is overflowing or not to use assertion here I am not sure I can answer that well but the strategy of this one is using more with this memory mapping one and also here since this buffer size is very small so may be assertion might work here. This I am also not much aware of so the question is like if I can sanitize it for a very specific portion of the code right yeah you can no I am sorry I am not much aware of it you can reverse it you can prevent some specific code from being instrumented either by annotating the code or by using a blacklist. Yeah there is this blacklist address sanitizers options as well yeah. Have you you say that sanitizers are primarily a development tool and yes they mostly are but have you ever looked into using some of them for actual production executables for hardening for example UV sun has a fairly minimal overhead so it can be used in production especially if you make a strap or if you make it if you use the minimal runtime or also there is GWP ASAN which is like a lightweight sampling version of other sanitizers which can be used in runtime I think Android is using it actually. Okay so does it support some of the embedded platforms as well like ARM32 or 64? It supports I believe it does well UV sun works pretty much everywhere almost everywhere GWP ASAN works I think almost everywhere but it is also dependent on like external function for unwinding so it might not be great in all scenarios it really depends. I was wondering if you can use this for kernel ring zero code as well. Yes you can but like there's like. But there's a. While there are no if you don't have like the runtime it's not in the NPM it's actually offered by the kernel and you infer the checks but the hooks themselves are implemented in the kernel. Well some sanitizers don't require any runtime. So for ASAN you need instrumentation. Yeah you can use kernel address sanitizer for it. But like ASAN also needs like the ASAN best point like the IRF. I think it's just a level implementation of the stuff. There's other sanitizers in kernel which are implemented this way. I think that it's GACFI. Yeah. Yes. Do you know where the code lives currently that does the hooking to malloc and free like the C library? Like how does the interaction with the C library work do you know because like I could have that for example have a muscle instead of the C library and I guess the code has to be adapted somehow or there must be some book infrastructure. So do you know how that works and where the code lives that books malloc and free for example. It's in compiler RT instance if I'm right. So if you change the version of library you have. Yeah the F on runtime has to be for malloc and free. Okay. So outside of the C library. Yeah. For ASAN yes but for example for ASAN for leak sanitizer which is enabled by ASAN you need to be aware of things like PLS layout and so on. But the runtime in LVM does implement both. Yes. Are the sanitizers shared between GCC and LLVM or does each have its own implementation? They are shared. Yes. I noticed that one shadow byte corresponds to eight actual bytes. However considering that there are special values for it. Does it mean that there could be situations where there could be some bytes which are not protected necessarily? Yeah there can be some cases where you can call it as a false positive kind of thing or sometimes it is checking very much in the end. So it was a very small example but it can happen that you get these square brackets at the very end and it's an overrun case. So that can happen. Yes. Could you get a false negative in some sense in the sense that if you have two almost adjacent blocks of advocated application memory and you access a pointer from one to the other could you get a false negative in this sense? So because that would not be a point and it would still be part of the application but for example what an address could you get? Yeah it can be. It can be a false positive case maybe. Yes. Okay. I think it was already partially answered before but I am not sure. So I am just going to ask it. So for example I am also working on an embedded scenario and we don't use, I think we don't use glpc or muscle like we have our own set of routines for malloc and free. Yes. Would it also work in that case or is that then something that you would need to, are there more requirements before you can use these sanitizers on those devices? For my experience I have been just using this meta-clang layer included and for testing with like or for just doing on the SDKs and emulator it was perfectly fine. So not on the actual devices because it is just meant for testing. All right. Thank you Manta. Thank you. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 14.24, "text": " Good afternoon, everyone. I'm Mamta. I work as a software engineer at Leica Geosystems", "tokens": [2205, 6499, 11, 1518, 13, 286, 478, 19899, 1328, 13, 286, 589, 382, 257, 4722, 11403, 412, 1456, 2262, 2876, 329, 9321, 82], "temperature": 0.0, "avg_logprob": -0.24949710845947265, "compression_ratio": 1.2962962962962963, "no_speech_prob": 0.17576070129871368}, {"id": 1, "seek": 0, "start": 14.24, "end": 29.98, "text": " and I work mostly in embedded domain. So this is the outline of my talk. So just to keep", "tokens": [293, 286, 589, 5240, 294, 16741, 9274, 13, 407, 341, 307, 264, 16387, 295, 452, 751, 13, 407, 445, 281, 1066], "temperature": 0.0, "avg_logprob": -0.24949710845947265, "compression_ratio": 1.2962962962962963, "no_speech_prob": 0.17576070129871368}, {"id": 2, "seek": 2998, "start": 29.98, "end": 35.480000000000004, "text": " everyone on the same page, I'll be giving a brief introduction about LLVM and Clank", "tokens": [1518, 322, 264, 912, 3028, 11, 286, 603, 312, 2902, 257, 5353, 9339, 466, 441, 43, 53, 44, 293, 2033, 657], "temperature": 0.0, "avg_logprob": -0.1555718400261619, "compression_ratio": 1.5418502202643172, "no_speech_prob": 9.746842260938138e-05}, {"id": 3, "seek": 2998, "start": 35.480000000000004, "end": 42.16, "text": " and so that the terminologies next I'm using are clear. Then I'll talk about compiler RT", "tokens": [293, 370, 300, 264, 10761, 6204, 958, 286, 478, 1228, 366, 1850, 13, 1396, 286, 603, 751, 466, 31958, 21797], "temperature": 0.0, "avg_logprob": -0.1555718400261619, "compression_ratio": 1.5418502202643172, "no_speech_prob": 9.746842260938138e-05}, {"id": 4, "seek": 2998, "start": 42.16, "end": 49.64, "text": " sanitizers, what they are, how you can build them and how exactly they work and then my", "tokens": [24533, 22525, 11, 437, 436, 366, 11, 577, 291, 393, 1322, 552, 293, 577, 2293, 436, 589, 293, 550, 452], "temperature": 0.0, "avg_logprob": -0.1555718400261619, "compression_ratio": 1.5418502202643172, "no_speech_prob": 9.746842260938138e-05}, {"id": 5, "seek": 2998, "start": 49.64, "end": 58.24, "text": " final thoughts about sanitizers. So this is a typical compiler pipeline which most of you", "tokens": [2572, 4598, 466, 24533, 22525, 13, 407, 341, 307, 257, 7476, 31958, 15517, 597, 881, 295, 291], "temperature": 0.0, "avg_logprob": -0.1555718400261619, "compression_ratio": 1.5418502202643172, "no_speech_prob": 9.746842260938138e-05}, {"id": 6, "seek": 5824, "start": 58.24, "end": 65.68, "text": " are aware of and they call it as a textbook diagram as well. So whenever you write a source", "tokens": [366, 3650, 295, 293, 436, 818, 309, 382, 257, 25591, 10686, 382, 731, 13, 407, 5699, 291, 2464, 257, 4009], "temperature": 0.0, "avg_logprob": -0.11534871477069276, "compression_ratio": 1.5027322404371584, "no_speech_prob": 2.3547592718387023e-05}, {"id": 7, "seek": 5824, "start": 65.68, "end": 73.28, "text": " or a code in any language to produce a binary executable for your machine it has to go through", "tokens": [420, 257, 3089, 294, 604, 2856, 281, 5258, 257, 17434, 7568, 712, 337, 428, 3479, 309, 575, 281, 352, 807], "temperature": 0.0, "avg_logprob": -0.11534871477069276, "compression_ratio": 1.5027322404371584, "no_speech_prob": 2.3547592718387023e-05}, {"id": 8, "seek": 5824, "start": 73.28, "end": 79.32000000000001, "text": " multiple stages. So mostly the most important ones are the front end, middle end and the", "tokens": [3866, 10232, 13, 407, 5240, 264, 881, 1021, 2306, 366, 264, 1868, 917, 11, 2808, 917, 293, 264], "temperature": 0.0, "avg_logprob": -0.11534871477069276, "compression_ratio": 1.5027322404371584, "no_speech_prob": 2.3547592718387023e-05}, {"id": 9, "seek": 7932, "start": 79.32, "end": 88.39999999999999, "text": " back end and the front end actually does all the lexical analysis, semantic analysis, it", "tokens": [646, 917, 293, 264, 1868, 917, 767, 775, 439, 264, 476, 87, 804, 5215, 11, 47982, 5215, 11, 309], "temperature": 0.0, "avg_logprob": -0.13723808223918332, "compression_ratio": 1.670807453416149, "no_speech_prob": 6.108539673732594e-05}, {"id": 10, "seek": 7932, "start": 88.39999999999999, "end": 94.55999999999999, "text": " checks the syntax and then it generates an intermediate representation. Then it is passed", "tokens": [13834, 264, 28431, 293, 550, 309, 23815, 364, 19376, 10290, 13, 1396, 309, 307, 4678], "temperature": 0.0, "avg_logprob": -0.13723808223918332, "compression_ratio": 1.670807453416149, "no_speech_prob": 6.108539673732594e-05}, {"id": 11, "seek": 7932, "start": 94.55999999999999, "end": 101.39999999999999, "text": " to the middle end which does optimizations independent of the target and then it is passed", "tokens": [281, 264, 2808, 917, 597, 775, 5028, 14455, 6695, 295, 264, 3779, 293, 550, 309, 307, 4678], "temperature": 0.0, "avg_logprob": -0.13723808223918332, "compression_ratio": 1.670807453416149, "no_speech_prob": 6.108539673732594e-05}, {"id": 12, "seek": 10140, "start": 101.4, "end": 109.44000000000001, "text": " to the back end which generates executable and it has more optimizations depending on", "tokens": [281, 264, 646, 917, 597, 23815, 7568, 712, 293, 309, 575, 544, 5028, 14455, 5413, 322], "temperature": 0.0, "avg_logprob": -0.16015084149086312, "compression_ratio": 1.5260416666666667, "no_speech_prob": 4.425381575856591e-06}, {"id": 13, "seek": 10140, "start": 109.44000000000001, "end": 116.2, "text": " the target you are building it for and sometimes if there are multiple object files then comes", "tokens": [264, 3779, 291, 366, 2390, 309, 337, 293, 2171, 498, 456, 366, 3866, 2657, 7098, 550, 1487], "temperature": 0.0, "avg_logprob": -0.16015084149086312, "compression_ratio": 1.5260416666666667, "no_speech_prob": 4.425381575856591e-06}, {"id": 14, "seek": 10140, "start": 116.2, "end": 119.72, "text": " in the picture linker.", "tokens": [294, 264, 3036, 2113, 260, 13], "temperature": 0.0, "avg_logprob": -0.16015084149086312, "compression_ratio": 1.5260416666666667, "no_speech_prob": 4.425381575856591e-06}, {"id": 15, "seek": 10140, "start": 119.72, "end": 130.6, "text": " So how does LLVM fits in our pipeline? So basically the same, it is a modular and useable", "tokens": [407, 577, 775, 441, 43, 53, 44, 9001, 294, 527, 15517, 30, 407, 1936, 264, 912, 11, 309, 307, 257, 31111, 293, 764, 712], "temperature": 0.0, "avg_logprob": -0.16015084149086312, "compression_ratio": 1.5260416666666667, "no_speech_prob": 4.425381575856591e-06}, {"id": 16, "seek": 13060, "start": 130.6, "end": 138.95999999999998, "text": " compiler framework and it provides front end, back end and LLVM core which is the LLVM optimizer.", "tokens": [31958, 8388, 293, 309, 6417, 1868, 917, 11, 646, 917, 293, 441, 43, 53, 44, 4965, 597, 307, 264, 441, 43, 53, 44, 5028, 6545, 13], "temperature": 0.0, "avg_logprob": -0.12489966074625651, "compression_ratio": 1.582857142857143, "no_speech_prob": 2.0461880922084674e-05}, {"id": 17, "seek": 13060, "start": 138.95999999999998, "end": 146.24, "text": " So if we map it to our compiling pipeline, so for depending on the language you are trying", "tokens": [407, 498, 321, 4471, 309, 281, 527, 715, 4883, 15517, 11, 370, 337, 5413, 322, 264, 2856, 291, 366, 1382], "temperature": 0.0, "avg_logprob": -0.12489966074625651, "compression_ratio": 1.582857142857143, "no_speech_prob": 2.0461880922084674e-05}, {"id": 18, "seek": 13060, "start": 146.24, "end": 153.04, "text": " to build or use this compiling tool chain you have compile sorry you have LLVM front end", "tokens": [281, 1322, 420, 764, 341, 715, 4883, 2290, 5021, 291, 362, 31413, 2597, 291, 362, 441, 43, 53, 44, 1868, 917], "temperature": 0.0, "avg_logprob": -0.12489966074625651, "compression_ratio": 1.582857142857143, "no_speech_prob": 2.0461880922084674e-05}, {"id": 19, "seek": 15304, "start": 153.04, "end": 161.0, "text": " that is the clang for C languages and Rust, Rust C for Rust and then depending upon the", "tokens": [300, 307, 264, 596, 656, 337, 383, 8650, 293, 34952, 11, 34952, 383, 337, 34952, 293, 550, 5413, 3564, 264], "temperature": 0.0, "avg_logprob": -0.13668945857456752, "compression_ratio": 1.4698795180722892, "no_speech_prob": 2.6272860850440338e-05}, {"id": 20, "seek": 15304, "start": 161.0, "end": 173.32, "text": " target it will use the target as x86, 32 bit or 64 and the main part which is most reusable", "tokens": [3779, 309, 486, 764, 264, 3779, 382, 2031, 22193, 11, 8858, 857, 420, 12145, 293, 264, 2135, 644, 597, 307, 881, 41807], "temperature": 0.0, "avg_logprob": -0.13668945857456752, "compression_ratio": 1.4698795180722892, "no_speech_prob": 2.6272860850440338e-05}, {"id": 21, "seek": 15304, "start": 173.32, "end": 178.2, "text": " from the LLVM perspective it is the LLVM optimizer and the core.", "tokens": [490, 264, 441, 43, 53, 44, 4585, 309, 307, 264, 441, 43, 53, 44, 5028, 6545, 293, 264, 4965, 13], "temperature": 0.0, "avg_logprob": -0.13668945857456752, "compression_ratio": 1.4698795180722892, "no_speech_prob": 2.6272860850440338e-05}, {"id": 22, "seek": 17820, "start": 178.2, "end": 185.79999999999998, "text": " So if I have to develop a new compiler tool chain I can easily reuse LLVM I just have", "tokens": [407, 498, 286, 362, 281, 1499, 257, 777, 31958, 2290, 5021, 286, 393, 3612, 26225, 441, 43, 53, 44, 286, 445, 362], "temperature": 0.0, "avg_logprob": -0.09221393114899935, "compression_ratio": 1.5029239766081872, "no_speech_prob": 1.1124895536340773e-05}, {"id": 23, "seek": 17820, "start": 185.79999999999998, "end": 193.35999999999999, "text": " to write my own front end and if there is a new hardware back end maybe. So in short", "tokens": [281, 2464, 452, 1065, 1868, 917, 293, 498, 456, 307, 257, 777, 8837, 646, 917, 1310, 13, 407, 294, 2099], "temperature": 0.0, "avg_logprob": -0.09221393114899935, "compression_ratio": 1.5029239766081872, "no_speech_prob": 1.1124895536340773e-05}, {"id": 24, "seek": 17820, "start": 193.35999999999999, "end": 201.92, "text": " I can say LLVM is like a Lego of compiler tool chains. Next focusing a bit more on one", "tokens": [286, 393, 584, 441, 43, 53, 44, 307, 411, 257, 28761, 295, 31958, 2290, 12626, 13, 3087, 8416, 257, 857, 544, 322, 472], "temperature": 0.0, "avg_logprob": -0.09221393114899935, "compression_ratio": 1.5029239766081872, "no_speech_prob": 1.1124895536340773e-05}, {"id": 25, "seek": 20192, "start": 201.92, "end": 211.64, "text": " of the LLVM front end clang which is for targeting mostly C, C++ and C like languages.", "tokens": [295, 264, 441, 43, 53, 44, 1868, 917, 596, 656, 597, 307, 337, 17918, 5240, 383, 11, 383, 25472, 293, 383, 411, 8650, 13], "temperature": 0.0, "avg_logprob": -0.18088060525747446, "compression_ratio": 1.483695652173913, "no_speech_prob": 3.844878392555984e-06}, {"id": 26, "seek": 20192, "start": 211.64, "end": 219.0, "text": " And here it whenever you provide your source code it performs some lexical analysis generates", "tokens": [400, 510, 309, 5699, 291, 2893, 428, 4009, 3089, 309, 26213, 512, 476, 87, 804, 5215, 23815], "temperature": 0.0, "avg_logprob": -0.18088060525747446, "compression_ratio": 1.483695652173913, "no_speech_prob": 3.844878392555984e-06}, {"id": 27, "seek": 20192, "start": 219.0, "end": 226.92, "text": " tokens for parsing then it does semantic analysis and generates abstract syntax tree and the", "tokens": [22667, 337, 21156, 278, 550, 309, 775, 47982, 5215, 293, 23815, 12649, 28431, 4230, 293, 264], "temperature": 0.0, "avg_logprob": -0.18088060525747446, "compression_ratio": 1.483695652173913, "no_speech_prob": 3.844878392555984e-06}, {"id": 28, "seek": 22692, "start": 226.92, "end": 235.16, "text": " end goal should be LLVM intermediary presentation. So just to summarize LLVM is a collection", "tokens": [917, 3387, 820, 312, 441, 43, 53, 44, 15184, 822, 5860, 13, 407, 445, 281, 20858, 441, 43, 53, 44, 307, 257, 5765], "temperature": 0.0, "avg_logprob": -0.12537070054274338, "compression_ratio": 1.4946236559139785, "no_speech_prob": 8.267373232229147e-06}, {"id": 29, "seek": 22692, "start": 235.16, "end": 242.11999999999998, "text": " of all modular and reusable compiler technologies and there is much more to it because it provides", "tokens": [295, 439, 31111, 293, 41807, 31958, 7943, 293, 456, 307, 709, 544, 281, 309, 570, 309, 6417], "temperature": 0.0, "avg_logprob": -0.12537070054274338, "compression_ratio": 1.4946236559139785, "no_speech_prob": 8.267373232229147e-06}, {"id": 30, "seek": 22692, "start": 242.11999999999998, "end": 248.32, "text": " now with static analyzers, sanitizers and more libraries so it comes under an umbrella", "tokens": [586, 365, 13437, 6459, 41698, 11, 24533, 22525, 293, 544, 15148, 370, 309, 1487, 833, 364, 21925], "temperature": 0.0, "avg_logprob": -0.12537070054274338, "compression_ratio": 1.4946236559139785, "no_speech_prob": 8.267373232229147e-06}, {"id": 31, "seek": 24832, "start": 248.32, "end": 257.04, "text": " project as LLVM.org and clang is a compiler front end which is mostly for C, C++ and", "tokens": [1716, 382, 441, 43, 53, 44, 13, 4646, 293, 596, 656, 307, 257, 31958, 1868, 917, 597, 307, 5240, 337, 383, 11, 383, 25472, 293], "temperature": 0.0, "avg_logprob": -0.1301381838949103, "compression_ratio": 1.5679012345679013, "no_speech_prob": 1.8631460989126936e-05}, {"id": 32, "seek": 24832, "start": 257.04, "end": 265.84, "text": " C like languages but when we say clang executable it is more than a front end. So when you build", "tokens": [383, 411, 8650, 457, 562, 321, 584, 596, 656, 7568, 712, 309, 307, 544, 813, 257, 1868, 917, 13, 407, 562, 291, 1322], "temperature": 0.0, "avg_logprob": -0.1301381838949103, "compression_ratio": 1.5679012345679013, "no_speech_prob": 1.8631460989126936e-05}, {"id": 33, "seek": 24832, "start": 265.84, "end": 271.88, "text": " LLVM you have clang executable as well and it is like a compiler driver.", "tokens": [441, 43, 53, 44, 291, 362, 596, 656, 7568, 712, 382, 731, 293, 309, 307, 411, 257, 31958, 6787, 13], "temperature": 0.0, "avg_logprob": -0.1301381838949103, "compression_ratio": 1.5679012345679013, "no_speech_prob": 1.8631460989126936e-05}, {"id": 34, "seek": 27188, "start": 271.88, "end": 280.15999999999997, "text": " So for example if you have a static compiler and we have to tell it which directives to", "tokens": [407, 337, 1365, 498, 291, 362, 257, 13437, 31958, 293, 321, 362, 281, 980, 309, 597, 2047, 1539, 281], "temperature": 0.0, "avg_logprob": -0.12256925497482073, "compression_ratio": 1.5029239766081872, "no_speech_prob": 4.565777999232523e-06}, {"id": 35, "seek": 27188, "start": 280.15999999999997, "end": 287.48, "text": " use or to use this hyphen i option where is the standard library path for example for", "tokens": [764, 420, 281, 764, 341, 2477, 47059, 741, 3614, 689, 307, 264, 3832, 6405, 3100, 337, 1365, 337], "temperature": 0.0, "avg_logprob": -0.12256925497482073, "compression_ratio": 1.5029239766081872, "no_speech_prob": 4.565777999232523e-06}, {"id": 36, "seek": 27188, "start": 287.48, "end": 295.15999999999997, "text": " C, C++. So clang as a driver does most of the housekeeping for all this task and it", "tokens": [383, 11, 383, 25472, 13, 407, 596, 656, 382, 257, 6787, 775, 881, 295, 264, 48033, 337, 439, 341, 5633, 293, 309], "temperature": 0.0, "avg_logprob": -0.12256925497482073, "compression_ratio": 1.5029239766081872, "no_speech_prob": 4.565777999232523e-06}, {"id": 37, "seek": 29516, "start": 295.16, "end": 302.20000000000005, "text": " helps this compiling pipeline to tell you where to look for the libraries and also provide", "tokens": [3665, 341, 715, 4883, 15517, 281, 980, 291, 689, 281, 574, 337, 264, 15148, 293, 611, 2893], "temperature": 0.0, "avg_logprob": -0.1295199896159925, "compression_ratio": 1.4766839378238341, "no_speech_prob": 5.173662884772057e-06}, {"id": 38, "seek": 29516, "start": 302.20000000000005, "end": 311.88, "text": " some OS related features and how your OS is. So that was just a brief introduction about", "tokens": [512, 12731, 4077, 4122, 293, 577, 428, 12731, 307, 13, 407, 300, 390, 445, 257, 5353, 9339, 466], "temperature": 0.0, "avg_logprob": -0.1295199896159925, "compression_ratio": 1.4766839378238341, "no_speech_prob": 5.173662884772057e-06}, {"id": 39, "seek": 29516, "start": 311.88, "end": 313.88, "text": " clang and LLVM.", "tokens": [596, 656, 293, 441, 43, 53, 44, 13], "temperature": 0.0, "avg_logprob": -0.1295199896159925, "compression_ratio": 1.4766839378238341, "no_speech_prob": 5.173662884772057e-06}, {"id": 40, "seek": 29516, "start": 313.88, "end": 322.08000000000004, "text": " So now I will talk about compiler RT sanitizers it is one of the sub projects in LLVM but", "tokens": [407, 586, 286, 486, 751, 466, 31958, 21797, 24533, 22525, 309, 307, 472, 295, 264, 1422, 4455, 294, 441, 43, 53, 44, 457], "temperature": 0.0, "avg_logprob": -0.1295199896159925, "compression_ratio": 1.4766839378238341, "no_speech_prob": 5.173662884772057e-06}, {"id": 41, "seek": 32208, "start": 322.08, "end": 329.08, "text": " before that I will highlight about the runtimes. So LLVM comes with compiler RT runtimes it", "tokens": [949, 300, 286, 486, 5078, 466, 264, 49435, 1532, 13, 407, 441, 43, 53, 44, 1487, 365, 31958, 21797, 49435, 1532, 309], "temperature": 0.0, "avg_logprob": -0.1563288702893613, "compression_ratio": 1.4352331606217616, "no_speech_prob": 1.6699554180377163e-05}, {"id": 42, "seek": 32208, "start": 329.08, "end": 337.52, "text": " is pretty much equivalent of libGCC for LLVM pipeline and it provides target specific support", "tokens": [307, 1238, 709, 10344, 295, 22854, 38, 11717, 337, 441, 43, 53, 44, 15517, 293, 309, 6417, 3779, 2685, 1406], "temperature": 0.0, "avg_logprob": -0.1563288702893613, "compression_ratio": 1.4352331606217616, "no_speech_prob": 1.6699554180377163e-05}, {"id": 43, "seek": 32208, "start": 337.52, "end": 344.2, "text": " for some low level functionalities which hardware itself cannot do. So it consists of three", "tokens": [337, 512, 2295, 1496, 11745, 1088, 597, 8837, 2564, 2644, 360, 13, 407, 309, 14689, 295, 1045], "temperature": 0.0, "avg_logprob": -0.1563288702893613, "compression_ratio": 1.4352331606217616, "no_speech_prob": 1.6699554180377163e-05}, {"id": 44, "seek": 34420, "start": 344.2, "end": 352.4, "text": " main components built-ins, sanitizer runtimes and profilers. So built-ins provide implementation", "tokens": [2135, 6677, 3094, 12, 1292, 11, 47080, 49435, 1532, 293, 1740, 388, 433, 13, 407, 3094, 12, 1292, 2893, 11420], "temperature": 0.0, "avg_logprob": -0.15701764205406452, "compression_ratio": 1.4761904761904763, "no_speech_prob": 2.2472760974778794e-05}, {"id": 45, "seek": 34420, "start": 352.4, "end": 357.52, "text": " for target specific hooks which hardware itself cannot do.", "tokens": [337, 3779, 2685, 26485, 597, 8837, 2564, 2644, 360, 13], "temperature": 0.0, "avg_logprob": -0.15701764205406452, "compression_ratio": 1.4761904761904763, "no_speech_prob": 2.2472760974778794e-05}, {"id": 46, "seek": 34420, "start": 357.52, "end": 367.76, "text": " So just to simplify it a bit more for example if the 32 bit system cannot do 64 bit division", "tokens": [407, 445, 281, 20460, 309, 257, 857, 544, 337, 1365, 498, 264, 8858, 857, 1185, 2644, 360, 12145, 857, 10044], "temperature": 0.0, "avg_logprob": -0.15701764205406452, "compression_ratio": 1.4761904761904763, "no_speech_prob": 2.2472760974778794e-05}, {"id": 47, "seek": 36776, "start": 367.76, "end": 375.92, "text": " so here you can see a code snippet and if I try to compile it using clang. So first", "tokens": [370, 510, 291, 393, 536, 257, 3089, 35623, 302, 293, 498, 286, 853, 281, 31413, 309, 1228, 596, 656, 13, 407, 700], "temperature": 0.0, "avg_logprob": -0.11725806456345778, "compression_ratio": 1.488235294117647, "no_speech_prob": 1.9222163246013224e-05}, {"id": 48, "seek": 36776, "start": 375.92, "end": 383.88, "text": " we do a normal compilation on x86 machine which is a 64 bit and here on left you can", "tokens": [321, 360, 257, 2710, 40261, 322, 2031, 22193, 3479, 597, 307, 257, 12145, 857, 293, 510, 322, 1411, 291, 393], "temperature": 0.0, "avg_logprob": -0.11725806456345778, "compression_ratio": 1.488235294117647, "no_speech_prob": 1.9222163246013224e-05}, {"id": 49, "seek": 36776, "start": 383.88, "end": 391.8, "text": " see it directly calls this diff cube which means it performs the division itself but", "tokens": [536, 309, 3838, 5498, 341, 7593, 13728, 597, 1355, 309, 26213, 264, 10044, 2564, 457], "temperature": 0.0, "avg_logprob": -0.11725806456345778, "compression_ratio": 1.488235294117647, "no_speech_prob": 1.9222163246013224e-05}, {"id": 50, "seek": 39180, "start": 391.8, "end": 400.40000000000003, "text": " when I use hyphen m32 which is I am forcing it to compile for 32 bit machine it depends", "tokens": [562, 286, 764, 2477, 47059, 275, 11440, 597, 307, 286, 669, 19030, 309, 281, 31413, 337, 8858, 857, 3479, 309, 5946], "temperature": 0.0, "avg_logprob": -0.14727957546710968, "compression_ratio": 1.5120481927710843, "no_speech_prob": 1.1659129086183384e-05}, {"id": 51, "seek": 39180, "start": 400.40000000000003, "end": 407.32, "text": " on another call it actually calls this udiff i3 which is basically a built-in implementation", "tokens": [322, 1071, 818, 309, 767, 5498, 341, 11727, 3661, 741, 18, 597, 307, 1936, 257, 3094, 12, 259, 11420], "temperature": 0.0, "avg_logprob": -0.14727957546710968, "compression_ratio": 1.5120481927710843, "no_speech_prob": 1.1659129086183384e-05}, {"id": 52, "seek": 39180, "start": 407.32, "end": 415.36, "text": " in compiler RT. So this is an overall picture of compiler RT runtimes.", "tokens": [294, 31958, 21797, 13, 407, 341, 307, 364, 4787, 3036, 295, 31958, 21797, 49435, 1532, 13], "temperature": 0.0, "avg_logprob": -0.14727957546710968, "compression_ratio": 1.5120481927710843, "no_speech_prob": 1.1659129086183384e-05}, {"id": 53, "seek": 41536, "start": 415.36, "end": 422.0, "text": " So talking about the sanitizers, sanitizers are like runtime checks which it is like adding", "tokens": [407, 1417, 466, 264, 24533, 22525, 11, 24533, 22525, 366, 411, 34474, 13834, 597, 309, 307, 411, 5127], "temperature": 0.0, "avg_logprob": -0.11428933212722557, "compression_ratio": 1.5224719101123596, "no_speech_prob": 7.52756614019745e-06}, {"id": 54, "seek": 41536, "start": 422.0, "end": 430.56, "text": " a code probe in your code to verify if there are any memory bugs or to sanitize the code", "tokens": [257, 3089, 22715, 294, 428, 3089, 281, 16888, 498, 456, 366, 604, 4675, 15120, 420, 281, 24533, 1125, 264, 3089], "temperature": 0.0, "avg_logprob": -0.11428933212722557, "compression_ratio": 1.5224719101123596, "no_speech_prob": 7.52756614019745e-06}, {"id": 55, "seek": 41536, "start": 430.56, "end": 439.28000000000003, "text": " or to find any security flaws. So in case of LLVM it is provided by compiler RT and called", "tokens": [420, 281, 915, 604, 3825, 27108, 13, 407, 294, 1389, 295, 441, 43, 53, 44, 309, 307, 5649, 538, 31958, 21797, 293, 1219], "temperature": 0.0, "avg_logprob": -0.11428933212722557, "compression_ratio": 1.5224719101123596, "no_speech_prob": 7.52756614019745e-06}, {"id": 56, "seek": 43928, "start": 439.28, "end": 447.03999999999996, "text": " as compiler RT sanitizers and there are multiple kind of sanitizers available. First is address", "tokens": [382, 31958, 21797, 24533, 22525, 293, 456, 366, 3866, 733, 295, 24533, 22525, 2435, 13, 2386, 307, 2985], "temperature": 0.0, "avg_logprob": -0.15507734738863432, "compression_ratio": 1.7233009708737863, "no_speech_prob": 8.139440978993662e-06}, {"id": 57, "seek": 43928, "start": 447.03999999999996, "end": 453.44, "text": " sanitizer which you can use to detect use after free buffer overflow and memory leaks", "tokens": [47080, 597, 291, 393, 764, 281, 5531, 764, 934, 1737, 21762, 37772, 293, 4675, 28885], "temperature": 0.0, "avg_logprob": -0.15507734738863432, "compression_ratio": 1.7233009708737863, "no_speech_prob": 8.139440978993662e-06}, {"id": 58, "seek": 43928, "start": 453.44, "end": 459.11999999999995, "text": " as well. Then you have undefined behavior sanitizers, memory sanitizers to identify", "tokens": [382, 731, 13, 1396, 291, 362, 674, 5666, 2001, 5223, 24533, 22525, 11, 4675, 24533, 22525, 281, 5876], "temperature": 0.0, "avg_logprob": -0.15507734738863432, "compression_ratio": 1.7233009708737863, "no_speech_prob": 8.139440978993662e-06}, {"id": 59, "seek": 43928, "start": 459.11999999999995, "end": 465.91999999999996, "text": " if there is some uninitialized memory and threat sanitizer to detect some race conditions", "tokens": [498, 456, 307, 512, 43456, 270, 831, 1602, 4675, 293, 4734, 47080, 281, 5531, 512, 4569, 4487], "temperature": 0.0, "avg_logprob": -0.15507734738863432, "compression_ratio": 1.7233009708737863, "no_speech_prob": 8.139440978993662e-06}, {"id": 60, "seek": 46592, "start": 465.92, "end": 471.32, "text": " and dead locks. So here it is just an example of how sanitizer", "tokens": [293, 3116, 20703, 13, 407, 510, 309, 307, 445, 364, 1365, 295, 577, 47080], "temperature": 0.0, "avg_logprob": -0.13273978233337402, "compression_ratio": 1.7354497354497354, "no_speech_prob": 1.078299646906089e-05}, {"id": 61, "seek": 46592, "start": 471.32, "end": 480.48, "text": " looks. So here is a very simple code where I am allocating some memory in heap and then", "tokens": [1542, 13, 407, 510, 307, 257, 588, 2199, 3089, 689, 286, 669, 12660, 990, 512, 4675, 294, 33591, 293, 550], "temperature": 0.0, "avg_logprob": -0.13273978233337402, "compression_ratio": 1.7354497354497354, "no_speech_prob": 1.078299646906089e-05}, {"id": 62, "seek": 46592, "start": 480.48, "end": 485.56, "text": " I am trying to I am freeing it and then I am trying to access it after free. So if you", "tokens": [286, 669, 1382, 281, 286, 669, 1737, 278, 309, 293, 550, 286, 669, 1382, 281, 2105, 309, 934, 1737, 13, 407, 498, 291], "temperature": 0.0, "avg_logprob": -0.13273978233337402, "compression_ratio": 1.7354497354497354, "no_speech_prob": 1.078299646906089e-05}, {"id": 63, "seek": 46592, "start": 485.56, "end": 492.40000000000003, "text": " build this code with your sanitizer flag on and try to run it immediately it will complain", "tokens": [1322, 341, 3089, 365, 428, 47080, 7166, 322, 293, 853, 281, 1190, 309, 4258, 309, 486, 11024], "temperature": 0.0, "avg_logprob": -0.13273978233337402, "compression_ratio": 1.7354497354497354, "no_speech_prob": 1.078299646906089e-05}, {"id": 64, "seek": 49240, "start": 492.4, "end": 499.44, "text": " that you are trying to access some memory after free. So that is how it looks like when", "tokens": [300, 291, 366, 1382, 281, 2105, 512, 4675, 934, 1737, 13, 407, 300, 307, 577, 309, 1542, 411, 562], "temperature": 0.0, "avg_logprob": -0.13051771276137408, "compression_ratio": 1.6222222222222222, "no_speech_prob": 1.2606224117917009e-05}, {"id": 65, "seek": 49240, "start": 499.44, "end": 505.96, "text": " it is built with address sanitizer and I will talk in more detail about how what goes behind", "tokens": [309, 307, 3094, 365, 2985, 47080, 293, 286, 486, 751, 294, 544, 2607, 466, 577, 437, 1709, 2261], "temperature": 0.0, "avg_logprob": -0.13051771276137408, "compression_ratio": 1.6222222222222222, "no_speech_prob": 1.2606224117917009e-05}, {"id": 66, "seek": 49240, "start": 505.96, "end": 513.72, "text": " the scene. But before that how to build compiler RT sanitizers. So there are lot of documentation", "tokens": [264, 4145, 13, 583, 949, 300, 577, 281, 1322, 31958, 21797, 24533, 22525, 13, 407, 456, 366, 688, 295, 14333], "temperature": 0.0, "avg_logprob": -0.13051771276137408, "compression_ratio": 1.6222222222222222, "no_speech_prob": 1.2606224117917009e-05}, {"id": 67, "seek": 49240, "start": 513.72, "end": 518.48, "text": " around as well and it is very easy to follow as well but sometimes it works, sometimes", "tokens": [926, 382, 731, 293, 309, 307, 588, 1858, 281, 1524, 382, 731, 457, 2171, 309, 1985, 11, 2171], "temperature": 0.0, "avg_logprob": -0.13051771276137408, "compression_ratio": 1.6222222222222222, "no_speech_prob": 1.2606224117917009e-05}, {"id": 68, "seek": 51848, "start": 518.48, "end": 527.16, "text": " it does not. So you can build first compiler RT with LLVM it is easy you can directly", "tokens": [309, 775, 406, 13, 407, 291, 393, 1322, 700, 31958, 21797, 365, 441, 43, 53, 44, 309, 307, 1858, 291, 393, 3838], "temperature": 0.0, "avg_logprob": -0.1240118079715305, "compression_ratio": 1.6455696202531647, "no_speech_prob": 9.080112249648664e-06}, {"id": 69, "seek": 51848, "start": 527.16, "end": 535.36, "text": " enable it with LLVM enable projects when you are building your complete LLVM tool chain", "tokens": [9528, 309, 365, 441, 43, 53, 44, 9528, 4455, 562, 291, 366, 2390, 428, 3566, 441, 43, 53, 44, 2290, 5021], "temperature": 0.0, "avg_logprob": -0.1240118079715305, "compression_ratio": 1.6455696202531647, "no_speech_prob": 9.080112249648664e-06}, {"id": 70, "seek": 51848, "start": 535.36, "end": 541.36, "text": " and you can do a separate build as well if you have your LLVM config and use generator", "tokens": [293, 291, 393, 360, 257, 4994, 1322, 382, 731, 498, 291, 362, 428, 441, 43, 53, 44, 6662, 293, 764, 19265], "temperature": 0.0, "avg_logprob": -0.1240118079715305, "compression_ratio": 1.6455696202531647, "no_speech_prob": 9.080112249648664e-06}, {"id": 71, "seek": 54136, "start": 541.36, "end": 549.88, "text": " of your choice. To enable the sanitizers so if I am doing a build along with the complete", "tokens": [295, 428, 3922, 13, 1407, 9528, 264, 24533, 22525, 370, 498, 286, 669, 884, 257, 1322, 2051, 365, 264, 3566], "temperature": 0.0, "avg_logprob": -0.11995173863002233, "compression_ratio": 1.5114942528735633, "no_speech_prob": 9.818068065214902e-06}, {"id": 72, "seek": 54136, "start": 549.88, "end": 559.36, "text": " LLVM tool chain I just have to use this flag compiler RT build sanitizers to on and when", "tokens": [441, 43, 53, 44, 2290, 5021, 286, 445, 362, 281, 764, 341, 7166, 31958, 21797, 1322, 24533, 22525, 281, 322, 293, 562], "temperature": 0.0, "avg_logprob": -0.11995173863002233, "compression_ratio": 1.5114942528735633, "no_speech_prob": 9.818068065214902e-06}, {"id": 73, "seek": 54136, "start": 559.36, "end": 566.84, "text": " you do this and here I am using Ninja as a generator you can see we get a config out", "tokens": [291, 360, 341, 293, 510, 286, 669, 1228, 25566, 382, 257, 19265, 291, 393, 536, 321, 483, 257, 6662, 484], "temperature": 0.0, "avg_logprob": -0.11995173863002233, "compression_ratio": 1.5114942528735633, "no_speech_prob": 9.818068065214902e-06}, {"id": 74, "seek": 56684, "start": 566.84, "end": 575.0, "text": " of CMake and you can see it is enabling different sanitizers as address sanitizer, leak sanitizers,", "tokens": [295, 20424, 619, 293, 291, 393, 536, 309, 307, 23148, 819, 24533, 22525, 382, 2985, 47080, 11, 17143, 24533, 22525, 11], "temperature": 0.0, "avg_logprob": -0.13990169376521916, "compression_ratio": 1.7142857142857142, "no_speech_prob": 2.0904351458739256e-06}, {"id": 75, "seek": 56684, "start": 575.0, "end": 579.5600000000001, "text": " memory sanitizer, thread and undefined behavior.", "tokens": [4675, 47080, 11, 7207, 293, 674, 5666, 2001, 5223, 13], "temperature": 0.0, "avg_logprob": -0.13990169376521916, "compression_ratio": 1.7142857142857142, "no_speech_prob": 2.0904351458739256e-06}, {"id": 76, "seek": 56684, "start": 579.5600000000001, "end": 585.36, "text": " And same you can do for and after sorry after the installation and build you can get these", "tokens": [400, 912, 291, 393, 360, 337, 293, 934, 2597, 934, 264, 13260, 293, 1322, 291, 393, 483, 613], "temperature": 0.0, "avg_logprob": -0.13990169376521916, "compression_ratio": 1.7142857142857142, "no_speech_prob": 2.0904351458739256e-06}, {"id": 77, "seek": 56684, "start": 585.36, "end": 591.9200000000001, "text": " set of libraries. You can do the same for the standalone build as well with the same", "tokens": [992, 295, 15148, 13, 509, 393, 360, 264, 912, 337, 264, 37454, 1322, 382, 731, 365, 264, 912], "temperature": 0.0, "avg_logprob": -0.13990169376521916, "compression_ratio": 1.7142857142857142, "no_speech_prob": 2.0904351458739256e-06}, {"id": 78, "seek": 59192, "start": 591.92, "end": 600.0799999999999, "text": " similar flag and this is the config generated when I am doing a compiler RT standalone build", "tokens": [2531, 7166, 293, 341, 307, 264, 6662, 10833, 562, 286, 669, 884, 257, 31958, 21797, 37454, 1322], "temperature": 0.0, "avg_logprob": -0.12686533986786266, "compression_ratio": 1.634703196347032, "no_speech_prob": 2.282583045598585e-05}, {"id": 79, "seek": 59192, "start": 600.0799999999999, "end": 606.76, "text": " and then it is also possible to cross compile RT sanitizers you have to provide lot of flags", "tokens": [293, 550, 309, 307, 611, 1944, 281, 3278, 31413, 21797, 24533, 22525, 291, 362, 281, 2893, 688, 295, 23265], "temperature": 0.0, "avg_logprob": -0.12686533986786266, "compression_ratio": 1.634703196347032, "no_speech_prob": 2.282583045598585e-05}, {"id": 80, "seek": 59192, "start": 606.76, "end": 612.7199999999999, "text": " and you need to have your arms this route as well and I personally do not prefer this", "tokens": [293, 291, 643, 281, 362, 428, 5812, 341, 7955, 382, 731, 293, 286, 5665, 360, 406, 4382, 341], "temperature": 0.0, "avg_logprob": -0.12686533986786266, "compression_ratio": 1.634703196347032, "no_speech_prob": 2.282583045598585e-05}, {"id": 81, "seek": 59192, "start": 612.7199999999999, "end": 619.36, "text": " way but there is a talk today in the end from Peter about building embedded tool chain", "tokens": [636, 457, 456, 307, 257, 751, 965, 294, 264, 917, 490, 6508, 466, 2390, 16741, 2290, 5021], "temperature": 0.0, "avg_logprob": -0.12686533986786266, "compression_ratio": 1.634703196347032, "no_speech_prob": 2.282583045598585e-05}, {"id": 82, "seek": 61936, "start": 619.36, "end": 627.28, "text": " using LLVM. So, to make it a bit easier for all the embedded", "tokens": [1228, 441, 43, 53, 44, 13, 407, 11, 281, 652, 309, 257, 857, 3571, 337, 439, 264, 16741], "temperature": 0.0, "avg_logprob": -0.17536206543445587, "compression_ratio": 1.4497041420118344, "no_speech_prob": 2.0783127183676697e-05}, {"id": 83, "seek": 61936, "start": 627.28, "end": 634.44, "text": " developers there is a in Yachto project there is an open embedded layer called Meta Clang.", "tokens": [8849, 456, 307, 257, 294, 398, 3589, 78, 1716, 456, 307, 364, 1269, 16741, 4583, 1219, 6377, 64, 2033, 656, 13], "temperature": 0.0, "avg_logprob": -0.17536206543445587, "compression_ratio": 1.4497041420118344, "no_speech_prob": 2.0783127183676697e-05}, {"id": 84, "seek": 61936, "start": 634.44, "end": 640.16, "text": " It makes it bit easy because it provides everything for building your tool chain and you just", "tokens": [467, 1669, 309, 857, 1858, 570, 309, 6417, 1203, 337, 2390, 428, 2290, 5021, 293, 291, 445], "temperature": 0.0, "avg_logprob": -0.17536206543445587, "compression_ratio": 1.4497041420118344, "no_speech_prob": 2.0783127183676697e-05}, {"id": 85, "seek": 64016, "start": 640.16, "end": 649.28, "text": " have to include this layer if people are aware of Yachto builds. And just few configurations", "tokens": [362, 281, 4090, 341, 4583, 498, 561, 366, 3650, 295, 398, 3589, 78, 15182, 13, 400, 445, 1326, 31493], "temperature": 0.0, "avg_logprob": -0.13367989419520587, "compression_ratio": 1.592920353982301, "no_speech_prob": 8.939364306570496e-06}, {"id": 86, "seek": 64016, "start": 649.28, "end": 657.16, "text": " are needed like you have to enable the SDK, you have to use LLVM runtimes and then either", "tokens": [366, 2978, 411, 291, 362, 281, 9528, 264, 37135, 11, 291, 362, 281, 764, 441, 43, 53, 44, 49435, 1532, 293, 550, 2139], "temperature": 0.0, "avg_logprob": -0.13367989419520587, "compression_ratio": 1.592920353982301, "no_speech_prob": 8.939364306570496e-06}, {"id": 87, "seek": 64016, "start": 657.16, "end": 662.4399999999999, "text": " you can write in your package groups or in local conf to include compiler RT and compiler", "tokens": [291, 393, 2464, 294, 428, 7372, 3935, 420, 294, 2654, 1497, 281, 4090, 31958, 21797, 293, 31958], "temperature": 0.0, "avg_logprob": -0.13367989419520587, "compression_ratio": 1.592920353982301, "no_speech_prob": 8.939364306570496e-06}, {"id": 88, "seek": 64016, "start": 662.4399999999999, "end": 670.0799999999999, "text": " RT sanitizers. And this actually generates a SDK and it is very easy to distribute this", "tokens": [21797, 24533, 22525, 13, 400, 341, 767, 23815, 257, 37135, 293, 309, 307, 588, 1858, 281, 20594, 341], "temperature": 0.0, "avg_logprob": -0.13367989419520587, "compression_ratio": 1.592920353982301, "no_speech_prob": 8.939364306570496e-06}, {"id": 89, "seek": 67008, "start": 670.08, "end": 678.6, "text": " SDK to other developers or like in our case I used to send it to the application team", "tokens": [37135, 281, 661, 8849, 420, 411, 294, 527, 1389, 286, 1143, 281, 2845, 309, 281, 264, 3861, 1469], "temperature": 0.0, "avg_logprob": -0.14611751605302858, "compression_ratio": 1.6326530612244898, "no_speech_prob": 3.2696065318305045e-05}, {"id": 90, "seek": 67008, "start": 678.6, "end": 685.12, "text": " so that they can use this and the people who are developing C++ code they can run their", "tokens": [370, 300, 436, 393, 764, 341, 293, 264, 561, 567, 366, 6416, 383, 25472, 3089, 436, 393, 1190, 641], "temperature": 0.0, "avg_logprob": -0.14611751605302858, "compression_ratio": 1.6326530612244898, "no_speech_prob": 3.2696065318305045e-05}, {"id": 91, "seek": 67008, "start": 685.12, "end": 689.84, "text": " code they can compile their code and run sanitizers on it.", "tokens": [3089, 436, 393, 31413, 641, 3089, 293, 1190, 24533, 22525, 322, 309, 13], "temperature": 0.0, "avg_logprob": -0.14611751605302858, "compression_ratio": 1.6326530612244898, "no_speech_prob": 3.2696065318305045e-05}, {"id": 92, "seek": 67008, "start": 689.84, "end": 696.8000000000001, "text": " So this was actually while contributing to Meta Clang I came to became more aware about", "tokens": [407, 341, 390, 767, 1339, 19270, 281, 6377, 64, 2033, 656, 286, 1361, 281, 3062, 544, 3650, 466], "temperature": 0.0, "avg_logprob": -0.14611751605302858, "compression_ratio": 1.6326530612244898, "no_speech_prob": 3.2696065318305045e-05}, {"id": 93, "seek": 69680, "start": 696.8, "end": 707.04, "text": " compiler RT sanitizers and also now it is available for arm 32 bit and arm 64 bit and x86 of course", "tokens": [31958, 21797, 24533, 22525, 293, 611, 586, 309, 307, 2435, 337, 3726, 8858, 857, 293, 3726, 12145, 857, 293, 2031, 22193, 295, 1164], "temperature": 0.0, "avg_logprob": -0.16877982865518598, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.384561892336933e-05}, {"id": 94, "seek": 69680, "start": 707.04, "end": 715.04, "text": " and you can easily test it also on KMU arm as well just specifying your sys route and", "tokens": [293, 291, 393, 3612, 1500, 309, 611, 322, 591, 44, 52, 3726, 382, 731, 445, 1608, 5489, 428, 262, 749, 7955, 293], "temperature": 0.0, "avg_logprob": -0.16877982865518598, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.384561892336933e-05}, {"id": 95, "seek": 69680, "start": 715.04, "end": 722.0799999999999, "text": " running your test code to see how it behaves on your actual target.", "tokens": [2614, 428, 1500, 3089, 281, 536, 577, 309, 36896, 322, 428, 3539, 3779, 13], "temperature": 0.0, "avg_logprob": -0.16877982865518598, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.384561892336933e-05}, {"id": 96, "seek": 72208, "start": 722.08, "end": 729.6800000000001, "text": " So that was all about what is compiler RT sanitizers, how we build it but what exactly", "tokens": [407, 300, 390, 439, 466, 437, 307, 31958, 21797, 24533, 22525, 11, 577, 321, 1322, 309, 457, 437, 2293], "temperature": 0.0, "avg_logprob": -0.14565374030441533, "compression_ratio": 1.4942528735632183, "no_speech_prob": 1.184239772555884e-05}, {"id": 97, "seek": 72208, "start": 729.6800000000001, "end": 739.4000000000001, "text": " goes behind the scene. So here I am using an example of address sanitizer to use and", "tokens": [1709, 2261, 264, 4145, 13, 407, 510, 286, 669, 1228, 364, 1365, 295, 2985, 47080, 281, 764, 293], "temperature": 0.0, "avg_logprob": -0.14565374030441533, "compression_ratio": 1.4942528735632183, "no_speech_prob": 1.184239772555884e-05}, {"id": 98, "seek": 72208, "start": 739.4000000000001, "end": 746.96, "text": " here is a very basic code where we are taking some arguments and converting into integer", "tokens": [510, 307, 257, 588, 3875, 3089, 689, 321, 366, 1940, 512, 12869, 293, 29942, 666, 24922], "temperature": 0.0, "avg_logprob": -0.14565374030441533, "compression_ratio": 1.4942528735632183, "no_speech_prob": 1.184239772555884e-05}, {"id": 99, "seek": 74696, "start": 746.96, "end": 754.88, "text": " but here you can see we are using argument counter and the value for this can be very", "tokens": [457, 510, 291, 393, 536, 321, 366, 1228, 6770, 5682, 293, 264, 2158, 337, 341, 393, 312, 588], "temperature": 0.0, "avg_logprob": -0.1248613946578082, "compression_ratio": 1.5654761904761905, "no_speech_prob": 2.6272813556715846e-05}, {"id": 100, "seek": 74696, "start": 754.88, "end": 764.5600000000001, "text": " large as well. So first time when I try to compile it with Clang it compiles and when", "tokens": [2416, 382, 731, 13, 407, 700, 565, 562, 286, 853, 281, 31413, 309, 365, 2033, 656, 309, 715, 4680, 293, 562], "temperature": 0.0, "avg_logprob": -0.1248613946578082, "compression_ratio": 1.5654761904761905, "no_speech_prob": 2.6272813556715846e-05}, {"id": 101, "seek": 74696, "start": 764.5600000000001, "end": 771.72, "text": " you run it after like as you can see easily and it is very easy to spot here I have defined", "tokens": [291, 1190, 309, 934, 411, 382, 291, 393, 536, 3612, 293, 309, 307, 588, 1858, 281, 4008, 510, 286, 362, 7642], "temperature": 0.0, "avg_logprob": -0.1248613946578082, "compression_ratio": 1.5654761904761905, "no_speech_prob": 2.6272813556715846e-05}, {"id": 102, "seek": 77172, "start": 771.72, "end": 780.24, "text": " the size of buffer to be just 2 and if I provide input more than 2 it should fail actually", "tokens": [264, 2744, 295, 21762, 281, 312, 445, 568, 293, 498, 286, 2893, 4846, 544, 813, 568, 309, 820, 3061, 767], "temperature": 0.0, "avg_logprob": -0.12495179857526506, "compression_ratio": 1.6686746987951808, "no_speech_prob": 1.7778111214283854e-05}, {"id": 103, "seek": 77172, "start": 780.24, "end": 786.36, "text": " that is the case but it is very the crux here is like it is difficult for some machine it", "tokens": [300, 307, 264, 1389, 457, 309, 307, 588, 264, 5140, 87, 510, 307, 411, 309, 307, 2252, 337, 512, 3479, 309], "temperature": 0.0, "avg_logprob": -0.12495179857526506, "compression_ratio": 1.6686746987951808, "no_speech_prob": 1.7778111214283854e-05}, {"id": 104, "seek": 77172, "start": 786.36, "end": 794.84, "text": " will fail for 3 and for some machine it will fail with the 4 input and leads to the segmentation", "tokens": [486, 3061, 337, 805, 293, 337, 512, 3479, 309, 486, 3061, 365, 264, 1017, 4846, 293, 6689, 281, 264, 9469, 399], "temperature": 0.0, "avg_logprob": -0.12495179857526506, "compression_ratio": 1.6686746987951808, "no_speech_prob": 1.7778111214283854e-05}, {"id": 105, "seek": 79484, "start": 794.84, "end": 802.6, "text": " fault and we do not know what happened exactly behind the scene. Second when you try to build", "tokens": [7441, 293, 321, 360, 406, 458, 437, 2011, 2293, 2261, 264, 4145, 13, 5736, 562, 291, 853, 281, 1322], "temperature": 0.0, "avg_logprob": -0.11293616602497716, "compression_ratio": 1.563953488372093, "no_speech_prob": 1.321169656876009e-05}, {"id": 106, "seek": 79484, "start": 802.6, "end": 810.24, "text": " it with address sanitizer enabled or link it with compiler RT and with your address sanitizer", "tokens": [309, 365, 2985, 47080, 15172, 420, 2113, 309, 365, 31958, 21797, 293, 365, 428, 2985, 47080], "temperature": 0.0, "avg_logprob": -0.11293616602497716, "compression_ratio": 1.563953488372093, "no_speech_prob": 1.321169656876009e-05}, {"id": 107, "seek": 79484, "start": 810.24, "end": 817.76, "text": " flag as well and the output is actually a bit large this is the first part of it.", "tokens": [7166, 382, 731, 293, 264, 5598, 307, 767, 257, 857, 2416, 341, 307, 264, 700, 644, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.11293616602497716, "compression_ratio": 1.563953488372093, "no_speech_prob": 1.321169656876009e-05}, {"id": 108, "seek": 81776, "start": 817.76, "end": 825.4399999999999, "text": " So it can easily spot that there was a stack overflow stack buffer overflow and it also", "tokens": [407, 309, 393, 3612, 4008, 300, 456, 390, 257, 8630, 37772, 8630, 21762, 37772, 293, 309, 611], "temperature": 0.0, "avg_logprob": -0.14521421492099762, "compression_ratio": 1.598802395209581, "no_speech_prob": 2.52152085522539e-06}, {"id": 109, "seek": 81776, "start": 825.4399999999999, "end": 835.76, "text": " points out if you build it with hyphen g option it also points out at work line it is failing", "tokens": [2793, 484, 498, 291, 1322, 309, 365, 2477, 47059, 290, 3614, 309, 611, 2793, 484, 412, 589, 1622, 309, 307, 18223], "temperature": 0.0, "avg_logprob": -0.14521421492099762, "compression_ratio": 1.598802395209581, "no_speech_prob": 2.52152085522539e-06}, {"id": 110, "seek": 81776, "start": 835.76, "end": 843.8, "text": " but what exactly led to generation of this kind of error. So in very simple term when", "tokens": [457, 437, 2293, 4684, 281, 5125, 295, 341, 733, 295, 6713, 13, 407, 294, 588, 2199, 1433, 562], "temperature": 0.0, "avg_logprob": -0.14521421492099762, "compression_ratio": 1.598802395209581, "no_speech_prob": 2.52152085522539e-06}, {"id": 111, "seek": 84380, "start": 843.8, "end": 849.5999999999999, "text": " address sanitizers adding sanitizer is like adding an additional code to your actual code", "tokens": [2985, 24533, 22525, 5127, 47080, 307, 411, 5127, 364, 4497, 3089, 281, 428, 3539, 3089], "temperature": 0.0, "avg_logprob": -0.13281172797793434, "compression_ratio": 1.7989949748743719, "no_speech_prob": 3.3732951123965904e-05}, {"id": 112, "seek": 84380, "start": 849.5999999999999, "end": 855.3599999999999, "text": " to just check when it is going to fail and report the error. So here it looks very easy", "tokens": [281, 445, 1520, 562, 309, 307, 516, 281, 3061, 293, 2275, 264, 6713, 13, 407, 510, 309, 1542, 588, 1858], "temperature": 0.0, "avg_logprob": -0.13281172797793434, "compression_ratio": 1.7989949748743719, "no_speech_prob": 3.3732951123965904e-05}, {"id": 113, "seek": 84380, "start": 855.3599999999999, "end": 861.9599999999999, "text": " okay if my buffer size is more than 2 or sorry if the input size for the buffer is more than", "tokens": [1392, 498, 452, 21762, 2744, 307, 544, 813, 568, 420, 2597, 498, 264, 4846, 2744, 337, 264, 21762, 307, 544, 813], "temperature": 0.0, "avg_logprob": -0.13281172797793434, "compression_ratio": 1.7989949748743719, "no_speech_prob": 3.3732951123965904e-05}, {"id": 114, "seek": 84380, "start": 861.9599999999999, "end": 868.64, "text": " 2 just notify it is an error but behind the scene for address sanitizer it is much more", "tokens": [568, 445, 36560, 309, 307, 364, 6713, 457, 2261, 264, 4145, 337, 2985, 47080, 309, 307, 709, 544], "temperature": 0.0, "avg_logprob": -0.13281172797793434, "compression_ratio": 1.7989949748743719, "no_speech_prob": 3.3732951123965904e-05}, {"id": 115, "seek": 86864, "start": 868.64, "end": 877.56, "text": " and it can adopt multiple strategies to implement it. So here address sanitizer uses memory", "tokens": [293, 309, 393, 6878, 3866, 9029, 281, 4445, 309, 13, 407, 510, 2985, 47080, 4960, 4675], "temperature": 0.0, "avg_logprob": -0.12088655075936947, "compression_ratio": 1.575, "no_speech_prob": 1.750193041516468e-05}, {"id": 116, "seek": 86864, "start": 877.56, "end": 885.04, "text": " mapping so memory that should not be accessed is called as poisoned memory.", "tokens": [18350, 370, 4675, 300, 820, 406, 312, 34211, 307, 1219, 382, 36677, 4675, 13], "temperature": 0.0, "avg_logprob": -0.12088655075936947, "compression_ratio": 1.575, "no_speech_prob": 1.750193041516468e-05}, {"id": 117, "seek": 86864, "start": 885.04, "end": 890.3199999999999, "text": " So behind the scene it is implemented like to check whether this is getting poisoned", "tokens": [407, 2261, 264, 4145, 309, 307, 12270, 411, 281, 1520, 1968, 341, 307, 1242, 36677], "temperature": 0.0, "avg_logprob": -0.12088655075936947, "compression_ratio": 1.575, "no_speech_prob": 1.750193041516468e-05}, {"id": 118, "seek": 89032, "start": 890.32, "end": 899.0400000000001, "text": " or not so here poison means either it is referring to some deallocated memory or some already", "tokens": [420, 406, 370, 510, 10836, 1355, 2139, 309, 307, 13761, 281, 512, 368, 336, 905, 770, 4675, 420, 512, 1217], "temperature": 0.0, "avg_logprob": -0.13932952573222498, "compression_ratio": 1.656441717791411, "no_speech_prob": 2.212279287050478e-05}, {"id": 119, "seek": 89032, "start": 899.0400000000001, "end": 906.2800000000001, "text": " allocated memory or there is getting some overflow or not and just report the error", "tokens": [29772, 4675, 420, 456, 307, 1242, 512, 37772, 420, 406, 293, 445, 2275, 264, 6713], "temperature": 0.0, "avg_logprob": -0.13932952573222498, "compression_ratio": 1.656441717791411, "no_speech_prob": 2.212279287050478e-05}, {"id": 120, "seek": 89032, "start": 906.2800000000001, "end": 915.32, "text": " but there is much more how this memory is mapped. So for any code built with any application", "tokens": [457, 456, 307, 709, 544, 577, 341, 4675, 307, 33318, 13, 407, 337, 604, 3089, 3094, 365, 604, 3861], "temperature": 0.0, "avg_logprob": -0.13932952573222498, "compression_ratio": 1.656441717791411, "no_speech_prob": 2.212279287050478e-05}, {"id": 121, "seek": 91532, "start": 915.32, "end": 921.6400000000001, "text": " that you build the virtual address space is divided into two kind of memories one is", "tokens": [300, 291, 1322, 264, 6374, 2985, 1901, 307, 6666, 666, 732, 733, 295, 8495, 472, 307], "temperature": 0.0, "avg_logprob": -0.11469802571766412, "compression_ratio": 1.715846994535519, "no_speech_prob": 5.47357922187075e-05}, {"id": 122, "seek": 91532, "start": 921.6400000000001, "end": 928.96, "text": " shadow memory and one is application memory. So for address sanitizer it is more important", "tokens": [8576, 4675, 293, 472, 307, 3861, 4675, 13, 407, 337, 2985, 47080, 309, 307, 544, 1021], "temperature": 0.0, "avg_logprob": -0.11469802571766412, "compression_ratio": 1.715846994535519, "no_speech_prob": 5.47357922187075e-05}, {"id": 123, "seek": 91532, "start": 928.96, "end": 936.32, "text": " to implement this is poisoned and report error in a very compact and fast way then talking", "tokens": [281, 4445, 341, 307, 36677, 293, 2275, 6713, 294, 257, 588, 14679, 293, 2370, 636, 550, 1417], "temperature": 0.0, "avg_logprob": -0.11469802571766412, "compression_ratio": 1.715846994535519, "no_speech_prob": 5.47357922187075e-05}, {"id": 124, "seek": 91532, "start": 936.32, "end": 939.84, "text": " about shadow memory and the application memory.", "tokens": [466, 8576, 4675, 293, 264, 3861, 4675, 13], "temperature": 0.0, "avg_logprob": -0.11469802571766412, "compression_ratio": 1.715846994535519, "no_speech_prob": 5.47357922187075e-05}, {"id": 125, "seek": 93984, "start": 939.84, "end": 947.6800000000001, "text": " So application memory is the main memory of the code and shadow memory is a copy of application", "tokens": [407, 3861, 4675, 307, 264, 2135, 4675, 295, 264, 3089, 293, 8576, 4675, 307, 257, 5055, 295, 3861], "temperature": 0.0, "avg_logprob": -0.10673769449783584, "compression_ratio": 1.8680555555555556, "no_speech_prob": 1.2028258424834348e-05}, {"id": 126, "seek": 93984, "start": 947.6800000000001, "end": 954.88, "text": " memory but here 8 bytes of your application map memory is mapped as 1 byte in shadow", "tokens": [4675, 457, 510, 1649, 36088, 295, 428, 3861, 4471, 4675, 307, 33318, 382, 502, 40846, 294, 8576], "temperature": 0.0, "avg_logprob": -0.10673769449783584, "compression_ratio": 1.8680555555555556, "no_speech_prob": 1.2028258424834348e-05}, {"id": 127, "seek": 93984, "start": 954.88, "end": 962.6800000000001, "text": " memory and when the sanitizer checks whether this memory is poisoned or not it is mapped", "tokens": [4675, 293, 562, 264, 47080, 13834, 1968, 341, 4675, 307, 36677, 420, 406, 309, 307, 33318], "temperature": 0.0, "avg_logprob": -0.10673769449783584, "compression_ratio": 1.8680555555555556, "no_speech_prob": 1.2028258424834348e-05}, {"id": 128, "seek": 96268, "start": 962.68, "end": 971.4399999999999, "text": " to either 0 or 1. So here it is a small portion of shadow memory of our example and you can", "tokens": [281, 2139, 1958, 420, 502, 13, 407, 510, 309, 307, 257, 1359, 8044, 295, 8576, 4675, 295, 527, 1365, 293, 291, 393], "temperature": 0.0, "avg_logprob": -0.1278870995364972, "compression_ratio": 1.6047904191616766, "no_speech_prob": 1.1842754247481935e-05}, {"id": 129, "seek": 96268, "start": 971.4399999999999, "end": 978.8399999999999, "text": " see the memory which is accessible and which is in good condition is marked as 0.", "tokens": [536, 264, 4675, 597, 307, 9515, 293, 597, 307, 294, 665, 4188, 307, 12658, 382, 1958, 13], "temperature": 0.0, "avg_logprob": -0.1278870995364972, "compression_ratio": 1.6047904191616766, "no_speech_prob": 1.1842754247481935e-05}, {"id": 130, "seek": 96268, "start": 978.8399999999999, "end": 988.24, "text": " But here when we are allocating we are checking the buffer here you can see after it is marked", "tokens": [583, 510, 562, 321, 366, 12660, 990, 321, 366, 8568, 264, 21762, 510, 291, 393, 536, 934, 309, 307, 12658], "temperature": 0.0, "avg_logprob": -0.1278870995364972, "compression_ratio": 1.6047904191616766, "no_speech_prob": 1.1842754247481935e-05}, {"id": 131, "seek": 98824, "start": 988.24, "end": 994.76, "text": " as so the memory which is like more when we are trying to access more than the allocated", "tokens": [382, 370, 264, 4675, 597, 307, 411, 544, 562, 321, 366, 1382, 281, 2105, 544, 813, 264, 29772], "temperature": 0.0, "avg_logprob": -0.10096964778670345, "compression_ratio": 1.7777777777777777, "no_speech_prob": 1.2029112440359313e-05}, {"id": 132, "seek": 98824, "start": 994.76, "end": 1001.5600000000001, "text": " buffer size it is marked as 1 and these and here you can see in the square brackets it", "tokens": [21762, 2744, 309, 307, 12658, 382, 502, 293, 613, 293, 510, 291, 393, 536, 294, 264, 3732, 26179, 309], "temperature": 0.0, "avg_logprob": -0.10096964778670345, "compression_ratio": 1.7777777777777777, "no_speech_prob": 1.2029112440359313e-05}, {"id": 133, "seek": 98824, "start": 1001.5600000000001, "end": 1008.64, "text": " is it is marking that hello this here you are supposed not to access this it is getting", "tokens": [307, 309, 307, 25482, 300, 7751, 341, 510, 291, 366, 3442, 406, 281, 2105, 341, 309, 307, 1242], "temperature": 0.0, "avg_logprob": -0.10096964778670345, "compression_ratio": 1.7777777777777777, "no_speech_prob": 1.2029112440359313e-05}, {"id": 134, "seek": 98824, "start": 1008.64, "end": 1014.36, "text": " out of the range of the buffer. So that is how this application memory and shadow memory", "tokens": [484, 295, 264, 3613, 295, 264, 21762, 13, 407, 300, 307, 577, 341, 3861, 4675, 293, 8576, 4675], "temperature": 0.0, "avg_logprob": -0.10096964778670345, "compression_ratio": 1.7777777777777777, "no_speech_prob": 1.2029112440359313e-05}, {"id": 135, "seek": 101436, "start": 1014.36, "end": 1021.6, "text": " is used and then you can see here we restrict it as the red zones.", "tokens": [307, 1143, 293, 550, 291, 393, 536, 510, 321, 7694, 309, 382, 264, 2182, 16025, 13], "temperature": 0.0, "avg_logprob": -0.13675159023654077, "compression_ratio": 1.5816993464052287, "no_speech_prob": 6.8541794462362304e-06}, {"id": 136, "seek": 101436, "start": 1021.6, "end": 1028.88, "text": " So if you have anything greater than these than the allocated one so that one gets marked", "tokens": [407, 498, 291, 362, 1340, 5044, 813, 613, 813, 264, 29772, 472, 370, 300, 472, 2170, 12658], "temperature": 0.0, "avg_logprob": -0.13675159023654077, "compression_ratio": 1.5816993464052287, "no_speech_prob": 6.8541794462362304e-06}, {"id": 137, "seek": 101436, "start": 1028.88, "end": 1036.76, "text": " as 1 and you can see f 1 f 3 around and so that is how the address sanitizer works by", "tokens": [382, 502, 293, 291, 393, 536, 283, 502, 283, 805, 926, 293, 370, 300, 307, 577, 264, 2985, 47080, 1985, 538], "temperature": 0.0, "avg_logprob": -0.13675159023654077, "compression_ratio": 1.5816993464052287, "no_speech_prob": 6.8541794462362304e-06}, {"id": 138, "seek": 103676, "start": 1036.76, "end": 1044.68, "text": " using this shadow memory and application memory and knowing about your shadow memory and whenever", "tokens": [1228, 341, 8576, 4675, 293, 3861, 4675, 293, 5276, 466, 428, 8576, 4675, 293, 5699], "temperature": 0.0, "avg_logprob": -0.11923116956438337, "compression_ratio": 1.6836158192090396, "no_speech_prob": 2.078289253404364e-05}, {"id": 139, "seek": 103676, "start": 1044.68, "end": 1051.2, "text": " it spots it is 1 then it says okay there is a problem. So that is all about the address", "tokens": [309, 10681, 309, 307, 502, 550, 309, 1619, 1392, 456, 307, 257, 1154, 13, 407, 300, 307, 439, 466, 264, 2985], "temperature": 0.0, "avg_logprob": -0.11923116956438337, "compression_ratio": 1.6836158192090396, "no_speech_prob": 2.078289253404364e-05}, {"id": 140, "seek": 103676, "start": 1051.2, "end": 1055.28, "text": " sanitizer and how it works.", "tokens": [47080, 293, 577, 309, 1985, 13], "temperature": 0.0, "avg_logprob": -0.11923116956438337, "compression_ratio": 1.6836158192090396, "no_speech_prob": 2.078289253404364e-05}, {"id": 141, "seek": 103676, "start": 1055.28, "end": 1062.04, "text": " So here are my final thoughts about using sanitizers it is a very great tool to find", "tokens": [407, 510, 366, 452, 2572, 4598, 466, 1228, 24533, 22525, 309, 307, 257, 588, 869, 2290, 281, 915], "temperature": 0.0, "avg_logprob": -0.11923116956438337, "compression_ratio": 1.6836158192090396, "no_speech_prob": 2.078289253404364e-05}, {"id": 142, "seek": 106204, "start": 1062.04, "end": 1071.32, "text": " bugs and memory issues and in run time for complex applications. So by using sanitizers", "tokens": [15120, 293, 4675, 2663, 293, 294, 1190, 565, 337, 3997, 5821, 13, 407, 538, 1228, 24533, 22525], "temperature": 0.0, "avg_logprob": -0.12175119334253771, "compression_ratio": 1.5384615384615385, "no_speech_prob": 2.0783558284165338e-05}, {"id": 143, "seek": 106204, "start": 1071.32, "end": 1078.04, "text": " you can improve your development and you can spot the errors very quickly and since we", "tokens": [291, 393, 3470, 428, 3250, 293, 291, 393, 4008, 264, 13603, 588, 2661, 293, 1670, 321], "temperature": 0.0, "avg_logprob": -0.12175119334253771, "compression_ratio": 1.5384615384615385, "no_speech_prob": 2.0783558284165338e-05}, {"id": 144, "seek": 106204, "start": 1078.04, "end": 1083.24, "text": " had a very simple example but when the code gets more complex it is more difficult to", "tokens": [632, 257, 588, 2199, 1365, 457, 562, 264, 3089, 2170, 544, 3997, 309, 307, 544, 2252, 281], "temperature": 0.0, "avg_logprob": -0.12175119334253771, "compression_ratio": 1.5384615384615385, "no_speech_prob": 2.0783558284165338e-05}, {"id": 145, "seek": 108324, "start": 1083.24, "end": 1092.6, "text": " find what is the problem. And though with the sanitizers it is more like a tool to check", "tokens": [915, 437, 307, 264, 1154, 13, 400, 1673, 365, 264, 24533, 22525, 309, 307, 544, 411, 257, 2290, 281, 1520], "temperature": 0.0, "avg_logprob": -0.11895129864032451, "compression_ratio": 1.5988372093023255, "no_speech_prob": 1.2605936717591248e-05}, {"id": 146, "seek": 108324, "start": 1092.6, "end": 1099.28, "text": " not to be used in your production it increases the code size but the sanitizers are comparatively", "tokens": [406, 281, 312, 1143, 294, 428, 4265, 309, 8637, 264, 3089, 2744, 457, 264, 24533, 22525, 366, 6311, 19020], "temperature": 0.0, "avg_logprob": -0.11895129864032451, "compression_ratio": 1.5988372093023255, "no_speech_prob": 1.2605936717591248e-05}, {"id": 147, "seek": 108324, "start": 1099.28, "end": 1106.72, "text": " more faster than Valgrind the existing one and still there are not all the architectures", "tokens": [544, 4663, 813, 7188, 861, 471, 264, 6741, 472, 293, 920, 456, 366, 406, 439, 264, 6331, 1303], "temperature": 0.0, "avg_logprob": -0.11895129864032451, "compression_ratio": 1.5988372093023255, "no_speech_prob": 1.2605936717591248e-05}, {"id": 148, "seek": 110672, "start": 1106.72, "end": 1113.6000000000001, "text": " are supported uniformly like for example for arm 32 we do not have threat sanitizer completely", "tokens": [366, 8104, 48806, 411, 337, 1365, 337, 3726, 8858, 321, 360, 406, 362, 4734, 47080, 2584], "temperature": 0.0, "avg_logprob": -0.16675114631652832, "compression_ratio": 1.5365853658536586, "no_speech_prob": 3.763424319913611e-05}, {"id": 149, "seek": 110672, "start": 1113.6000000000001, "end": 1121.76, "text": " implemented so I hope we see a better implementation later and it supports threat sanitization", "tokens": [12270, 370, 286, 1454, 321, 536, 257, 1101, 11420, 1780, 293, 309, 9346, 4734, 24533, 2144], "temperature": 0.0, "avg_logprob": -0.16675114631652832, "compression_ratio": 1.5365853658536586, "no_speech_prob": 3.763424319913611e-05}, {"id": 150, "seek": 112176, "start": 1121.76, "end": 1148.12, "text": " on 32 bit machines as well questions. Yes it works sorry the question here is like", "tokens": [322, 8858, 857, 8379, 382, 731, 1651, 13, 1079, 309, 1985, 2597, 264, 1168, 510, 307, 411], "temperature": 0.0, "avg_logprob": -0.34781419663202195, "compression_ratio": 1.0933333333333333, "no_speech_prob": 7.367320358753204e-05}, {"id": 151, "seek": 114812, "start": 1148.12, "end": 1157.08, "text": " I am using the optimization flag for building with address sanitizer enabled yes it can", "tokens": [286, 669, 1228, 264, 19618, 7166, 337, 2390, 365, 2985, 47080, 15172, 2086, 309, 393], "temperature": 0.0, "avg_logprob": -0.16182220304334485, "compression_ratio": 1.293103448275862, "no_speech_prob": 0.00016589672304689884}, {"id": 152, "seek": 114812, "start": 1157.08, "end": 1176.7199999999998, "text": " be enabled to up to 3 as well and you get similar kind of log.", "tokens": [312, 15172, 281, 493, 281, 805, 382, 731, 293, 291, 483, 2531, 733, 295, 3565, 13], "temperature": 0.0, "avg_logprob": -0.16182220304334485, "compression_ratio": 1.293103448275862, "no_speech_prob": 0.00016589672304689884}, {"id": 153, "seek": 117672, "start": 1176.72, "end": 1182.56, "text": " So the question is where I am placing the instrumentation to identify whether my buffer", "tokens": [407, 264, 1168, 307, 689, 286, 669, 17221, 264, 7198, 399, 281, 5876, 1968, 452, 21762], "temperature": 0.0, "avg_logprob": -0.1242533806831606, "compression_ratio": 1.6158536585365855, "no_speech_prob": 6.501477037090808e-05}, {"id": 154, "seek": 117672, "start": 1182.56, "end": 1192.72, "text": " is overflowing or not to use assertion here I am not sure I can answer that well but the", "tokens": [307, 670, 43955, 420, 406, 281, 764, 19810, 313, 510, 286, 669, 406, 988, 286, 393, 1867, 300, 731, 457, 264], "temperature": 0.0, "avg_logprob": -0.1242533806831606, "compression_ratio": 1.6158536585365855, "no_speech_prob": 6.501477037090808e-05}, {"id": 155, "seek": 117672, "start": 1192.72, "end": 1199.84, "text": " strategy of this one is using more with this memory mapping one and also here since this", "tokens": [5206, 295, 341, 472, 307, 1228, 544, 365, 341, 4675, 18350, 472, 293, 611, 510, 1670, 341], "temperature": 0.0, "avg_logprob": -0.1242533806831606, "compression_ratio": 1.6158536585365855, "no_speech_prob": 6.501477037090808e-05}, {"id": 156, "seek": 119984, "start": 1199.84, "end": 1226.0, "text": " buffer size is very small so may be assertion might work here.", "tokens": [21762, 2744, 307, 588, 1359, 370, 815, 312, 19810, 313, 1062, 589, 510, 13], "temperature": 0.0, "avg_logprob": -0.3599749671088325, "compression_ratio": 0.9841269841269841, "no_speech_prob": 8.47500268719159e-05}, {"id": 157, "seek": 122600, "start": 1226.0, "end": 1247.44, "text": " This I am also not much aware of so the question is like if I can sanitize it for a very specific", "tokens": [639, 286, 669, 611, 406, 709, 3650, 295, 370, 264, 1168, 307, 411, 498, 286, 393, 24533, 1125, 309, 337, 257, 588, 2685], "temperature": 0.0, "avg_logprob": -0.1382280190785726, "compression_ratio": 1.1411764705882352, "no_speech_prob": 0.0003403126320336014}, {"id": 158, "seek": 124744, "start": 1247.44, "end": 1257.72, "text": " portion of the code right yeah you can no I am sorry I am not much aware of it you can", "tokens": [8044, 295, 264, 3089, 558, 1338, 291, 393, 572, 286, 669, 2597, 286, 669, 406, 709, 3650, 295, 309, 291, 393], "temperature": 0.0, "avg_logprob": -0.3682793967331512, "compression_ratio": 1.682051282051282, "no_speech_prob": 0.0005437574000097811}, {"id": 159, "seek": 124744, "start": 1257.72, "end": 1262.76, "text": " reverse it you can prevent some specific code from being instrumented either by annotating", "tokens": [9943, 309, 291, 393, 4871, 512, 2685, 3089, 490, 885, 7198, 292, 2139, 538, 25339, 990], "temperature": 0.0, "avg_logprob": -0.3682793967331512, "compression_ratio": 1.682051282051282, "no_speech_prob": 0.0005437574000097811}, {"id": 160, "seek": 124744, "start": 1262.76, "end": 1268.4, "text": " the code or by using a blacklist. Yeah there is this blacklist address sanitizers", "tokens": [264, 3089, 420, 538, 1228, 257, 2211, 8264, 13, 865, 456, 307, 341, 2211, 8264, 2985, 24533, 22525], "temperature": 0.0, "avg_logprob": -0.3682793967331512, "compression_ratio": 1.682051282051282, "no_speech_prob": 0.0005437574000097811}, {"id": 161, "seek": 124744, "start": 1268.4, "end": 1273.8400000000001, "text": " options as well yeah. Have you you say that sanitizers are primarily", "tokens": [3956, 382, 731, 1338, 13, 3560, 291, 291, 584, 300, 24533, 22525, 366, 10029], "temperature": 0.0, "avg_logprob": -0.3682793967331512, "compression_ratio": 1.682051282051282, "no_speech_prob": 0.0005437574000097811}, {"id": 162, "seek": 127384, "start": 1273.84, "end": 1278.6399999999999, "text": " a development tool and yes they mostly are but have you ever looked into using some of", "tokens": [257, 3250, 2290, 293, 2086, 436, 5240, 366, 457, 362, 291, 1562, 2956, 666, 1228, 512, 295], "temperature": 0.0, "avg_logprob": -0.2850311093214082, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.0038035342004150152}, {"id": 163, "seek": 127384, "start": 1278.6399999999999, "end": 1285.6399999999999, "text": " them for actual production executables for hardening for example UV sun has a fairly", "tokens": [552, 337, 3539, 4265, 7568, 2965, 337, 1152, 4559, 337, 1365, 17887, 3295, 575, 257, 6457], "temperature": 0.0, "avg_logprob": -0.2850311093214082, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.0038035342004150152}, {"id": 164, "seek": 127384, "start": 1285.6399999999999, "end": 1291.4399999999998, "text": " minimal overhead so it can be used in production especially if you make a strap or if you make", "tokens": [13206, 19922, 370, 309, 393, 312, 1143, 294, 4265, 2318, 498, 291, 652, 257, 18359, 420, 498, 291, 652], "temperature": 0.0, "avg_logprob": -0.2850311093214082, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.0038035342004150152}, {"id": 165, "seek": 127384, "start": 1291.4399999999998, "end": 1299.36, "text": " it if you use the minimal runtime or also there is GWP ASAN which is like a lightweight", "tokens": [309, 498, 291, 764, 264, 13206, 34474, 420, 611, 456, 307, 36704, 47, 7469, 1770, 597, 307, 411, 257, 22052], "temperature": 0.0, "avg_logprob": -0.2850311093214082, "compression_ratio": 1.5945945945945945, "no_speech_prob": 0.0038035342004150152}, {"id": 166, "seek": 129936, "start": 1299.36, "end": 1304.36, "text": " sampling version of other sanitizers which can be used in runtime I think Android is", "tokens": [21179, 3037, 295, 661, 24533, 22525, 597, 393, 312, 1143, 294, 34474, 286, 519, 8853, 307], "temperature": 0.0, "avg_logprob": -0.2668255615234375, "compression_ratio": 1.5069767441860464, "no_speech_prob": 0.0005635784473270178}, {"id": 167, "seek": 129936, "start": 1304.36, "end": 1309.24, "text": " using it actually. Okay so does it support some of the embedded", "tokens": [1228, 309, 767, 13, 1033, 370, 775, 309, 1406, 512, 295, 264, 16741], "temperature": 0.0, "avg_logprob": -0.2668255615234375, "compression_ratio": 1.5069767441860464, "no_speech_prob": 0.0005635784473270178}, {"id": 168, "seek": 129936, "start": 1309.24, "end": 1316.32, "text": " platforms as well like ARM32 or 64? It supports I believe it does well UV sun works pretty", "tokens": [9473, 382, 731, 411, 45209, 11440, 420, 12145, 30, 467, 9346, 286, 1697, 309, 775, 731, 17887, 3295, 1985, 1238], "temperature": 0.0, "avg_logprob": -0.2668255615234375, "compression_ratio": 1.5069767441860464, "no_speech_prob": 0.0005635784473270178}, {"id": 169, "seek": 129936, "start": 1316.32, "end": 1324.1599999999999, "text": " much everywhere almost everywhere GWP ASAN works I think almost everywhere but it is", "tokens": [709, 5315, 1920, 5315, 36704, 47, 7469, 1770, 1985, 286, 519, 1920, 5315, 457, 309, 307], "temperature": 0.0, "avg_logprob": -0.2668255615234375, "compression_ratio": 1.5069767441860464, "no_speech_prob": 0.0005635784473270178}, {"id": 170, "seek": 132416, "start": 1324.16, "end": 1332.72, "text": " also dependent on like external function for unwinding so it might not be great in all", "tokens": [611, 12334, 322, 411, 8320, 2445, 337, 14853, 9245, 370, 309, 1062, 406, 312, 869, 294, 439], "temperature": 0.0, "avg_logprob": -0.39603628763338417, "compression_ratio": 1.3937007874015748, "no_speech_prob": 0.0018306378042325377}, {"id": 171, "seek": 132416, "start": 1332.72, "end": 1344.6000000000001, "text": " scenarios it really depends. I was wondering if you can use this for kernel ring zero code", "tokens": [15077, 309, 534, 5946, 13, 286, 390, 6359, 498, 291, 393, 764, 341, 337, 28256, 4875, 4018, 3089], "temperature": 0.0, "avg_logprob": -0.39603628763338417, "compression_ratio": 1.3937007874015748, "no_speech_prob": 0.0018306378042325377}, {"id": 172, "seek": 134460, "start": 1344.6, "end": 1354.6399999999999, "text": " as well. Yes you can but like there's like. But there's a. While there are no if you don't", "tokens": [382, 731, 13, 1079, 291, 393, 457, 411, 456, 311, 411, 13, 583, 456, 311, 257, 13, 3987, 456, 366, 572, 498, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.6065646035330636, "compression_ratio": 1.560693641618497, "no_speech_prob": 0.00441875122487545}, {"id": 173, "seek": 134460, "start": 1354.6399999999999, "end": 1361.6, "text": " have like the runtime it's not in the NPM it's actually offered by the kernel and you", "tokens": [362, 411, 264, 34474, 309, 311, 406, 294, 264, 426, 18819, 309, 311, 767, 8059, 538, 264, 28256, 293, 291], "temperature": 0.0, "avg_logprob": -0.6065646035330636, "compression_ratio": 1.560693641618497, "no_speech_prob": 0.00441875122487545}, {"id": 174, "seek": 134460, "start": 1361.6, "end": 1368.12, "text": " infer the checks but the hooks themselves are implemented in the kernel. Well some sanitizers", "tokens": [13596, 264, 13834, 457, 264, 26485, 2969, 366, 12270, 294, 264, 28256, 13, 1042, 512, 24533, 22525], "temperature": 0.0, "avg_logprob": -0.6065646035330636, "compression_ratio": 1.560693641618497, "no_speech_prob": 0.00441875122487545}, {"id": 175, "seek": 136812, "start": 1368.12, "end": 1376.6799999999998, "text": " don't require any runtime. So for ASAN you need instrumentation. Yeah you can use kernel", "tokens": [500, 380, 3651, 604, 34474, 13, 407, 337, 7469, 1770, 291, 643, 7198, 399, 13, 865, 291, 393, 764, 28256], "temperature": 0.0, "avg_logprob": -0.4414707681407099, "compression_ratio": 1.5056179775280898, "no_speech_prob": 0.0012181750498712063}, {"id": 176, "seek": 136812, "start": 1376.6799999999998, "end": 1385.56, "text": " address sanitizer for it. But like ASAN also needs like the ASAN best point like the IRF.", "tokens": [2985, 47080, 337, 309, 13, 583, 411, 7469, 1770, 611, 2203, 411, 264, 7469, 1770, 1151, 935, 411, 264, 16486, 37, 13], "temperature": 0.0, "avg_logprob": -0.4414707681407099, "compression_ratio": 1.5056179775280898, "no_speech_prob": 0.0012181750498712063}, {"id": 177, "seek": 136812, "start": 1385.56, "end": 1390.4799999999998, "text": " I think it's just a level implementation of the stuff. There's other sanitizers in kernel", "tokens": [286, 519, 309, 311, 445, 257, 1496, 11420, 295, 264, 1507, 13, 821, 311, 661, 24533, 22525, 294, 28256], "temperature": 0.0, "avg_logprob": -0.4414707681407099, "compression_ratio": 1.5056179775280898, "no_speech_prob": 0.0012181750498712063}, {"id": 178, "seek": 139048, "start": 1390.48, "end": 1402.92, "text": " which are implemented this way. I think that it's GACFI. Yeah. Yes. Do you know where the", "tokens": [597, 366, 12270, 341, 636, 13, 286, 519, 300, 309, 311, 460, 4378, 38568, 13, 865, 13, 1079, 13, 1144, 291, 458, 689, 264], "temperature": 0.0, "avg_logprob": -0.3932331813855118, "compression_ratio": 1.627906976744186, "no_speech_prob": 0.00087624357547611}, {"id": 179, "seek": 139048, "start": 1402.92, "end": 1408.64, "text": " code lives currently that does the hooking to malloc and free like the C library? Like", "tokens": [3089, 2909, 4362, 300, 775, 264, 1106, 5953, 281, 16026, 905, 293, 1737, 411, 264, 383, 6405, 30, 1743], "temperature": 0.0, "avg_logprob": -0.3932331813855118, "compression_ratio": 1.627906976744186, "no_speech_prob": 0.00087624357547611}, {"id": 180, "seek": 139048, "start": 1408.64, "end": 1413.96, "text": " how does the interaction with the C library work do you know because like I could have", "tokens": [577, 775, 264, 9285, 365, 264, 383, 6405, 589, 360, 291, 458, 570, 411, 286, 727, 362], "temperature": 0.0, "avg_logprob": -0.3932331813855118, "compression_ratio": 1.627906976744186, "no_speech_prob": 0.00087624357547611}, {"id": 181, "seek": 139048, "start": 1413.96, "end": 1419.3600000000001, "text": " that for example have a muscle instead of the C library and I guess the code has to be", "tokens": [300, 337, 1365, 362, 257, 8679, 2602, 295, 264, 383, 6405, 293, 286, 2041, 264, 3089, 575, 281, 312], "temperature": 0.0, "avg_logprob": -0.3932331813855118, "compression_ratio": 1.627906976744186, "no_speech_prob": 0.00087624357547611}, {"id": 182, "seek": 141936, "start": 1419.36, "end": 1424.24, "text": " adapted somehow or there must be some book infrastructure. So do you know how that works", "tokens": [20871, 6063, 420, 456, 1633, 312, 512, 1446, 6896, 13, 407, 360, 291, 458, 577, 300, 1985], "temperature": 0.0, "avg_logprob": -0.3011683282398042, "compression_ratio": 1.3410852713178294, "no_speech_prob": 0.00012338091619312763}, {"id": 183, "seek": 141936, "start": 1424.24, "end": 1432.3999999999999, "text": " and where the code lives that books malloc and free for example. It's in compiler RT", "tokens": [293, 689, 264, 3089, 2909, 300, 3642, 16026, 905, 293, 1737, 337, 1365, 13, 467, 311, 294, 31958, 21797], "temperature": 0.0, "avg_logprob": -0.3011683282398042, "compression_ratio": 1.3410852713178294, "no_speech_prob": 0.00012338091619312763}, {"id": 184, "seek": 143240, "start": 1432.4, "end": 1451.4, "text": " instance if I'm right. So if you change the version of library you have. Yeah the F on", "tokens": [5197, 498, 286, 478, 558, 13, 407, 498, 291, 1319, 264, 3037, 295, 6405, 291, 362, 13, 865, 264, 479, 322], "temperature": 0.0, "avg_logprob": -0.5743650817871093, "compression_ratio": 1.0617283950617284, "no_speech_prob": 0.000903175794519484}, {"id": 185, "seek": 145140, "start": 1451.4, "end": 1466.16, "text": " runtime has to be for malloc and free. Okay. So outside of the C library. Yeah. For ASAN", "tokens": [34474, 575, 281, 312, 337, 16026, 905, 293, 1737, 13, 1033, 13, 407, 2380, 295, 264, 383, 6405, 13, 865, 13, 1171, 7469, 1770], "temperature": 0.0, "avg_logprob": -0.5340147205427581, "compression_ratio": 1.318840579710145, "no_speech_prob": 0.0028605156112462282}, {"id": 186, "seek": 145140, "start": 1466.16, "end": 1473.4, "text": " yes but for example for ASAN for leak sanitizer which is enabled by ASAN you need to be aware", "tokens": [2086, 457, 337, 1365, 337, 7469, 1770, 337, 17143, 47080, 597, 307, 15172, 538, 7469, 1770, 291, 643, 281, 312, 3650], "temperature": 0.0, "avg_logprob": -0.5340147205427581, "compression_ratio": 1.318840579710145, "no_speech_prob": 0.0028605156112462282}, {"id": 187, "seek": 147340, "start": 1473.4, "end": 1486.2800000000002, "text": " of things like PLS layout and so on. But the runtime in LVM does implement both. Yes. Are", "tokens": [295, 721, 411, 6999, 50, 13333, 293, 370, 322, 13, 583, 264, 34474, 294, 441, 53, 44, 775, 4445, 1293, 13, 1079, 13, 2014], "temperature": 0.0, "avg_logprob": -0.4923392868041992, "compression_ratio": 1.27007299270073, "no_speech_prob": 0.0004835760628338903}, {"id": 188, "seek": 147340, "start": 1486.2800000000002, "end": 1494.44, "text": " the sanitizers shared between GCC and LLVM or does each have its own implementation?", "tokens": [264, 24533, 22525, 5507, 1296, 460, 11717, 293, 441, 43, 53, 44, 420, 775, 1184, 362, 1080, 1065, 11420, 30], "temperature": 0.0, "avg_logprob": -0.4923392868041992, "compression_ratio": 1.27007299270073, "no_speech_prob": 0.0004835760628338903}, {"id": 189, "seek": 149444, "start": 1494.44, "end": 1506.04, "text": " They are shared. Yes. I noticed that one shadow byte corresponds to eight actual bytes. However", "tokens": [814, 366, 5507, 13, 1079, 13, 286, 5694, 300, 472, 8576, 40846, 23249, 281, 3180, 3539, 36088, 13, 2908], "temperature": 0.0, "avg_logprob": -0.29234561920166013, "compression_ratio": 1.6759259259259258, "no_speech_prob": 0.00020648750069085509}, {"id": 190, "seek": 149444, "start": 1506.04, "end": 1510.3600000000001, "text": " considering that there are special values for it. Does it mean that there could be situations", "tokens": [8079, 300, 456, 366, 2121, 4190, 337, 309, 13, 4402, 309, 914, 300, 456, 727, 312, 6851], "temperature": 0.0, "avg_logprob": -0.29234561920166013, "compression_ratio": 1.6759259259259258, "no_speech_prob": 0.00020648750069085509}, {"id": 191, "seek": 149444, "start": 1510.3600000000001, "end": 1515.3200000000002, "text": " where there could be some bytes which are not protected necessarily? Yeah there can be", "tokens": [689, 456, 727, 312, 512, 36088, 597, 366, 406, 10594, 4725, 30, 865, 456, 393, 312], "temperature": 0.0, "avg_logprob": -0.29234561920166013, "compression_ratio": 1.6759259259259258, "no_speech_prob": 0.00020648750069085509}, {"id": 192, "seek": 149444, "start": 1515.3200000000002, "end": 1521.3200000000002, "text": " some cases where you can call it as a false positive kind of thing or sometimes it is", "tokens": [512, 3331, 689, 291, 393, 818, 309, 382, 257, 7908, 3353, 733, 295, 551, 420, 2171, 309, 307], "temperature": 0.0, "avg_logprob": -0.29234561920166013, "compression_ratio": 1.6759259259259258, "no_speech_prob": 0.00020648750069085509}, {"id": 193, "seek": 152132, "start": 1521.32, "end": 1527.96, "text": " checking very much in the end. So it was a very small example but it can happen that", "tokens": [8568, 588, 709, 294, 264, 917, 13, 407, 309, 390, 257, 588, 1359, 1365, 457, 309, 393, 1051, 300], "temperature": 0.0, "avg_logprob": -0.14120091332329643, "compression_ratio": 1.4, "no_speech_prob": 5.141863948665559e-05}, {"id": 194, "seek": 152132, "start": 1527.96, "end": 1534.3999999999999, "text": " you get these square brackets at the very end and it's an overrun case. So that can", "tokens": [291, 483, 613, 3732, 26179, 412, 264, 588, 917, 293, 309, 311, 364, 670, 12997, 1389, 13, 407, 300, 393], "temperature": 0.0, "avg_logprob": -0.14120091332329643, "compression_ratio": 1.4, "no_speech_prob": 5.141863948665559e-05}, {"id": 195, "seek": 153440, "start": 1534.4, "end": 1557.24, "text": " happen. Yes. Could you get a false negative in some sense in the sense that if you have", "tokens": [1051, 13, 1079, 13, 7497, 291, 483, 257, 7908, 3671, 294, 512, 2020, 294, 264, 2020, 300, 498, 291, 362], "temperature": 0.0, "avg_logprob": -0.4354652961095174, "compression_ratio": 1.144736842105263, "no_speech_prob": 0.0003225647087674588}, {"id": 196, "seek": 155724, "start": 1557.24, "end": 1565.36, "text": " two almost adjacent blocks of advocated application memory and you access a pointer from one to", "tokens": [732, 1920, 24441, 8474, 295, 7915, 770, 3861, 4675, 293, 291, 2105, 257, 23918, 490, 472, 281], "temperature": 0.0, "avg_logprob": -0.39988511403401694, "compression_ratio": 1.5647058823529412, "no_speech_prob": 0.00010534190369071439}, {"id": 197, "seek": 155724, "start": 1565.36, "end": 1570.68, "text": " the other could you get a false negative in this sense? So because that would not be", "tokens": [264, 661, 727, 291, 483, 257, 7908, 3671, 294, 341, 2020, 30, 407, 570, 300, 576, 406, 312], "temperature": 0.0, "avg_logprob": -0.39988511403401694, "compression_ratio": 1.5647058823529412, "no_speech_prob": 0.00010534190369071439}, {"id": 198, "seek": 155724, "start": 1570.68, "end": 1576.84, "text": " a point and it would still be part of the application but for example what an address", "tokens": [257, 935, 293, 309, 576, 920, 312, 644, 295, 264, 3861, 457, 337, 1365, 437, 364, 2985], "temperature": 0.0, "avg_logprob": -0.39988511403401694, "compression_ratio": 1.5647058823529412, "no_speech_prob": 0.00010534190369071439}, {"id": 199, "seek": 157684, "start": 1576.84, "end": 1600.1599999999999, "text": " could you get? Yeah it can be. It can be a false positive case maybe. Yes. Okay. I think", "tokens": [727, 291, 483, 30, 865, 309, 393, 312, 13, 467, 393, 312, 257, 7908, 3353, 1389, 1310, 13, 1079, 13, 1033, 13, 286, 519], "temperature": 0.0, "avg_logprob": -0.6963915143694196, "compression_ratio": 1.0602409638554218, "no_speech_prob": 0.0002727476239670068}, {"id": 200, "seek": 160016, "start": 1600.16, "end": 1607.16, "text": " it was already partially answered before but I am not sure. So I am just going to ask it.", "tokens": [309, 390, 1217, 18886, 10103, 949, 457, 286, 669, 406, 988, 13, 407, 286, 669, 445, 516, 281, 1029, 309, 13], "temperature": 0.0, "avg_logprob": -0.36293387624014795, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00019106818945147097}, {"id": 201, "seek": 160016, "start": 1607.16, "end": 1613.16, "text": " So for example I am also working on an embedded scenario and we don't use, I think we don't", "tokens": [407, 337, 1365, 286, 669, 611, 1364, 322, 364, 16741, 9005, 293, 321, 500, 380, 764, 11, 286, 519, 321, 500, 380], "temperature": 0.0, "avg_logprob": -0.36293387624014795, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00019106818945147097}, {"id": 202, "seek": 160016, "start": 1613.16, "end": 1615.16, "text": " use glpc or muscle like we have our own set of routines for malloc and free. Yes. Would", "tokens": [764, 1563, 79, 66, 420, 8679, 411, 321, 362, 527, 1065, 992, 295, 33827, 337, 16026, 905, 293, 1737, 13, 1079, 13, 6068], "temperature": 0.0, "avg_logprob": -0.36293387624014795, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00019106818945147097}, {"id": 203, "seek": 160016, "start": 1615.16, "end": 1620.16, "text": " it also work in that case or is that then something that you would need to, are there", "tokens": [309, 611, 589, 294, 300, 1389, 420, 307, 300, 550, 746, 300, 291, 576, 643, 281, 11, 366, 456], "temperature": 0.0, "avg_logprob": -0.36293387624014795, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00019106818945147097}, {"id": 204, "seek": 160016, "start": 1620.16, "end": 1626.72, "text": " more requirements before you can use these sanitizers on those devices? For my experience", "tokens": [544, 7728, 949, 291, 393, 764, 613, 24533, 22525, 322, 729, 5759, 30, 1171, 452, 1752], "temperature": 0.0, "avg_logprob": -0.36293387624014795, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00019106818945147097}, {"id": 205, "seek": 162672, "start": 1626.72, "end": 1633.52, "text": " I have been just using this meta-clang layer included and for testing with like or for", "tokens": [286, 362, 668, 445, 1228, 341, 19616, 12, 3474, 656, 4583, 5556, 293, 337, 4997, 365, 411, 420, 337], "temperature": 0.0, "avg_logprob": -0.20893374549018012, "compression_ratio": 1.3384615384615384, "no_speech_prob": 4.1981053072959185e-05}, {"id": 206, "seek": 162672, "start": 1633.52, "end": 1640.72, "text": " just doing on the SDKs and emulator it was perfectly fine. So not on the actual devices", "tokens": [445, 884, 322, 264, 37135, 82, 293, 846, 16381, 309, 390, 6239, 2489, 13, 407, 406, 322, 264, 3539, 5759], "temperature": 0.0, "avg_logprob": -0.20893374549018012, "compression_ratio": 1.3384615384615384, "no_speech_prob": 4.1981053072959185e-05}, {"id": 207, "seek": 164072, "start": 1640.72, "end": 1664.72, "text": " because it is just meant for testing.", "tokens": [570, 309, 307, 445, 4140, 337, 4997, 13], "temperature": 0.0, "avg_logprob": -0.4102809429168701, "compression_ratio": 0.8222222222222222, "no_speech_prob": 0.00011945379083044827}, {"id": 208, "seek": 166472, "start": 1664.72, "end": 1691.72, "text": " All right. Thank you Manta. Thank you.", "tokens": [50364, 1057, 558, 13, 1044, 291, 376, 5983, 13, 1044, 291, 13, 51714], "temperature": 0.0, "avg_logprob": -0.5633037430899483, "compression_ratio": 1.027027027027027, "no_speech_prob": 0.0019149433355778456}, {"id": 209, "seek": 169472, "start": 1694.72, "end": 1701.72, "text": " Thank you.", "tokens": [50364, 1044, 291, 13, 50714], "temperature": 0.0, "avg_logprob": -0.7901856899261475, "compression_ratio": 0.5555555555555556, "no_speech_prob": 0.9908013939857483}], "language": "en"}