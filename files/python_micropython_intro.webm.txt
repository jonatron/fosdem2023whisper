[00:00.000 --> 00:12.000]  Please give a big welcome to Walter, who is coming from the Netherlands for an introduction
[00:12.000 --> 00:15.000]  to MicroPython.
[00:15.000 --> 00:27.880]  Well, hello everyone, take your seats, few more people.
[00:27.880 --> 00:33.880]  I cringe at every extra person who walks in, because it's an extra hundred watts of heating.
[00:33.880 --> 00:43.880]  It's already quite hot here.
[00:43.880 --> 00:45.880]  OK, it can start, I think.
[00:45.880 --> 00:50.880]  OK, that's me, and that's a Python subject for today.
[00:50.880 --> 00:52.880]  I welcome questions.
[00:52.880 --> 00:58.880]  If anyone wants to ask something while I'm talking, please raise your hand and we'll get a microphone.
[00:58.880 --> 01:01.880]  And if that takes too much time, I just skip subjects.
[01:01.880 --> 01:04.880]  Interaction is always nice.
[01:04.880 --> 01:08.880]  OK, I'm Baud van Olje.
[01:08.880 --> 01:13.880]  I did informatics, the technical version, but it didn't just exist.
[01:13.880 --> 01:16.880]  I worked in industry for quite a long time.
[01:16.880 --> 01:21.880]  I still have a web shop and sell things like these stuff.
[01:21.880 --> 01:28.880]  I worked at Hoogschoo Utrecht and for a year at Avants to teach technical informatics, of course,
[01:28.880 --> 01:32.880]  and now I'm employed by a company who does robotics in industry.
[01:32.880 --> 01:36.880]  But this is about MicroPython.
[01:36.880 --> 01:41.880]  First context, I guess you all know what a microprocessor is.
[01:41.880 --> 01:48.880]  Way back when they first made a single processor on one chip.
[01:48.880 --> 01:52.880]  It was a very feeble, small thing, and since then we have progressed a lot.
[01:52.880 --> 01:58.880]  Now we can pack a lot of power in one chip, but that's still a processor.
[01:58.880 --> 02:00.880]  It cannot do anything on itself.
[02:00.880 --> 02:06.880]  It needs external stuff like memory, I.O., hard disk to store things permanently,
[02:06.880 --> 02:10.880]  probably a lot of cooling like we all do here.
[02:10.880 --> 02:14.880]  That's one way to use what we can put in a chip.
[02:14.880 --> 02:20.880]  The other route is don't make necessarily the processor much powerful,
[02:20.880 --> 02:22.880]  but put more things on a single chip.
[02:22.880 --> 02:25.880]  More RAM, Flash ROM to store code,
[02:25.880 --> 02:28.880]  peripherals to do things with the outside world,
[02:28.880 --> 02:30.880]  and then you have a microcontroller.
[02:30.880 --> 02:36.880]  Everything in one chip and, well, that's a nice thing not to run your windows on,
[02:36.880 --> 02:39.880]  but to think of things in the real world,
[02:39.880 --> 02:44.880]  with motors, LEDs, relays, and all kind of stuff.
[02:44.880 --> 02:47.880]  That is if you can still buy them.
[02:47.880 --> 02:50.880]  Maybe that will be solved in the near future
[02:50.880 --> 02:56.880]  when ASML produces more chip machines.
[02:56.880 --> 03:00.880]  Compilers and interpreters.
[03:00.880 --> 03:05.880]  You know, an interpreter looks at source code,
[03:05.880 --> 03:10.880]  writes a line by line, sees what's there, does it,
[03:10.880 --> 03:13.880]  and then it looks at the next line and does it again.
[03:13.880 --> 03:18.880]  That's not very quick, but there is no extra steps involved,
[03:18.880 --> 03:22.880]  so when you change your source code, it immediately has effect.
[03:22.880 --> 03:28.880]  And when you interact, you interact in its way with that interpreter.
[03:28.880 --> 03:33.880]  Compiler takes source code, translated to native machine code,
[03:33.880 --> 03:35.880]  and that is the thing that runs.
[03:35.880 --> 03:38.880]  When you interact, when you're interacting with a program,
[03:38.880 --> 03:42.880]  you interact with the running native code.
[03:42.880 --> 03:43.880]  All clear?
[03:43.880 --> 03:47.880]  Yeah, I used to be a lecturer, so I'll ask everyone clear.
[03:47.880 --> 03:50.880]  And then, of course, no one raised a finger.
[03:50.880 --> 03:54.880]  It's not clear to me.
[03:54.880 --> 03:56.880]  Things cannot be that simple,
[03:56.880 --> 03:58.880]  so there's combos of compile interpreter.
[03:58.880 --> 04:01.880]  That's actually how Python generally works.
[04:01.880 --> 04:03.880]  You have a source code.
[04:03.880 --> 04:06.880]  You have a compiler that translates that source code
[04:06.880 --> 04:08.880]  to an intermediate representation,
[04:08.880 --> 04:13.880]  and then you have an interpreter that interprets that intermediate code.
[04:13.880 --> 04:16.880]  Now, you have either the best of both worlds or the worst.
[04:16.880 --> 04:17.880]  I don't know.
[04:17.880 --> 04:21.880]  This takes some time, but less than real compilation,
[04:21.880 --> 04:26.880]  and this is slower than real running native code,
[04:26.880 --> 04:30.880]  but it's still somewhat faster than directly interpreting the source code.
[04:30.880 --> 04:31.880]  Still clear?
[04:31.880 --> 04:33.880]  Yeah.
[04:33.880 --> 04:35.880]  Okay.
[04:35.880 --> 04:40.880]  Python typically runs interpreted, which has benefits,
[04:40.880 --> 04:43.880]  and this is fun with this, but we'll come by that.
[04:43.880 --> 04:46.880]  What's Python's place in the larger world of things?
[04:46.880 --> 04:50.880]  And there are program language, I think,
[04:50.880 --> 04:55.880]  you can recognize the symbols that make it easy to change your code,
[04:55.880 --> 04:59.880]  to run it quickly, to tinker with it, to try things.
[04:59.880 --> 05:01.880]  That's the one end of the spectrum.
[05:01.880 --> 05:03.880]  There's the other side of the spectrum.
[05:03.880 --> 05:07.880]  When you write high-performance codes like operating systems,
[05:07.880 --> 05:10.880]  graphical tools, games, and things like that,
[05:10.880 --> 05:16.880]  those languages are much less forgiving in what you do.
[05:16.880 --> 05:19.880]  It takes a lot of time to compile it correctly,
[05:19.880 --> 05:22.880]  but then they filter out a lot more errors
[05:22.880 --> 05:24.880]  than those type of languages do,
[05:24.880 --> 05:27.880]  especially Vitorius for that.
[05:27.880 --> 05:31.880]  And somewhere in between, under compromises,
[05:31.880 --> 05:34.880]  that's generally used for not too high-performance,
[05:34.880 --> 05:36.880]  but really reasonably performance,
[05:36.880 --> 05:42.880]  user interaction thing, websites, simple graphical applications.
[05:42.880 --> 05:44.880]  That's the whole scheme of things.
[05:44.880 --> 05:47.880]  And traditionally, microcontrollers, these kind of things,
[05:47.880 --> 05:49.880]  were programmed with these kind of languages
[05:49.880 --> 05:52.880]  because they simply didn't have the resources,
[05:52.880 --> 05:56.880]  the speed of the processor, size of the RAM, size of the flash,
[05:56.880 --> 05:58.880]  they just didn't have the resources,
[05:58.880 --> 06:01.880]  and they just didn't have the resources to run
[06:01.880 --> 06:04.880]  with these kind of languages.
[06:04.880 --> 06:07.880]  What really distinguishes the language
[06:07.880 --> 06:12.880]  is whether you are runtime-typed.
[06:12.880 --> 06:15.880]  In Python, when you have a variable,
[06:15.880 --> 06:17.880]  the runtime system has no idea
[06:17.880 --> 06:20.880]  whether it's a string or an integer or a list or whatever.
[06:20.880 --> 06:22.880]  It will find out runtime.
[06:22.880 --> 06:25.880]  In strongly-typed languages, that's fixed.
[06:25.880 --> 06:27.880]  It's flexible for you.
[06:27.880 --> 06:30.880]  Easier on that processor.
[06:30.880 --> 06:32.880]  It compiles to, well, the left side compiles
[06:32.880 --> 06:34.880]  some intermediate languages.
[06:34.880 --> 06:36.880]  Some of them are even really source interpreted.
[06:36.880 --> 06:41.880]  Right-side languages are compiled to mostly machine language.
[06:41.880 --> 06:44.880]  And memory management, an important one.
[06:44.880 --> 06:48.880]  In Python, you rarely wonder about where your memory is,
[06:48.880 --> 06:53.880]  what memory is used, the runtime system solves it.
[06:53.880 --> 06:57.880]  In, well, C and C++, you have to worry a lot
[06:57.880 --> 07:01.880]  about which memory you claimed, what you released,
[07:01.880 --> 07:03.880]  don't release it too early,
[07:03.880 --> 07:06.880]  or you'll get a nice crash or something else.
[07:06.880 --> 07:11.880]  And in between, well, you take some care of it,
[07:11.880 --> 07:14.880]  maybe give some hints to the runtime system,
[07:14.880 --> 07:16.880]  but in general, you don't bother too much with it.
[07:16.880 --> 07:22.880]  So left side, ease of programming, right side, quick running.
[07:22.880 --> 07:27.880]  That's how traditional C Python works.
[07:27.880 --> 07:29.880]  You have your source.
[07:29.880 --> 07:32.880]  You translate it to an intermediate language representation.
[07:32.880 --> 07:34.880]  That is runs.
[07:34.880 --> 07:38.880]  And that's all done by your Python system you install.
[07:38.880 --> 07:43.880]  That's both compiler and interpreter.
[07:43.880 --> 07:46.880]  Wow, this is a lot more complex.
[07:46.880 --> 07:48.880]  This is my Python.
[07:48.880 --> 07:51.880]  You still have a Python system,
[07:51.880 --> 07:55.880]  but now it no longer runs on your quick-fast desktop.
[07:55.880 --> 07:57.880]  It runs on a small mic controller.
[07:57.880 --> 08:01.880]  Both the compiler and interpreter run on the mic controller.
[08:01.880 --> 08:03.880]  And when your Python application runs,
[08:03.880 --> 08:06.880]  you interact with that mic controller.
[08:06.880 --> 08:10.880]  You still have your laptop because you do the editing.
[08:10.880 --> 08:13.880]  I don't have an editor running on this thing,
[08:13.880 --> 08:15.880]  so that's still the desktop.
[08:15.880 --> 08:19.880]  I use Tony, it's a simple Python application,
[08:19.880 --> 08:22.880]  but it's quite useful to interact with Michael Python.
[08:22.880 --> 08:25.880]  So I interact with Tony.
[08:25.880 --> 08:27.880]  I edit my code there.
[08:27.880 --> 08:32.880]  It's sent or stored or kept on the mic controller itself.
[08:32.880 --> 08:35.880]  There it is compiled and runs.
[08:35.880 --> 08:40.880]  And then it runs here and hopefully does nice things with the outside world.
[08:40.880 --> 08:42.880]  Still clear?
[08:42.880 --> 08:45.880]  Nothing new, nice.
[08:45.880 --> 08:50.880]  On the mic controller,
[08:50.880 --> 08:54.880]  let's say standard, read, evaluate,
[08:54.880 --> 08:56.880]  what is it, print loop,
[08:56.880 --> 09:00.880]  so you can do things just like you did on the prompt
[09:00.880 --> 09:04.880]  on the Python on your normal computer.
[09:04.880 --> 09:07.880]  And it evaluates what you do, prints it,
[09:07.880 --> 09:10.880]  and it can do more interesting things like linking leads
[09:10.880 --> 09:14.880]  or reading files that are stored on the chip.
[09:14.880 --> 09:20.880]  I think we should just show,
[09:20.880 --> 09:24.880]  because it's too...
[09:24.880 --> 09:28.880]  Okay, here I have a Raspberry Pico,
[09:28.880 --> 09:30.880]  RP2040 chip,
[09:30.880 --> 09:33.880]  when I plug it in
[09:33.880 --> 09:36.880]  and I press the boot button,
[09:36.880 --> 09:38.880]  it goes into load mode.
[09:38.880 --> 09:42.880]  You can hear a very faint bleep for my laptop.
[09:42.880 --> 09:47.880]  And when I now look at,
[09:47.880 --> 09:52.880]  well, my explorer,
[09:52.880 --> 09:54.880]  I see an extra drive here
[09:54.880 --> 09:57.880]  that's the drive he created,
[09:57.880 --> 10:02.880]  and I can copy...
[10:02.880 --> 10:06.880]  Here's the FOSDM image.
[10:06.880 --> 10:13.880]  I copy my Python image to that drive.
[10:13.880 --> 10:15.880]  It copies it.
[10:15.880 --> 10:17.880]  When it's done, it reboots.
[10:17.880 --> 10:20.880]  Now the extra drive is gone,
[10:20.880 --> 10:23.880]  and I can see...
[10:23.880 --> 10:26.880]  Oh, I have to put it first.
[10:26.880 --> 10:36.880]  Right.
[10:36.880 --> 10:38.880]  There's an extra communication port here.
[10:38.880 --> 10:40.880]  That's what the chip made.
[10:40.880 --> 10:44.880]  I always rename my communication ports to 42,
[10:44.880 --> 10:56.880]  because...
[10:56.880 --> 11:00.880]  Okay.
[11:00.880 --> 11:04.880]  Just replete it to be sure.
[11:04.880 --> 11:08.880]  Now let's start.
[11:08.880 --> 11:16.880]  Tony.
[11:16.880 --> 11:17.880]  Okay.
[11:17.880 --> 11:19.880]  Now here I have a prompt
[11:19.880 --> 11:23.880]  that is running on that small chipie.
[11:23.880 --> 11:25.880]  And just like a good Python,
[11:25.880 --> 11:27.880]  it can print,
[11:27.880 --> 11:31.880]  hello.
[11:31.880 --> 11:32.880]  Doesn't seem like much,
[11:32.880 --> 11:34.880]  but that's happening here.
[11:34.880 --> 11:36.880]  It's not my laptop that's doing it.
[11:36.880 --> 11:38.880]  And if you're a bit lazy
[11:38.880 --> 11:40.880]  and you don't want to fiddle with files,
[11:40.880 --> 11:46.880]  you can also boot again.
[11:46.880 --> 11:47.880]  Here in Tony,
[11:47.880 --> 11:52.880]  you can select under options interpreter.
[11:52.880 --> 11:54.880]  I want to install Michael Python,
[11:54.880 --> 11:56.880]  and for the Raspberry Pi Pico,
[11:56.880 --> 11:59.880]  it just knows where to find it.
[11:59.880 --> 12:02.880]  Internet is working.
[12:02.880 --> 12:06.880]  It just grabbed the latest version, installed it.
[12:06.880 --> 12:08.880]  Close.
[12:08.880 --> 12:12.880]  And I have it running.
[12:12.880 --> 12:14.880]  Yep, it runs.
[12:14.880 --> 12:15.880]  Nice.
[12:15.880 --> 12:16.880]  Okay.
[12:16.880 --> 12:19.880]  Now I must do something.
[12:19.880 --> 12:34.880]  Let's take some code.
[12:34.880 --> 12:39.880]  I can put code simply in the editor and say run this.
[12:39.880 --> 12:40.880]  No.
[12:40.880 --> 12:43.880]  Are you able to make it larger, please?
[12:43.880 --> 12:46.880]  I think that's the wrong direction.
[12:46.880 --> 12:48.880]  Largely enough for you.
[12:48.880 --> 12:51.880]  And, well, it didn't show that the LED was not on,
[12:51.880 --> 13:00.880]  but now it's on, so it worked.
[13:00.880 --> 13:04.880]  No, well, maybe I can convince you if I put a zero here
[13:04.880 --> 13:06.880]  and then run it again.
[13:06.880 --> 13:08.880]  Ah, let's off.
[13:08.880 --> 13:13.880]  You can all see that?
[13:13.880 --> 13:23.880]  Well, just on is not that interesting.
[13:23.880 --> 13:24.880]  Let's blink.
[13:24.880 --> 13:25.880]  Blink is simple.
[13:25.880 --> 13:27.880]  Define the pin.
[13:27.880 --> 13:31.880]  I import the libraries that are standard for this chip,
[13:31.880 --> 13:34.880]  and it allows me to access a pin.
[13:34.880 --> 13:38.880]  Pin 25 happens to be the onboard LED.
[13:38.880 --> 13:40.880]  I say it's an output pin.
[13:40.880 --> 13:43.880]  Then I make it high, sleep a little time,
[13:43.880 --> 13:45.880]  make it low, sleep a little time,
[13:45.880 --> 13:47.880]  and repeat it forever.
[13:47.880 --> 13:48.880]  Okay.
[13:48.880 --> 13:50.880]  That should blink.
[13:50.880 --> 13:52.880]  Ah, it blinks.
[13:52.880 --> 13:54.880]  Oh, nice.
[13:54.880 --> 13:56.880]  Don't applaud for any day more,
[13:56.880 --> 13:59.880]  otherwise your hands will get sore.
[13:59.880 --> 14:04.880]  Okay, but now when I stop it, it stops,
[14:04.880 --> 14:07.880]  and this thing doesn't do anything.
[14:07.880 --> 14:14.880]  It should stop, it doesn't.
[14:14.880 --> 14:18.880]  Well, there's always the reboot for that.
[14:18.880 --> 14:23.880]  It's supposed to be interruptible by that stop button,
[14:23.880 --> 14:27.880]  but since a week it doesn't do anything.
[14:27.880 --> 14:28.880]  I don't know why.
[14:28.880 --> 14:32.880]  If I want to do the chip do something on itself,
[14:32.880 --> 14:36.880]  I have to store this file on the chip.
[14:36.880 --> 14:43.880]  So I make the blink.py on the chip.
[14:43.880 --> 14:48.880]  Now it's here, and I can run it from there.
[14:48.880 --> 14:50.880]  Yeah, it still blinks.
[14:50.880 --> 14:52.880]  That's not very interesting.
[14:52.880 --> 15:00.880]  Now, if I stop it and put it on a power bank,
[15:00.880 --> 15:02.880]  it doesn't do anything.
[15:02.880 --> 15:03.880]  That's a pity.
[15:03.880 --> 15:06.880]  When it starts, it looks for a main.py
[15:06.880 --> 15:08.880]  and exudes that file.
[15:08.880 --> 15:14.880]  So if I wanted to start, I have to make a file.
[15:14.880 --> 15:25.880]  Import, blink, save that as main.py.
[15:25.880 --> 15:26.880]  Ah, it's a mess.
[15:26.880 --> 15:29.880]  Well, this irritating, there is a small file system here.
[15:29.880 --> 15:32.880]  I can make a new file directly delete,
[15:32.880 --> 15:34.880]  but I cannot rename a file.
[15:34.880 --> 15:40.880]  So let's do the poor man's way of doing that.
[15:40.880 --> 15:51.880]  Save as main, not neon.
[15:51.880 --> 15:53.880]  Now I can delete that one.
[15:53.880 --> 15:55.880]  Yeah, nice.
[15:55.880 --> 15:57.880]  Main, yeah?
[15:57.880 --> 15:59.880]  I deleted the correct one.
[15:59.880 --> 16:00.880]  And that's the important thing.
[16:00.880 --> 16:04.880]  So now, if I put it on a power bank,
[16:04.880 --> 16:06.880]  it starts blinking on its own.
[16:06.880 --> 16:13.880]  But now, at least that's what happened yesterday.
[16:13.880 --> 16:17.880]  One is thought to hold it again now.
[16:17.880 --> 16:19.880]  It doesn't want to.
[16:19.880 --> 16:21.880]  I cannot get into it anymore.
[16:21.880 --> 16:23.880]  It's bricked.
[16:23.880 --> 16:28.880]  But okay, I can still reload.
[16:28.880 --> 16:32.880]  But if I reload the micropyton interpreter again,
[16:32.880 --> 16:35.880]  it keeps the file system, so it keeps the main.py,
[16:35.880 --> 16:37.880]  so it doesn't work.
[16:37.880 --> 16:48.880]  So some clever guy made a flash nuke.
[16:48.880 --> 16:53.880]  I'm going to put that there.
[16:53.880 --> 16:55.880]  It reboots with that code.
[16:55.880 --> 16:58.880]  Now it's nothing.
[16:58.880 --> 17:01.880]  And if I now reboot it,
[17:01.880 --> 17:07.880]  I can put the normal code on it again.
[17:07.880 --> 17:10.880]  Where it is.
[17:10.880 --> 17:15.880]  Force the pickle images.
[17:15.880 --> 17:22.880]  Okay, put it one over there.
[17:22.880 --> 17:25.880]  It's just USB transfer, it's quite quick.
[17:25.880 --> 17:29.880]  And now I have a normal behaving.
[17:29.880 --> 17:30.880]  Yeah.
[17:30.880 --> 17:32.880]  Okay, that behaves again.
[17:32.880 --> 17:34.880]  Nice.
[17:34.880 --> 17:35.880]  The name's real port.
[17:35.880 --> 17:36.880]  You've seen Blinky.
[17:36.880 --> 17:39.880]  You've seen the startup.
[17:39.880 --> 17:41.880]  Demo of the startup, okay.
[17:41.880 --> 17:45.880]  I was going to demonstrate blinking a LED on the breadboard,
[17:45.880 --> 17:47.880]  but it's too feeble to bring here,
[17:47.880 --> 17:50.880]  so let's blink more LEDs.
[17:50.880 --> 17:56.880]  More is better.
[17:56.880 --> 17:59.880]  Okay.
[17:59.880 --> 18:02.880]  Now you know why I put all the things on the table,
[18:02.880 --> 18:10.880]  so I have the correct order of driving everything.
[18:10.880 --> 18:14.880]  What's on here?
[18:14.880 --> 18:24.880]  I did it.
[18:24.880 --> 18:29.880]  I want that one.
[18:29.880 --> 18:33.880]  I can blink a single LED.
[18:33.880 --> 18:35.880]  Oh, it should.
[18:35.880 --> 18:38.880]  Now I use a library I wrote,
[18:38.880 --> 18:40.880]  and it's loading all those library files.
[18:40.880 --> 18:41.880]  It takes some time.
[18:41.880 --> 18:44.880]  After that, yeah, it really blinks.
[18:44.880 --> 18:47.880]  I'll come back to that later.
[18:47.880 --> 18:50.880]  And this one, if I'm a bit insistent,
[18:50.880 --> 18:54.880]  it will probably stop.
[18:54.880 --> 18:56.880]  Yeah, there it is again.
[18:56.880 --> 19:00.880]  We can also have more LEDs.
[19:00.880 --> 19:05.880]  I've made a system that, whatever target ship I use,
[19:05.880 --> 19:07.880]  it has eight pins that are connected here,
[19:07.880 --> 19:10.880]  so we can swap it for another board.
[19:10.880 --> 19:12.880]  There's a whole different processor,
[19:12.880 --> 19:14.880]  and it still has the same eight pins.
[19:14.880 --> 19:16.880]  That's the edge library,
[19:16.880 --> 19:20.880]  and edge.port is those eight pins
[19:20.880 --> 19:22.880]  gathered together in one port,
[19:22.880 --> 19:25.880]  and then I give it to the kit demo,
[19:25.880 --> 19:32.880]  and then it should first load everything.
[19:32.880 --> 19:34.880]  And then it's kits.
[19:34.880 --> 19:36.880]  Okay, kits on eight LEDs.
[19:36.880 --> 19:45.880]  If that's not enough,
[19:45.880 --> 19:48.880]  you take an I2C extender chip,
[19:48.880 --> 19:53.880]  and the chip...
[19:53.880 --> 19:54.880]  Does it work?
[19:54.880 --> 19:56.880]  Yes, it works.
[19:56.880 --> 20:04.880]  And it has more output pins.
[20:04.880 --> 20:05.880]  Load, load, load, load.
[20:05.880 --> 20:08.880]  And then have a kit with 16 ports,
[20:08.880 --> 20:10.880]  and if that's too slow,
[20:10.880 --> 20:18.880]  I think it's boringly slow.
[20:18.880 --> 20:28.880]  Maybe 10 milliseconds is nice.
[20:28.880 --> 20:32.880]  Load, load, load, load, load.
[20:32.880 --> 20:35.880]  Yeah, that's a bit quicker.
[20:35.880 --> 20:43.880]  Okay, back to the sheets.
[20:43.880 --> 20:45.880]  On morelets, we have seen morelets.
[20:45.880 --> 20:48.880]  Okay, you saw that it spent some time
[20:48.880 --> 20:51.880]  at the beginning by loading a few libraries.
[20:51.880 --> 20:53.880]  It showed, because I coded it that way,
[20:53.880 --> 20:55.880]  because I wanted to know how long it takes
[20:55.880 --> 20:58.880]  to load the libraries and how much RAM it uses.
[20:58.880 --> 21:01.880]  In general, you can have three ways
[21:01.880 --> 21:05.880]  of putting library code on MicroPython.
[21:05.880 --> 21:07.880]  You can have the source files,
[21:07.880 --> 21:09.880]  the simple.py files,
[21:09.880 --> 21:11.880]  and then when you load them,
[21:11.880 --> 21:13.880]  they're first compiled and then loaded.
[21:13.880 --> 21:17.880]  You can also pre-compile those files on your laptop
[21:17.880 --> 21:19.880]  and then load the compiled version,
[21:19.880 --> 21:22.880]  that's the.mpi files.
[21:22.880 --> 21:25.880]  You can also take the files
[21:25.880 --> 21:28.880]  and build them into the image you load anyway.
[21:28.880 --> 21:30.880]  You saw me copying that image onto the chip.
[21:30.880 --> 21:32.880]  You can put your files in there.
[21:32.880 --> 21:36.880]  And that has effect for how much time it takes.
[21:36.880 --> 21:40.880]  When I demoed it, it was irritatingly long.
[21:40.880 --> 21:46.880]  My files took about 12 seconds to get loaded
[21:46.880 --> 21:52.880]  from the flash compiled and ready for run.
[21:52.880 --> 21:54.880]  When I pre-compiled, it's a little bit faster.
[21:54.880 --> 21:57.880]  And when I freeze it,
[21:57.880 --> 22:02.880]  I build an image of MicroPython with those files included,
[22:02.880 --> 22:04.880]  it gets really fast.
[22:04.880 --> 22:07.880]  And then it also uses less RAM.
[22:07.880 --> 22:09.880]  RAM, memory on those chips,
[22:09.880 --> 22:11.880]  is always a very scarce resource.
[22:11.880 --> 22:15.880]  This chip has about, I think,
[22:15.880 --> 22:19.880]  130K left after loading this library.
[22:19.880 --> 22:22.880]  Looks like a lot, but you can eat it quickly,
[22:22.880 --> 22:26.880]  especially if you make screen buffers for LCDs and things like that.
[22:26.880 --> 22:33.880]  240 by 320 LCD with full color, that's 2 bytes per color.
[22:33.880 --> 22:37.880]  I think that's more than is left there.
[22:37.880 --> 22:39.880]  So you couldn't still use it.
[22:39.880 --> 22:42.880]  So it's very important to conserve that.
[22:42.880 --> 22:45.880]  When I develop things,
[22:45.880 --> 22:48.880]  I simply take a very fast target.
[22:48.880 --> 22:52.880]  A TNG is maybe 10 times faster than a PyPico,
[22:52.880 --> 22:55.880]  and it has, I think, one megabyte memory.
[22:55.880 --> 22:57.880]  So that's ample.
[22:57.880 --> 23:01.880]  But there's always the but, but it comes later.
[23:01.880 --> 23:05.880]  Okay, embedding your code into MicroPython image
[23:05.880 --> 23:07.880]  is not that complex.
[23:07.880 --> 23:11.880]  I had it running on my Linux machine in maybe an hour.
[23:11.880 --> 23:14.880]  Then I tried the same recipe on Windows and it fails.
[23:14.880 --> 23:18.880]  So when it happens, what do you do?
[23:18.880 --> 23:20.880]  You make a Docker container.
[23:20.880 --> 23:23.880]  So I made the Docker container on the Linux machine
[23:23.880 --> 23:25.880]  that does exactly the same thing, worked.
[23:25.880 --> 23:28.880]  Then I run it on Windows, works too.
[23:28.880 --> 23:30.880]  It's fine.
[23:30.880 --> 23:47.880]  And I can show if I take this chipy here.
[23:47.880 --> 23:58.880]  There it is. If I import my library, it's...
[23:58.880 --> 24:05.880]  Okay, you can do it.
[24:05.880 --> 24:08.880]  There's a license statement, a lot of text.
[24:08.880 --> 24:16.880]  Okay, here I have that license statement in the source.
[24:16.880 --> 24:23.880]  Let's add this is FOSDEM.
[24:23.880 --> 24:26.880]  FOSDEM?
[24:26.880 --> 24:29.880]  Whatever.
[24:29.880 --> 24:33.880]  Okay, start the Docker container.
[24:33.880 --> 24:37.880]  Internet works, otherwise it doesn't do it.
[24:37.880 --> 24:40.880]  It takes some 40 to 400 seconds.
[24:40.880 --> 24:44.880]  I cannot predict how long.
[24:44.880 --> 24:47.880]  Of course, it's Docker, so all the preparations,
[24:47.880 --> 24:50.880]  loading the Linux image, loading all the development tools,
[24:50.880 --> 24:52.880]  that's cached.
[24:52.880 --> 24:56.880]  But then after it, it takes my library code
[24:56.880 --> 25:00.880]  and then it compiles the MicroPython system
[25:00.880 --> 25:08.880]  with that library code added, and that takes some time.
[25:08.880 --> 25:15.880]  Okay, it's running now.
[25:15.880 --> 25:17.880]  Well, didn't take that long.
[25:17.880 --> 25:19.880]  So what do I do now?
[25:19.880 --> 25:29.880]  I reboot my chip again and now take the new code.
[25:29.880 --> 25:42.880]  This is the new code.
[25:42.880 --> 25:52.880]  Copy that to the boot.
[25:52.880 --> 25:58.880]  Okay, let's see what we have here.
[25:58.880 --> 26:01.880]  Now you no longer see the library files there
[26:01.880 --> 26:04.880]  because they're not present on the internal file system.
[26:04.880 --> 26:09.880]  They're built into the MicroPython interpreter.
[26:09.880 --> 26:28.880]  But I can still...
[26:28.880 --> 26:34.880]  Oops, it's a bit faster now than it used to be.
[26:34.880 --> 26:39.880]  Now the license text is expanded, so I really have put
[26:39.880 --> 26:41.880]  the changed version of the library in there.
[26:41.880 --> 26:46.880]  Okay, let's go on.
[26:46.880 --> 26:48.880]  I showed freezing code.
[26:48.880 --> 26:50.880]  I still want more LEDs.
[26:50.880 --> 26:52.880]  Not enough.
[26:52.880 --> 26:54.880]  Why is more LEDs?
[26:54.880 --> 27:03.880]  I think this is enough.
[27:03.880 --> 27:06.880]  Okay, that needs more power.
[27:06.880 --> 27:10.880]  I cannot power it off the USB port of my laptop,
[27:10.880 --> 27:16.880]  so I need external power for that.
[27:16.880 --> 27:30.880]  All right, now I take...
[27:30.880 --> 27:39.880]  Oh, it's a microphone.
[27:39.880 --> 27:49.880]  Okay, let's see what's on this chip.
[27:49.880 --> 27:51.880]  Let's try that code.
[27:51.880 --> 27:53.880]  Now I loaded the code from the chip.
[27:53.880 --> 27:56.880]  I prepared it on the chip there.
[27:56.880 --> 27:59.880]  I don't need to load it from my PC there.
[27:59.880 --> 28:03.880]  And it runs over there.
[28:03.880 --> 28:14.880]  And it still loads the library.
[28:14.880 --> 28:16.880]  So, enough LEDs for you.
[28:16.880 --> 28:20.880]  Okay, put it over there.
[28:20.880 --> 28:23.880]  With so many LEDs, you can do nicer things
[28:23.880 --> 28:25.880]  and just put them in the long line.
[28:25.880 --> 28:29.880]  Put them in a square and make displays with it.
[28:29.880 --> 28:43.880]  So, take that one off.
[28:43.880 --> 28:44.880]  Does it stop?
[28:44.880 --> 28:46.880]  Yeah, it stops.
[28:46.880 --> 29:02.880]  And let's run that one.
[29:02.880 --> 29:07.880]  And we are at FOSDEM, so it prints an F on it.
[29:07.880 --> 29:13.880]  The code takes a long line of 64 LEDs,
[29:13.880 --> 29:19.880]  and it folds it after 8888 LEDs to make a square.
[29:19.880 --> 29:23.880]  That's what we call a canvas, and I can write text on that.
[29:23.880 --> 29:26.880]  You can also print the old code letters after each other.
[29:26.880 --> 29:27.880]  Sorry?
[29:27.880 --> 29:29.880]  You can also show the old code letters after each other.
[29:29.880 --> 29:31.880]  Timed, you mean?
[29:31.880 --> 29:37.880]  Yeah.
[29:37.880 --> 29:42.880]  I'm not going to do them all, but...
[29:42.880 --> 29:53.880]  FOSDEM, let's say gf.
[29:53.880 --> 29:57.880]  Wait a little bit.
[29:57.880 --> 29:58.880]  What did I do wrong?
[29:58.880 --> 30:00.880]  Ah, slap.
[30:00.880 --> 30:02.880]  Won't work.
[30:02.880 --> 30:05.880]  And then...
[30:05.880 --> 30:10.880]  Because we can't get enough of it.
[30:10.880 --> 30:17.880]  While true.
[30:17.880 --> 30:23.880]  Sorry, conventions will take one.
[30:23.880 --> 30:27.880]  Yeah, I need a flush, and I need to wait after that.
[30:27.880 --> 30:33.880]  And I need this flush over here.
[30:33.880 --> 30:35.880]  Oh, this should work.
[30:35.880 --> 30:39.880]  I didn't prepare this one, so let's see.
[30:39.880 --> 30:55.880]  Something like that.
[30:55.880 --> 30:57.880]  What did I...
[30:57.880 --> 30:59.880]  Ah!
[30:59.880 --> 31:01.880]  Yeah, yeah, yeah, yeah.
[31:01.880 --> 31:03.880]  Okay, demo.
[31:03.880 --> 31:05.880]  What am I missing?
[31:05.880 --> 31:08.880]  Yeah.
[31:08.880 --> 31:13.880]  A flush and sleep.
[31:13.880 --> 31:14.880]  I have a sleep here.
[31:14.880 --> 31:16.880]  Clear right flush sleep.
[31:16.880 --> 31:18.880]  It's because flush is up to sleep,
[31:18.880 --> 31:22.880]  and it should be good for...
[31:22.880 --> 31:37.880]  Oh, you guys are wonderful.
[31:37.880 --> 31:41.880]  It gets even more hot now, so...
[31:41.880 --> 31:49.880]  Oh.
[31:49.880 --> 31:53.880]  But I guess two letters is not enough, isn't it?
[31:53.880 --> 31:57.880]  Where are more stuff here?
[31:57.880 --> 32:00.880]  Ah, here are my flexies.
[32:00.880 --> 32:02.880]  They also sell these things on flexible PCBs.
[32:02.880 --> 32:05.880]  It's nice.
[32:05.880 --> 32:14.880]  And I put on this one again.
[32:14.880 --> 32:24.880]  Like this one.
[32:24.880 --> 32:28.880]  And now it's garbage.
[32:28.880 --> 32:34.880]  Anyone has any idea why it's garbage?
[32:34.880 --> 32:37.880]  It's another shame.
[32:37.880 --> 32:38.880]  Yeah.
[32:38.880 --> 32:42.880]  The first one, they go tuk, tuk, tuk, tuk, and then tuk, tuk, tuk.
[32:42.880 --> 32:45.880]  And this one goes tuk, tuk, tuk, tuk, tuk.
[32:45.880 --> 32:49.880]  Instead of going the same direction, it's niksacht.
[32:49.880 --> 32:59.880]  Okay.
[32:59.880 --> 33:05.880]  So we must fold it in...
[33:05.880 --> 33:13.880]  Inzigsacht version. Yeah.
[33:13.880 --> 33:26.880]  If you know a better term for it, feel free.
[33:26.880 --> 33:29.880]  Oh, hit the bug.
[33:29.880 --> 33:33.880]  Oh, fortunately I know where to correct this.
[33:33.880 --> 33:37.880]  Get to source.
[33:37.880 --> 33:40.880]  It's in canvas.
[33:40.880 --> 33:53.880]  And I made an error there in the zigzagging.
[33:53.880 --> 33:56.880]  Rotate it.
[33:56.880 --> 34:05.880]  Yeah, somewhere like here.
[34:05.880 --> 34:09.880]  It's a fold one here.
[34:09.880 --> 34:11.880]  It's, of course, an off-by-one error.
[34:11.880 --> 34:18.880]  I have to subtract one more here because size is one beyond.
[34:18.880 --> 34:26.880]  So... Ah, plus one, yeah.
[34:26.880 --> 34:33.880]  Okay, save it.
[34:33.880 --> 34:36.880]  And run it again.
[34:36.880 --> 34:40.880]  And just a hint, this won't work.
[34:40.880 --> 34:42.880]  Why doesn't this work?
[34:42.880 --> 34:44.880]  I made a stupid mistake.
[34:44.880 --> 34:53.880]  And it's not in the code.
[34:53.880 --> 34:56.880]  No, that was a different chip.
[34:56.880 --> 34:58.880]  But you're hot.
[34:58.880 --> 35:01.880]  It's hot anyway here, but...
[35:01.880 --> 35:05.880]  What did I just edit?
[35:05.880 --> 35:09.880]  I edited the source code on my laptop.
[35:09.880 --> 35:11.880]  That's the upper screen here.
[35:11.880 --> 35:14.880]  This one is a source code on my laptop.
[35:14.880 --> 35:17.880]  This one is the code on the chip.
[35:17.880 --> 35:21.880]  I made that mistake a gazillion times.
[35:21.880 --> 35:32.880]  So, do the same thing, but now on the code here.
[35:32.880 --> 35:34.880]  That one...
[35:34.880 --> 35:36.880]  Now, you see it's a bit slower
[35:36.880 --> 35:39.880]  because the most first retrieve that code from the chip
[35:39.880 --> 35:41.880]  to the laptop.
[35:41.880 --> 35:43.880]  Then I can edit it.
[35:43.880 --> 35:47.880]  It's the same code, but still I have to edit it.
[35:47.880 --> 35:50.880]  Flash is going to take...
[35:50.880 --> 35:54.880]  Well, which one on the mark?
[35:54.880 --> 35:56.880]  Ah, that's quick.
[35:56.880 --> 36:02.880]  Okay, thanks.
[36:02.880 --> 36:08.880]  I'm not... 25, okay, near.
[36:08.880 --> 36:10.880]  Ah...
[36:10.880 --> 36:12.880]  I'm doing something stupid here.
[36:12.880 --> 36:17.880]  Control Z is your friend.
[36:17.880 --> 36:22.880]  And now I've changed it on the...
[36:22.880 --> 36:24.880]  Okay, there.
[36:24.880 --> 36:27.880]  And I'm still at saving.
[36:27.880 --> 36:29.880]  Now I run that one again.
[36:29.880 --> 36:35.880]  It should compile...
[36:35.880 --> 36:38.880]  There's not the baked-in version.
[36:38.880 --> 36:42.880]  It's the from-source version.
[36:42.880 --> 36:43.880]  And now it's...
[36:43.880 --> 36:44.880]  Now it works.
[36:44.880 --> 36:48.880]  Well...
[36:48.880 --> 37:00.880]  Okay.
[37:00.880 --> 37:02.880]  I prepared all kinds of versions.
[37:02.880 --> 37:12.880]  They do all kinds of things with the ordering of the LEDs on the screens.
[37:12.880 --> 37:15.880]  Ah...
[37:15.880 --> 37:17.880]  Not again.
[37:17.880 --> 37:21.880]  Okay.
[37:21.880 --> 37:23.880]  Shouldn't it be just X and melted?
[37:23.880 --> 37:24.880]  Sorry?
[37:24.880 --> 37:31.880]  Shouldn't it be just X and melted, not both X and Y?
[37:31.880 --> 37:36.880]  Actually, it is not an accident.
[37:36.880 --> 37:43.880]  Okay, so what I do is the X, Y inverted.
[37:43.880 --> 37:50.880]  And that should be in here somewhere.
[37:50.880 --> 37:54.880]  Where is that X, Y inverted?
[37:54.880 --> 38:00.880]  You asked me to enlarge your ledger, so I'm scrolling slowly.
[38:00.880 --> 38:01.880]  Swapped?
[38:01.880 --> 38:12.880]  Ah, it's called swapped.
[38:12.880 --> 38:14.880]  What's this one?
[38:14.880 --> 38:24.880]  Okay.
[38:24.880 --> 38:31.880]  But do reflect on what I was about to do.
[38:31.880 --> 38:35.880]  That is, to edit it in the code stored on the chip.
[38:35.880 --> 38:37.880]  That's another problem.
[38:37.880 --> 38:42.880]  But then I decouple the chip and start working on the chip.
[38:42.880 --> 38:44.880]  And I just lost my code.
[38:44.880 --> 38:49.880]  Or I don't know where it is on one of the 20 chips I have.
[38:49.880 --> 38:52.880]  And now it's FO again.
[38:52.880 --> 38:53.880]  So that works.
[38:53.880 --> 38:59.880]  So I frequently don't know where I have put my last version of the code.
[38:59.880 --> 39:05.880]  And Tony doesn't support GitHub via the mark controller.
[39:05.880 --> 39:09.880]  That, in fact, would be very nice.
[39:09.880 --> 39:11.880]  Okay, never enough.
[39:11.880 --> 39:22.880]  Let's take more.
[39:22.880 --> 39:30.880]  Now it doesn't know it has more leds, so let's tell it.
[39:30.880 --> 39:37.880]  Where is that code?
[39:37.880 --> 39:43.880]  I'll just top it first.
[39:43.880 --> 40:00.880]  That one, run that one.
[40:00.880 --> 40:06.880]  Sorry?
[40:06.880 --> 40:08.880]  Oh, that takes a lot of time.
[40:08.880 --> 40:12.880]  You might do that for consistency.
[40:12.880 --> 40:15.880]  Downloading the live takes one minute.
[40:15.880 --> 40:17.880]  So not for...
[40:17.880 --> 40:19.880]  You wouldn't know where your editor is.
[40:19.880 --> 40:20.880]  That's true.
[40:20.880 --> 40:24.880]  But then you lose a bit of the essence of using Python.
[40:24.880 --> 40:27.880]  The essence is you can quickly make a modification.
[40:27.880 --> 40:30.880]  If I can afford one or two minutes,
[40:30.880 --> 40:35.880]  I might as well use a really compiled language and spend that much time.
[40:35.880 --> 40:38.880]  So, yeah, you couldn't need to do it.
[40:38.880 --> 40:43.880]  Okay, so I could add one more display, but that's more of the same.
[40:43.880 --> 40:48.880]  Let's not do that.
[40:48.880 --> 40:51.880]  Go back to these things.
[40:51.880 --> 41:01.880]  Yeah, you saw that again loading such a library from source is slow.
[41:01.880 --> 41:03.880]  You can also use a faster chip.
[41:03.880 --> 41:11.880]  If I take my fast chip, this one,
[41:11.880 --> 41:21.880]  and take that connection from it,
[41:21.880 --> 41:26.880]  and use that one.
[41:26.880 --> 41:29.880]  Tony, stop again and recognize a new chip, please.
[41:29.880 --> 41:31.880]  Yes, it does.
[41:31.880 --> 41:35.880]  And this one even has a separate flash card,
[41:35.880 --> 41:38.880]  so I can store more files on it if I want.
[41:38.880 --> 41:45.880]  And I can blink on it.
[41:45.880 --> 41:48.880]  This loads the library quite a bit faster.
[41:48.880 --> 41:50.880]  It doesn't have an onboard LID,
[41:50.880 --> 41:55.880]  so I blink on how LCD screen works, too.
[41:55.880 --> 42:00.880]  But sadly, I cannot use this target with the new pixels
[42:00.880 --> 42:04.880]  because it doesn't have the new pixel library built into the
[42:04.880 --> 42:08.880]  Python version for this chip.
[42:08.880 --> 42:13.880]  Sometimes you're just screwed.
[42:13.880 --> 42:15.880]  But I can...
[42:15.880 --> 42:18.880]  Oh, it doesn't want that.
[42:18.880 --> 42:20.880]  Sometimes when the communication goes wrong,
[42:20.880 --> 42:23.880]  Tony is very confused about what's happening.
[42:23.880 --> 42:25.880]  You just have to restart the chip
[42:25.880 --> 42:30.880]  and restart Tony or whatever you want.
[42:30.880 --> 42:33.880]  You can do this one.
[42:33.880 --> 42:36.880]  Well, now that it will leave that.
[42:36.880 --> 42:44.880]  I'll go to the sheets again.
[42:44.880 --> 42:47.880]  Okay.
[42:47.880 --> 42:50.880]  I've compared a few target chips that you could use
[42:50.880 --> 42:52.880]  for this kind of work.
[42:52.880 --> 42:55.880]  The teensy is what I just showed, a very fast one,
[42:55.880 --> 42:58.880]  but then it costs 36.
[42:58.880 --> 42:59.880]  So this might be real.
[42:59.880 --> 43:03.880]  36, maybe I'll photograph you all.
[43:03.880 --> 43:05.880]  It's quite expensive.
[43:05.880 --> 43:09.880]  If you want to have lots of fun with things that are expendable,
[43:09.880 --> 43:14.880]  the ESP32 and the PyPico are very good competitors.
[43:14.880 --> 43:19.880]  Less than 10 euros and really available everywhere.
[43:19.880 --> 43:24.880]  And for ESP32s, there are a lot of funny versions of it.
[43:24.880 --> 43:28.880]  There's a watch with ESP32 in it.
[43:28.880 --> 43:30.880]  I don't know my Python on it.
[43:30.880 --> 43:34.880]  In a previous situation, I did a demo with it,
[43:34.880 --> 43:36.880]  but it uses Wi-Fi,
[43:36.880 --> 43:39.880]  and it has the habit of working perfectly
[43:39.880 --> 43:42.880]  before you all walk in,
[43:42.880 --> 43:44.880]  over tens of meters,
[43:44.880 --> 43:46.880]  and then when you're all present with all your phones,
[43:46.880 --> 43:49.880]  the reach is reduced to five centimeters.
[43:49.880 --> 43:52.880]  Let's break half our condemos.
[43:52.880 --> 43:54.880]  These are other things.
[43:54.880 --> 43:57.880]  A doorbell camera has a built-in ESP32.
[43:57.880 --> 43:59.880]  It can run Michael Python,
[43:59.880 --> 44:04.880]  and then you can transmit the images over Wi-Fi,
[44:04.880 --> 44:07.880]  at least if you're not all present.
[44:07.880 --> 44:10.880]  And then...
[44:10.880 --> 44:14.880]  Do you all know these ones?
[44:14.880 --> 44:17.880]  You see one bit...
[44:17.880 --> 44:20.880]  Well, they can run MicroPython, sort of.
[44:20.880 --> 44:24.880]  They cannot store files on the flash system,
[44:24.880 --> 44:27.880]  and they can run about 50 lines or so of Python.
[44:27.880 --> 44:31.880]  So it's nice for a kindergarten Python course,
[44:31.880 --> 44:33.880]  but not for real work.
[44:33.880 --> 44:37.880]  And this one, I sure hope I can get it to work sometime.
[44:37.880 --> 44:39.880]  It's a kendrite.
[44:39.880 --> 44:41.880]  It's down here.
[44:41.880 --> 44:45.880]  It's quite powerful, and it also has neural network hardware on it.
[44:45.880 --> 44:49.880]  But it uses some Chinese version of MicroPython,
[44:49.880 --> 44:51.880]  and Tony doesn't recognize it,
[44:51.880 --> 44:54.880]  so maybe it works, but I don't know how.
[44:54.880 --> 44:56.880]  Ten minutes left. Thank you.
[44:56.880 --> 44:58.880]  If you have questions,
[44:58.880 --> 45:00.880]  those are more important than the rest of my sheets,
[45:00.880 --> 45:02.880]  so interrupt me.
[45:02.880 --> 45:06.880]  A few of those more interesting chips we saw
[45:06.880 --> 45:08.880]  are, in fact, not a pure mark controller
[45:08.880 --> 45:10.880]  or pure mark processor.
[45:10.880 --> 45:13.880]  They have a microcontroller core,
[45:13.880 --> 45:15.880]  but an external ROM added,
[45:15.880 --> 45:18.880]  and in some cases even external RAM.
[45:18.880 --> 45:21.880]  That is overall a cheaper configuration,
[45:21.880 --> 45:24.880]  because optimal, let's say, process parameter
[45:24.880 --> 45:28.880]  for making microchips, flash and RAM,
[45:28.880 --> 45:30.880]  are quite different.
[45:30.880 --> 45:34.880]  So you can make a cheaper, more effectively make a RAM chip,
[45:34.880 --> 45:37.880]  when you have only RAM cells on it.
[45:37.880 --> 45:43.880]  So, for instance, the ESP32 doesn't have that many,
[45:43.880 --> 45:45.880]  not that much RAM on board,
[45:45.880 --> 45:48.880]  but it can use an external coupled RAM chip
[45:48.880 --> 45:51.880]  as a buffer for it, it caches the things,
[45:51.880 --> 45:55.880]  and then you suddenly have a few megabytes of RAM,
[45:55.880 --> 45:57.880]  small actually, but it's a bit slower.
[45:57.880 --> 45:59.880]  Not that much, but a bit slower.
[45:59.880 --> 46:02.880]  Excuse me, can you make the slides real screen, please?
[46:02.880 --> 46:07.880]  I will, if I get my cursor back.
[46:07.880 --> 46:09.880]  Where's my cursor?
[46:11.880 --> 46:13.880]  Yeah.
[46:13.880 --> 46:18.880]  Oh, they'll publish this slide, so don't worry.
[46:21.880 --> 46:24.880]  So that's, then it's nice appearing,
[46:24.880 --> 46:26.880]  and then you have the hybrid version in between.
[46:26.880 --> 46:28.880]  Okay.
[46:28.880 --> 46:33.880]  When you work with this thing, RAM is very scarce.
[46:33.880 --> 46:35.880]  So the more RAM you have, the better,
[46:35.880 --> 46:37.880]  especially if you work with screen buffers or images
[46:37.880 --> 46:40.880]  or things from a camera or so.
[46:42.880 --> 46:48.880]  The thing is, when files are loaded by Michael Python,
[46:48.880 --> 46:50.880]  it first loads the source,
[46:50.880 --> 46:53.880]  then from that builds intermediate representation,
[46:53.880 --> 46:56.880]  that intermediate representation is smaller than the source,
[46:56.880 --> 46:59.880]  but the peak memory use is still the full source.
[46:59.880 --> 47:04.880]  So I cannot load my library as one file,
[47:04.880 --> 47:06.880]  or let's say in eSp3.2,
[47:06.880 --> 47:10.880]  because it doesn't have enough RAM to load that peak amount.
[47:10.880 --> 47:14.880]  It can load it in compiled form, but not as source form.
[47:14.880 --> 47:17.880]  So what I do, I split it in a lot of small files,
[47:17.880 --> 47:21.880]  and one trick I often use is I don't,
[47:21.880 --> 47:25.880]  I have a main file which imports all sub files,
[47:25.880 --> 47:30.880]  and for, let's say, basic classes you must do that,
[47:30.880 --> 47:34.880]  but for utility things like a driver for an LCD,
[47:34.880 --> 47:36.880]  I use a trampoline function.
[47:36.880 --> 47:39.880]  It pretends to be the class, but it's a function,
[47:39.880 --> 47:43.880]  and when it's called, it loads the real submodule,
[47:43.880 --> 47:46.880]  so it's loaded only when it needs it,
[47:46.880 --> 47:50.880]  and then it calls that with all the arguments.
[47:50.880 --> 47:53.880]  And such a trampoline takes maybe 50 bytes,
[47:53.880 --> 47:56.880]  while this full file could take a few kilobytes,
[47:56.880 --> 48:00.880]  so it saves a lot of RAM and loading time.
[48:00.880 --> 48:03.880]  Can you get a version of MicroPython
[48:03.880 --> 48:08.880]  which only takes pre-compiled to save space on smaller machines?
[48:08.880 --> 48:10.880]  Yeah, you sure can.
[48:10.880 --> 48:13.880]  So when you really develop something,
[48:13.880 --> 48:16.880]  I think you should take a larger machine,
[48:16.880 --> 48:19.880]  and when it's in production,
[48:19.880 --> 48:23.880]  take a smaller machine and use a pre-compiled version, yes, of course.
[48:23.880 --> 48:27.880]  Oh, sorry, he asked whether using pre-compiled version
[48:27.880 --> 48:29.880]  saves RAM, yes it does.
[48:29.880 --> 48:32.880]  Well, whether you could have a smaller MicroPython program
[48:32.880 --> 48:36.880]  with complete MicroPorts to save space?
[48:36.880 --> 48:43.880]  Yeah, but you still want to tweak with your own main code
[48:43.880 --> 48:45.880]  if you're developing.
[48:45.880 --> 48:48.880]  If you have a finished product, then all things are different,
[48:48.880 --> 48:50.880]  and I think the main power of MicroPython
[48:50.880 --> 48:53.880]  is that you can tinker with it at a late stadium.
[48:53.880 --> 48:55.880]  If you have a finished product,
[48:55.880 --> 48:58.880]  well, indeed you can freeze it,
[48:58.880 --> 49:03.880]  but if you want that, how do you develop it?
[49:03.880 --> 49:07.880]  Presumably on a different processor with more RAM.
[49:07.880 --> 49:10.880]  Let's tinkle it.
[49:10.880 --> 49:12.880]  Limitations.
[49:12.880 --> 49:18.880]  Should we pre-compile large libraries and put them on the chip,
[49:18.880 --> 49:20.880]  and then we can tinker with our own code,
[49:20.880 --> 49:23.880]  but have to pre-compile libraries?
[49:23.880 --> 49:25.880]  Is that something to do?
[49:25.880 --> 49:28.880]  Yeah, indeed, but there are a lot of pre...
[49:28.880 --> 49:32.880]  Oh, is it a good idea to have pre-compiled libraries
[49:32.880 --> 49:35.880]  incorporated in the Python interpreter
[49:35.880 --> 49:38.880]  and then tinker with your own code?
[49:38.880 --> 49:40.880]  Yeah, I think that's a good approach.
[49:40.880 --> 49:42.880]  These libraries are stable,
[49:42.880 --> 49:44.880]  because if you must change in those libraries,
[49:44.880 --> 49:46.880]  you don't have the source code,
[49:46.880 --> 49:48.880]  at least not on your target chip,
[49:48.880 --> 49:51.880]  and you're stuck in a much slower development cycle.
[49:51.880 --> 49:54.880]  So it's, well, if things are indeed stable,
[49:54.880 --> 49:58.880]  freeze them in the MicroPython interpreter.
[49:58.880 --> 50:04.880]  If not, take a large chip and develop on that.
[50:04.880 --> 50:06.880]  Five minutes left.
[50:06.880 --> 50:09.880]  Well, you can really develop limitations.
[50:09.880 --> 50:14.880]  Time-wise, if you're in the, let's say, clock cycles,
[50:14.880 --> 50:18.880]  time domain, if it must be that fast,
[50:18.880 --> 50:21.880]  then even C or C++ won't do it.
[50:21.880 --> 50:27.880]  You need hardware or Raspberry Pico Pios.
[50:27.880 --> 50:29.880]  If you're in the tens or hundreds of cycles,
[50:29.880 --> 50:31.880]  you can use compiled language.
[50:31.880 --> 50:33.880]  If you're in the thousands of cycles,
[50:33.880 --> 50:36.880]  you can use an interpreter language like Python
[50:36.880 --> 50:39.880]  to concrete driving those new pixels
[50:39.880 --> 50:41.880]  that requires microseconds timing.
[50:41.880 --> 50:44.880]  You cannot do that in Python code.
[50:44.880 --> 50:46.880]  In the MicroPython interpreter,
[50:46.880 --> 50:50.880]  they do it in C code, and that's built-in.
[50:50.880 --> 50:54.880]  Driving a servo motor, a hobby servo back and forth,
[50:54.880 --> 50:56.880]  that's millisecond timing.
[50:56.880 --> 50:58.880]  You can easily do that in Python,
[50:58.880 --> 51:01.880]  in the Python source code.
[51:01.880 --> 51:04.880]  Oh, there's a list of deviations from C Python.
[51:04.880 --> 51:06.880]  You can read it.
[51:06.880 --> 51:08.880]  They didn't bother me much,
[51:08.880 --> 51:11.880]  except that it doesn't support type hints,
[51:11.880 --> 51:13.880]  and I like type hints from my testing,
[51:13.880 --> 51:16.880]  so I must do the testing on my laptop.
[51:16.880 --> 51:19.880]  You can test a lot of basic things,
[51:19.880 --> 51:22.880]  not on the small machine between your desktop.
[51:22.880 --> 51:25.880]  Question.
[51:25.880 --> 51:30.880]  When it's compiled, is it the same by code as Cpyto?
[51:30.880 --> 51:31.880]  No.
[51:31.880 --> 51:34.880]  When it's compiled, MicroPython intermediate code
[51:34.880 --> 51:36.880]  is different from Cpyto code.
[51:36.880 --> 51:40.880]  It has its own pre-compiler, which you can download,
[51:40.880 --> 51:42.880]  and you can pre-compile it,
[51:42.880 --> 51:45.880]  but it's different from the standard Cpyto.
[51:45.880 --> 51:48.880]  Question.
[51:48.880 --> 51:51.880]  Does MicroPython have a garbage collector?
[51:51.880 --> 51:53.880]  Does MicroPython have a garbage collector?
[51:53.880 --> 51:55.880]  You can bet it has, yes.
[51:55.880 --> 51:59.880]  And when you want to do really time-critical things,
[51:59.880 --> 52:02.880]  call the garbage collector and do it after that.
[52:02.880 --> 52:04.880]  Then you can be reasonably sure that it's called.
[52:04.880 --> 52:07.880]  But if you want to do really time-critical,
[52:07.880 --> 52:10.880]  life-critical things, don't use Python.
[52:10.880 --> 52:14.880]  Sorry.
[52:14.880 --> 52:16.880]  Okay, I'll skip this one.
[52:16.880 --> 52:18.880]  Where is it good for?
[52:18.880 --> 52:21.880]  Well, maybe not for volume production.
[52:21.880 --> 52:23.880]  For that you use compiled language,
[52:23.880 --> 52:26.880]  but for anything that requires tinkering,
[52:26.880 --> 52:31.880]  exploration, lab setups, experiments, education,
[52:31.880 --> 52:33.880]  it's really nice tool.
[52:33.880 --> 52:36.880]  Okay, what is problems?
[52:36.880 --> 52:40.880]  I'm always confused where my latest version of the source code is.
[52:40.880 --> 52:42.880]  I changed what's something on that ship.
[52:42.880 --> 52:45.880]  Maybe it's on my PC or on GitHub, I don't know.
[52:45.880 --> 52:49.880]  Remember, USB port cannot supply a large current,
[52:49.880 --> 52:51.880]  which you want things like these pixels
[52:51.880 --> 52:54.880]  have a separate power supply.
[52:54.880 --> 52:59.880]  The terminology of Tony with upload and download
[52:59.880 --> 53:02.880]  is reversed from what I think is normal,
[53:02.880 --> 53:04.880]  but you have to use it.
[53:04.880 --> 53:05.880]  No problem.
[53:05.880 --> 53:11.880]  If you want to have your code safe from prying eyes,
[53:11.880 --> 53:13.880]  I think forget it.
[53:13.880 --> 53:16.880]  The intermediate code can be back-compiled
[53:16.880 --> 53:20.880]  so anyone can see into your code.
[53:20.880 --> 53:25.880]  If you have large invested interest in your code,
[53:25.880 --> 53:27.880]  maybe Python root is not the way.
[53:27.880 --> 53:31.880]  Then probably you want to make a large amount of products
[53:31.880 --> 53:34.880]  so it's not the way anyway.
[53:34.880 --> 53:38.880]  Okay, I did cover some things.
[53:38.880 --> 53:39.880]  Take away.
[53:39.880 --> 53:40.880]  Well, start tinkering.
[53:40.880 --> 53:42.880]  It's always a good idea.
[53:42.880 --> 53:45.880]  Get the same hardware as you would use for an Arduino.
[53:45.880 --> 53:48.880]  Get some micro-python cable board loaded on it.
[53:48.880 --> 53:51.880]  Five minutes work and start doing things.
[53:51.880 --> 53:53.880]  Okay, well, if I did that demo,
[53:53.880 --> 53:56.880]  then those pixels would show questions,
[53:56.880 --> 53:59.880]  but I think we're at times up anyway.
[53:59.880 --> 54:00.880]  One minute.
[54:00.880 --> 54:01.880]  One minute.
[54:01.880 --> 54:03.880]  One last question.
[54:03.880 --> 54:04.880]  Yeah.
[54:04.880 --> 54:07.880]  In the beginning, you showed the custom
[54:07.880 --> 54:09.880]  that you called it, like,
[54:09.880 --> 54:23.880]  machine or pin.
[54:23.880 --> 54:25.880]  Yeah.
[54:25.880 --> 54:26.880]  Where does it come from?
[54:26.880 --> 54:28.880]  That's...
[54:28.880 --> 54:30.880]  Micro-python is a bulk of...
[54:30.880 --> 54:31.880]  Sorry.
[54:31.880 --> 54:34.880]  He asked, where does this code come?
[54:34.880 --> 54:35.880]  The pin and the machine.
[54:35.880 --> 54:37.880]  Micro-python is common parts
[54:37.880 --> 54:40.880]  and then the specific part for specific chips.
[54:40.880 --> 54:42.880]  And accessing a GPO pin of a chip
[54:42.880 --> 54:44.880]  is very different from chips.
[54:44.880 --> 54:47.880]  But that's a very shallow part.
[54:47.880 --> 54:48.880]  Once you have that,
[54:48.880 --> 54:50.880]  you can build a lot of things on top of that.
[54:50.880 --> 54:52.880]  So the micro-python distribution
[54:52.880 --> 54:54.880]  that I used here to compile,
[54:54.880 --> 54:57.880]  I'm a specifier for which target chip I compile
[54:57.880 --> 55:00.880]  and then it grabs the correct code.
[55:00.880 --> 55:01.880]  Okay.
[55:01.880 --> 55:02.880]  Thank you.
[55:02.880 --> 55:14.880]  Thank you.
[55:14.880 --> 55:16.880]  Thanks a lot, Walter.
[55:16.880 --> 55:19.880]  Will you be available outside for questions?
[55:19.880 --> 55:20.880]  I'll be here around.
[55:20.880 --> 55:22.880]  So Walter will be around for questions
[55:22.880 --> 55:24.880]  if you have questions and hesitate.
[55:24.880 --> 55:26.880]  Python may have lost the smartphone wars,
[55:26.880 --> 55:33.880]  but for the smartwatches, we still have hope.
