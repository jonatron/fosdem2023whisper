{"text": " Yeah, I hope you had a great Boston so far. I'm happy to talk about how to build your own MLIR dialect. So just as a first question, who is aware of what MLIR actually is, who have heard of the MLIR subproject? Awesome. So it's not the whole audience, so I'm going to talk a little bit more about what MLIR is. So my outline is, yeah, what is MLIR actually, but I only have a really short slide on that. I will show you the standalone example, which exists in the MLIR, or in the LLVM repository as part of the MLIR project. And I will tell you a little bit more about how you can extend it, how you can build your own dialect, because following the discussions on discourse and discourse, it always seems like people hitting the same pain points, at least we did several times. So that's why I set up this kind of tutorial to show you some of the tricks behind, mainly from the CMake perspective, which is some kind of tricky sometimes. So beside that, how to build it, I show you how you can combine it with other dialects. And last but not least, how to extend your dialect with types or attributes. So and just as a side note, all code snippets are, of course, licensed under Apache 2 with LLVM exceptions. So what is MLIR? MLIR is actually a reusable compiler infrastructure that was introduced by Google in 2019, early 2019, and at the end of 2019, Google donated it to the LLVM foundation. So it's officially part of the LLVM project, and there it lives in the mono repo and MLIR, and what it allows you is to define operations, attributes and types, which are grouped in so-called dialects, and that let you define your own intermediate representation. Later on in the session, we will also have an update about the Flang compiler, which also uses MLIR to define its own intermediate representation. And these dialects that can be part either of MLIR core, meaning they are in upstream, like the hung dialect, which gives you the ability to define what a function is, or there's also an LLVM IR dialect, which actually mirrors what LLVM IR is. But it is modeled in MLIR, sorry, what LLVM IR is, but it is modeled in MLIR. There are tons of other dialects, like a GPU dialect, a Tosa dialect, which is the tensor-operate set architecture, or MTC, which I am one of the developers behind. And there are also many, many out-of-tree dialects, like the SORC project is using it, or Torch MLIR, which is actually modeling PyTorch in MLIR. Many, many more, and these are considered as out-of-tree. So when we look at the standalone example, which is really a brilliant starter when you want to create your own dialect, you find it as part of the LLVM Mono repository, and you can just build it against an installed LLVM. You can just run CMake, configure it accordingly. You just need to pass where you find your installed MLIR and where the LLVM external lit is present. And actually, then you can just build your target, which is here's a check standalone. It builds all the tools and further runs some tests. This actually assumes, as I have mentioned, that LLVM and MLIR are built here and built here, and then they are installed to prefix. And that corresponds to out-of-tree somehow. And for me, when I began with LLVM or MLIR, I was not a compiler developer, but I had some experience in CMake and how these terms out-of-tree are used in LLVM and MLIR and the outer world are sometimes confusing, so I want to give at least a short definition. So in the LLVM world, entry also often or nearly every time refers to a monolithic build. That means you build LLVM or your LLVM subproject plus your dialects or whatever. Entry can refer to the source location. So here we have an out-of-tree dialect, which is however part of the LLVM monorepo, but it's considered out-of-tree because you can pull it out and you don't need to have it in the monorepo. So out-of-tree normally refers to work with a separate repository. However, there is also a mechanism which you can use to build your project with this LLVM external projects mechanism, and projects using this, and if you look into their CMake configuration or into other tutorials, either they call it out-of-tree monolithic build. So it's not a component build like you have against an installed MLIR or LLVM, or they even call it entry, which is somehow confusing because when you look to CMake, normally infantry just means you're building where your source code lives, which is actually a bad practice. You shouldn't do this. Normally you do out-of-tree builds. It just means you create a separate directory where you set up your configuration and where you do your build. This can also be a sub-directory in the source tree, but it's a separate directory not checked into your Git later on. So within this talk, I just call it the external project mechanism. For me, it's always an out-of-tree build, regardless of what I do. Even if I build LLVM, I wouldn't call it personally entry because I'm using the CMake notation normally just to make it clear when you look into some of the projects and don't get confused. So what we can do is we can extend the standalone project by this LLVM external projects mechanism and the question is, why should we do this? So Stephen Noindover gave a great tutorial about how to architecture LLVM projects at the LLVM DevMitting 2021, which is available on YouTube. I also have the link in my references. Here we are referring to a monolithic build and in his tutorial, he says, use the component build. That is what the standalone project already gives you. But there are some benefits when you maybe want to use the LLVM external projects. So what we actually do is when we developed the IMHC dialect, we developed this as an out of three dialect, completely independent or buildable against an installed MLIR version. IMHC is now part of the MLIR core, so it's upstreamed. And what we normally do is, or what's quite nice is, sometimes we want to look into when we change our dialect upstream or when we extend it, how does it behave together with these out of three source, which we still have, all our conversions, all our transformations are not upstreamed yet. And it is quite nice to build it as a run project because you can easily debug into, you don't have to keep your installation and what you're building out of source, you don't have to keep this in sync, you just have a monolithic build. So there are some benefits and we just want to look into what do we need to do to build it with the LLVM external project mechanism. So we are creating our build directory again, then we have to define the LLVM targets to build. So here you need to specify for which architect you want to build LLVM. So here it's just host or x86, which is also an option. You must specify the build type, either release, debug, minstars with relinfo, whatever. And we need to enable our project MLIR, otherwise it's not build. And in addition to that, as we want to build our standalone project, we specify LLVM external projects, standalone dialect, which is our project name. And furthermore, we specify LLVM external standalone dialect source tree to specify where do we find our source, that are the two additional parameters you need to pass. And here LLVM source tier, actually, we assume that it points to the root of our monorepo checked out. So that is what we want to have later on. Right now the standalone example can't do this. What do we need to change to make this possible? So right now it's looking like the following, looking to the main CMake configuration and what is important here is we have find package, we call find package MLIR, and find package in general imports information which were exported by a project. So here find package imports information from the installed MLIR version. And furthermore, the find package MLIR also calls find package LLVM for us, so we don't need to care about this. So then just the MLIR config CMake is actually parsed as well as the LLVM config CMake parsed and we can gladly just do our includes, which adds some further code for us. So for the external project mechanism build, we don't need to do this. So what we need to change is we only need to call find package. If there is an installed MLIR otherwise there won't be one because we're just building it as part of our build process. So in that case CMake source here normally is equal to CMake current source here. If it's not the case we have a different build type and we're just adding this if else block and we don't have the need no longer for our other project to load the CMake models with include. And the code we're adding is we're just setting the variables which are not available as export a project settings by yourself. So MLIR main source here, main include here and that's actually it. So that are the few lines we need to make it buildable. However, your LIT tests will fail. So there is a little bit more code that we need to modify. Here we just define a standalone source here and standalone binary variables which are then later on used also for include directories. And we adjust our LIT side CFG upon pi accordingly. So here we actually need to change CMake binary D or CMake source here by our newly set variable. Otherwise, yeah, the LIT tests are the location of LIT CFG is assumed in the wrong place. So we just fix that here. That's nearly it. So when you now want to use a dialect with other dialects and you have these in several repositories or with several projects at least, you can either use LLVM external projects to build multiple dialects. Torch MLIR for example is doing exactly this. Another option is to use CMake's external project at which is considered as the cleanest way as it really keeps the projects enclosed and doesn't transfer variables between the projects. However, what I normally do is I use a sub directory, but in addition with the exclude from awesome no only require the build targets I really use are exported or transferred to the other project. And we do this in our MLIR MLC repository and to do this we actually have an option just embedded which changes our source code a little bit. So only when we want to call it embedded then we check is it the case or not because the find package is already done by the other project. We don't need to call this. We only do the includes which we don't need for the external project mechanism. So getting to types. This is how the standalone dialect is currently structured or at least most of it. There are also some tools standalone ops standalone translate which are considered here. And you see we have multiple finds and types could be specified in standalone ops.td in our table definition file. However, it's quite nice to not put it into all into one file but to use separate files for it. So what we're doing is we're adding new files. We're adding a table gen file standalone types. We're adding a header file and we're adding the CPP for our implementation. And what you need to put into those are actually the following. Let's start with the table gen file. First of all, we include the attribute type base and the dialect itself because the dialect has some definitions and then we can define our standalone types class which is the base class for types. And in addition to that, we can define a custom type. Actually this is a simple copy of a mid-seas or park type. Quite straightforward but here we use a standard assembly format so no custom parser and printer and it just holds a string of parameters. So nothing special just to illustrate the example. So that is how the table gen file could look like. Getting to standalone ops, we can just replace the include of standalone dialect by standalone types. And this is because the types already includes the table gen TDE file so that's fine and that's it. Regarding the CMAC list, we don't need anything to change. Why is that? Actually at MLIR dialect already calls MLIR table gen for you with gen type decals and type definitions so that's fine. We don't need to change anything here. Whatever for attributes that would be different because for attributes, the at MLIR dialect doesn't call MLIR table gen for you to just set the LRM target definitions by yourself, call MLIR table gen by yourself, add a public table gen target and that's it. So attributes are quite close related to, are quite similar except for that you need to adjust your CMAC configuration by yourself. For the header file, just include the auto-generated type dev classes in the header, that's it, add the define, the include, nothing more to do. For our implementation, we need to make sure that the types can actually be registered by the parent dialect. So what we do is we have a define here, get type dev classes, we include then our generated code, generated by table gen and then we implement or we write a function register types which actually calls the method add types plus some of the auto-generated code and this needs to be called in our standalone dialect.cpp. So we just add the register types here and that's nearly the real trick. You can do the same not with ad operands or add types but with add attributes for attributes and to register your attributes. For the CMAC list itself, just add this to your MLIR standalone live or MLIR dialect library target, that's it, nothing more to do. For attributes, you can also just add your source code or you must add your source file here of course. But in addition, you also need a dependency on MLIR standalone attributes, ink gen, the target we generate or we create it by hand because it's not auto-generated just to make sure that table gen generates the code before CMAC tries to, or before the MLIR standalone target is built. You might be lucky otherwise you might have a race condition in your build system. I experienced that several times, tried to fix it or just keep it in mind and that's mainly it. For the standalone dialect, here we use the default printer and parser. Just let us tell table gen to generate those. And for register types, actually we need of course a declaration. We have the implementation but we also need the extra cards declaration generated by table gen. Otherwise, yeah, we cannot use it in our standalone ops.cpp. So all the examples are available in my fork of the LLVM project. I couldn't make it to senses, we are fabricated to be reviewed through upstream inclusion prior to my talk. But I will do so, I will add some more documentation to this, that's at least my goal. So when I planned this talk, I thought maybe some hints which could have one or the other and hopefully it's even more helpful if you not only find it in the slidespot also in the upstream example. And there are many good resources out there. So the talk given by media mini and river riddle, the MLIR primer, the MLIR tutorial at the 2020 LLVM deaf meeting. We have some great docs at MLIRLLVM.org, here how to create a dialect, the toy example for example, how to combine it, how to add attribute and types if you want to get more into the details what you can do all in the table gen world. Thanks, last but not least, the tutorial given by Steven Neuerhender at the LLVM 2021 deaf meeting. Yeah, so that's it from my side. So if you have questions, please let me know and I try to answer them. Hey, I just recently got into learning how to develop compilers, even less how to create languages. I've been focusing mostly on the front end part, like lexing and parsing. And my idea was to use LLVM as the back end for a really abstracted C type language which I'm working on and use LLVM as a back end to generate machine code for x86. And my understanding was that I only had to use or generate an IR for LLVM, the LLVM IR. And now you mentioned that LLVM IR can be described or is somehow related with the MLIR, right? So I was wondering if I'm still in the correct track to try to generate the parse tree and use LLVM and try to generate the standard LLVM IR and target the x86 or an x86 platform or do I need to learn something about the MLIR? So to try to summarize the question, the question is when as a compiler starter you're mostly focusing on parsing an abstract C type like language and want to know if you can just go through the ordinary LLVM IR way or if you need to plug in switch over to MLIR to do what you want. So in real short. So you can do this definitely. You can go the way you're right now doing. So MLIR actually is a little bit different. So if we are looking to clang, if you're talking about an abstract C language, looking into clang, there is clang AST and then we directly or more or less go to LLVM IR and that is one of the things which yeah isn't that nice or if you look into other compilers they introduce more intermediate representations in between like we will see later on in the session the flang app that for example or even Swift has two intermediate representations for example. So MLIR just gives you the ability to define additional intermediate representations. So you can also write a front end for your language, parse it into MLIR, convert it to the LLVM IR dialect and then translate it to LLVM IR. So that would be identical. It really depends on what you want to do, what kind of infrastructure you want to use. But you can go the way you're already going. So hopefully that somehow at least answers your question. Okay, the question is not directly related to the talk but as I'm one of the developers behind MLC, why we developed MLC? Sometimes you cannot compile with clang or directly or with LLVM at all to your target. So the idea was to get something independent of the compiler and when we actually generate C code with MLC you can have send the freedom to choose which compiler you want to use to translate for your final target. So we are in the domain of compilers for machine learning and sometimes we have some very exotic targets where clang unfortunately is not the option to use it as a compiler. So that's the simple reason. Hi, I was coming from the opposite side of the spectrum, I was looking into doing some sort of just in time compilation but I also wanted to define my own types and my own let's say things. My question is would MLIR be a good fit for that or would possibly just see with some sort of, I don't know, C++ with templates and some sort of, I don't know, dynamic language or something like that. So the question is when coming from the other side, so for JIT essentially if MLIR might be a good fit to define your own types and attributes and well I'm not an expert regarding JIT but MLIR provides you, I think most of the codes are upstream provides you the possibility to register types and attributes I'm quite sure at least at runtime. So you can extend your dialect after you compiled MLIR. So that is maybe, yeah, depending on what you want to do. If you really want to modify it during runtime, that should be possible with MLIR. So I'm not 100% sure but at least worth a look, I think. Well, I'm partly aware of IRDL but I don't know, you mean how you composite VRC make into targets or would, yeah, probably you, as you with IRDL as far as I know as you do most of the time at runtime, you wouldn't need to build it in advance. So yeah, the CMake stuff would be somehow obsolete, yeah, I think so. All right, if we're out of questions, thank you Marius, thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.52, "text": " Yeah, I hope you had a great Boston so far.", "tokens": [865, 11, 286, 1454, 291, 632, 257, 869, 12333, 370, 1400, 13], "temperature": 0.0, "avg_logprob": -0.24767383452384703, "compression_ratio": 1.4854368932038835, "no_speech_prob": 0.27734917402267456}, {"id": 1, "seek": 0, "start": 10.52, "end": 14.4, "text": " I'm happy to talk about how to build your own MLIR dialect.", "tokens": [286, 478, 2055, 281, 751, 466, 577, 281, 1322, 428, 1065, 21601, 7740, 24652, 13], "temperature": 0.0, "avg_logprob": -0.24767383452384703, "compression_ratio": 1.4854368932038835, "no_speech_prob": 0.27734917402267456}, {"id": 2, "seek": 0, "start": 14.4, "end": 20.52, "text": " So just as a first question, who is aware of what MLIR actually is, who have heard of", "tokens": [407, 445, 382, 257, 700, 1168, 11, 567, 307, 3650, 295, 437, 21601, 7740, 767, 307, 11, 567, 362, 2198, 295], "temperature": 0.0, "avg_logprob": -0.24767383452384703, "compression_ratio": 1.4854368932038835, "no_speech_prob": 0.27734917402267456}, {"id": 3, "seek": 0, "start": 20.52, "end": 22.44, "text": " the MLIR subproject?", "tokens": [264, 21601, 7740, 1422, 4318, 1020, 30], "temperature": 0.0, "avg_logprob": -0.24767383452384703, "compression_ratio": 1.4854368932038835, "no_speech_prob": 0.27734917402267456}, {"id": 4, "seek": 0, "start": 22.44, "end": 24.44, "text": " Awesome.", "tokens": [10391, 13], "temperature": 0.0, "avg_logprob": -0.24767383452384703, "compression_ratio": 1.4854368932038835, "no_speech_prob": 0.27734917402267456}, {"id": 5, "seek": 0, "start": 24.44, "end": 29.240000000000002, "text": " So it's not the whole audience, so I'm going to talk a little bit more about what MLIR", "tokens": [407, 309, 311, 406, 264, 1379, 4034, 11, 370, 286, 478, 516, 281, 751, 257, 707, 857, 544, 466, 437, 21601, 7740], "temperature": 0.0, "avg_logprob": -0.24767383452384703, "compression_ratio": 1.4854368932038835, "no_speech_prob": 0.27734917402267456}, {"id": 6, "seek": 2924, "start": 29.24, "end": 30.24, "text": " is.", "tokens": [307, 13], "temperature": 0.0, "avg_logprob": -0.12582714758186697, "compression_ratio": 1.6446280991735538, "no_speech_prob": 0.0002909291652031243}, {"id": 7, "seek": 2924, "start": 30.24, "end": 37.44, "text": " So my outline is, yeah, what is MLIR actually, but I only have a really short slide on that.", "tokens": [407, 452, 16387, 307, 11, 1338, 11, 437, 307, 21601, 7740, 767, 11, 457, 286, 787, 362, 257, 534, 2099, 4137, 322, 300, 13], "temperature": 0.0, "avg_logprob": -0.12582714758186697, "compression_ratio": 1.6446280991735538, "no_speech_prob": 0.0002909291652031243}, {"id": 8, "seek": 2924, "start": 37.44, "end": 44.44, "text": " I will show you the standalone example, which exists in the MLIR, or in the LLVM repository", "tokens": [286, 486, 855, 291, 264, 37454, 1365, 11, 597, 8198, 294, 264, 21601, 7740, 11, 420, 294, 264, 441, 43, 53, 44, 25841], "temperature": 0.0, "avg_logprob": -0.12582714758186697, "compression_ratio": 1.6446280991735538, "no_speech_prob": 0.0002909291652031243}, {"id": 9, "seek": 2924, "start": 44.44, "end": 46.92, "text": " as part of the MLIR project.", "tokens": [382, 644, 295, 264, 21601, 7740, 1716, 13], "temperature": 0.0, "avg_logprob": -0.12582714758186697, "compression_ratio": 1.6446280991735538, "no_speech_prob": 0.0002909291652031243}, {"id": 10, "seek": 2924, "start": 46.92, "end": 52.04, "text": " And I will tell you a little bit more about how you can extend it, how you can build your", "tokens": [400, 286, 486, 980, 291, 257, 707, 857, 544, 466, 577, 291, 393, 10101, 309, 11, 577, 291, 393, 1322, 428], "temperature": 0.0, "avg_logprob": -0.12582714758186697, "compression_ratio": 1.6446280991735538, "no_speech_prob": 0.0002909291652031243}, {"id": 11, "seek": 2924, "start": 52.04, "end": 57.56, "text": " own dialect, because following the discussions on discourse and discourse, it always seems", "tokens": [1065, 24652, 11, 570, 3480, 264, 11088, 322, 23938, 293, 23938, 11, 309, 1009, 2544], "temperature": 0.0, "avg_logprob": -0.12582714758186697, "compression_ratio": 1.6446280991735538, "no_speech_prob": 0.0002909291652031243}, {"id": 12, "seek": 5756, "start": 57.56, "end": 64.16, "text": " like people hitting the same pain points, at least we did several times.", "tokens": [411, 561, 8850, 264, 912, 1822, 2793, 11, 412, 1935, 321, 630, 2940, 1413, 13], "temperature": 0.0, "avg_logprob": -0.0796630091783477, "compression_ratio": 1.5792079207920793, "no_speech_prob": 2.8401793315424584e-05}, {"id": 13, "seek": 5756, "start": 64.16, "end": 70.36, "text": " So that's why I set up this kind of tutorial to show you some of the tricks behind, mainly", "tokens": [407, 300, 311, 983, 286, 992, 493, 341, 733, 295, 7073, 281, 855, 291, 512, 295, 264, 11733, 2261, 11, 8704], "temperature": 0.0, "avg_logprob": -0.0796630091783477, "compression_ratio": 1.5792079207920793, "no_speech_prob": 2.8401793315424584e-05}, {"id": 14, "seek": 5756, "start": 70.36, "end": 74.96000000000001, "text": " from the CMake perspective, which is some kind of tricky sometimes.", "tokens": [490, 264, 20424, 619, 4585, 11, 597, 307, 512, 733, 295, 12414, 2171, 13], "temperature": 0.0, "avg_logprob": -0.0796630091783477, "compression_ratio": 1.5792079207920793, "no_speech_prob": 2.8401793315424584e-05}, {"id": 15, "seek": 5756, "start": 74.96000000000001, "end": 80.08, "text": " So beside that, how to build it, I show you how you can combine it with other dialects.", "tokens": [407, 15726, 300, 11, 577, 281, 1322, 309, 11, 286, 855, 291, 577, 291, 393, 10432, 309, 365, 661, 24652, 82, 13], "temperature": 0.0, "avg_logprob": -0.0796630091783477, "compression_ratio": 1.5792079207920793, "no_speech_prob": 2.8401793315424584e-05}, {"id": 16, "seek": 8008, "start": 80.08, "end": 87.92, "text": " And last but not least, how to extend your dialect with types or attributes.", "tokens": [400, 1036, 457, 406, 1935, 11, 577, 281, 10101, 428, 24652, 365, 3467, 420, 17212, 13], "temperature": 0.0, "avg_logprob": -0.17625109757049173, "compression_ratio": 1.4056603773584906, "no_speech_prob": 2.506421151338145e-05}, {"id": 17, "seek": 8008, "start": 87.92, "end": 93.48, "text": " So and just as a side note, all code snippets are, of course, licensed under Apache 2 with", "tokens": [407, 293, 445, 382, 257, 1252, 3637, 11, 439, 3089, 35623, 1385, 366, 11, 295, 1164, 11, 25225, 833, 46597, 568, 365], "temperature": 0.0, "avg_logprob": -0.17625109757049173, "compression_ratio": 1.4056603773584906, "no_speech_prob": 2.506421151338145e-05}, {"id": 18, "seek": 8008, "start": 93.48, "end": 95.48, "text": " LLVM exceptions.", "tokens": [441, 43, 53, 44, 22847, 13], "temperature": 0.0, "avg_logprob": -0.17625109757049173, "compression_ratio": 1.4056603773584906, "no_speech_prob": 2.506421151338145e-05}, {"id": 19, "seek": 8008, "start": 95.48, "end": 96.47999999999999, "text": " So what is MLIR?", "tokens": [407, 437, 307, 21601, 7740, 30], "temperature": 0.0, "avg_logprob": -0.17625109757049173, "compression_ratio": 1.4056603773584906, "no_speech_prob": 2.506421151338145e-05}, {"id": 20, "seek": 8008, "start": 96.47999999999999, "end": 106.92, "text": " MLIR is actually a reusable compiler infrastructure that was introduced by Google in 2019, early", "tokens": [21601, 7740, 307, 767, 257, 41807, 31958, 6896, 300, 390, 7268, 538, 3329, 294, 6071, 11, 2440], "temperature": 0.0, "avg_logprob": -0.17625109757049173, "compression_ratio": 1.4056603773584906, "no_speech_prob": 2.506421151338145e-05}, {"id": 21, "seek": 10692, "start": 106.92, "end": 112.48, "text": " 2019, and at the end of 2019, Google donated it to the LLVM foundation.", "tokens": [6071, 11, 293, 412, 264, 917, 295, 6071, 11, 3329, 23723, 309, 281, 264, 441, 43, 53, 44, 7030, 13], "temperature": 0.0, "avg_logprob": -0.15847286481535836, "compression_ratio": 1.5509259259259258, "no_speech_prob": 0.00012924234033562243}, {"id": 22, "seek": 10692, "start": 112.48, "end": 122.24000000000001, "text": " So it's officially part of the LLVM project, and there it lives in the mono repo and MLIR,", "tokens": [407, 309, 311, 12053, 644, 295, 264, 441, 43, 53, 44, 1716, 11, 293, 456, 309, 2909, 294, 264, 35624, 49040, 293, 21601, 7740, 11], "temperature": 0.0, "avg_logprob": -0.15847286481535836, "compression_ratio": 1.5509259259259258, "no_speech_prob": 0.00012924234033562243}, {"id": 23, "seek": 10692, "start": 122.24000000000001, "end": 129.2, "text": " and what it allows you is to define operations, attributes and types, which are grouped in", "tokens": [293, 437, 309, 4045, 291, 307, 281, 6964, 7705, 11, 17212, 293, 3467, 11, 597, 366, 41877, 294], "temperature": 0.0, "avg_logprob": -0.15847286481535836, "compression_ratio": 1.5509259259259258, "no_speech_prob": 0.00012924234033562243}, {"id": 24, "seek": 10692, "start": 129.2, "end": 134.28, "text": " so-called dialects, and that let you define your own intermediate representation.", "tokens": [370, 12, 11880, 24652, 82, 11, 293, 300, 718, 291, 6964, 428, 1065, 19376, 10290, 13], "temperature": 0.0, "avg_logprob": -0.15847286481535836, "compression_ratio": 1.5509259259259258, "no_speech_prob": 0.00012924234033562243}, {"id": 25, "seek": 13428, "start": 134.28, "end": 139.68, "text": " Later on in the session, we will also have an update about the Flang compiler, which", "tokens": [11965, 322, 294, 264, 5481, 11, 321, 486, 611, 362, 364, 5623, 466, 264, 3235, 656, 31958, 11, 597], "temperature": 0.0, "avg_logprob": -0.16301153220382392, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.00015839120896998793}, {"id": 26, "seek": 13428, "start": 139.68, "end": 145.52, "text": " also uses MLIR to define its own intermediate representation.", "tokens": [611, 4960, 21601, 7740, 281, 6964, 1080, 1065, 19376, 10290, 13], "temperature": 0.0, "avg_logprob": -0.16301153220382392, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.00015839120896998793}, {"id": 27, "seek": 13428, "start": 145.52, "end": 151.36, "text": " And these dialects that can be part either of MLIR core, meaning they are in upstream,", "tokens": [400, 613, 24652, 82, 300, 393, 312, 644, 2139, 295, 21601, 7740, 4965, 11, 3620, 436, 366, 294, 33915, 11], "temperature": 0.0, "avg_logprob": -0.16301153220382392, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.00015839120896998793}, {"id": 28, "seek": 13428, "start": 151.36, "end": 156.52, "text": " like the hung dialect, which gives you the ability to define what a function is, or there's", "tokens": [411, 264, 5753, 24652, 11, 597, 2709, 291, 264, 3485, 281, 6964, 437, 257, 2445, 307, 11, 420, 456, 311], "temperature": 0.0, "avg_logprob": -0.16301153220382392, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.00015839120896998793}, {"id": 29, "seek": 13428, "start": 156.52, "end": 162.36, "text": " also an LLVM IR dialect, which actually mirrors what LLVM IR is.", "tokens": [611, 364, 441, 43, 53, 44, 16486, 24652, 11, 597, 767, 24238, 437, 441, 43, 53, 44, 16486, 307, 13], "temperature": 0.0, "avg_logprob": -0.16301153220382392, "compression_ratio": 1.638655462184874, "no_speech_prob": 0.00015839120896998793}, {"id": 30, "seek": 16236, "start": 162.36, "end": 169.20000000000002, "text": " But it is modeled in MLIR, sorry, what LLVM IR is, but it is modeled in MLIR.", "tokens": [583, 309, 307, 37140, 294, 21601, 7740, 11, 2597, 11, 437, 441, 43, 53, 44, 16486, 307, 11, 457, 309, 307, 37140, 294, 21601, 7740, 13], "temperature": 0.0, "avg_logprob": -0.1975482274027704, "compression_ratio": 1.5817307692307692, "no_speech_prob": 6.202243093866855e-05}, {"id": 31, "seek": 16236, "start": 169.20000000000002, "end": 175.12, "text": " There are tons of other dialects, like a GPU dialect, a Tosa dialect, which is the", "tokens": [821, 366, 9131, 295, 661, 24652, 82, 11, 411, 257, 18407, 24652, 11, 257, 314, 6447, 24652, 11, 597, 307, 264], "temperature": 0.0, "avg_logprob": -0.1975482274027704, "compression_ratio": 1.5817307692307692, "no_speech_prob": 6.202243093866855e-05}, {"id": 32, "seek": 16236, "start": 175.12, "end": 181.52, "text": " tensor-operate set architecture, or MTC, which I am one of the developers behind.", "tokens": [40863, 12, 7192, 473, 992, 9482, 11, 420, 376, 18238, 11, 597, 286, 669, 472, 295, 264, 8849, 2261, 13], "temperature": 0.0, "avg_logprob": -0.1975482274027704, "compression_ratio": 1.5817307692307692, "no_speech_prob": 6.202243093866855e-05}, {"id": 33, "seek": 16236, "start": 181.52, "end": 187.44000000000003, "text": " And there are also many, many out-of-tree dialects, like the SORC project is using it,", "tokens": [400, 456, 366, 611, 867, 11, 867, 484, 12, 2670, 12, 83, 701, 24652, 82, 11, 411, 264, 318, 2483, 34, 1716, 307, 1228, 309, 11], "temperature": 0.0, "avg_logprob": -0.1975482274027704, "compression_ratio": 1.5817307692307692, "no_speech_prob": 6.202243093866855e-05}, {"id": 34, "seek": 18744, "start": 187.44, "end": 192.72, "text": " or Torch MLIR, which is actually modeling PyTorch in MLIR.", "tokens": [420, 7160, 339, 21601, 7740, 11, 597, 307, 767, 15983, 9953, 51, 284, 339, 294, 21601, 7740, 13], "temperature": 0.0, "avg_logprob": -0.12685179710388184, "compression_ratio": 1.547945205479452, "no_speech_prob": 8.475763752358034e-05}, {"id": 35, "seek": 18744, "start": 192.72, "end": 196.44, "text": " Many, many more, and these are considered as out-of-tree.", "tokens": [5126, 11, 867, 544, 11, 293, 613, 366, 4888, 382, 484, 12, 2670, 12, 83, 701, 13], "temperature": 0.0, "avg_logprob": -0.12685179710388184, "compression_ratio": 1.547945205479452, "no_speech_prob": 8.475763752358034e-05}, {"id": 36, "seek": 18744, "start": 196.44, "end": 202.2, "text": " So when we look at the standalone example, which is really a brilliant starter when you", "tokens": [407, 562, 321, 574, 412, 264, 37454, 1365, 11, 597, 307, 534, 257, 10248, 22465, 562, 291], "temperature": 0.0, "avg_logprob": -0.12685179710388184, "compression_ratio": 1.547945205479452, "no_speech_prob": 8.475763752358034e-05}, {"id": 37, "seek": 18744, "start": 202.2, "end": 210.0, "text": " want to create your own dialect, you find it as part of the LLVM Mono repository, and", "tokens": [528, 281, 1884, 428, 1065, 24652, 11, 291, 915, 309, 382, 644, 295, 264, 441, 43, 53, 44, 4713, 78, 25841, 11, 293], "temperature": 0.0, "avg_logprob": -0.12685179710388184, "compression_ratio": 1.547945205479452, "no_speech_prob": 8.475763752358034e-05}, {"id": 38, "seek": 18744, "start": 210.0, "end": 214.6, "text": " you can just build it against an installed LLVM.", "tokens": [291, 393, 445, 1322, 309, 1970, 364, 8899, 441, 43, 53, 44, 13], "temperature": 0.0, "avg_logprob": -0.12685179710388184, "compression_ratio": 1.547945205479452, "no_speech_prob": 8.475763752358034e-05}, {"id": 39, "seek": 21460, "start": 214.6, "end": 220.2, "text": " You can just run CMake, configure it accordingly.", "tokens": [509, 393, 445, 1190, 20424, 619, 11, 22162, 309, 19717, 13], "temperature": 0.0, "avg_logprob": -0.15754420214360304, "compression_ratio": 1.5815899581589958, "no_speech_prob": 4.9851860239868984e-05}, {"id": 40, "seek": 21460, "start": 220.2, "end": 226.2, "text": " You just need to pass where you find your installed MLIR and where the LLVM external", "tokens": [509, 445, 643, 281, 1320, 689, 291, 915, 428, 8899, 21601, 7740, 293, 689, 264, 441, 43, 53, 44, 8320], "temperature": 0.0, "avg_logprob": -0.15754420214360304, "compression_ratio": 1.5815899581589958, "no_speech_prob": 4.9851860239868984e-05}, {"id": 41, "seek": 21460, "start": 226.2, "end": 229.51999999999998, "text": " lit is present.", "tokens": [7997, 307, 1974, 13], "temperature": 0.0, "avg_logprob": -0.15754420214360304, "compression_ratio": 1.5815899581589958, "no_speech_prob": 4.9851860239868984e-05}, {"id": 42, "seek": 21460, "start": 229.51999999999998, "end": 233.84, "text": " And actually, then you can just build your target, which is here's a check standalone.", "tokens": [400, 767, 11, 550, 291, 393, 445, 1322, 428, 3779, 11, 597, 307, 510, 311, 257, 1520, 37454, 13], "temperature": 0.0, "avg_logprob": -0.15754420214360304, "compression_ratio": 1.5815899581589958, "no_speech_prob": 4.9851860239868984e-05}, {"id": 43, "seek": 21460, "start": 233.84, "end": 237.88, "text": " It builds all the tools and further runs some tests.", "tokens": [467, 15182, 439, 264, 3873, 293, 3052, 6676, 512, 6921, 13], "temperature": 0.0, "avg_logprob": -0.15754420214360304, "compression_ratio": 1.5815899581589958, "no_speech_prob": 4.9851860239868984e-05}, {"id": 44, "seek": 21460, "start": 237.88, "end": 243.04, "text": " This actually assumes, as I have mentioned, that LLVM and MLIR are built here and built", "tokens": [639, 767, 37808, 11, 382, 286, 362, 2835, 11, 300, 441, 43, 53, 44, 293, 21601, 7740, 366, 3094, 510, 293, 3094], "temperature": 0.0, "avg_logprob": -0.15754420214360304, "compression_ratio": 1.5815899581589958, "no_speech_prob": 4.9851860239868984e-05}, {"id": 45, "seek": 24304, "start": 243.04, "end": 246.32, "text": " here, and then they are installed to prefix.", "tokens": [510, 11, 293, 550, 436, 366, 8899, 281, 46969, 13], "temperature": 0.0, "avg_logprob": -0.13409546705392691, "compression_ratio": 1.5625, "no_speech_prob": 6.813630898250267e-05}, {"id": 46, "seek": 24304, "start": 246.32, "end": 250.2, "text": " And that corresponds to out-of-tree somehow.", "tokens": [400, 300, 23249, 281, 484, 12, 2670, 12, 83, 701, 6063, 13], "temperature": 0.0, "avg_logprob": -0.13409546705392691, "compression_ratio": 1.5625, "no_speech_prob": 6.813630898250267e-05}, {"id": 47, "seek": 24304, "start": 250.2, "end": 258.52, "text": " And for me, when I began with LLVM or MLIR, I was not a compiler developer, but I had", "tokens": [400, 337, 385, 11, 562, 286, 4283, 365, 441, 43, 53, 44, 420, 21601, 7740, 11, 286, 390, 406, 257, 31958, 10754, 11, 457, 286, 632], "temperature": 0.0, "avg_logprob": -0.13409546705392691, "compression_ratio": 1.5625, "no_speech_prob": 6.813630898250267e-05}, {"id": 48, "seek": 24304, "start": 258.52, "end": 264.59999999999997, "text": " some experience in CMake and how these terms out-of-tree are used in LLVM and MLIR and", "tokens": [512, 1752, 294, 20424, 619, 293, 577, 613, 2115, 484, 12, 2670, 12, 83, 701, 366, 1143, 294, 441, 43, 53, 44, 293, 21601, 7740, 293], "temperature": 0.0, "avg_logprob": -0.13409546705392691, "compression_ratio": 1.5625, "no_speech_prob": 6.813630898250267e-05}, {"id": 49, "seek": 24304, "start": 264.59999999999997, "end": 270.88, "text": " the outer world are sometimes confusing, so I want to give at least a short definition.", "tokens": [264, 10847, 1002, 366, 2171, 13181, 11, 370, 286, 528, 281, 976, 412, 1935, 257, 2099, 7123, 13], "temperature": 0.0, "avg_logprob": -0.13409546705392691, "compression_ratio": 1.5625, "no_speech_prob": 6.813630898250267e-05}, {"id": 50, "seek": 27088, "start": 270.88, "end": 278.84, "text": " So in the LLVM world, entry also often or nearly every time refers to a monolithic build.", "tokens": [407, 294, 264, 441, 43, 53, 44, 1002, 11, 8729, 611, 2049, 420, 6217, 633, 565, 14942, 281, 257, 1108, 42878, 1322, 13], "temperature": 0.0, "avg_logprob": -0.11821587346181148, "compression_ratio": 1.6382978723404256, "no_speech_prob": 1.4963843568693846e-05}, {"id": 51, "seek": 27088, "start": 278.84, "end": 285.24, "text": " That means you build LLVM or your LLVM subproject plus your dialects or whatever.", "tokens": [663, 1355, 291, 1322, 441, 43, 53, 44, 420, 428, 441, 43, 53, 44, 1422, 4318, 1020, 1804, 428, 24652, 82, 420, 2035, 13], "temperature": 0.0, "avg_logprob": -0.11821587346181148, "compression_ratio": 1.6382978723404256, "no_speech_prob": 1.4963843568693846e-05}, {"id": 52, "seek": 27088, "start": 285.24, "end": 287.8, "text": " Entry can refer to the source location.", "tokens": [3951, 627, 393, 2864, 281, 264, 4009, 4914, 13], "temperature": 0.0, "avg_logprob": -0.11821587346181148, "compression_ratio": 1.6382978723404256, "no_speech_prob": 1.4963843568693846e-05}, {"id": 53, "seek": 27088, "start": 287.8, "end": 293.32, "text": " So here we have an out-of-tree dialect, which is however part of the LLVM monorepo, but", "tokens": [407, 510, 321, 362, 364, 484, 12, 2670, 12, 83, 701, 24652, 11, 597, 307, 4461, 644, 295, 264, 441, 43, 53, 44, 1108, 418, 2259, 11, 457], "temperature": 0.0, "avg_logprob": -0.11821587346181148, "compression_ratio": 1.6382978723404256, "no_speech_prob": 1.4963843568693846e-05}, {"id": 54, "seek": 27088, "start": 293.32, "end": 299.71999999999997, "text": " it's considered out-of-tree because you can pull it out and you don't need to have it", "tokens": [309, 311, 4888, 484, 12, 2670, 12, 83, 701, 570, 291, 393, 2235, 309, 484, 293, 291, 500, 380, 643, 281, 362, 309], "temperature": 0.0, "avg_logprob": -0.11821587346181148, "compression_ratio": 1.6382978723404256, "no_speech_prob": 1.4963843568693846e-05}, {"id": 55, "seek": 29972, "start": 299.72, "end": 301.40000000000003, "text": " in the monorepo.", "tokens": [294, 264, 1108, 418, 2259, 13], "temperature": 0.0, "avg_logprob": -0.13227894774868956, "compression_ratio": 1.6577946768060836, "no_speech_prob": 3.1689880415797234e-05}, {"id": 56, "seek": 29972, "start": 301.40000000000003, "end": 306.40000000000003, "text": " So out-of-tree normally refers to work with a separate repository.", "tokens": [407, 484, 12, 2670, 12, 83, 701, 5646, 14942, 281, 589, 365, 257, 4994, 25841, 13], "temperature": 0.0, "avg_logprob": -0.13227894774868956, "compression_ratio": 1.6577946768060836, "no_speech_prob": 3.1689880415797234e-05}, {"id": 57, "seek": 29972, "start": 306.40000000000003, "end": 311.72, "text": " However, there is also a mechanism which you can use to build your project with this LLVM", "tokens": [2908, 11, 456, 307, 611, 257, 7513, 597, 291, 393, 764, 281, 1322, 428, 1716, 365, 341, 441, 43, 53, 44], "temperature": 0.0, "avg_logprob": -0.13227894774868956, "compression_ratio": 1.6577946768060836, "no_speech_prob": 3.1689880415797234e-05}, {"id": 58, "seek": 29972, "start": 311.72, "end": 317.96000000000004, "text": " external projects mechanism, and projects using this, and if you look into their CMake configuration", "tokens": [8320, 4455, 7513, 11, 293, 4455, 1228, 341, 11, 293, 498, 291, 574, 666, 641, 20424, 619, 11694], "temperature": 0.0, "avg_logprob": -0.13227894774868956, "compression_ratio": 1.6577946768060836, "no_speech_prob": 3.1689880415797234e-05}, {"id": 59, "seek": 29972, "start": 317.96000000000004, "end": 323.16, "text": " or into other tutorials, either they call it out-of-tree monolithic build.", "tokens": [420, 666, 661, 17616, 11, 2139, 436, 818, 309, 484, 12, 2670, 12, 83, 701, 1108, 42878, 1322, 13], "temperature": 0.0, "avg_logprob": -0.13227894774868956, "compression_ratio": 1.6577946768060836, "no_speech_prob": 3.1689880415797234e-05}, {"id": 60, "seek": 29972, "start": 323.16, "end": 328.48, "text": " So it's not a component build like you have against an installed MLIR or LLVM, or they", "tokens": [407, 309, 311, 406, 257, 6542, 1322, 411, 291, 362, 1970, 364, 8899, 21601, 7740, 420, 441, 43, 53, 44, 11, 420, 436], "temperature": 0.0, "avg_logprob": -0.13227894774868956, "compression_ratio": 1.6577946768060836, "no_speech_prob": 3.1689880415797234e-05}, {"id": 61, "seek": 32848, "start": 328.48, "end": 333.52000000000004, "text": " even call it entry, which is somehow confusing because when you look to CMake, normally infantry", "tokens": [754, 818, 309, 8729, 11, 597, 307, 6063, 13181, 570, 562, 291, 574, 281, 20424, 619, 11, 5646, 30887], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 62, "seek": 32848, "start": 333.52000000000004, "end": 339.16, "text": " just means you're building where your source code lives, which is actually a bad practice.", "tokens": [445, 1355, 291, 434, 2390, 689, 428, 4009, 3089, 2909, 11, 597, 307, 767, 257, 1578, 3124, 13], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 63, "seek": 32848, "start": 339.16, "end": 340.66, "text": " You shouldn't do this.", "tokens": [509, 4659, 380, 360, 341, 13], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 64, "seek": 32848, "start": 340.66, "end": 342.24, "text": " Normally you do out-of-tree builds.", "tokens": [17424, 291, 360, 484, 12, 2670, 12, 83, 701, 15182, 13], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 65, "seek": 32848, "start": 342.24, "end": 347.64000000000004, "text": " It just means you create a separate directory where you set up your configuration and where", "tokens": [467, 445, 1355, 291, 1884, 257, 4994, 21120, 689, 291, 992, 493, 428, 11694, 293, 689], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 66, "seek": 32848, "start": 347.64000000000004, "end": 348.8, "text": " you do your build.", "tokens": [291, 360, 428, 1322, 13], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 67, "seek": 32848, "start": 348.8, "end": 355.40000000000003, "text": " This can also be a sub-directory in the source tree, but it's a separate directory not checked", "tokens": [639, 393, 611, 312, 257, 1422, 12, 44868, 827, 294, 264, 4009, 4230, 11, 457, 309, 311, 257, 4994, 21120, 406, 10033], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 68, "seek": 32848, "start": 355.40000000000003, "end": 357.92, "text": " into your Git later on.", "tokens": [666, 428, 16939, 1780, 322, 13], "temperature": 0.0, "avg_logprob": -0.13486036190316697, "compression_ratio": 1.75, "no_speech_prob": 2.392235546722077e-05}, {"id": 69, "seek": 35792, "start": 357.92, "end": 365.44, "text": " So within this talk, I just call it the external project mechanism.", "tokens": [407, 1951, 341, 751, 11, 286, 445, 818, 309, 264, 8320, 1716, 7513, 13], "temperature": 0.0, "avg_logprob": -0.11417773600374714, "compression_ratio": 1.4594594594594594, "no_speech_prob": 2.1110281522851437e-05}, {"id": 70, "seek": 35792, "start": 365.44, "end": 370.04, "text": " For me, it's always an out-of-tree build, regardless of what I do.", "tokens": [1171, 385, 11, 309, 311, 1009, 364, 484, 12, 2670, 12, 83, 701, 1322, 11, 10060, 295, 437, 286, 360, 13], "temperature": 0.0, "avg_logprob": -0.11417773600374714, "compression_ratio": 1.4594594594594594, "no_speech_prob": 2.1110281522851437e-05}, {"id": 71, "seek": 35792, "start": 370.04, "end": 375.92, "text": " Even if I build LLVM, I wouldn't call it personally entry because I'm using the CMake notation", "tokens": [2754, 498, 286, 1322, 441, 43, 53, 44, 11, 286, 2759, 380, 818, 309, 5665, 8729, 570, 286, 478, 1228, 264, 20424, 619, 24657], "temperature": 0.0, "avg_logprob": -0.11417773600374714, "compression_ratio": 1.4594594594594594, "no_speech_prob": 2.1110281522851437e-05}, {"id": 72, "seek": 35792, "start": 375.92, "end": 382.32, "text": " normally just to make it clear when you look into some of the projects and don't get confused.", "tokens": [5646, 445, 281, 652, 309, 1850, 562, 291, 574, 666, 512, 295, 264, 4455, 293, 500, 380, 483, 9019, 13], "temperature": 0.0, "avg_logprob": -0.11417773600374714, "compression_ratio": 1.4594594594594594, "no_speech_prob": 2.1110281522851437e-05}, {"id": 73, "seek": 38232, "start": 382.32, "end": 389.04, "text": " So what we can do is we can extend the standalone project by this LLVM external projects mechanism", "tokens": [407, 437, 321, 393, 360, 307, 321, 393, 10101, 264, 37454, 1716, 538, 341, 441, 43, 53, 44, 8320, 4455, 7513], "temperature": 0.0, "avg_logprob": -0.19915695623918014, "compression_ratio": 1.4862385321100917, "no_speech_prob": 2.627204048621934e-05}, {"id": 74, "seek": 38232, "start": 389.04, "end": 391.68, "text": " and the question is, why should we do this?", "tokens": [293, 264, 1168, 307, 11, 983, 820, 321, 360, 341, 30], "temperature": 0.0, "avg_logprob": -0.19915695623918014, "compression_ratio": 1.4862385321100917, "no_speech_prob": 2.627204048621934e-05}, {"id": 75, "seek": 38232, "start": 391.68, "end": 397.08, "text": " So Stephen Noindover gave a great tutorial about how to architecture LLVM projects at", "tokens": [407, 13391, 883, 471, 3570, 2729, 257, 869, 7073, 466, 577, 281, 9482, 441, 43, 53, 44, 4455, 412], "temperature": 0.0, "avg_logprob": -0.19915695623918014, "compression_ratio": 1.4862385321100917, "no_speech_prob": 2.627204048621934e-05}, {"id": 76, "seek": 38232, "start": 397.08, "end": 400.88, "text": " the LLVM DevMitting 2021, which is available on YouTube.", "tokens": [264, 441, 43, 53, 44, 9096, 44, 2414, 7201, 11, 597, 307, 2435, 322, 3088, 13], "temperature": 0.0, "avg_logprob": -0.19915695623918014, "compression_ratio": 1.4862385321100917, "no_speech_prob": 2.627204048621934e-05}, {"id": 77, "seek": 38232, "start": 400.88, "end": 405.92, "text": " I also have the link in my references.", "tokens": [286, 611, 362, 264, 2113, 294, 452, 15400, 13], "temperature": 0.0, "avg_logprob": -0.19915695623918014, "compression_ratio": 1.4862385321100917, "no_speech_prob": 2.627204048621934e-05}, {"id": 78, "seek": 40592, "start": 405.92, "end": 414.0, "text": " Here we are referring to a monolithic build and in his tutorial, he says, use the component", "tokens": [1692, 321, 366, 13761, 281, 257, 1108, 42878, 1322, 293, 294, 702, 7073, 11, 415, 1619, 11, 764, 264, 6542], "temperature": 0.0, "avg_logprob": -0.19952810816017977, "compression_ratio": 1.5406698564593302, "no_speech_prob": 3.372218270669691e-05}, {"id": 79, "seek": 40592, "start": 414.0, "end": 415.0, "text": " build.", "tokens": [1322, 13], "temperature": 0.0, "avg_logprob": -0.19952810816017977, "compression_ratio": 1.5406698564593302, "no_speech_prob": 3.372218270669691e-05}, {"id": 80, "seek": 40592, "start": 415.0, "end": 418.16, "text": " That is what the standalone project already gives you.", "tokens": [663, 307, 437, 264, 37454, 1716, 1217, 2709, 291, 13], "temperature": 0.0, "avg_logprob": -0.19952810816017977, "compression_ratio": 1.5406698564593302, "no_speech_prob": 3.372218270669691e-05}, {"id": 81, "seek": 40592, "start": 418.16, "end": 423.12, "text": " But there are some benefits when you maybe want to use the LLVM external projects.", "tokens": [583, 456, 366, 512, 5311, 562, 291, 1310, 528, 281, 764, 264, 441, 43, 53, 44, 8320, 4455, 13], "temperature": 0.0, "avg_logprob": -0.19952810816017977, "compression_ratio": 1.5406698564593302, "no_speech_prob": 3.372218270669691e-05}, {"id": 82, "seek": 40592, "start": 423.12, "end": 428.52000000000004, "text": " So what we actually do is when we developed the IMHC dialect, we developed this as an", "tokens": [407, 437, 321, 767, 360, 307, 562, 321, 4743, 264, 21463, 39, 34, 24652, 11, 321, 4743, 341, 382, 364], "temperature": 0.0, "avg_logprob": -0.19952810816017977, "compression_ratio": 1.5406698564593302, "no_speech_prob": 3.372218270669691e-05}, {"id": 83, "seek": 42852, "start": 428.52, "end": 438.91999999999996, "text": " out of three dialect, completely independent or buildable against an installed MLIR version.", "tokens": [484, 295, 1045, 24652, 11, 2584, 6695, 420, 1322, 712, 1970, 364, 8899, 21601, 7740, 3037, 13], "temperature": 0.0, "avg_logprob": -0.1566810378109116, "compression_ratio": 1.5188679245283019, "no_speech_prob": 7.599843956995755e-05}, {"id": 84, "seek": 42852, "start": 438.91999999999996, "end": 443.71999999999997, "text": " IMHC is now part of the MLIR core, so it's upstreamed.", "tokens": [21463, 39, 34, 307, 586, 644, 295, 264, 21601, 7740, 4965, 11, 370, 309, 311, 33915, 292, 13], "temperature": 0.0, "avg_logprob": -0.1566810378109116, "compression_ratio": 1.5188679245283019, "no_speech_prob": 7.599843956995755e-05}, {"id": 85, "seek": 42852, "start": 443.71999999999997, "end": 449.79999999999995, "text": " And what we normally do is, or what's quite nice is, sometimes we want to look into when", "tokens": [400, 437, 321, 5646, 360, 307, 11, 420, 437, 311, 1596, 1481, 307, 11, 2171, 321, 528, 281, 574, 666, 562], "temperature": 0.0, "avg_logprob": -0.1566810378109116, "compression_ratio": 1.5188679245283019, "no_speech_prob": 7.599843956995755e-05}, {"id": 86, "seek": 42852, "start": 449.79999999999995, "end": 455.32, "text": " we change our dialect upstream or when we extend it, how does it behave together with", "tokens": [321, 1319, 527, 24652, 33915, 420, 562, 321, 10101, 309, 11, 577, 775, 309, 15158, 1214, 365], "temperature": 0.0, "avg_logprob": -0.1566810378109116, "compression_ratio": 1.5188679245283019, "no_speech_prob": 7.599843956995755e-05}, {"id": 87, "seek": 45532, "start": 455.32, "end": 461.0, "text": " these out of three source, which we still have, all our conversions, all our transformations", "tokens": [613, 484, 295, 1045, 4009, 11, 597, 321, 920, 362, 11, 439, 527, 42256, 11, 439, 527, 34852], "temperature": 0.0, "avg_logprob": -0.1481588568006243, "compression_ratio": 1.778225806451613, "no_speech_prob": 7.252168870763853e-05}, {"id": 88, "seek": 45532, "start": 461.0, "end": 463.84, "text": " are not upstreamed yet.", "tokens": [366, 406, 33915, 292, 1939, 13], "temperature": 0.0, "avg_logprob": -0.1481588568006243, "compression_ratio": 1.778225806451613, "no_speech_prob": 7.252168870763853e-05}, {"id": 89, "seek": 45532, "start": 463.84, "end": 468.71999999999997, "text": " And it is quite nice to build it as a run project because you can easily debug into,", "tokens": [400, 309, 307, 1596, 1481, 281, 1322, 309, 382, 257, 1190, 1716, 570, 291, 393, 3612, 24083, 666, 11], "temperature": 0.0, "avg_logprob": -0.1481588568006243, "compression_ratio": 1.778225806451613, "no_speech_prob": 7.252168870763853e-05}, {"id": 90, "seek": 45532, "start": 468.71999999999997, "end": 475.08, "text": " you don't have to keep your installation and what you're building out of source, you don't", "tokens": [291, 500, 380, 362, 281, 1066, 428, 13260, 293, 437, 291, 434, 2390, 484, 295, 4009, 11, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.1481588568006243, "compression_ratio": 1.778225806451613, "no_speech_prob": 7.252168870763853e-05}, {"id": 91, "seek": 45532, "start": 475.08, "end": 477.68, "text": " have to keep this in sync, you just have a monolithic build.", "tokens": [362, 281, 1066, 341, 294, 20271, 11, 291, 445, 362, 257, 1108, 42878, 1322, 13], "temperature": 0.0, "avg_logprob": -0.1481588568006243, "compression_ratio": 1.778225806451613, "no_speech_prob": 7.252168870763853e-05}, {"id": 92, "seek": 45532, "start": 477.68, "end": 482.76, "text": " So there are some benefits and we just want to look into what do we need to do to build", "tokens": [407, 456, 366, 512, 5311, 293, 321, 445, 528, 281, 574, 666, 437, 360, 321, 643, 281, 360, 281, 1322], "temperature": 0.0, "avg_logprob": -0.1481588568006243, "compression_ratio": 1.778225806451613, "no_speech_prob": 7.252168870763853e-05}, {"id": 93, "seek": 48276, "start": 482.76, "end": 486.4, "text": " it with the LLVM external project mechanism.", "tokens": [309, 365, 264, 441, 43, 53, 44, 8320, 1716, 7513, 13], "temperature": 0.0, "avg_logprob": -0.17450255614060622, "compression_ratio": 1.579646017699115, "no_speech_prob": 0.00011230266682105139}, {"id": 94, "seek": 48276, "start": 486.4, "end": 493.76, "text": " So we are creating our build directory again, then we have to define the LLVM targets to", "tokens": [407, 321, 366, 4084, 527, 1322, 21120, 797, 11, 550, 321, 362, 281, 6964, 264, 441, 43, 53, 44, 12911, 281], "temperature": 0.0, "avg_logprob": -0.17450255614060622, "compression_ratio": 1.579646017699115, "no_speech_prob": 0.00011230266682105139}, {"id": 95, "seek": 48276, "start": 493.76, "end": 494.76, "text": " build.", "tokens": [1322, 13], "temperature": 0.0, "avg_logprob": -0.17450255614060622, "compression_ratio": 1.579646017699115, "no_speech_prob": 0.00011230266682105139}, {"id": 96, "seek": 48276, "start": 494.76, "end": 498.76, "text": " So here you need to specify for which architect you want to build LLVM.", "tokens": [407, 510, 291, 643, 281, 16500, 337, 597, 6331, 291, 528, 281, 1322, 441, 43, 53, 44, 13], "temperature": 0.0, "avg_logprob": -0.17450255614060622, "compression_ratio": 1.579646017699115, "no_speech_prob": 0.00011230266682105139}, {"id": 97, "seek": 48276, "start": 498.76, "end": 502.84, "text": " So here it's just host or x86, which is also an option.", "tokens": [407, 510, 309, 311, 445, 3975, 420, 2031, 22193, 11, 597, 307, 611, 364, 3614, 13], "temperature": 0.0, "avg_logprob": -0.17450255614060622, "compression_ratio": 1.579646017699115, "no_speech_prob": 0.00011230266682105139}, {"id": 98, "seek": 48276, "start": 502.84, "end": 510.24, "text": " You must specify the build type, either release, debug, minstars with relinfo, whatever.", "tokens": [509, 1633, 16500, 264, 1322, 2010, 11, 2139, 4374, 11, 24083, 11, 923, 372, 685, 365, 1039, 259, 16931, 11, 2035, 13], "temperature": 0.0, "avg_logprob": -0.17450255614060622, "compression_ratio": 1.579646017699115, "no_speech_prob": 0.00011230266682105139}, {"id": 99, "seek": 51024, "start": 510.24, "end": 516.4, "text": " And we need to enable our project MLIR, otherwise it's not build.", "tokens": [400, 321, 643, 281, 9528, 527, 1716, 21601, 7740, 11, 5911, 309, 311, 406, 1322, 13], "temperature": 0.0, "avg_logprob": -0.15922804002637986, "compression_ratio": 1.7894736842105263, "no_speech_prob": 7.60059047024697e-05}, {"id": 100, "seek": 51024, "start": 516.4, "end": 524.52, "text": " And in addition to that, as we want to build our standalone project, we specify LLVM external", "tokens": [400, 294, 4500, 281, 300, 11, 382, 321, 528, 281, 1322, 527, 37454, 1716, 11, 321, 16500, 441, 43, 53, 44, 8320], "temperature": 0.0, "avg_logprob": -0.15922804002637986, "compression_ratio": 1.7894736842105263, "no_speech_prob": 7.60059047024697e-05}, {"id": 101, "seek": 51024, "start": 524.52, "end": 528.4, "text": " projects, standalone dialect, which is our project name.", "tokens": [4455, 11, 37454, 24652, 11, 597, 307, 527, 1716, 1315, 13], "temperature": 0.0, "avg_logprob": -0.15922804002637986, "compression_ratio": 1.7894736842105263, "no_speech_prob": 7.60059047024697e-05}, {"id": 102, "seek": 51024, "start": 528.4, "end": 534.16, "text": " And furthermore, we specify LLVM external standalone dialect source tree to specify where", "tokens": [400, 3052, 3138, 11, 321, 16500, 441, 43, 53, 44, 8320, 37454, 24652, 4009, 4230, 281, 16500, 689], "temperature": 0.0, "avg_logprob": -0.15922804002637986, "compression_ratio": 1.7894736842105263, "no_speech_prob": 7.60059047024697e-05}, {"id": 103, "seek": 53416, "start": 534.16, "end": 542.0799999999999, "text": " do we find our source, that are the two additional parameters you need to pass.", "tokens": [360, 321, 915, 527, 4009, 11, 300, 366, 264, 732, 4497, 9834, 291, 643, 281, 1320, 13], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 104, "seek": 53416, "start": 542.0799999999999, "end": 547.24, "text": " And here LLVM source tier, actually, we assume that it points to the root of our monorepo", "tokens": [400, 510, 441, 43, 53, 44, 4009, 12362, 11, 767, 11, 321, 6552, 300, 309, 2793, 281, 264, 5593, 295, 527, 1108, 418, 2259], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 105, "seek": 53416, "start": 547.24, "end": 548.36, "text": " checked out.", "tokens": [10033, 484, 13], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 106, "seek": 53416, "start": 548.36, "end": 550.92, "text": " So that is what we want to have later on.", "tokens": [407, 300, 307, 437, 321, 528, 281, 362, 1780, 322, 13], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 107, "seek": 53416, "start": 550.92, "end": 553.48, "text": " Right now the standalone example can't do this.", "tokens": [1779, 586, 264, 37454, 1365, 393, 380, 360, 341, 13], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 108, "seek": 53416, "start": 553.48, "end": 557.68, "text": " What do we need to change to make this possible?", "tokens": [708, 360, 321, 643, 281, 1319, 281, 652, 341, 1944, 30], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 109, "seek": 53416, "start": 557.68, "end": 563.48, "text": " So right now it's looking like the following, looking to the main CMake configuration and", "tokens": [407, 558, 586, 309, 311, 1237, 411, 264, 3480, 11, 1237, 281, 264, 2135, 20424, 619, 11694, 293], "temperature": 0.0, "avg_logprob": -0.14273502176458186, "compression_ratio": 1.60546875, "no_speech_prob": 4.468885526875965e-05}, {"id": 110, "seek": 56348, "start": 563.48, "end": 570.12, "text": " what is important here is we have find package, we call find package MLIR, and find package", "tokens": [437, 307, 1021, 510, 307, 321, 362, 915, 7372, 11, 321, 818, 915, 7372, 21601, 7740, 11, 293, 915, 7372], "temperature": 0.0, "avg_logprob": -0.1390551300935967, "compression_ratio": 1.7772020725388602, "no_speech_prob": 0.00014647039643023163}, {"id": 111, "seek": 56348, "start": 570.12, "end": 574.88, "text": " in general imports information which were exported by a project.", "tokens": [294, 2674, 41596, 1589, 597, 645, 42055, 538, 257, 1716, 13], "temperature": 0.0, "avg_logprob": -0.1390551300935967, "compression_ratio": 1.7772020725388602, "no_speech_prob": 0.00014647039643023163}, {"id": 112, "seek": 56348, "start": 574.88, "end": 580.76, "text": " So here find package imports information from the installed MLIR version.", "tokens": [407, 510, 915, 7372, 41596, 1589, 490, 264, 8899, 21601, 7740, 3037, 13], "temperature": 0.0, "avg_logprob": -0.1390551300935967, "compression_ratio": 1.7772020725388602, "no_speech_prob": 0.00014647039643023163}, {"id": 113, "seek": 56348, "start": 580.76, "end": 587.08, "text": " And furthermore, the find package MLIR also calls find package LLVM for us, so we don't", "tokens": [400, 3052, 3138, 11, 264, 915, 7372, 21601, 7740, 611, 5498, 915, 7372, 441, 43, 53, 44, 337, 505, 11, 370, 321, 500, 380], "temperature": 0.0, "avg_logprob": -0.1390551300935967, "compression_ratio": 1.7772020725388602, "no_speech_prob": 0.00014647039643023163}, {"id": 114, "seek": 56348, "start": 587.08, "end": 589.32, "text": " need to care about this.", "tokens": [643, 281, 1127, 466, 341, 13], "temperature": 0.0, "avg_logprob": -0.1390551300935967, "compression_ratio": 1.7772020725388602, "no_speech_prob": 0.00014647039643023163}, {"id": 115, "seek": 58932, "start": 589.32, "end": 599.0, "text": " So then just the MLIR config CMake is actually parsed as well as the LLVM config CMake parsed", "tokens": [407, 550, 445, 264, 21601, 7740, 6662, 20424, 619, 307, 767, 21156, 292, 382, 731, 382, 264, 441, 43, 53, 44, 6662, 20424, 619, 21156, 292], "temperature": 0.0, "avg_logprob": -0.15681674366905576, "compression_ratio": 1.5404040404040404, "no_speech_prob": 7.250108319567516e-05}, {"id": 116, "seek": 58932, "start": 599.0, "end": 606.84, "text": " and we can gladly just do our includes, which adds some further code for us.", "tokens": [293, 321, 393, 47307, 445, 360, 527, 5974, 11, 597, 10860, 512, 3052, 3089, 337, 505, 13], "temperature": 0.0, "avg_logprob": -0.15681674366905576, "compression_ratio": 1.5404040404040404, "no_speech_prob": 7.250108319567516e-05}, {"id": 117, "seek": 58932, "start": 606.84, "end": 612.2800000000001, "text": " So for the external project mechanism build, we don't need to do this.", "tokens": [407, 337, 264, 8320, 1716, 7513, 1322, 11, 321, 500, 380, 643, 281, 360, 341, 13], "temperature": 0.0, "avg_logprob": -0.15681674366905576, "compression_ratio": 1.5404040404040404, "no_speech_prob": 7.250108319567516e-05}, {"id": 118, "seek": 58932, "start": 612.2800000000001, "end": 617.3800000000001, "text": " So what we need to change is we only need to call find package.", "tokens": [407, 437, 321, 643, 281, 1319, 307, 321, 787, 643, 281, 818, 915, 7372, 13], "temperature": 0.0, "avg_logprob": -0.15681674366905576, "compression_ratio": 1.5404040404040404, "no_speech_prob": 7.250108319567516e-05}, {"id": 119, "seek": 61738, "start": 617.38, "end": 621.36, "text": " If there is an installed MLIR otherwise there won't be one because we're just building it", "tokens": [759, 456, 307, 364, 8899, 21601, 7740, 5911, 456, 1582, 380, 312, 472, 570, 321, 434, 445, 2390, 309], "temperature": 0.0, "avg_logprob": -0.1477278679916539, "compression_ratio": 1.6724890829694323, "no_speech_prob": 5.1428982260404155e-05}, {"id": 120, "seek": 61738, "start": 621.36, "end": 623.84, "text": " as part of our build process.", "tokens": [382, 644, 295, 527, 1322, 1399, 13], "temperature": 0.0, "avg_logprob": -0.1477278679916539, "compression_ratio": 1.6724890829694323, "no_speech_prob": 5.1428982260404155e-05}, {"id": 121, "seek": 61738, "start": 623.84, "end": 632.24, "text": " So in that case CMake source here normally is equal to CMake current source here.", "tokens": [407, 294, 300, 1389, 20424, 619, 4009, 510, 5646, 307, 2681, 281, 20424, 619, 2190, 4009, 510, 13], "temperature": 0.0, "avg_logprob": -0.1477278679916539, "compression_ratio": 1.6724890829694323, "no_speech_prob": 5.1428982260404155e-05}, {"id": 122, "seek": 61738, "start": 632.24, "end": 637.4, "text": " If it's not the case we have a different build type and we're just adding this if else block", "tokens": [759, 309, 311, 406, 264, 1389, 321, 362, 257, 819, 1322, 2010, 293, 321, 434, 445, 5127, 341, 498, 1646, 3461], "temperature": 0.0, "avg_logprob": -0.1477278679916539, "compression_ratio": 1.6724890829694323, "no_speech_prob": 5.1428982260404155e-05}, {"id": 123, "seek": 61738, "start": 637.4, "end": 646.36, "text": " and we don't have the need no longer for our other project to load the CMake models with", "tokens": [293, 321, 500, 380, 362, 264, 643, 572, 2854, 337, 527, 661, 1716, 281, 3677, 264, 20424, 619, 5245, 365], "temperature": 0.0, "avg_logprob": -0.1477278679916539, "compression_ratio": 1.6724890829694323, "no_speech_prob": 5.1428982260404155e-05}, {"id": 124, "seek": 64636, "start": 646.36, "end": 647.8000000000001, "text": " include.", "tokens": [4090, 13], "temperature": 0.0, "avg_logprob": -0.22331585884094238, "compression_ratio": 1.5051020408163265, "no_speech_prob": 4.0687282307771966e-05}, {"id": 125, "seek": 64636, "start": 647.8000000000001, "end": 656.84, "text": " And the code we're adding is we're just setting the variables which are not available as export", "tokens": [400, 264, 3089, 321, 434, 5127, 307, 321, 434, 445, 3287, 264, 9102, 597, 366, 406, 2435, 382, 10725], "temperature": 0.0, "avg_logprob": -0.22331585884094238, "compression_ratio": 1.5051020408163265, "no_speech_prob": 4.0687282307771966e-05}, {"id": 126, "seek": 64636, "start": 656.84, "end": 659.24, "text": " a project settings by yourself.", "tokens": [257, 1716, 6257, 538, 1803, 13], "temperature": 0.0, "avg_logprob": -0.22331585884094238, "compression_ratio": 1.5051020408163265, "no_speech_prob": 4.0687282307771966e-05}, {"id": 127, "seek": 64636, "start": 659.24, "end": 664.48, "text": " So MLIR main source here, main include here and that's actually it.", "tokens": [407, 21601, 7740, 2135, 4009, 510, 11, 2135, 4090, 510, 293, 300, 311, 767, 309, 13], "temperature": 0.0, "avg_logprob": -0.22331585884094238, "compression_ratio": 1.5051020408163265, "no_speech_prob": 4.0687282307771966e-05}, {"id": 128, "seek": 64636, "start": 664.48, "end": 668.24, "text": " So that are the few lines we need to make it buildable.", "tokens": [407, 300, 366, 264, 1326, 3876, 321, 643, 281, 652, 309, 1322, 712, 13], "temperature": 0.0, "avg_logprob": -0.22331585884094238, "compression_ratio": 1.5051020408163265, "no_speech_prob": 4.0687282307771966e-05}, {"id": 129, "seek": 64636, "start": 668.24, "end": 671.36, "text": " However, your LIT tests will fail.", "tokens": [2908, 11, 428, 441, 3927, 6921, 486, 3061, 13], "temperature": 0.0, "avg_logprob": -0.22331585884094238, "compression_ratio": 1.5051020408163265, "no_speech_prob": 4.0687282307771966e-05}, {"id": 130, "seek": 67136, "start": 671.36, "end": 676.92, "text": " So there is a little bit more code that we need to modify.", "tokens": [407, 456, 307, 257, 707, 857, 544, 3089, 300, 321, 643, 281, 16927, 13], "temperature": 0.0, "avg_logprob": -0.19640630190489722, "compression_ratio": 1.4219653179190752, "no_speech_prob": 1.618536771275103e-05}, {"id": 131, "seek": 67136, "start": 676.92, "end": 683.48, "text": " Here we just define a standalone source here and standalone binary variables which are", "tokens": [1692, 321, 445, 6964, 257, 37454, 4009, 510, 293, 37454, 17434, 9102, 597, 366], "temperature": 0.0, "avg_logprob": -0.19640630190489722, "compression_ratio": 1.4219653179190752, "no_speech_prob": 1.618536771275103e-05}, {"id": 132, "seek": 67136, "start": 683.48, "end": 688.8000000000001, "text": " then later on used also for include directories.", "tokens": [550, 1780, 322, 1143, 611, 337, 4090, 5391, 530, 13], "temperature": 0.0, "avg_logprob": -0.19640630190489722, "compression_ratio": 1.4219653179190752, "no_speech_prob": 1.618536771275103e-05}, {"id": 133, "seek": 67136, "start": 688.8000000000001, "end": 693.5600000000001, "text": " And we adjust our LIT side CFG upon pi accordingly.", "tokens": [400, 321, 4369, 527, 441, 3927, 1252, 21792, 38, 3564, 3895, 19717, 13], "temperature": 0.0, "avg_logprob": -0.19640630190489722, "compression_ratio": 1.4219653179190752, "no_speech_prob": 1.618536771275103e-05}, {"id": 134, "seek": 69356, "start": 693.56, "end": 702.3199999999999, "text": " So here we actually need to change CMake binary D or CMake source here by our newly set variable.", "tokens": [407, 510, 321, 767, 643, 281, 1319, 20424, 619, 17434, 413, 420, 20424, 619, 4009, 510, 538, 527, 15109, 992, 7006, 13], "temperature": 0.0, "avg_logprob": -0.18916972715463212, "compression_ratio": 1.3832335329341316, "no_speech_prob": 6.143188784335507e-06}, {"id": 135, "seek": 69356, "start": 702.3199999999999, "end": 713.1999999999999, "text": " Otherwise, yeah, the LIT tests are the location of LIT CFG is assumed in the wrong place.", "tokens": [10328, 11, 1338, 11, 264, 441, 3927, 6921, 366, 264, 4914, 295, 441, 3927, 21792, 38, 307, 15895, 294, 264, 2085, 1081, 13], "temperature": 0.0, "avg_logprob": -0.18916972715463212, "compression_ratio": 1.3832335329341316, "no_speech_prob": 6.143188784335507e-06}, {"id": 136, "seek": 69356, "start": 713.1999999999999, "end": 718.52, "text": " So we just fix that here.", "tokens": [407, 321, 445, 3191, 300, 510, 13], "temperature": 0.0, "avg_logprob": -0.18916972715463212, "compression_ratio": 1.3832335329341316, "no_speech_prob": 6.143188784335507e-06}, {"id": 137, "seek": 69356, "start": 718.52, "end": 720.3199999999999, "text": " That's nearly it.", "tokens": [663, 311, 6217, 309, 13], "temperature": 0.0, "avg_logprob": -0.18916972715463212, "compression_ratio": 1.3832335329341316, "no_speech_prob": 6.143188784335507e-06}, {"id": 138, "seek": 72032, "start": 720.32, "end": 726.7600000000001, "text": " So when you now want to use a dialect with other dialects and you have these in several", "tokens": [407, 562, 291, 586, 528, 281, 764, 257, 24652, 365, 661, 24652, 82, 293, 291, 362, 613, 294, 2940], "temperature": 0.0, "avg_logprob": -0.1855042401482077, "compression_ratio": 1.642512077294686, "no_speech_prob": 3.119605389656499e-05}, {"id": 139, "seek": 72032, "start": 726.7600000000001, "end": 733.2, "text": " repositories or with several projects at least, you can either use LLVM external projects", "tokens": [22283, 2083, 420, 365, 2940, 4455, 412, 1935, 11, 291, 393, 2139, 764, 441, 43, 53, 44, 8320, 4455], "temperature": 0.0, "avg_logprob": -0.1855042401482077, "compression_ratio": 1.642512077294686, "no_speech_prob": 3.119605389656499e-05}, {"id": 140, "seek": 72032, "start": 733.2, "end": 734.88, "text": " to build multiple dialects.", "tokens": [281, 1322, 3866, 24652, 82, 13], "temperature": 0.0, "avg_logprob": -0.1855042401482077, "compression_ratio": 1.642512077294686, "no_speech_prob": 3.119605389656499e-05}, {"id": 141, "seek": 72032, "start": 734.88, "end": 738.9200000000001, "text": " Torch MLIR for example is doing exactly this.", "tokens": [7160, 339, 21601, 7740, 337, 1365, 307, 884, 2293, 341, 13], "temperature": 0.0, "avg_logprob": -0.1855042401482077, "compression_ratio": 1.642512077294686, "no_speech_prob": 3.119605389656499e-05}, {"id": 142, "seek": 72032, "start": 738.9200000000001, "end": 745.0, "text": " Another option is to use CMake's external project at which is considered as the cleanest", "tokens": [3996, 3614, 307, 281, 764, 20424, 619, 311, 8320, 1716, 412, 597, 307, 4888, 382, 264, 2541, 377], "temperature": 0.0, "avg_logprob": -0.1855042401482077, "compression_ratio": 1.642512077294686, "no_speech_prob": 3.119605389656499e-05}, {"id": 143, "seek": 74500, "start": 745.0, "end": 752.56, "text": " way as it really keeps the projects enclosed and doesn't transfer variables between the", "tokens": [636, 382, 309, 534, 5965, 264, 4455, 42089, 293, 1177, 380, 5003, 9102, 1296, 264], "temperature": 0.0, "avg_logprob": -0.21849835620206945, "compression_ratio": 1.572192513368984, "no_speech_prob": 0.0001583542616572231}, {"id": 144, "seek": 74500, "start": 752.56, "end": 753.56, "text": " projects.", "tokens": [4455, 13], "temperature": 0.0, "avg_logprob": -0.21849835620206945, "compression_ratio": 1.572192513368984, "no_speech_prob": 0.0001583542616572231}, {"id": 145, "seek": 74500, "start": 753.56, "end": 762.28, "text": " However, what I normally do is I use a sub directory, but in addition with the exclude", "tokens": [2908, 11, 437, 286, 5646, 360, 307, 286, 764, 257, 1422, 21120, 11, 457, 294, 4500, 365, 264, 33536], "temperature": 0.0, "avg_logprob": -0.21849835620206945, "compression_ratio": 1.572192513368984, "no_speech_prob": 0.0001583542616572231}, {"id": 146, "seek": 74500, "start": 762.28, "end": 768.04, "text": " from awesome no only require the build targets I really use are exported or transferred to", "tokens": [490, 3476, 572, 787, 3651, 264, 1322, 12911, 286, 534, 764, 366, 42055, 420, 15809, 281], "temperature": 0.0, "avg_logprob": -0.21849835620206945, "compression_ratio": 1.572192513368984, "no_speech_prob": 0.0001583542616572231}, {"id": 147, "seek": 74500, "start": 768.04, "end": 770.64, "text": " the other project.", "tokens": [264, 661, 1716, 13], "temperature": 0.0, "avg_logprob": -0.21849835620206945, "compression_ratio": 1.572192513368984, "no_speech_prob": 0.0001583542616572231}, {"id": 148, "seek": 77064, "start": 770.64, "end": 777.88, "text": " And we do this in our MLIR MLC repository and to do this we actually have an option just", "tokens": [400, 321, 360, 341, 294, 527, 21601, 7740, 21601, 34, 25841, 293, 281, 360, 341, 321, 767, 362, 364, 3614, 445], "temperature": 0.0, "avg_logprob": -0.15003207235625296, "compression_ratio": 1.6623931623931625, "no_speech_prob": 6.108020170358941e-05}, {"id": 149, "seek": 77064, "start": 777.88, "end": 782.08, "text": " embedded which changes our source code a little bit.", "tokens": [16741, 597, 2962, 527, 4009, 3089, 257, 707, 857, 13], "temperature": 0.0, "avg_logprob": -0.15003207235625296, "compression_ratio": 1.6623931623931625, "no_speech_prob": 6.108020170358941e-05}, {"id": 150, "seek": 77064, "start": 782.08, "end": 790.4, "text": " So only when we want to call it embedded then we check is it the case or not because the", "tokens": [407, 787, 562, 321, 528, 281, 818, 309, 16741, 550, 321, 1520, 307, 309, 264, 1389, 420, 406, 570, 264], "temperature": 0.0, "avg_logprob": -0.15003207235625296, "compression_ratio": 1.6623931623931625, "no_speech_prob": 6.108020170358941e-05}, {"id": 151, "seek": 77064, "start": 790.4, "end": 792.76, "text": " find package is already done by the other project.", "tokens": [915, 7372, 307, 1217, 1096, 538, 264, 661, 1716, 13], "temperature": 0.0, "avg_logprob": -0.15003207235625296, "compression_ratio": 1.6623931623931625, "no_speech_prob": 6.108020170358941e-05}, {"id": 152, "seek": 77064, "start": 792.76, "end": 794.28, "text": " We don't need to call this.", "tokens": [492, 500, 380, 643, 281, 818, 341, 13], "temperature": 0.0, "avg_logprob": -0.15003207235625296, "compression_ratio": 1.6623931623931625, "no_speech_prob": 6.108020170358941e-05}, {"id": 153, "seek": 77064, "start": 794.28, "end": 800.4399999999999, "text": " We only do the includes which we don't need for the external project mechanism.", "tokens": [492, 787, 360, 264, 5974, 597, 321, 500, 380, 643, 337, 264, 8320, 1716, 7513, 13], "temperature": 0.0, "avg_logprob": -0.15003207235625296, "compression_ratio": 1.6623931623931625, "no_speech_prob": 6.108020170358941e-05}, {"id": 154, "seek": 80044, "start": 800.44, "end": 804.96, "text": " So getting to types.", "tokens": [407, 1242, 281, 3467, 13], "temperature": 0.0, "avg_logprob": -0.22874770365970234, "compression_ratio": 1.6329787234042554, "no_speech_prob": 4.8309633712051436e-05}, {"id": 155, "seek": 80044, "start": 804.96, "end": 809.72, "text": " This is how the standalone dialect is currently structured or at least most of it.", "tokens": [639, 307, 577, 264, 37454, 24652, 307, 4362, 18519, 420, 412, 1935, 881, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.22874770365970234, "compression_ratio": 1.6329787234042554, "no_speech_prob": 4.8309633712051436e-05}, {"id": 156, "seek": 80044, "start": 809.72, "end": 814.36, "text": " There are also some tools standalone ops standalone translate which are considered here.", "tokens": [821, 366, 611, 512, 3873, 37454, 44663, 37454, 13799, 597, 366, 4888, 510, 13], "temperature": 0.0, "avg_logprob": -0.22874770365970234, "compression_ratio": 1.6329787234042554, "no_speech_prob": 4.8309633712051436e-05}, {"id": 157, "seek": 80044, "start": 814.36, "end": 820.72, "text": " And you see we have multiple finds and types could be specified in standalone ops.td in", "tokens": [400, 291, 536, 321, 362, 3866, 10704, 293, 3467, 727, 312, 22206, 294, 37454, 44663, 13, 83, 67, 294], "temperature": 0.0, "avg_logprob": -0.22874770365970234, "compression_ratio": 1.6329787234042554, "no_speech_prob": 4.8309633712051436e-05}, {"id": 158, "seek": 80044, "start": 820.72, "end": 823.6, "text": " our table definition file.", "tokens": [527, 3199, 7123, 3991, 13], "temperature": 0.0, "avg_logprob": -0.22874770365970234, "compression_ratio": 1.6329787234042554, "no_speech_prob": 4.8309633712051436e-05}, {"id": 159, "seek": 82360, "start": 823.6, "end": 832.28, "text": " However, it's quite nice to not put it into all into one file but to use separate files", "tokens": [2908, 11, 309, 311, 1596, 1481, 281, 406, 829, 309, 666, 439, 666, 472, 3991, 457, 281, 764, 4994, 7098], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 160, "seek": 82360, "start": 832.28, "end": 833.28, "text": " for it.", "tokens": [337, 309, 13], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 161, "seek": 82360, "start": 833.28, "end": 835.0400000000001, "text": " So what we're doing is we're adding new files.", "tokens": [407, 437, 321, 434, 884, 307, 321, 434, 5127, 777, 7098, 13], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 162, "seek": 82360, "start": 835.0400000000001, "end": 838.72, "text": " We're adding a table gen file standalone types.", "tokens": [492, 434, 5127, 257, 3199, 1049, 3991, 37454, 3467, 13], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 163, "seek": 82360, "start": 838.72, "end": 843.28, "text": " We're adding a header file and we're adding the CPP for our implementation.", "tokens": [492, 434, 5127, 257, 23117, 3991, 293, 321, 434, 5127, 264, 383, 17755, 337, 527, 11420, 13], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 164, "seek": 82360, "start": 843.28, "end": 847.84, "text": " And what you need to put into those are actually the following.", "tokens": [400, 437, 291, 643, 281, 829, 666, 729, 366, 767, 264, 3480, 13], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 165, "seek": 82360, "start": 847.84, "end": 849.88, "text": " Let's start with the table gen file.", "tokens": [961, 311, 722, 365, 264, 3199, 1049, 3991, 13], "temperature": 0.0, "avg_logprob": -0.1786688232421875, "compression_ratio": 1.7230046948356808, "no_speech_prob": 4.7566238208673894e-05}, {"id": 166, "seek": 84988, "start": 849.88, "end": 857.16, "text": " First of all, we include the attribute type base and the dialect itself because the dialect", "tokens": [2386, 295, 439, 11, 321, 4090, 264, 19667, 2010, 3096, 293, 264, 24652, 2564, 570, 264, 24652], "temperature": 0.0, "avg_logprob": -0.2106045453976362, "compression_ratio": 1.712707182320442, "no_speech_prob": 4.8304245865438133e-05}, {"id": 167, "seek": 84988, "start": 857.16, "end": 864.48, "text": " has some definitions and then we can define our standalone types class which is the base", "tokens": [575, 512, 21988, 293, 550, 321, 393, 6964, 527, 37454, 3467, 1508, 597, 307, 264, 3096], "temperature": 0.0, "avg_logprob": -0.2106045453976362, "compression_ratio": 1.712707182320442, "no_speech_prob": 4.8304245865438133e-05}, {"id": 168, "seek": 84988, "start": 864.48, "end": 867.6, "text": " class for types.", "tokens": [1508, 337, 3467, 13], "temperature": 0.0, "avg_logprob": -0.2106045453976362, "compression_ratio": 1.712707182320442, "no_speech_prob": 4.8304245865438133e-05}, {"id": 169, "seek": 84988, "start": 867.6, "end": 872.08, "text": " And in addition to that, we can define a custom type.", "tokens": [400, 294, 4500, 281, 300, 11, 321, 393, 6964, 257, 2375, 2010, 13], "temperature": 0.0, "avg_logprob": -0.2106045453976362, "compression_ratio": 1.712707182320442, "no_speech_prob": 4.8304245865438133e-05}, {"id": 170, "seek": 84988, "start": 872.08, "end": 876.16, "text": " Actually this is a simple copy of a mid-seas or park type.", "tokens": [5135, 341, 307, 257, 2199, 5055, 295, 257, 2062, 12, 405, 296, 420, 3884, 2010, 13], "temperature": 0.0, "avg_logprob": -0.2106045453976362, "compression_ratio": 1.712707182320442, "no_speech_prob": 4.8304245865438133e-05}, {"id": 171, "seek": 87616, "start": 876.16, "end": 883.8, "text": " Quite straightforward but here we use a standard assembly format so no custom parser and printer", "tokens": [20464, 15325, 457, 510, 321, 764, 257, 3832, 12103, 7877, 370, 572, 2375, 21156, 260, 293, 16671], "temperature": 0.0, "avg_logprob": -0.2009759371793723, "compression_ratio": 1.6601941747572815, "no_speech_prob": 4.756701673613861e-05}, {"id": 172, "seek": 87616, "start": 883.8, "end": 885.68, "text": " and it just holds a string of parameters.", "tokens": [293, 309, 445, 9190, 257, 6798, 295, 9834, 13], "temperature": 0.0, "avg_logprob": -0.2009759371793723, "compression_ratio": 1.6601941747572815, "no_speech_prob": 4.756701673613861e-05}, {"id": 173, "seek": 87616, "start": 885.68, "end": 888.48, "text": " So nothing special just to illustrate the example.", "tokens": [407, 1825, 2121, 445, 281, 23221, 264, 1365, 13], "temperature": 0.0, "avg_logprob": -0.2009759371793723, "compression_ratio": 1.6601941747572815, "no_speech_prob": 4.756701673613861e-05}, {"id": 174, "seek": 87616, "start": 888.48, "end": 893.8399999999999, "text": " So that is how the table gen file could look like.", "tokens": [407, 300, 307, 577, 264, 3199, 1049, 3991, 727, 574, 411, 13], "temperature": 0.0, "avg_logprob": -0.2009759371793723, "compression_ratio": 1.6601941747572815, "no_speech_prob": 4.756701673613861e-05}, {"id": 175, "seek": 87616, "start": 893.8399999999999, "end": 899.7199999999999, "text": " Getting to standalone ops, we can just replace the include of standalone dialect by standalone", "tokens": [13674, 281, 37454, 44663, 11, 321, 393, 445, 7406, 264, 4090, 295, 37454, 24652, 538, 37454], "temperature": 0.0, "avg_logprob": -0.2009759371793723, "compression_ratio": 1.6601941747572815, "no_speech_prob": 4.756701673613861e-05}, {"id": 176, "seek": 87616, "start": 899.7199999999999, "end": 902.12, "text": " types.", "tokens": [3467, 13], "temperature": 0.0, "avg_logprob": -0.2009759371793723, "compression_ratio": 1.6601941747572815, "no_speech_prob": 4.756701673613861e-05}, {"id": 177, "seek": 90212, "start": 902.12, "end": 908.72, "text": " And this is because the types already includes the table gen TDE file so that's fine and", "tokens": [400, 341, 307, 570, 264, 3467, 1217, 5974, 264, 3199, 1049, 314, 22296, 3991, 370, 300, 311, 2489, 293], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 178, "seek": 90212, "start": 908.72, "end": 911.88, "text": " that's it.", "tokens": [300, 311, 309, 13], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 179, "seek": 90212, "start": 911.88, "end": 915.2, "text": " Regarding the CMAC list, we don't need anything to change.", "tokens": [35523, 264, 20424, 4378, 1329, 11, 321, 500, 380, 643, 1340, 281, 1319, 13], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 180, "seek": 90212, "start": 915.2, "end": 916.6, "text": " Why is that?", "tokens": [1545, 307, 300, 30], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 181, "seek": 90212, "start": 916.6, "end": 925.32, "text": " Actually at MLIR dialect already calls MLIR table gen for you with gen type decals and", "tokens": [5135, 412, 21601, 7740, 24652, 1217, 5498, 21601, 7740, 3199, 1049, 337, 291, 365, 1049, 2010, 979, 1124, 293], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 182, "seek": 90212, "start": 925.32, "end": 929.64, "text": " type definitions so that's fine.", "tokens": [2010, 21988, 370, 300, 311, 2489, 13], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 183, "seek": 90212, "start": 929.64, "end": 931.96, "text": " We don't need to change anything here.", "tokens": [492, 500, 380, 643, 281, 1319, 1340, 510, 13], "temperature": 0.0, "avg_logprob": -0.21501273694245712, "compression_ratio": 1.65, "no_speech_prob": 1.1842737876577303e-05}, {"id": 184, "seek": 93196, "start": 931.96, "end": 938.32, "text": " Whatever for attributes that would be different because for attributes, the at MLIR dialect", "tokens": [8541, 337, 17212, 300, 576, 312, 819, 570, 337, 17212, 11, 264, 412, 21601, 7740, 24652], "temperature": 0.0, "avg_logprob": -0.20795619103216356, "compression_ratio": 1.7762557077625571, "no_speech_prob": 9.457699343329296e-05}, {"id": 185, "seek": 93196, "start": 938.32, "end": 944.88, "text": " doesn't call MLIR table gen for you to just set the LRM target definitions by yourself,", "tokens": [1177, 380, 818, 21601, 7740, 3199, 1049, 337, 291, 281, 445, 992, 264, 441, 49, 44, 3779, 21988, 538, 1803, 11], "temperature": 0.0, "avg_logprob": -0.20795619103216356, "compression_ratio": 1.7762557077625571, "no_speech_prob": 9.457699343329296e-05}, {"id": 186, "seek": 93196, "start": 944.88, "end": 951.12, "text": " call MLIR table gen by yourself, add a public table gen target and that's it.", "tokens": [818, 21601, 7740, 3199, 1049, 538, 1803, 11, 909, 257, 1908, 3199, 1049, 3779, 293, 300, 311, 309, 13], "temperature": 0.0, "avg_logprob": -0.20795619103216356, "compression_ratio": 1.7762557077625571, "no_speech_prob": 9.457699343329296e-05}, {"id": 187, "seek": 93196, "start": 951.12, "end": 958.8000000000001, "text": " So attributes are quite close related to, are quite similar except for that you need", "tokens": [407, 17212, 366, 1596, 1998, 4077, 281, 11, 366, 1596, 2531, 3993, 337, 300, 291, 643], "temperature": 0.0, "avg_logprob": -0.20795619103216356, "compression_ratio": 1.7762557077625571, "no_speech_prob": 9.457699343329296e-05}, {"id": 188, "seek": 93196, "start": 958.8000000000001, "end": 961.9200000000001, "text": " to adjust your CMAC configuration by yourself.", "tokens": [281, 4369, 428, 20424, 4378, 11694, 538, 1803, 13], "temperature": 0.0, "avg_logprob": -0.20795619103216356, "compression_ratio": 1.7762557077625571, "no_speech_prob": 9.457699343329296e-05}, {"id": 189, "seek": 96192, "start": 961.92, "end": 968.5999999999999, "text": " For the header file, just include the auto-generated type dev classes in the header, that's it,", "tokens": [1171, 264, 23117, 3991, 11, 445, 4090, 264, 8399, 12, 21848, 770, 2010, 1905, 5359, 294, 264, 23117, 11, 300, 311, 309, 11], "temperature": 0.0, "avg_logprob": -0.19011379627699262, "compression_ratio": 1.671497584541063, "no_speech_prob": 3.425696195336059e-05}, {"id": 190, "seek": 96192, "start": 968.5999999999999, "end": 972.92, "text": " add the define, the include, nothing more to do.", "tokens": [909, 264, 6964, 11, 264, 4090, 11, 1825, 544, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.19011379627699262, "compression_ratio": 1.671497584541063, "no_speech_prob": 3.425696195336059e-05}, {"id": 191, "seek": 96192, "start": 972.92, "end": 980.4, "text": " For our implementation, we need to make sure that the types can actually be registered", "tokens": [1171, 527, 11420, 11, 321, 643, 281, 652, 988, 300, 264, 3467, 393, 767, 312, 13968], "temperature": 0.0, "avg_logprob": -0.19011379627699262, "compression_ratio": 1.671497584541063, "no_speech_prob": 3.425696195336059e-05}, {"id": 192, "seek": 96192, "start": 980.4, "end": 982.68, "text": " by the parent dialect.", "tokens": [538, 264, 2596, 24652, 13], "temperature": 0.0, "avg_logprob": -0.19011379627699262, "compression_ratio": 1.671497584541063, "no_speech_prob": 3.425696195336059e-05}, {"id": 193, "seek": 96192, "start": 982.68, "end": 989.48, "text": " So what we do is we have a define here, get type dev classes, we include then our generated", "tokens": [407, 437, 321, 360, 307, 321, 362, 257, 6964, 510, 11, 483, 2010, 1905, 5359, 11, 321, 4090, 550, 527, 10833], "temperature": 0.0, "avg_logprob": -0.19011379627699262, "compression_ratio": 1.671497584541063, "no_speech_prob": 3.425696195336059e-05}, {"id": 194, "seek": 98948, "start": 989.48, "end": 998.52, "text": " code, generated by table gen and then we implement or we write a function register types which", "tokens": [3089, 11, 10833, 538, 3199, 1049, 293, 550, 321, 4445, 420, 321, 2464, 257, 2445, 7280, 3467, 597], "temperature": 0.0, "avg_logprob": -0.19423401192443013, "compression_ratio": 1.6162162162162161, "no_speech_prob": 4.6836274123052135e-05}, {"id": 195, "seek": 98948, "start": 998.52, "end": 1006.24, "text": " actually calls the method add types plus some of the auto-generated code and this needs", "tokens": [767, 5498, 264, 3170, 909, 3467, 1804, 512, 295, 264, 8399, 12, 21848, 770, 3089, 293, 341, 2203], "temperature": 0.0, "avg_logprob": -0.19423401192443013, "compression_ratio": 1.6162162162162161, "no_speech_prob": 4.6836274123052135e-05}, {"id": 196, "seek": 98948, "start": 1006.24, "end": 1010.16, "text": " to be called in our standalone dialect.cpp.", "tokens": [281, 312, 1219, 294, 527, 37454, 24652, 13, 66, 427, 13], "temperature": 0.0, "avg_logprob": -0.19423401192443013, "compression_ratio": 1.6162162162162161, "no_speech_prob": 4.6836274123052135e-05}, {"id": 197, "seek": 98948, "start": 1010.16, "end": 1016.6, "text": " So we just add the register types here and that's nearly the real trick.", "tokens": [407, 321, 445, 909, 264, 7280, 3467, 510, 293, 300, 311, 6217, 264, 957, 4282, 13], "temperature": 0.0, "avg_logprob": -0.19423401192443013, "compression_ratio": 1.6162162162162161, "no_speech_prob": 4.6836274123052135e-05}, {"id": 198, "seek": 101660, "start": 1016.6, "end": 1021.64, "text": " You can do the same not with ad operands or add types but with add attributes for attributes", "tokens": [509, 393, 360, 264, 912, 406, 365, 614, 2208, 2967, 420, 909, 3467, 457, 365, 909, 17212, 337, 17212], "temperature": 0.0, "avg_logprob": -0.21357294308241978, "compression_ratio": 1.6948356807511737, "no_speech_prob": 2.4297873096656986e-05}, {"id": 199, "seek": 101660, "start": 1021.64, "end": 1025.76, "text": " and to register your attributes.", "tokens": [293, 281, 7280, 428, 17212, 13], "temperature": 0.0, "avg_logprob": -0.21357294308241978, "compression_ratio": 1.6948356807511737, "no_speech_prob": 2.4297873096656986e-05}, {"id": 200, "seek": 101660, "start": 1025.76, "end": 1033.88, "text": " For the CMAC list itself, just add this to your MLIR standalone live or MLIR dialect", "tokens": [1171, 264, 20424, 4378, 1329, 2564, 11, 445, 909, 341, 281, 428, 21601, 7740, 37454, 1621, 420, 21601, 7740, 24652], "temperature": 0.0, "avg_logprob": -0.21357294308241978, "compression_ratio": 1.6948356807511737, "no_speech_prob": 2.4297873096656986e-05}, {"id": 201, "seek": 101660, "start": 1033.88, "end": 1038.52, "text": " library target, that's it, nothing more to do.", "tokens": [6405, 3779, 11, 300, 311, 309, 11, 1825, 544, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.21357294308241978, "compression_ratio": 1.6948356807511737, "no_speech_prob": 2.4297873096656986e-05}, {"id": 202, "seek": 101660, "start": 1038.52, "end": 1043.88, "text": " For attributes, you can also just add your source code or you must add your source file", "tokens": [1171, 17212, 11, 291, 393, 611, 445, 909, 428, 4009, 3089, 420, 291, 1633, 909, 428, 4009, 3991], "temperature": 0.0, "avg_logprob": -0.21357294308241978, "compression_ratio": 1.6948356807511737, "no_speech_prob": 2.4297873096656986e-05}, {"id": 203, "seek": 101660, "start": 1043.88, "end": 1045.3600000000001, "text": " here of course.", "tokens": [510, 295, 1164, 13], "temperature": 0.0, "avg_logprob": -0.21357294308241978, "compression_ratio": 1.6948356807511737, "no_speech_prob": 2.4297873096656986e-05}, {"id": 204, "seek": 104536, "start": 1045.36, "end": 1050.28, "text": " But in addition, you also need a dependency on MLIR standalone attributes, ink gen, the", "tokens": [583, 294, 4500, 11, 291, 611, 643, 257, 33621, 322, 21601, 7740, 37454, 17212, 11, 11276, 1049, 11, 264], "temperature": 0.0, "avg_logprob": -0.18890336354573567, "compression_ratio": 1.6123348017621146, "no_speech_prob": 6.919577572261915e-05}, {"id": 205, "seek": 104536, "start": 1050.28, "end": 1057.12, "text": " target we generate or we create it by hand because it's not auto-generated just to make", "tokens": [3779, 321, 8460, 420, 321, 1884, 309, 538, 1011, 570, 309, 311, 406, 8399, 12, 21848, 770, 445, 281, 652], "temperature": 0.0, "avg_logprob": -0.18890336354573567, "compression_ratio": 1.6123348017621146, "no_speech_prob": 6.919577572261915e-05}, {"id": 206, "seek": 104536, "start": 1057.12, "end": 1066.76, "text": " sure that table gen generates the code before CMAC tries to, or before the MLIR standalone", "tokens": [988, 300, 3199, 1049, 23815, 264, 3089, 949, 20424, 4378, 9898, 281, 11, 420, 949, 264, 21601, 7740, 37454], "temperature": 0.0, "avg_logprob": -0.18890336354573567, "compression_ratio": 1.6123348017621146, "no_speech_prob": 6.919577572261915e-05}, {"id": 207, "seek": 104536, "start": 1066.76, "end": 1068.4799999999998, "text": " target is built.", "tokens": [3779, 307, 3094, 13], "temperature": 0.0, "avg_logprob": -0.18890336354573567, "compression_ratio": 1.6123348017621146, "no_speech_prob": 6.919577572261915e-05}, {"id": 208, "seek": 104536, "start": 1068.4799999999998, "end": 1072.32, "text": " You might be lucky otherwise you might have a race condition in your build system.", "tokens": [509, 1062, 312, 6356, 5911, 291, 1062, 362, 257, 4569, 4188, 294, 428, 1322, 1185, 13], "temperature": 0.0, "avg_logprob": -0.18890336354573567, "compression_ratio": 1.6123348017621146, "no_speech_prob": 6.919577572261915e-05}, {"id": 209, "seek": 107232, "start": 1072.32, "end": 1080.28, "text": " I experienced that several times, tried to fix it or just keep it in mind and that's", "tokens": [286, 6751, 300, 2940, 1413, 11, 3031, 281, 3191, 309, 420, 445, 1066, 309, 294, 1575, 293, 300, 311], "temperature": 0.0, "avg_logprob": -0.1550444761912028, "compression_ratio": 1.4684210526315788, "no_speech_prob": 7.482431101379916e-05}, {"id": 210, "seek": 107232, "start": 1080.28, "end": 1081.76, "text": " mainly it.", "tokens": [8704, 309, 13], "temperature": 0.0, "avg_logprob": -0.1550444761912028, "compression_ratio": 1.4684210526315788, "no_speech_prob": 7.482431101379916e-05}, {"id": 211, "seek": 107232, "start": 1081.76, "end": 1087.6799999999998, "text": " For the standalone dialect, here we use the default printer and parser.", "tokens": [1171, 264, 37454, 24652, 11, 510, 321, 764, 264, 7576, 16671, 293, 21156, 260, 13], "temperature": 0.0, "avg_logprob": -0.1550444761912028, "compression_ratio": 1.4684210526315788, "no_speech_prob": 7.482431101379916e-05}, {"id": 212, "seek": 107232, "start": 1087.6799999999998, "end": 1092.1599999999999, "text": " Just let us tell table gen to generate those.", "tokens": [1449, 718, 505, 980, 3199, 1049, 281, 8460, 729, 13], "temperature": 0.0, "avg_logprob": -0.1550444761912028, "compression_ratio": 1.4684210526315788, "no_speech_prob": 7.482431101379916e-05}, {"id": 213, "seek": 107232, "start": 1092.1599999999999, "end": 1099.2, "text": " And for register types, actually we need of course a declaration.", "tokens": [400, 337, 7280, 3467, 11, 767, 321, 643, 295, 1164, 257, 27606, 13], "temperature": 0.0, "avg_logprob": -0.1550444761912028, "compression_ratio": 1.4684210526315788, "no_speech_prob": 7.482431101379916e-05}, {"id": 214, "seek": 109920, "start": 1099.2, "end": 1104.6000000000001, "text": " We have the implementation but we also need the extra cards declaration generated by table", "tokens": [492, 362, 264, 11420, 457, 321, 611, 643, 264, 2857, 5632, 27606, 10833, 538, 3199], "temperature": 0.0, "avg_logprob": -0.2278375077521664, "compression_ratio": 1.5, "no_speech_prob": 2.177623173338361e-05}, {"id": 215, "seek": 109920, "start": 1104.6000000000001, "end": 1105.6000000000001, "text": " gen.", "tokens": [1049, 13], "temperature": 0.0, "avg_logprob": -0.2278375077521664, "compression_ratio": 1.5, "no_speech_prob": 2.177623173338361e-05}, {"id": 216, "seek": 109920, "start": 1105.6000000000001, "end": 1112.52, "text": " Otherwise, yeah, we cannot use it in our standalone ops.cpp.", "tokens": [10328, 11, 1338, 11, 321, 2644, 764, 309, 294, 527, 37454, 44663, 13, 66, 427, 13], "temperature": 0.0, "avg_logprob": -0.2278375077521664, "compression_ratio": 1.5, "no_speech_prob": 2.177623173338361e-05}, {"id": 217, "seek": 109920, "start": 1112.52, "end": 1119.24, "text": " So all the examples are available in my fork of the LLVM project.", "tokens": [407, 439, 264, 5110, 366, 2435, 294, 452, 17716, 295, 264, 441, 43, 53, 44, 1716, 13], "temperature": 0.0, "avg_logprob": -0.2278375077521664, "compression_ratio": 1.5, "no_speech_prob": 2.177623173338361e-05}, {"id": 218, "seek": 109920, "start": 1119.24, "end": 1125.8400000000001, "text": " I couldn't make it to senses, we are fabricated to be reviewed through upstream inclusion", "tokens": [286, 2809, 380, 652, 309, 281, 17057, 11, 321, 366, 7253, 770, 281, 312, 18429, 807, 33915, 15874], "temperature": 0.0, "avg_logprob": -0.2278375077521664, "compression_ratio": 1.5, "no_speech_prob": 2.177623173338361e-05}, {"id": 219, "seek": 109920, "start": 1125.8400000000001, "end": 1128.2, "text": " prior to my talk.", "tokens": [4059, 281, 452, 751, 13], "temperature": 0.0, "avg_logprob": -0.2278375077521664, "compression_ratio": 1.5, "no_speech_prob": 2.177623173338361e-05}, {"id": 220, "seek": 112820, "start": 1128.2, "end": 1136.56, "text": " But I will do so, I will add some more documentation to this, that's at least my goal.", "tokens": [583, 286, 486, 360, 370, 11, 286, 486, 909, 512, 544, 14333, 281, 341, 11, 300, 311, 412, 1935, 452, 3387, 13], "temperature": 0.0, "avg_logprob": -0.20963884241440717, "compression_ratio": 1.5592417061611374, "no_speech_prob": 0.00012725112901534885}, {"id": 221, "seek": 112820, "start": 1136.56, "end": 1143.0, "text": " So when I planned this talk, I thought maybe some hints which could have one or the other", "tokens": [407, 562, 286, 8589, 341, 751, 11, 286, 1194, 1310, 512, 27271, 597, 727, 362, 472, 420, 264, 661], "temperature": 0.0, "avg_logprob": -0.20963884241440717, "compression_ratio": 1.5592417061611374, "no_speech_prob": 0.00012725112901534885}, {"id": 222, "seek": 112820, "start": 1143.0, "end": 1147.8400000000001, "text": " and hopefully it's even more helpful if you not only find it in the slidespot also in", "tokens": [293, 4696, 309, 311, 754, 544, 4961, 498, 291, 406, 787, 915, 309, 294, 264, 9788, 17698, 611, 294], "temperature": 0.0, "avg_logprob": -0.20963884241440717, "compression_ratio": 1.5592417061611374, "no_speech_prob": 0.00012725112901534885}, {"id": 223, "seek": 112820, "start": 1147.8400000000001, "end": 1150.0, "text": " the upstream example.", "tokens": [264, 33915, 1365, 13], "temperature": 0.0, "avg_logprob": -0.20963884241440717, "compression_ratio": 1.5592417061611374, "no_speech_prob": 0.00012725112901534885}, {"id": 224, "seek": 112820, "start": 1150.0, "end": 1152.28, "text": " And there are many good resources out there.", "tokens": [400, 456, 366, 867, 665, 3593, 484, 456, 13], "temperature": 0.0, "avg_logprob": -0.20963884241440717, "compression_ratio": 1.5592417061611374, "no_speech_prob": 0.00012725112901534885}, {"id": 225, "seek": 115228, "start": 1152.28, "end": 1158.6, "text": " So the talk given by media mini and river riddle, the MLIR primer, the MLIR tutorial", "tokens": [407, 264, 751, 2212, 538, 3021, 8382, 293, 6810, 3973, 2285, 11, 264, 21601, 7740, 12595, 11, 264, 21601, 7740, 7073], "temperature": 0.0, "avg_logprob": -0.20912544400084251, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.462785000214353e-05}, {"id": 226, "seek": 115228, "start": 1158.6, "end": 1161.08, "text": " at the 2020 LLVM deaf meeting.", "tokens": [412, 264, 4808, 441, 43, 53, 44, 15559, 3440, 13], "temperature": 0.0, "avg_logprob": -0.20912544400084251, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.462785000214353e-05}, {"id": 227, "seek": 115228, "start": 1161.08, "end": 1170.08, "text": " We have some great docs at MLIRLLVM.org, here how to create a dialect, the toy example", "tokens": [492, 362, 512, 869, 45623, 412, 21601, 7740, 43, 43, 53, 44, 13, 4646, 11, 510, 577, 281, 1884, 257, 24652, 11, 264, 12058, 1365], "temperature": 0.0, "avg_logprob": -0.20912544400084251, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.462785000214353e-05}, {"id": 228, "seek": 115228, "start": 1170.08, "end": 1175.04, "text": " for example, how to combine it, how to add attribute and types if you want to get more", "tokens": [337, 1365, 11, 577, 281, 10432, 309, 11, 577, 281, 909, 19667, 293, 3467, 498, 291, 528, 281, 483, 544], "temperature": 0.0, "avg_logprob": -0.20912544400084251, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.462785000214353e-05}, {"id": 229, "seek": 115228, "start": 1175.04, "end": 1179.56, "text": " into the details what you can do all in the table gen world.", "tokens": [666, 264, 4365, 437, 291, 393, 360, 439, 294, 264, 3199, 1049, 1002, 13], "temperature": 0.0, "avg_logprob": -0.20912544400084251, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.462785000214353e-05}, {"id": 230, "seek": 117956, "start": 1179.56, "end": 1185.8, "text": " Thanks, last but not least, the tutorial given by Steven Neuerhender at the LLVM 2021 deaf", "tokens": [2561, 11, 1036, 457, 406, 1935, 11, 264, 7073, 2212, 538, 12754, 1734, 5486, 71, 3216, 412, 264, 441, 43, 53, 44, 7201, 15559], "temperature": 0.0, "avg_logprob": -0.330017574249752, "compression_ratio": 1.2848101265822784, "no_speech_prob": 0.00037295048241503537}, {"id": 231, "seek": 117956, "start": 1185.8, "end": 1187.04, "text": " meeting.", "tokens": [3440, 13], "temperature": 0.0, "avg_logprob": -0.330017574249752, "compression_ratio": 1.2848101265822784, "no_speech_prob": 0.00037295048241503537}, {"id": 232, "seek": 117956, "start": 1187.04, "end": 1190.1599999999999, "text": " Yeah, so that's it from my side.", "tokens": [865, 11, 370, 300, 311, 309, 490, 452, 1252, 13], "temperature": 0.0, "avg_logprob": -0.330017574249752, "compression_ratio": 1.2848101265822784, "no_speech_prob": 0.00037295048241503537}, {"id": 233, "seek": 117956, "start": 1190.1599999999999, "end": 1197.44, "text": " So if you have questions, please let me know and I try to answer them.", "tokens": [407, 498, 291, 362, 1651, 11, 1767, 718, 385, 458, 293, 286, 853, 281, 1867, 552, 13], "temperature": 0.0, "avg_logprob": -0.330017574249752, "compression_ratio": 1.2848101265822784, "no_speech_prob": 0.00037295048241503537}, {"id": 234, "seek": 119744, "start": 1197.44, "end": 1212.76, "text": " Hey, I just recently got into learning how to develop compilers, even less how to create", "tokens": [1911, 11, 286, 445, 3938, 658, 666, 2539, 577, 281, 1499, 715, 388, 433, 11, 754, 1570, 577, 281, 1884], "temperature": 0.0, "avg_logprob": -0.3757138154944595, "compression_ratio": 1.3410852713178294, "no_speech_prob": 0.007922577671706676}, {"id": 235, "seek": 119744, "start": 1212.76, "end": 1213.76, "text": " languages.", "tokens": [8650, 13], "temperature": 0.0, "avg_logprob": -0.3757138154944595, "compression_ratio": 1.3410852713178294, "no_speech_prob": 0.007922577671706676}, {"id": 236, "seek": 119744, "start": 1213.76, "end": 1219.76, "text": " I've been focusing mostly on the front end part, like lexing and parsing.", "tokens": [286, 600, 668, 8416, 5240, 322, 264, 1868, 917, 644, 11, 411, 476, 87, 278, 293, 21156, 278, 13], "temperature": 0.0, "avg_logprob": -0.3757138154944595, "compression_ratio": 1.3410852713178294, "no_speech_prob": 0.007922577671706676}, {"id": 237, "seek": 121976, "start": 1219.76, "end": 1230.24, "text": " And my idea was to use LLVM as the back end for a really abstracted C type language which", "tokens": [400, 452, 1558, 390, 281, 764, 441, 43, 53, 44, 382, 264, 646, 917, 337, 257, 534, 12649, 292, 383, 2010, 2856, 597], "temperature": 0.0, "avg_logprob": -0.23953502934153487, "compression_ratio": 1.4941176470588236, "no_speech_prob": 0.0013965271646156907}, {"id": 238, "seek": 121976, "start": 1230.24, "end": 1238.4, "text": " I'm working on and use LLVM as a back end to generate machine code for x86.", "tokens": [286, 478, 1364, 322, 293, 764, 441, 43, 53, 44, 382, 257, 646, 917, 281, 8460, 3479, 3089, 337, 2031, 22193, 13], "temperature": 0.0, "avg_logprob": -0.23953502934153487, "compression_ratio": 1.4941176470588236, "no_speech_prob": 0.0013965271646156907}, {"id": 239, "seek": 121976, "start": 1238.4, "end": 1247.56, "text": " And my understanding was that I only had to use or generate an IR for LLVM, the LLVM", "tokens": [400, 452, 3701, 390, 300, 286, 787, 632, 281, 764, 420, 8460, 364, 16486, 337, 441, 43, 53, 44, 11, 264, 441, 43, 53, 44], "temperature": 0.0, "avg_logprob": -0.23953502934153487, "compression_ratio": 1.4941176470588236, "no_speech_prob": 0.0013965271646156907}, {"id": 240, "seek": 121976, "start": 1247.56, "end": 1248.56, "text": " IR.", "tokens": [16486, 13], "temperature": 0.0, "avg_logprob": -0.23953502934153487, "compression_ratio": 1.4941176470588236, "no_speech_prob": 0.0013965271646156907}, {"id": 241, "seek": 124856, "start": 1248.56, "end": 1260.6, "text": " And now you mentioned that LLVM IR can be described or is somehow related with the MLIR, right?", "tokens": [400, 586, 291, 2835, 300, 441, 43, 53, 44, 16486, 393, 312, 7619, 420, 307, 6063, 4077, 365, 264, 21601, 7740, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.24691317631648138, "compression_ratio": 1.5054945054945055, "no_speech_prob": 0.0014570135390385985}, {"id": 242, "seek": 124856, "start": 1260.6, "end": 1266.6, "text": " So I was wondering if I'm still in the correct track to try to generate the parse tree and", "tokens": [407, 286, 390, 6359, 498, 286, 478, 920, 294, 264, 3006, 2837, 281, 853, 281, 8460, 264, 48377, 4230, 293], "temperature": 0.0, "avg_logprob": -0.24691317631648138, "compression_ratio": 1.5054945054945055, "no_speech_prob": 0.0014570135390385985}, {"id": 243, "seek": 124856, "start": 1266.6, "end": 1275.04, "text": " use LLVM and try to generate the standard LLVM IR and target the x86 or an x86 platform", "tokens": [764, 441, 43, 53, 44, 293, 853, 281, 8460, 264, 3832, 441, 43, 53, 44, 16486, 293, 3779, 264, 2031, 22193, 420, 364, 2031, 22193, 3663], "temperature": 0.0, "avg_logprob": -0.24691317631648138, "compression_ratio": 1.5054945054945055, "no_speech_prob": 0.0014570135390385985}, {"id": 244, "seek": 127504, "start": 1275.04, "end": 1279.8, "text": " or do I need to learn something about the MLIR?", "tokens": [420, 360, 286, 643, 281, 1466, 746, 466, 264, 21601, 7740, 30], "temperature": 0.0, "avg_logprob": -0.16442248225212097, "compression_ratio": 1.5130434782608695, "no_speech_prob": 5.062569471192546e-05}, {"id": 245, "seek": 127504, "start": 1279.8, "end": 1287.04, "text": " So to try to summarize the question, the question is when as a compiler starter you're mostly", "tokens": [407, 281, 853, 281, 20858, 264, 1168, 11, 264, 1168, 307, 562, 382, 257, 31958, 22465, 291, 434, 5240], "temperature": 0.0, "avg_logprob": -0.16442248225212097, "compression_ratio": 1.5130434782608695, "no_speech_prob": 5.062569471192546e-05}, {"id": 246, "seek": 127504, "start": 1287.04, "end": 1292.48, "text": " focusing on parsing an abstract C type like language and want to know if you can just", "tokens": [8416, 322, 21156, 278, 364, 12649, 383, 2010, 411, 2856, 293, 528, 281, 458, 498, 291, 393, 445], "temperature": 0.0, "avg_logprob": -0.16442248225212097, "compression_ratio": 1.5130434782608695, "no_speech_prob": 5.062569471192546e-05}, {"id": 247, "seek": 127504, "start": 1292.48, "end": 1299.68, "text": " go through the ordinary LLVM IR way or if you need to plug in switch over to MLIR to", "tokens": [352, 807, 264, 10547, 441, 43, 53, 44, 16486, 636, 420, 498, 291, 643, 281, 5452, 294, 3679, 670, 281, 21601, 7740, 281], "temperature": 0.0, "avg_logprob": -0.16442248225212097, "compression_ratio": 1.5130434782608695, "no_speech_prob": 5.062569471192546e-05}, {"id": 248, "seek": 127504, "start": 1299.68, "end": 1301.92, "text": " do what you want.", "tokens": [360, 437, 291, 528, 13], "temperature": 0.0, "avg_logprob": -0.16442248225212097, "compression_ratio": 1.5130434782608695, "no_speech_prob": 5.062569471192546e-05}, {"id": 249, "seek": 127504, "start": 1301.92, "end": 1303.32, "text": " So in real short.", "tokens": [407, 294, 957, 2099, 13], "temperature": 0.0, "avg_logprob": -0.16442248225212097, "compression_ratio": 1.5130434782608695, "no_speech_prob": 5.062569471192546e-05}, {"id": 250, "seek": 130332, "start": 1303.32, "end": 1305.2, "text": " So you can do this definitely.", "tokens": [407, 291, 393, 360, 341, 2138, 13], "temperature": 0.0, "avg_logprob": -0.17942739616740833, "compression_ratio": 1.5204081632653061, "no_speech_prob": 5.8275370975025e-05}, {"id": 251, "seek": 130332, "start": 1305.2, "end": 1309.6, "text": " You can go the way you're right now doing.", "tokens": [509, 393, 352, 264, 636, 291, 434, 558, 586, 884, 13], "temperature": 0.0, "avg_logprob": -0.17942739616740833, "compression_ratio": 1.5204081632653061, "no_speech_prob": 5.8275370975025e-05}, {"id": 252, "seek": 130332, "start": 1309.6, "end": 1314.2, "text": " So MLIR actually is a little bit different.", "tokens": [407, 21601, 7740, 767, 307, 257, 707, 857, 819, 13], "temperature": 0.0, "avg_logprob": -0.17942739616740833, "compression_ratio": 1.5204081632653061, "no_speech_prob": 5.8275370975025e-05}, {"id": 253, "seek": 130332, "start": 1314.2, "end": 1321.8, "text": " So if we are looking to clang, if you're talking about an abstract C language, looking into", "tokens": [407, 498, 321, 366, 1237, 281, 596, 656, 11, 498, 291, 434, 1417, 466, 364, 12649, 383, 2856, 11, 1237, 666], "temperature": 0.0, "avg_logprob": -0.17942739616740833, "compression_ratio": 1.5204081632653061, "no_speech_prob": 5.8275370975025e-05}, {"id": 254, "seek": 130332, "start": 1321.8, "end": 1327.0, "text": " clang, there is clang AST and then we directly or more or less go to LLVM IR and that is", "tokens": [596, 656, 11, 456, 307, 596, 656, 316, 6840, 293, 550, 321, 3838, 420, 544, 420, 1570, 352, 281, 441, 43, 53, 44, 16486, 293, 300, 307], "temperature": 0.0, "avg_logprob": -0.17942739616740833, "compression_ratio": 1.5204081632653061, "no_speech_prob": 5.8275370975025e-05}, {"id": 255, "seek": 132700, "start": 1327.0, "end": 1336.56, "text": " one of the things which yeah isn't that nice or if you look into other compilers they introduce", "tokens": [472, 295, 264, 721, 597, 1338, 1943, 380, 300, 1481, 420, 498, 291, 574, 666, 661, 715, 388, 433, 436, 5366], "temperature": 0.0, "avg_logprob": -0.15557402058651573, "compression_ratio": 1.723809523809524, "no_speech_prob": 3.763392669497989e-05}, {"id": 256, "seek": 132700, "start": 1336.56, "end": 1341.56, "text": " more intermediate representations in between like we will see later on in the session the", "tokens": [544, 19376, 33358, 294, 1296, 411, 321, 486, 536, 1780, 322, 294, 264, 5481, 264], "temperature": 0.0, "avg_logprob": -0.15557402058651573, "compression_ratio": 1.723809523809524, "no_speech_prob": 3.763392669497989e-05}, {"id": 257, "seek": 132700, "start": 1341.56, "end": 1347.88, "text": " flang app that for example or even Swift has two intermediate representations for example.", "tokens": [932, 656, 724, 300, 337, 1365, 420, 754, 25539, 575, 732, 19376, 33358, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.15557402058651573, "compression_ratio": 1.723809523809524, "no_speech_prob": 3.763392669497989e-05}, {"id": 258, "seek": 132700, "start": 1347.88, "end": 1356.24, "text": " So MLIR just gives you the ability to define additional intermediate representations.", "tokens": [407, 21601, 7740, 445, 2709, 291, 264, 3485, 281, 6964, 4497, 19376, 33358, 13], "temperature": 0.0, "avg_logprob": -0.15557402058651573, "compression_ratio": 1.723809523809524, "no_speech_prob": 3.763392669497989e-05}, {"id": 259, "seek": 135624, "start": 1356.24, "end": 1366.24, "text": " So you can also write a front end for your language, parse it into MLIR, convert it to", "tokens": [407, 291, 393, 611, 2464, 257, 1868, 917, 337, 428, 2856, 11, 48377, 309, 666, 21601, 7740, 11, 7620, 309, 281], "temperature": 0.0, "avg_logprob": -0.13392447329115595, "compression_ratio": 1.530612244897959, "no_speech_prob": 1.833888927649241e-05}, {"id": 260, "seek": 135624, "start": 1366.24, "end": 1371.1200000000001, "text": " the LLVM IR dialect and then translate it to LLVM IR.", "tokens": [264, 441, 43, 53, 44, 16486, 24652, 293, 550, 13799, 309, 281, 441, 43, 53, 44, 16486, 13], "temperature": 0.0, "avg_logprob": -0.13392447329115595, "compression_ratio": 1.530612244897959, "no_speech_prob": 1.833888927649241e-05}, {"id": 261, "seek": 135624, "start": 1371.1200000000001, "end": 1372.4, "text": " So that would be identical.", "tokens": [407, 300, 576, 312, 14800, 13], "temperature": 0.0, "avg_logprob": -0.13392447329115595, "compression_ratio": 1.530612244897959, "no_speech_prob": 1.833888927649241e-05}, {"id": 262, "seek": 135624, "start": 1372.4, "end": 1376.24, "text": " It really depends on what you want to do, what kind of infrastructure you want to use.", "tokens": [467, 534, 5946, 322, 437, 291, 528, 281, 360, 11, 437, 733, 295, 6896, 291, 528, 281, 764, 13], "temperature": 0.0, "avg_logprob": -0.13392447329115595, "compression_ratio": 1.530612244897959, "no_speech_prob": 1.833888927649241e-05}, {"id": 263, "seek": 135624, "start": 1376.24, "end": 1380.4, "text": " But you can go the way you're already going.", "tokens": [583, 291, 393, 352, 264, 636, 291, 434, 1217, 516, 13], "temperature": 0.0, "avg_logprob": -0.13392447329115595, "compression_ratio": 1.530612244897959, "no_speech_prob": 1.833888927649241e-05}, {"id": 264, "seek": 138040, "start": 1380.4, "end": 1387.72, "text": " So hopefully that somehow at least answers your question.", "tokens": [407, 4696, 300, 6063, 412, 1935, 6338, 428, 1168, 13], "temperature": 0.0, "avg_logprob": -0.4194279534476144, "compression_ratio": 1.25, "no_speech_prob": 0.0002820777881424874}, {"id": 265, "seek": 138040, "start": 1387.72, "end": 1410.3600000000001, "text": " Okay, the question is not directly related to the talk but as I'm one of the developers", "tokens": [1033, 11, 264, 1168, 307, 406, 3838, 4077, 281, 264, 751, 457, 382, 286, 478, 472, 295, 264, 8849], "temperature": 0.0, "avg_logprob": -0.4194279534476144, "compression_ratio": 1.25, "no_speech_prob": 0.0002820777881424874}, {"id": 266, "seek": 141036, "start": 1410.36, "end": 1415.0, "text": " behind MLC, why we developed MLC?", "tokens": [2261, 21601, 34, 11, 983, 321, 4743, 21601, 34, 30], "temperature": 0.0, "avg_logprob": -0.2204462224786932, "compression_ratio": 1.3856209150326797, "no_speech_prob": 0.00021302897948771715}, {"id": 267, "seek": 141036, "start": 1415.0, "end": 1424.12, "text": " Sometimes you cannot compile with clang or directly or with LLVM at all to your target.", "tokens": [4803, 291, 2644, 31413, 365, 596, 656, 420, 3838, 420, 365, 441, 43, 53, 44, 412, 439, 281, 428, 3779, 13], "temperature": 0.0, "avg_logprob": -0.2204462224786932, "compression_ratio": 1.3856209150326797, "no_speech_prob": 0.00021302897948771715}, {"id": 268, "seek": 141036, "start": 1424.12, "end": 1436.76, "text": " So the idea was to get something independent of the compiler and when we actually generate", "tokens": [407, 264, 1558, 390, 281, 483, 746, 6695, 295, 264, 31958, 293, 562, 321, 767, 8460], "temperature": 0.0, "avg_logprob": -0.2204462224786932, "compression_ratio": 1.3856209150326797, "no_speech_prob": 0.00021302897948771715}, {"id": 269, "seek": 143676, "start": 1436.76, "end": 1443.32, "text": " C code with MLC you can have send the freedom to choose which compiler you want to use to", "tokens": [383, 3089, 365, 21601, 34, 291, 393, 362, 2845, 264, 5645, 281, 2826, 597, 31958, 291, 528, 281, 764, 281], "temperature": 0.0, "avg_logprob": -0.1896007090439031, "compression_ratio": 1.625, "no_speech_prob": 0.00012335865176282823}, {"id": 270, "seek": 143676, "start": 1443.32, "end": 1446.8, "text": " translate for your final target.", "tokens": [13799, 337, 428, 2572, 3779, 13], "temperature": 0.0, "avg_logprob": -0.1896007090439031, "compression_ratio": 1.625, "no_speech_prob": 0.00012335865176282823}, {"id": 271, "seek": 143676, "start": 1446.8, "end": 1452.0, "text": " So we are in the domain of compilers for machine learning and sometimes we have some very exotic", "tokens": [407, 321, 366, 294, 264, 9274, 295, 715, 388, 433, 337, 3479, 2539, 293, 2171, 321, 362, 512, 588, 27063], "temperature": 0.0, "avg_logprob": -0.1896007090439031, "compression_ratio": 1.625, "no_speech_prob": 0.00012335865176282823}, {"id": 272, "seek": 143676, "start": 1452.0, "end": 1457.92, "text": " targets where clang unfortunately is not the option to use it as a compiler.", "tokens": [12911, 689, 596, 656, 7015, 307, 406, 264, 3614, 281, 764, 309, 382, 257, 31958, 13], "temperature": 0.0, "avg_logprob": -0.1896007090439031, "compression_ratio": 1.625, "no_speech_prob": 0.00012335865176282823}, {"id": 273, "seek": 143676, "start": 1457.92, "end": 1462.92, "text": " So that's the simple reason.", "tokens": [407, 300, 311, 264, 2199, 1778, 13], "temperature": 0.0, "avg_logprob": -0.1896007090439031, "compression_ratio": 1.625, "no_speech_prob": 0.00012335865176282823}, {"id": 274, "seek": 146292, "start": 1462.92, "end": 1475.0800000000002, "text": " Hi, I was coming from the opposite side of the spectrum, I was looking into doing some", "tokens": [2421, 11, 286, 390, 1348, 490, 264, 6182, 1252, 295, 264, 11143, 11, 286, 390, 1237, 666, 884, 512], "temperature": 0.0, "avg_logprob": -0.4158848571777344, "compression_ratio": 1.4104477611940298, "no_speech_prob": 0.002357864286750555}, {"id": 275, "seek": 146292, "start": 1475.0800000000002, "end": 1483.76, "text": " sort of just in time compilation but I also wanted to define my own types and my own let's", "tokens": [1333, 295, 445, 294, 565, 40261, 457, 286, 611, 1415, 281, 6964, 452, 1065, 3467, 293, 452, 1065, 718, 311], "temperature": 0.0, "avg_logprob": -0.4158848571777344, "compression_ratio": 1.4104477611940298, "no_speech_prob": 0.002357864286750555}, {"id": 276, "seek": 146292, "start": 1483.76, "end": 1484.76, "text": " say things.", "tokens": [584, 721, 13], "temperature": 0.0, "avg_logprob": -0.4158848571777344, "compression_ratio": 1.4104477611940298, "no_speech_prob": 0.002357864286750555}, {"id": 277, "seek": 148476, "start": 1484.76, "end": 1494.76, "text": " My question is would MLIR be a good fit for that or would possibly just see with some", "tokens": [1222, 1168, 307, 576, 21601, 7740, 312, 257, 665, 3318, 337, 300, 420, 576, 6264, 445, 536, 365, 512], "temperature": 0.0, "avg_logprob": -0.2877346430069361, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.00020017467613797635}, {"id": 278, "seek": 148476, "start": 1494.76, "end": 1501.92, "text": " sort of, I don't know, C++ with templates and some sort of, I don't know, dynamic language", "tokens": [1333, 295, 11, 286, 500, 380, 458, 11, 383, 25472, 365, 21165, 293, 512, 1333, 295, 11, 286, 500, 380, 458, 11, 8546, 2856], "temperature": 0.0, "avg_logprob": -0.2877346430069361, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.00020017467613797635}, {"id": 279, "seek": 148476, "start": 1501.92, "end": 1504.24, "text": " or something like that.", "tokens": [420, 746, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.2877346430069361, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.00020017467613797635}, {"id": 280, "seek": 148476, "start": 1504.24, "end": 1513.24, "text": " So the question is when coming from the other side, so for JIT essentially if MLIR might", "tokens": [407, 264, 1168, 307, 562, 1348, 490, 264, 661, 1252, 11, 370, 337, 508, 3927, 4476, 498, 21601, 7740, 1062], "temperature": 0.0, "avg_logprob": -0.2877346430069361, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.00020017467613797635}, {"id": 281, "seek": 151324, "start": 1513.24, "end": 1520.92, "text": " be a good fit to define your own types and attributes and well I'm not an expert regarding", "tokens": [312, 257, 665, 3318, 281, 6964, 428, 1065, 3467, 293, 17212, 293, 731, 286, 478, 406, 364, 5844, 8595], "temperature": 0.0, "avg_logprob": -0.14706914265950521, "compression_ratio": 1.5816326530612246, "no_speech_prob": 7.842471677577123e-05}, {"id": 282, "seek": 151324, "start": 1520.92, "end": 1529.96, "text": " JIT but MLIR provides you, I think most of the codes are upstream provides you the possibility", "tokens": [508, 3927, 457, 21601, 7740, 6417, 291, 11, 286, 519, 881, 295, 264, 14211, 366, 33915, 6417, 291, 264, 7959], "temperature": 0.0, "avg_logprob": -0.14706914265950521, "compression_ratio": 1.5816326530612246, "no_speech_prob": 7.842471677577123e-05}, {"id": 283, "seek": 151324, "start": 1529.96, "end": 1535.24, "text": " to register types and attributes I'm quite sure at least at runtime.", "tokens": [281, 7280, 3467, 293, 17212, 286, 478, 1596, 988, 412, 1935, 412, 34474, 13], "temperature": 0.0, "avg_logprob": -0.14706914265950521, "compression_ratio": 1.5816326530612246, "no_speech_prob": 7.842471677577123e-05}, {"id": 284, "seek": 151324, "start": 1535.24, "end": 1540.92, "text": " So you can extend your dialect after you compiled MLIR.", "tokens": [407, 291, 393, 10101, 428, 24652, 934, 291, 36548, 21601, 7740, 13], "temperature": 0.0, "avg_logprob": -0.14706914265950521, "compression_ratio": 1.5816326530612246, "no_speech_prob": 7.842471677577123e-05}, {"id": 285, "seek": 154092, "start": 1540.92, "end": 1546.0, "text": " So that is maybe, yeah, depending on what you want to do.", "tokens": [407, 300, 307, 1310, 11, 1338, 11, 5413, 322, 437, 291, 528, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.19502752255170774, "compression_ratio": 1.2280701754385965, "no_speech_prob": 5.822723687742837e-05}, {"id": 286, "seek": 154092, "start": 1546.0, "end": 1557.04, "text": " If you really want to modify it during runtime, that should be possible with MLIR.", "tokens": [759, 291, 534, 528, 281, 16927, 309, 1830, 34474, 11, 300, 820, 312, 1944, 365, 21601, 7740, 13], "temperature": 0.0, "avg_logprob": -0.19502752255170774, "compression_ratio": 1.2280701754385965, "no_speech_prob": 5.822723687742837e-05}, {"id": 287, "seek": 155704, "start": 1557.04, "end": 1573.08, "text": " So I'm not 100% sure but at least worth a look, I think.", "tokens": [407, 286, 478, 406, 2319, 4, 988, 457, 412, 1935, 3163, 257, 574, 11, 286, 519, 13], "temperature": 0.0, "avg_logprob": -0.3602363495599656, "compression_ratio": 0.875, "no_speech_prob": 0.00011711368279065937}, {"id": 288, "seek": 157308, "start": 1573.08, "end": 1601.48, "text": " Well, I'm partly aware of IRDL but I don't know, you mean how you composite VRC make", "tokens": [1042, 11, 286, 478, 17031, 3650, 295, 16486, 35, 43, 457, 286, 500, 380, 458, 11, 291, 914, 577, 291, 25557, 13722, 34, 652], "temperature": 0.0, "avg_logprob": -0.26305391107286724, "compression_ratio": 0.9882352941176471, "no_speech_prob": 0.0007299205171875656}, {"id": 289, "seek": 160148, "start": 1601.48, "end": 1610.44, "text": " into targets or would, yeah, probably you, as you with IRDL as far as I know as you do", "tokens": [666, 12911, 420, 576, 11, 1338, 11, 1391, 291, 11, 382, 291, 365, 16486, 35, 43, 382, 1400, 382, 286, 458, 382, 291, 360], "temperature": 0.0, "avg_logprob": -0.27846473010618294, "compression_ratio": 1.4367088607594938, "no_speech_prob": 0.00021278104395605624}, {"id": 290, "seek": 160148, "start": 1610.44, "end": 1615.6, "text": " most of the time at runtime, you wouldn't need to build it in advance.", "tokens": [881, 295, 264, 565, 412, 34474, 11, 291, 2759, 380, 643, 281, 1322, 309, 294, 7295, 13], "temperature": 0.0, "avg_logprob": -0.27846473010618294, "compression_ratio": 1.4367088607594938, "no_speech_prob": 0.00021278104395605624}, {"id": 291, "seek": 160148, "start": 1615.6, "end": 1623.44, "text": " So yeah, the CMake stuff would be somehow obsolete, yeah, I think so.", "tokens": [407, 1338, 11, 264, 20424, 619, 1507, 576, 312, 6063, 46333, 11, 1338, 11, 286, 519, 370, 13], "temperature": 0.0, "avg_logprob": -0.27846473010618294, "compression_ratio": 1.4367088607594938, "no_speech_prob": 0.00021278104395605624}, {"id": 292, "seek": 162344, "start": 1623.44, "end": 1634.3200000000002, "text": " All right, if we're out of questions, thank you Marius, thank you.", "tokens": [50364, 1057, 558, 11, 498, 321, 434, 484, 295, 1651, 11, 1309, 291, 2039, 4872, 11, 1309, 291, 13, 50908], "temperature": 0.0, "avg_logprob": -0.5219440460205078, "compression_ratio": 1.03125, "no_speech_prob": 0.0010767773492261767}], "language": "en"}