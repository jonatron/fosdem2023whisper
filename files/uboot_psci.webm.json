{"text": " Yeah, so let's start with this talk. My name is Marek Vashu and this talk is about Ubooth as a PSCI provider. Now, PSCI stands for Power State Coordination Interface. It's a standard drafted by ARM and it is used on ARM system. It defines a software interface that's used by things like bootloader's operating systems to bring up CPU cores, stop the CPU cores, do a system suspend, resume, perform, reboot and power off. The presence of the PSCI interface is mandatory on ARM v8. It is optional on ARM v7 although you can find ARM v7 systems which do also provide PSCI. There is a related interface which is called an SCMI and this is used for clock management, power domain management of devices. You may sometimes see that there are systems which misuse PSCI for this kind of functionality like power domain on and off and this is wrong. So that all goes into SCMI. We will not talk about SCMI however right now. The reason why PSCI exists is multiple fold. One of them is convenience. The thing is doing these things like CPU core on, off, suspend, resume. This is a really horribly complex process and hardware is full of bugs so implementing it correctly so that your system doesn't randomly crash during suspend for example. The code is very complex and if you want to run multiple OS's on an ARM machine there is a balancing act in place. Basically what ARM decided was to implement this once, implement it properly and then expose to the operating system an interface which allows it to say okay well now suspend or now bring up a CPU core. And all this horrible complexity and all the work arounds for the hardware bugs they are hidden in this sort of an interface which is implemented once. So it pretty much covers the convenience, the complexity. The other thing is the thing which brings up CPU cores may interact with say regulators and this could potentially damage the hardware if you do it wrong. So if the hardware is very fragile it may also be a good idea to hide this from the operating system which may crash and do something wrong and then potentially damage the hardware. That's why it's hidden in the firmware. However what you may argue is that if we put this functionality in the firmware what happens if the firmware is buggy then you have to update the firmware which essentially means updating your boot loader which is dangerous operation unless you are very well prepared for that. So it can break your machine if you do it wrong. So all of this is really a balancing act why not put it into the OS or into the boot loader. One completely separate reason for existence of this API is virtualization. So in a virtualized setup on ARM the secure monitor firmware which is running in the highest privilege level provides a PSCI interface to the OS running in lower privilege mode which is like the EL2 and that OS itself can provide the same looking PSCI interface to the OS running in virtualization so in EL1 and to the OS this looks very much identical whether it's running in virtualization or whether it's running on bare metal. So for that purpose also there is the PSCI interface which allows you to bring up CPU cores which in one case may be virtual in the other case they are the actual real CPU cores hardware ones. Now the way PSCI is implemented is by means of SMC CC which stands for SMC call convention which is another standard drafted by ARM and it basically tells you that on ARM64 there are two instructions one of them SMC the other HVC instruction and they both trigger a synchronous exception. In case of the SMC instruction the synchronous exception lands in exception level three in case of the HVC the synchronous exception lands in EL2 and the SMC CC also tells you which CPU registers to set up before you call the SMC and which CPU registers are then used as a return value from the SMC or HVC instruction. As for the exception levels there is four of them on ARM64 EL3 to EL0 the EL3 is the most privileged one this is where the secure monitor firmware runs and this is also where the code which brings up the CPU cores and does the suspend resume and all this is running. EL2 is the last privileged and this is where operating system is running the one which is running on bare metal. You can use SMC from the EL2 into the EL3 to request services from the secure monitor. EL1 is used for virtualized OS so an OS which is running in virtualization can do HVC which would trigger synchronous exception in EL2 in the OS which is running on the bare metal and the OS running on the bare metal may provide some services to the virtualized OS this way. You can read all about these exception levels in the ARM specification. If you download the slides which are in PENTA you can use all these links which will redirect you to all the specifications so we can just read all about that. Suffice to say there are these four exception levels on ARM for now. The way the SMC actually works is that if you want to do an SMC request you're supposed to set up CPU register zero with a function ID which basically says what kind of request you want to do. You want performed by the secure monitor or by the OS and then you're supposed to set up six additional parameters 6.1 all the way to x6 which are parameters for this function which you want to trigger. With this setup you have to do the SMC or HVC instruction. This instruction triggers synchronous exception. The synchronous exception then makes the CPU elevate its exception level to the higher one and trigger the exception handler which validates that the function ID is even okay for you to call that the parameters for the function are okay at all and if all of this is correct then the request which is represented by this function ID is then performed by the secure monitor firmware or by the OS. Once the request is performed the secure monitor firmware or the OS will set up for additional registers x0 to x3 with the return values and will return just past the SMC or HVC instruction into the calling software and resume execution at the exception level of the calling software and then the calling software can collect the result of this call in the registers x0 to x3 and do something about this. This is roughly how it works about these function IDs. These function IDs are the requests you can do to the secure monitor firmware or to the OS running in the bare metal. You can actually not find them in the SMCCC specification because the SMCCC specification just says there are function IDs but the blocks of these function IDs are distributed across various specifications like the PSCI specification which has two blocks carved out of the function IDs or the SCMI specification which has its own set of function IDs. The PSCI specification has two sets of function IDs. One is for 32-bit PSCI calls, the other is for 64-bit PSCI calls. The only reason for this is that 64-bit PSCI calls just take 64-bit parameters so the function signature is slightly different. But beyond that it's very much compatible the 32-bit and 64-bit PSCI functions and function implementations. So you can look up the function IDs obviously in the PSCI specification. You can also look them up in the UBOOT sources. You can look them up in the Linux kernel sources. This stuff here is coming from the UBOOT sources. Hello. So what you can see here is for example CPU on PSCI function which is actually a macro which is expanded to like C4 plus 3. So this would actually go into the SMC register x0 before you call the SMC instruction. Now there are multiple callers of the SMC instruction as well as multiple handlers. There are callers in UBOOT. This is all built around this FV call that see SMC call and HVC call implementation. In Linux the PSCI implementation lives in driver's firmware PSCI PSCI. The handlers are either in ATF or in UBOOT itself. The UBOOT SMC callers are all built around this SMC call function. So like anything in UBOOT which does PSCI interaction is essentially SMC call PSCI function name and then some parameters for the PSCI function. If you look at the SMC call and UBOOT actually it very much copies what's in the SMC CC. So that means set up register x0 with function ID, set up a couple of parameter registers x1 to x6, then trigger the SMC instruction. Once the SMC instruction request is done the execution will return past the SMC instruction and continue here where the UBOOT code will collect the registers which were set up by the secure monitor firmware as the return values from the SMC instruction and then you can use them in the UBOOT code. There is a matching HVC call a little bit further in this FV call that see in UBOOT if you want to look it up which is used for the EL2 HVC call. UBOOT has the bonus thing that it actually has a command which is called NSMC. So in the UBOOT command line you can experiment with the SMC calls and it's a command which takes seven parameters up to seven parameters. The first parameter is the SMC function ID and then the six additional parameters are the parameters for the SMC function. So if you want to do like a PSCI call I think this one is like PSCI version here you can do it like from the UBOOT command line and you can experiment with this all you want. The return value from the SMC command is four values which is the x0 x1 x3 and x0 x1 x2 and x3 CPU registers. So you can then analyze what you got out of the SMC call if it didn't fail obviously. As for the Linux kernel there is this additional thing in Linux then when the PSCI firmware driver is probing Linux has to figure out whether it is running on bare metal or in virtualization. So if Linux is running on bare metal then it uses the SMC instruction to communicate with the secure monitor firmware otherwise it's using the HVC instruction if it's running in virtualization to communicate with the OS that's running on the bare metal. But beyond that the PSCI firmware driver in Linux just exposes the PSCI functions as a wrapper around SMC calls and the actual SMC instruction call and the setup of the x0 all the way to x6 registers. This is implemented in smccc call.s in Rx64 so it's very much yet again a wrapper around the SMC instruction no matter whether it's UBOOT whether it's Linux. But now let's talk about the more interesting part which are the handlers and for one to be an SMC handler the CPU core has to fulfill a couple of requirements. The main requirement to handle SMC exceptions is to be able to even receive the exceptions. So the CPU core basically has to be able to receive exception in EL3 if it wants to handle SMC. If you are on an SMP system you also have to be able to receive IPIs inter processor interrupts because in order to bring up secondary cores it is necessary for the secondary cores to be able to receive IPIs to break them out of a loop in the PSCI provider firmware because the OS is not immediately ready for the secondary cores. I'll explain that in a bit. In UBOOT most of this PSCI and synchronous exception handling code is actually in place already and it's all generic code. So the UBOOT entry point the UBOOT entry point is very much here in the startup.s and the PSCI synchronous exception handling code is here in PSCI.s. It's there both for ARM32 and ARM64 it's just in different subdirectories. All you as a user actually have to implement is the PSCI.C which are the C callbacks of the actual PSCI functionality which perform the stuff which the PSCI function are supposed to do with the hardware like start the CPU core, stop the CPU core. So all this stuff is generic, all this stuff is so specific and if you decide to implement PSCI provider in UBOOT you have to fill that in. Now if a UBOOT is configured as a PSCI provider then UBOOT is running in EL3 that means in the highest execution level, exception level. That means UBOOT is not able to perform any SMC calls so you have to make sure there are none because otherwise the system would just hang on boot. The OS will be running in EL2 and it will be able to do SMC calls into the UBOOT synchronous exception handler so this is something to keep in mind. Beyond that if UBOOT is configured to be a PSCI provider there is only really a little bit of additional setup when the UBOOT starts up in this MV8 setup PSCI and this code does basically that it takes parts of UBOOT which are marked with attribute secure which is essentially the PSCI handling code. It copies it into an SRAM then it setups MMU tables and flags this SRAM with a secure bit. That means no code running in not EL3 that means anything lower than EL3 will be able to modify this secure handling code. Finally the UBOOT sets up an exception vectors so that when the synchronous exception happens it will land in the UBOOT synchronous exception handler and then enter the PSCI code. When such a synchronous exception happens the UBOOT synchronous exception handler is entered so when like an OS does SMC call it will land here in the MV8 PSCI.S handle thing and at that point the synchronous exception can be anything so first we have to figure out whether this is even an SMC at all or it could be a hardware fault it could be an unknown SMC exception which we cannot even handle. If it is an SMC exception we need to figure out whether it's 32-bit one or 64-bit one assuming it's an SMC 64 on MV8 we still need to figure out whether this is a even a PSCI exception or it could be another type of an SMC. If it is a PSCI then UBOOT looks up the callback function which implements the PSCI function ID if it even exists in UBOOT and if it does then it sets up C runtime environment and jumps onto the C function which then looks very much like this and in this C function you can just do like a write into a register and for example in this case power of the system and like you don't have to care about the assembler before that all you have to care about with the PSCI provider is very much this because this is so specific and this is something you have to implement. Now on SMP there is this additional problem in that when the operating system running in EL2 requests from the PSCI provider that it wants to bring up secondary core the operating system will pass through the PSCI a pointer for the OS entry point but you cannot just turn on the secondary core which will start up in EL3 and point it into the OS entry point because this would be a security violation you would essentially start the CPU core which is running in the highest privilege level and make it enter the operating system in some sort of a highest privilege level state even though the OS is running in lower privilege state so what happens there is the CPU core actually has to enter Uboot in the Uboot init code the CPU core gets configured gets set in a defined state so that it can enter the OS the CPU core GIC the interrupt controller registers are configured so that it can receive an IPI then the CPU core drops into EL2 and then the CPU core starts spinning and waiting for an IPI so that when the operating system is actually ready to receive the CPU core it can ping it with an IPI and the CPU core will then be released to the operating system and it jumps to the operating system entry point and then the operating system runs on two cores so this is the detail with an smp finally here is a summary of what to do in case you want to use Uboot as a psci provider so you have to look up the gig distributor and redistributor base this is something which you find out in your SOC datasheet or if there is a linux device today it's already there and define these two macros gig debase and gigar base then you have to make sure that your DRAM is marked as non-secure because sometimes it is marked as secure and if it is marked as secure in the MMU tables then your OS will not be able to access DRAM and it will crash you potentially have to configure other security related registers of the CPU this is again SOC specific you have to look it up in your SOC datasheet then finally the main part of the implementation is fill in your psci.c callback implementation against SOC specific and then remove the previews pl31 psci implementation block which potentially was atf enable these Uboot config options give or take in the Uboot port config and compile and then it should basically work and in case it doesn't work Uboot has the debug UART functionality so if you have two UARTs on your machine you can point the debug UART into the other UART not the console UART and use this dedicated lightweight printing mechanism to essentially print some sort of debug output from the Uboot psci provider the secure part even while the Linux kernel is running it is possible to get some debug UART prints out of this here are the config options which you used for that okay and now since I am through my slides I promised an example so this will be very boring here is Uboot and if you are familiar with Uboot this is how it looks and it just looks all the same except if you are familiar with Uboot on imx8m plus or imx8m in general you may notice that there is no notice here the notice comes from the atfpl31 blob and the blob is not there because the Uboot is the provider of that functionality now but beyond that I can boot the Linux kernel all the same the Linux kernel detects that there is a psci interface in the firmware which is now provided by the Uboot the Linux kernel brings up the cpu course the cpu course show up in proc cpu info and the cpu course just work and that's actually all there is to show it's exactly the same as it was with the blob except now you have one less entry in the s-point so you no longer need the atfpl31 blob which is bundled with Uboot because Uboot can do it now for you and by the way this stuff is now upstream since two days ago in case you enable the debug uart you will see some sort of a debug print out of the secure part of Uboot for example here is psci cpu 164 this is the Linux kernel sending the psci request to Uboot and Uboot just brings up the cpu code for the Linux kernel and that's it thank you for your attention questions yeah so if you have an existing atf implementing psci and you want to move to Uboot you have to convert everything at once there's no way to like step by step move functionality over so you see the functionality is actually super simple i mean all you have to do is like turn on cpu code turn off cpu code and suspend and power off and reset and this is like 200 lines of code so it's like super simple really um and it's actually all now upstream for imx 8m plus so we can actually just use that as an inspiration", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 12.200000000000001, "text": " Yeah, so let's start with this talk. My name is Marek Vashu and this talk is about Ubooth", "tokens": [50364, 865, 11, 370, 718, 311, 722, 365, 341, 751, 13, 1222, 1315, 307, 376, 543, 74, 691, 1299, 84, 293, 341, 751, 307, 466, 624, 1763, 900, 50974], "temperature": 0.0, "avg_logprob": -0.2672908978584485, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.1335625946521759}, {"id": 1, "seek": 0, "start": 12.200000000000001, "end": 19.76, "text": " as a PSCI provider. Now, PSCI stands for Power State Coordination Interface. It's a standard", "tokens": [50974, 382, 257, 8168, 25240, 12398, 13, 823, 11, 8168, 25240, 7382, 337, 7086, 4533, 3066, 765, 2486, 5751, 2868, 13, 467, 311, 257, 3832, 51352], "temperature": 0.0, "avg_logprob": -0.2672908978584485, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.1335625946521759}, {"id": 2, "seek": 0, "start": 19.76, "end": 27.36, "text": " drafted by ARM and it is used on ARM system. It defines a software interface that's used", "tokens": [51352, 36288, 538, 45209, 293, 309, 307, 1143, 322, 45209, 1185, 13, 467, 23122, 257, 4722, 9226, 300, 311, 1143, 51732], "temperature": 0.0, "avg_logprob": -0.2672908978584485, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.1335625946521759}, {"id": 3, "seek": 2736, "start": 27.36, "end": 34.68, "text": " by things like bootloader's operating systems to bring up CPU cores, stop the CPU cores,", "tokens": [50364, 538, 721, 411, 11450, 2907, 260, 311, 7447, 3652, 281, 1565, 493, 13199, 24826, 11, 1590, 264, 13199, 24826, 11, 50730], "temperature": 0.0, "avg_logprob": -0.19129636254109128, "compression_ratio": 1.4619565217391304, "no_speech_prob": 0.028248341754078865}, {"id": 4, "seek": 2736, "start": 34.68, "end": 45.92, "text": " do a system suspend, resume, perform, reboot and power off. The presence of the PSCI interface", "tokens": [50730, 360, 257, 1185, 42546, 11, 15358, 11, 2042, 11, 33818, 293, 1347, 766, 13, 440, 6814, 295, 264, 8168, 25240, 9226, 51292], "temperature": 0.0, "avg_logprob": -0.19129636254109128, "compression_ratio": 1.4619565217391304, "no_speech_prob": 0.028248341754078865}, {"id": 5, "seek": 2736, "start": 45.92, "end": 52.480000000000004, "text": " is mandatory on ARM v8. It is optional on ARM v7 although you can find ARM v7 systems", "tokens": [51292, 307, 22173, 322, 45209, 371, 23, 13, 467, 307, 17312, 322, 45209, 371, 22, 4878, 291, 393, 915, 45209, 371, 22, 3652, 51620], "temperature": 0.0, "avg_logprob": -0.19129636254109128, "compression_ratio": 1.4619565217391304, "no_speech_prob": 0.028248341754078865}, {"id": 6, "seek": 5248, "start": 52.519999999999996, "end": 60.12, "text": " which do also provide PSCI. There is a related interface which is called an SCMI and this", "tokens": [50366, 597, 360, 611, 2893, 8168, 25240, 13, 821, 307, 257, 4077, 9226, 597, 307, 1219, 364, 9028, 13808, 293, 341, 50746], "temperature": 0.0, "avg_logprob": -0.13267539268316225, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.008261969313025475}, {"id": 7, "seek": 5248, "start": 60.12, "end": 67.44, "text": " is used for clock management, power domain management of devices. You may sometimes see", "tokens": [50746, 307, 1143, 337, 7830, 4592, 11, 1347, 9274, 4592, 295, 5759, 13, 509, 815, 2171, 536, 51112], "temperature": 0.0, "avg_logprob": -0.13267539268316225, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.008261969313025475}, {"id": 8, "seek": 5248, "start": 67.44, "end": 74.0, "text": " that there are systems which misuse PSCI for this kind of functionality like power domain", "tokens": [51112, 300, 456, 366, 3652, 597, 3346, 438, 8168, 25240, 337, 341, 733, 295, 14980, 411, 1347, 9274, 51440], "temperature": 0.0, "avg_logprob": -0.13267539268316225, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.008261969313025475}, {"id": 9, "seek": 5248, "start": 74.0, "end": 82.08, "text": " on and off and this is wrong. So that all goes into SCMI. We will not talk about SCMI", "tokens": [51440, 322, 293, 766, 293, 341, 307, 2085, 13, 407, 300, 439, 1709, 666, 9028, 13808, 13, 492, 486, 406, 751, 466, 9028, 13808, 51844], "temperature": 0.0, "avg_logprob": -0.13267539268316225, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.008261969313025475}, {"id": 10, "seek": 8208, "start": 82.12, "end": 92.16, "text": " however right now. The reason why PSCI exists is multiple fold. One of them is convenience.", "tokens": [50366, 4461, 558, 586, 13, 440, 1778, 983, 8168, 25240, 8198, 307, 3866, 4860, 13, 1485, 295, 552, 307, 19283, 13, 50868], "temperature": 0.0, "avg_logprob": -0.18164181428797105, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.004841723944991827}, {"id": 11, "seek": 8208, "start": 92.16, "end": 99.72, "text": " The thing is doing these things like CPU core on, off, suspend, resume. This is a really", "tokens": [50868, 440, 551, 307, 884, 613, 721, 411, 13199, 4965, 322, 11, 766, 11, 42546, 11, 15358, 13, 639, 307, 257, 534, 51246], "temperature": 0.0, "avg_logprob": -0.18164181428797105, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.004841723944991827}, {"id": 12, "seek": 8208, "start": 99.72, "end": 105.16, "text": " horribly complex process and hardware is full of bugs so implementing it correctly so that", "tokens": [51246, 45028, 3997, 1399, 293, 8837, 307, 1577, 295, 15120, 370, 18114, 309, 8944, 370, 300, 51518], "temperature": 0.0, "avg_logprob": -0.18164181428797105, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.004841723944991827}, {"id": 13, "seek": 8208, "start": 105.16, "end": 111.64, "text": " your system doesn't randomly crash during suspend for example. The code is very complex and if you", "tokens": [51518, 428, 1185, 1177, 380, 16979, 8252, 1830, 42546, 337, 1365, 13, 440, 3089, 307, 588, 3997, 293, 498, 291, 51842], "temperature": 0.0, "avg_logprob": -0.18164181428797105, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.004841723944991827}, {"id": 14, "seek": 11164, "start": 111.68, "end": 120.12, "text": " want to run multiple OS's on an ARM machine there is a balancing act in place. Basically what", "tokens": [50366, 528, 281, 1190, 3866, 12731, 311, 322, 364, 45209, 3479, 456, 307, 257, 22495, 605, 294, 1081, 13, 8537, 437, 50788], "temperature": 0.0, "avg_logprob": -0.2110937890552339, "compression_ratio": 1.5416666666666667, "no_speech_prob": 0.0009630760177969933}, {"id": 15, "seek": 11164, "start": 120.12, "end": 127.44, "text": " ARM decided was to implement this once, implement it properly and then expose to the operating", "tokens": [50788, 45209, 3047, 390, 281, 4445, 341, 1564, 11, 4445, 309, 6108, 293, 550, 19219, 281, 264, 7447, 51154], "temperature": 0.0, "avg_logprob": -0.2110937890552339, "compression_ratio": 1.5416666666666667, "no_speech_prob": 0.0009630760177969933}, {"id": 16, "seek": 11164, "start": 127.44, "end": 133.52, "text": " system an interface which allows it to say okay well now suspend or now bring up a CPU core.", "tokens": [51154, 1185, 364, 9226, 597, 4045, 309, 281, 584, 1392, 731, 586, 42546, 420, 586, 1565, 493, 257, 13199, 4965, 13, 51458], "temperature": 0.0, "avg_logprob": -0.2110937890552339, "compression_ratio": 1.5416666666666667, "no_speech_prob": 0.0009630760177969933}, {"id": 17, "seek": 11164, "start": 133.52, "end": 139.44, "text": " And all this horrible complexity and all the work arounds for the hardware bugs they are", "tokens": [51458, 400, 439, 341, 9263, 14024, 293, 439, 264, 589, 926, 82, 337, 264, 8837, 15120, 436, 366, 51754], "temperature": 0.0, "avg_logprob": -0.2110937890552339, "compression_ratio": 1.5416666666666667, "no_speech_prob": 0.0009630760177969933}, {"id": 18, "seek": 13944, "start": 139.64, "end": 146.04, "text": " hidden in this sort of an interface which is implemented once. So it pretty much covers the", "tokens": [50374, 7633, 294, 341, 1333, 295, 364, 9226, 597, 307, 12270, 1564, 13, 407, 309, 1238, 709, 10538, 264, 50694], "temperature": 0.0, "avg_logprob": -0.14256668090820312, "compression_ratio": 1.668122270742358, "no_speech_prob": 0.004932979121804237}, {"id": 19, "seek": 13944, "start": 146.04, "end": 152.56, "text": " convenience, the complexity. The other thing is the thing which brings up CPU cores may interact", "tokens": [50694, 19283, 11, 264, 14024, 13, 440, 661, 551, 307, 264, 551, 597, 5607, 493, 13199, 24826, 815, 4648, 51020], "temperature": 0.0, "avg_logprob": -0.14256668090820312, "compression_ratio": 1.668122270742358, "no_speech_prob": 0.004932979121804237}, {"id": 20, "seek": 13944, "start": 152.56, "end": 160.04, "text": " with say regulators and this could potentially damage the hardware if you do it wrong. So if the", "tokens": [51020, 365, 584, 37311, 293, 341, 727, 7263, 4344, 264, 8837, 498, 291, 360, 309, 2085, 13, 407, 498, 264, 51394], "temperature": 0.0, "avg_logprob": -0.14256668090820312, "compression_ratio": 1.668122270742358, "no_speech_prob": 0.004932979121804237}, {"id": 21, "seek": 13944, "start": 160.04, "end": 164.28, "text": " hardware is very fragile it may also be a good idea to hide this from the operating system which", "tokens": [51394, 8837, 307, 588, 23847, 309, 815, 611, 312, 257, 665, 1558, 281, 6479, 341, 490, 264, 7447, 1185, 597, 51606], "temperature": 0.0, "avg_logprob": -0.14256668090820312, "compression_ratio": 1.668122270742358, "no_speech_prob": 0.004932979121804237}, {"id": 22, "seek": 16428, "start": 164.32, "end": 168.56, "text": " may crash and do something wrong and then potentially damage the hardware. That's why it's", "tokens": [50366, 815, 8252, 293, 360, 746, 2085, 293, 550, 7263, 4344, 264, 8837, 13, 663, 311, 983, 309, 311, 50578], "temperature": 0.0, "avg_logprob": -0.15773314237594604, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.012872901745140553}, {"id": 23, "seek": 16428, "start": 168.56, "end": 176.36, "text": " hidden in the firmware. However what you may argue is that if we put this functionality in the", "tokens": [50578, 7633, 294, 264, 30289, 13, 2908, 437, 291, 815, 9695, 307, 300, 498, 321, 829, 341, 14980, 294, 264, 50968], "temperature": 0.0, "avg_logprob": -0.15773314237594604, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.012872901745140553}, {"id": 24, "seek": 16428, "start": 176.36, "end": 180.64, "text": " firmware what happens if the firmware is buggy then you have to update the firmware which", "tokens": [50968, 30289, 437, 2314, 498, 264, 30289, 307, 7426, 1480, 550, 291, 362, 281, 5623, 264, 30289, 597, 51182], "temperature": 0.0, "avg_logprob": -0.15773314237594604, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.012872901745140553}, {"id": 25, "seek": 16428, "start": 180.64, "end": 188.2, "text": " essentially means updating your boot loader which is dangerous operation unless you are very well", "tokens": [51182, 4476, 1355, 25113, 428, 11450, 3677, 260, 597, 307, 5795, 6916, 5969, 291, 366, 588, 731, 51560], "temperature": 0.0, "avg_logprob": -0.15773314237594604, "compression_ratio": 1.7188940092165899, "no_speech_prob": 0.012872901745140553}, {"id": 26, "seek": 18820, "start": 188.23999999999998, "end": 194.64, "text": " prepared for that. So it can break your machine if you do it wrong. So all of this is really a", "tokens": [50366, 4927, 337, 300, 13, 407, 309, 393, 1821, 428, 3479, 498, 291, 360, 309, 2085, 13, 407, 439, 295, 341, 307, 534, 257, 50686], "temperature": 0.0, "avg_logprob": -0.11855305324901234, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.017764540389180183}, {"id": 27, "seek": 18820, "start": 194.64, "end": 202.44, "text": " balancing act why not put it into the OS or into the boot loader. One completely separate", "tokens": [50686, 22495, 605, 983, 406, 829, 309, 666, 264, 12731, 420, 666, 264, 11450, 3677, 260, 13, 1485, 2584, 4994, 51076], "temperature": 0.0, "avg_logprob": -0.11855305324901234, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.017764540389180183}, {"id": 28, "seek": 18820, "start": 202.44, "end": 210.83999999999997, "text": " reason for existence of this API is virtualization. So in a virtualized setup on ARM the secure", "tokens": [51076, 1778, 337, 9123, 295, 341, 9362, 307, 6374, 2144, 13, 407, 294, 257, 6374, 1602, 8657, 322, 45209, 264, 7144, 51496], "temperature": 0.0, "avg_logprob": -0.11855305324901234, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.017764540389180183}, {"id": 29, "seek": 18820, "start": 210.83999999999997, "end": 215.95999999999998, "text": " monitor firmware which is running in the highest privilege level provides a PSCI interface to", "tokens": [51496, 6002, 30289, 597, 307, 2614, 294, 264, 6343, 12122, 1496, 6417, 257, 8168, 25240, 9226, 281, 51752], "temperature": 0.0, "avg_logprob": -0.11855305324901234, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.017764540389180183}, {"id": 30, "seek": 21596, "start": 215.96, "end": 225.24, "text": " the OS running in lower privilege mode which is like the EL2 and that OS itself can provide the", "tokens": [50364, 264, 12731, 2614, 294, 3126, 12122, 4391, 597, 307, 411, 264, 14426, 17, 293, 300, 12731, 2564, 393, 2893, 264, 50828], "temperature": 0.0, "avg_logprob": -0.1310095257229275, "compression_ratio": 1.7219730941704037, "no_speech_prob": 0.0022310952190309763}, {"id": 31, "seek": 21596, "start": 225.24, "end": 232.72, "text": " same looking PSCI interface to the OS running in virtualization so in EL1 and to the OS this looks", "tokens": [50828, 912, 1237, 8168, 25240, 9226, 281, 264, 12731, 2614, 294, 6374, 2144, 370, 294, 14426, 16, 293, 281, 264, 12731, 341, 1542, 51202], "temperature": 0.0, "avg_logprob": -0.1310095257229275, "compression_ratio": 1.7219730941704037, "no_speech_prob": 0.0022310952190309763}, {"id": 32, "seek": 21596, "start": 232.72, "end": 237.04000000000002, "text": " very much identical whether it's running in virtualization or whether it's running on bare", "tokens": [51202, 588, 709, 14800, 1968, 309, 311, 2614, 294, 6374, 2144, 420, 1968, 309, 311, 2614, 322, 6949, 51418], "temperature": 0.0, "avg_logprob": -0.1310095257229275, "compression_ratio": 1.7219730941704037, "no_speech_prob": 0.0022310952190309763}, {"id": 33, "seek": 21596, "start": 237.04000000000002, "end": 243.64000000000001, "text": " metal. So for that purpose also there is the PSCI interface which allows you to bring up CPU cores", "tokens": [51418, 5760, 13, 407, 337, 300, 4334, 611, 456, 307, 264, 8168, 25240, 9226, 597, 4045, 291, 281, 1565, 493, 13199, 24826, 51748], "temperature": 0.0, "avg_logprob": -0.1310095257229275, "compression_ratio": 1.7219730941704037, "no_speech_prob": 0.0022310952190309763}, {"id": 34, "seek": 24364, "start": 243.67999999999998, "end": 250.11999999999998, "text": " which in one case may be virtual in the other case they are the actual real CPU cores hardware ones.", "tokens": [50366, 597, 294, 472, 1389, 815, 312, 6374, 294, 264, 661, 1389, 436, 366, 264, 3539, 957, 13199, 24826, 8837, 2306, 13, 50688], "temperature": 0.0, "avg_logprob": -0.16362709317888532, "compression_ratio": 1.5, "no_speech_prob": 0.0049879467114806175}, {"id": 35, "seek": 24364, "start": 250.11999999999998, "end": 259.03999999999996, "text": " Now the way PSCI is implemented is by means of SMC CC which stands for SMC call convention which is", "tokens": [50688, 823, 264, 636, 8168, 25240, 307, 12270, 307, 538, 1355, 295, 13115, 34, 12630, 597, 7382, 337, 13115, 34, 818, 10286, 597, 307, 51134], "temperature": 0.0, "avg_logprob": -0.16362709317888532, "compression_ratio": 1.5, "no_speech_prob": 0.0049879467114806175}, {"id": 36, "seek": 24364, "start": 259.03999999999996, "end": 265.71999999999997, "text": " another standard drafted by ARM and it basically tells you that on ARM64 there are two instructions", "tokens": [51134, 1071, 3832, 36288, 538, 45209, 293, 309, 1936, 5112, 291, 300, 322, 45209, 19395, 456, 366, 732, 9415, 51468], "temperature": 0.0, "avg_logprob": -0.16362709317888532, "compression_ratio": 1.5, "no_speech_prob": 0.0049879467114806175}, {"id": 37, "seek": 26572, "start": 266.20000000000005, "end": 275.44000000000005, "text": " one of them SMC the other HVC instruction and they both trigger a synchronous exception. In case of", "tokens": [50388, 472, 295, 552, 13115, 34, 264, 661, 389, 53, 34, 10951, 293, 436, 1293, 7875, 257, 44743, 11183, 13, 682, 1389, 295, 50850], "temperature": 0.0, "avg_logprob": -0.15264892578125, "compression_ratio": 1.8148148148148149, "no_speech_prob": 0.05866844952106476}, {"id": 38, "seek": 26572, "start": 275.44000000000005, "end": 283.36, "text": " the SMC instruction the synchronous exception lands in exception level three in case of the HVC", "tokens": [50850, 264, 13115, 34, 10951, 264, 44743, 11183, 5949, 294, 11183, 1496, 1045, 294, 1389, 295, 264, 389, 53, 34, 51246], "temperature": 0.0, "avg_logprob": -0.15264892578125, "compression_ratio": 1.8148148148148149, "no_speech_prob": 0.05866844952106476}, {"id": 39, "seek": 26572, "start": 283.36, "end": 290.08000000000004, "text": " the synchronous exception lands in EL2 and the SMC CC also tells you which CPU registers to set up", "tokens": [51246, 264, 44743, 11183, 5949, 294, 14426, 17, 293, 264, 13115, 34, 12630, 611, 5112, 291, 597, 13199, 38351, 281, 992, 493, 51582], "temperature": 0.0, "avg_logprob": -0.15264892578125, "compression_ratio": 1.8148148148148149, "no_speech_prob": 0.05866844952106476}, {"id": 40, "seek": 29008, "start": 290.08, "end": 298.2, "text": " before you call the SMC and which CPU registers are then used as a return value from the SMC or HVC", "tokens": [50364, 949, 291, 818, 264, 13115, 34, 293, 597, 13199, 38351, 366, 550, 1143, 382, 257, 2736, 2158, 490, 264, 13115, 34, 420, 389, 53, 34, 50770], "temperature": 0.0, "avg_logprob": -0.14026515107405813, "compression_ratio": 1.494949494949495, "no_speech_prob": 0.002787488279864192}, {"id": 41, "seek": 29008, "start": 298.2, "end": 308.15999999999997, "text": " instruction. As for the exception levels there is four of them on ARM64 EL3 to EL0 the EL3 is the most", "tokens": [50770, 10951, 13, 1018, 337, 264, 11183, 4358, 456, 307, 1451, 295, 552, 322, 45209, 19395, 14426, 18, 281, 14426, 15, 264, 14426, 18, 307, 264, 881, 51268], "temperature": 0.0, "avg_logprob": -0.14026515107405813, "compression_ratio": 1.494949494949495, "no_speech_prob": 0.002787488279864192}, {"id": 42, "seek": 29008, "start": 308.15999999999997, "end": 315.15999999999997, "text": " privileged one this is where the secure monitor firmware runs and this is also where the code", "tokens": [51268, 25293, 472, 341, 307, 689, 264, 7144, 6002, 30289, 6676, 293, 341, 307, 611, 689, 264, 3089, 51618], "temperature": 0.0, "avg_logprob": -0.14026515107405813, "compression_ratio": 1.494949494949495, "no_speech_prob": 0.002787488279864192}, {"id": 43, "seek": 31516, "start": 315.24, "end": 322.52000000000004, "text": " which brings up the CPU cores and does the suspend resume and all this is running. EL2 is the", "tokens": [50368, 597, 5607, 493, 264, 13199, 24826, 293, 775, 264, 42546, 15358, 293, 439, 341, 307, 2614, 13, 14426, 17, 307, 264, 50732], "temperature": 0.0, "avg_logprob": -0.12947569290796915, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.006419462617486715}, {"id": 44, "seek": 31516, "start": 322.52000000000004, "end": 327.24, "text": " last privileged and this is where operating system is running the one which is running on bare", "tokens": [50732, 1036, 25293, 293, 341, 307, 689, 7447, 1185, 307, 2614, 264, 472, 597, 307, 2614, 322, 6949, 50968], "temperature": 0.0, "avg_logprob": -0.12947569290796915, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.006419462617486715}, {"id": 45, "seek": 31516, "start": 327.24, "end": 335.56, "text": " metal. You can use SMC from the EL2 into the EL3 to request services from the secure monitor. EL1 is", "tokens": [50968, 5760, 13, 509, 393, 764, 13115, 34, 490, 264, 14426, 17, 666, 264, 14426, 18, 281, 5308, 3328, 490, 264, 7144, 6002, 13, 14426, 16, 307, 51384], "temperature": 0.0, "avg_logprob": -0.12947569290796915, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.006419462617486715}, {"id": 46, "seek": 31516, "start": 335.56, "end": 344.52000000000004, "text": " used for virtualized OS so an OS which is running in virtualization can do HVC which would trigger", "tokens": [51384, 1143, 337, 6374, 1602, 12731, 370, 364, 12731, 597, 307, 2614, 294, 6374, 2144, 393, 360, 389, 53, 34, 597, 576, 7875, 51832], "temperature": 0.0, "avg_logprob": -0.12947569290796915, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.006419462617486715}, {"id": 47, "seek": 34452, "start": 344.52, "end": 350.0, "text": " synchronous exception in EL2 in the OS which is running on the bare metal and the OS running on the", "tokens": [50364, 44743, 11183, 294, 14426, 17, 294, 264, 12731, 597, 307, 2614, 322, 264, 6949, 5760, 293, 264, 12731, 2614, 322, 264, 50638], "temperature": 0.0, "avg_logprob": -0.1301801630428859, "compression_ratio": 1.821969696969697, "no_speech_prob": 0.0007645549485459924}, {"id": 48, "seek": 34452, "start": 350.0, "end": 355.44, "text": " bare metal may provide some services to the virtualized OS this way. You can read all about", "tokens": [50638, 6949, 5760, 815, 2893, 512, 3328, 281, 264, 6374, 1602, 12731, 341, 636, 13, 509, 393, 1401, 439, 466, 50910], "temperature": 0.0, "avg_logprob": -0.1301801630428859, "compression_ratio": 1.821969696969697, "no_speech_prob": 0.0007645549485459924}, {"id": 49, "seek": 34452, "start": 355.44, "end": 362.0, "text": " these exception levels in the ARM specification. If you download the slides which are in PENTA you", "tokens": [50910, 613, 11183, 4358, 294, 264, 45209, 31256, 13, 759, 291, 5484, 264, 9788, 597, 366, 294, 430, 2195, 8241, 291, 51238], "temperature": 0.0, "avg_logprob": -0.1301801630428859, "compression_ratio": 1.821969696969697, "no_speech_prob": 0.0007645549485459924}, {"id": 50, "seek": 34452, "start": 362.0, "end": 366.44, "text": " can use all these links which will redirect you to all the specifications so we can just read all", "tokens": [51238, 393, 764, 439, 613, 6123, 597, 486, 29066, 291, 281, 439, 264, 29448, 370, 321, 393, 445, 1401, 439, 51460], "temperature": 0.0, "avg_logprob": -0.1301801630428859, "compression_ratio": 1.821969696969697, "no_speech_prob": 0.0007645549485459924}, {"id": 51, "seek": 34452, "start": 366.44, "end": 373.96, "text": " about that. Suffice to say there are these four exception levels on ARM for now. The way the", "tokens": [51460, 466, 300, 13, 40178, 573, 281, 584, 456, 366, 613, 1451, 11183, 4358, 322, 45209, 337, 586, 13, 440, 636, 264, 51836], "temperature": 0.0, "avg_logprob": -0.1301801630428859, "compression_ratio": 1.821969696969697, "no_speech_prob": 0.0007645549485459924}, {"id": 52, "seek": 37396, "start": 374.35999999999996, "end": 381.2, "text": " SMC actually works is that if you want to do an SMC request you're supposed to set up CPU", "tokens": [50384, 13115, 34, 767, 1985, 307, 300, 498, 291, 528, 281, 360, 364, 13115, 34, 5308, 291, 434, 3442, 281, 992, 493, 13199, 50726], "temperature": 0.0, "avg_logprob": -0.1693090355914572, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.0011470781173557043}, {"id": 53, "seek": 37396, "start": 381.2, "end": 389.08, "text": " register zero with a function ID which basically says what kind of request you want to do. You", "tokens": [50726, 7280, 4018, 365, 257, 2445, 7348, 597, 1936, 1619, 437, 733, 295, 5308, 291, 528, 281, 360, 13, 509, 51120], "temperature": 0.0, "avg_logprob": -0.1693090355914572, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.0011470781173557043}, {"id": 54, "seek": 37396, "start": 389.08, "end": 396.76, "text": " want performed by the secure monitor or by the OS and then you're supposed to set up six additional", "tokens": [51120, 528, 10332, 538, 264, 7144, 6002, 420, 538, 264, 12731, 293, 550, 291, 434, 3442, 281, 992, 493, 2309, 4497, 51504], "temperature": 0.0, "avg_logprob": -0.1693090355914572, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.0011470781173557043}, {"id": 55, "seek": 37396, "start": 396.76, "end": 402.47999999999996, "text": " parameters 6.1 all the way to x6 which are parameters for this function which you want to trigger.", "tokens": [51504, 9834, 1386, 13, 16, 439, 264, 636, 281, 2031, 21, 597, 366, 9834, 337, 341, 2445, 597, 291, 528, 281, 7875, 13, 51790], "temperature": 0.0, "avg_logprob": -0.1693090355914572, "compression_ratio": 1.6798245614035088, "no_speech_prob": 0.0011470781173557043}, {"id": 56, "seek": 40396, "start": 404.91999999999996, "end": 411.76, "text": " With this setup you have to do the SMC or HVC instruction. This instruction triggers synchronous", "tokens": [50412, 2022, 341, 8657, 291, 362, 281, 360, 264, 13115, 34, 420, 389, 53, 34, 10951, 13, 639, 10951, 22827, 44743, 50754], "temperature": 0.0, "avg_logprob": -0.17474356293678284, "compression_ratio": 1.6464088397790055, "no_speech_prob": 0.0005014471244066954}, {"id": 57, "seek": 40396, "start": 411.76, "end": 420.08, "text": " exception. The synchronous exception then makes the CPU elevate its exception level to the higher", "tokens": [50754, 11183, 13, 440, 44743, 11183, 550, 1669, 264, 13199, 33054, 1080, 11183, 1496, 281, 264, 2946, 51170], "temperature": 0.0, "avg_logprob": -0.17474356293678284, "compression_ratio": 1.6464088397790055, "no_speech_prob": 0.0005014471244066954}, {"id": 58, "seek": 40396, "start": 420.08, "end": 427.56, "text": " one and trigger the exception handler which validates that the function ID is even okay for you to call", "tokens": [51170, 472, 293, 7875, 264, 11183, 41967, 597, 7363, 1024, 300, 264, 2445, 7348, 307, 754, 1392, 337, 291, 281, 818, 51544], "temperature": 0.0, "avg_logprob": -0.17474356293678284, "compression_ratio": 1.6464088397790055, "no_speech_prob": 0.0005014471244066954}, {"id": 59, "seek": 42756, "start": 428.28000000000003, "end": 435.88, "text": " that the parameters for the function are okay at all and if all of this is correct then the", "tokens": [50400, 300, 264, 9834, 337, 264, 2445, 366, 1392, 412, 439, 293, 498, 439, 295, 341, 307, 3006, 550, 264, 50780], "temperature": 0.0, "avg_logprob": -0.13824791378445095, "compression_ratio": 1.76875, "no_speech_prob": 0.008506625890731812}, {"id": 60, "seek": 42756, "start": 435.88, "end": 440.92, "text": " request which is represented by this function ID is then performed by the secure monitor firmware", "tokens": [50780, 5308, 597, 307, 10379, 538, 341, 2445, 7348, 307, 550, 10332, 538, 264, 7144, 6002, 30289, 51032], "temperature": 0.0, "avg_logprob": -0.13824791378445095, "compression_ratio": 1.76875, "no_speech_prob": 0.008506625890731812}, {"id": 61, "seek": 42756, "start": 440.92, "end": 448.68, "text": " or by the OS. Once the request is performed the secure monitor firmware or the OS will set up", "tokens": [51032, 420, 538, 264, 12731, 13, 3443, 264, 5308, 307, 10332, 264, 7144, 6002, 30289, 420, 264, 12731, 486, 992, 493, 51420], "temperature": 0.0, "avg_logprob": -0.13824791378445095, "compression_ratio": 1.76875, "no_speech_prob": 0.008506625890731812}, {"id": 62, "seek": 44868, "start": 449.56, "end": 458.68, "text": " for additional registers x0 to x3 with the return values and will return just past the SMC or HVC", "tokens": [50408, 337, 4497, 38351, 2031, 15, 281, 2031, 18, 365, 264, 2736, 4190, 293, 486, 2736, 445, 1791, 264, 13115, 34, 420, 389, 53, 34, 50864], "temperature": 0.0, "avg_logprob": -0.14103352322297938, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.010739108547568321}, {"id": 63, "seek": 44868, "start": 458.68, "end": 466.92, "text": " instruction into the calling software and resume execution at the exception level of the calling", "tokens": [50864, 10951, 666, 264, 5141, 4722, 293, 15358, 15058, 412, 264, 11183, 1496, 295, 264, 5141, 51276], "temperature": 0.0, "avg_logprob": -0.14103352322297938, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.010739108547568321}, {"id": 64, "seek": 44868, "start": 466.92, "end": 473.96000000000004, "text": " software and then the calling software can collect the result of this call in the registers x0 to x3", "tokens": [51276, 4722, 293, 550, 264, 5141, 4722, 393, 2500, 264, 1874, 295, 341, 818, 294, 264, 38351, 2031, 15, 281, 2031, 18, 51628], "temperature": 0.0, "avg_logprob": -0.14103352322297938, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.010739108547568321}, {"id": 65, "seek": 47396, "start": 473.96, "end": 482.52, "text": " and do something about this. This is roughly how it works about these function IDs. These function", "tokens": [50364, 293, 360, 746, 466, 341, 13, 639, 307, 9810, 577, 309, 1985, 466, 613, 2445, 48212, 13, 1981, 2445, 50792], "temperature": 0.0, "avg_logprob": -0.08362854789285099, "compression_ratio": 1.786046511627907, "no_speech_prob": 0.013673563487827778}, {"id": 66, "seek": 47396, "start": 482.52, "end": 489.32, "text": " IDs are the requests you can do to the secure monitor firmware or to the OS running in the bare", "tokens": [50792, 48212, 366, 264, 12475, 291, 393, 360, 281, 264, 7144, 6002, 30289, 420, 281, 264, 12731, 2614, 294, 264, 6949, 51132], "temperature": 0.0, "avg_logprob": -0.08362854789285099, "compression_ratio": 1.786046511627907, "no_speech_prob": 0.013673563487827778}, {"id": 67, "seek": 47396, "start": 489.32, "end": 496.2, "text": " metal. You can actually not find them in the SMCCC specification because the SMCCC specification", "tokens": [51132, 5760, 13, 509, 393, 767, 406, 915, 552, 294, 264, 13115, 11717, 34, 31256, 570, 264, 13115, 11717, 34, 31256, 51476], "temperature": 0.0, "avg_logprob": -0.08362854789285099, "compression_ratio": 1.786046511627907, "no_speech_prob": 0.013673563487827778}, {"id": 68, "seek": 47396, "start": 496.2, "end": 502.59999999999997, "text": " just says there are function IDs but the blocks of these function IDs are distributed across", "tokens": [51476, 445, 1619, 456, 366, 2445, 48212, 457, 264, 8474, 295, 613, 2445, 48212, 366, 12631, 2108, 51796], "temperature": 0.0, "avg_logprob": -0.08362854789285099, "compression_ratio": 1.786046511627907, "no_speech_prob": 0.013673563487827778}, {"id": 69, "seek": 50260, "start": 502.6, "end": 507.96000000000004, "text": " various specifications like the PSCI specification which has two blocks carved out of the function", "tokens": [50364, 3683, 29448, 411, 264, 8168, 25240, 31256, 597, 575, 732, 8474, 28613, 484, 295, 264, 2445, 50632], "temperature": 0.0, "avg_logprob": -0.07107689506129215, "compression_ratio": 1.9740932642487046, "no_speech_prob": 0.0025742340367287397}, {"id": 70, "seek": 50260, "start": 507.96000000000004, "end": 516.9200000000001, "text": " IDs or the SCMI specification which has its own set of function IDs. The PSCI specification has", "tokens": [50632, 48212, 420, 264, 9028, 13808, 31256, 597, 575, 1080, 1065, 992, 295, 2445, 48212, 13, 440, 8168, 25240, 31256, 575, 51080], "temperature": 0.0, "avg_logprob": -0.07107689506129215, "compression_ratio": 1.9740932642487046, "no_speech_prob": 0.0025742340367287397}, {"id": 71, "seek": 50260, "start": 516.9200000000001, "end": 523.72, "text": " two sets of function IDs. One is for 32-bit PSCI calls, the other is for 64-bit PSCI calls.", "tokens": [51080, 732, 6352, 295, 2445, 48212, 13, 1485, 307, 337, 8858, 12, 5260, 8168, 25240, 5498, 11, 264, 661, 307, 337, 12145, 12, 5260, 8168, 25240, 5498, 13, 51420], "temperature": 0.0, "avg_logprob": -0.07107689506129215, "compression_ratio": 1.9740932642487046, "no_speech_prob": 0.0025742340367287397}, {"id": 72, "seek": 50260, "start": 524.9200000000001, "end": 531.5600000000001, "text": " The only reason for this is that 64-bit PSCI calls just take 64-bit parameters so the function", "tokens": [51480, 440, 787, 1778, 337, 341, 307, 300, 12145, 12, 5260, 8168, 25240, 5498, 445, 747, 12145, 12, 5260, 9834, 370, 264, 2445, 51812], "temperature": 0.0, "avg_logprob": -0.07107689506129215, "compression_ratio": 1.9740932642487046, "no_speech_prob": 0.0025742340367287397}, {"id": 73, "seek": 53156, "start": 531.56, "end": 537.9599999999999, "text": " signature is slightly different. But beyond that it's very much compatible the 32-bit and 64-bit", "tokens": [50364, 13397, 307, 4748, 819, 13, 583, 4399, 300, 309, 311, 588, 709, 18218, 264, 8858, 12, 5260, 293, 12145, 12, 5260, 50684], "temperature": 0.0, "avg_logprob": -0.12026506789187168, "compression_ratio": 1.654708520179372, "no_speech_prob": 0.0007830423419363797}, {"id": 74, "seek": 53156, "start": 538.76, "end": 546.3599999999999, "text": " PSCI functions and function implementations. So you can look up the function IDs obviously in the", "tokens": [50724, 8168, 25240, 6828, 293, 2445, 4445, 763, 13, 407, 291, 393, 574, 493, 264, 2445, 48212, 2745, 294, 264, 51104], "temperature": 0.0, "avg_logprob": -0.12026506789187168, "compression_ratio": 1.654708520179372, "no_speech_prob": 0.0007830423419363797}, {"id": 75, "seek": 53156, "start": 546.3599999999999, "end": 550.8399999999999, "text": " PSCI specification. You can also look them up in the UBOOT sources. You can look them up in the", "tokens": [51104, 8168, 25240, 31256, 13, 509, 393, 611, 574, 552, 493, 294, 264, 624, 33, 3783, 51, 7139, 13, 509, 393, 574, 552, 493, 294, 264, 51328], "temperature": 0.0, "avg_logprob": -0.12026506789187168, "compression_ratio": 1.654708520179372, "no_speech_prob": 0.0007830423419363797}, {"id": 76, "seek": 53156, "start": 550.8399999999999, "end": 556.4399999999999, "text": " Linux kernel sources. This stuff here is coming from the UBOOT sources. Hello.", "tokens": [51328, 18734, 28256, 7139, 13, 639, 1507, 510, 307, 1348, 490, 264, 624, 33, 3783, 51, 7139, 13, 2425, 13, 51608], "temperature": 0.0, "avg_logprob": -0.12026506789187168, "compression_ratio": 1.654708520179372, "no_speech_prob": 0.0007830423419363797}, {"id": 77, "seek": 55644, "start": 557.1600000000001, "end": 566.6, "text": " So what you can see here is for example CPU on PSCI function which is actually a macro which is", "tokens": [50400, 407, 437, 291, 393, 536, 510, 307, 337, 1365, 13199, 322, 8168, 25240, 2445, 597, 307, 767, 257, 18887, 597, 307, 50872], "temperature": 0.0, "avg_logprob": -0.19325800503001495, "compression_ratio": 1.3472222222222223, "no_speech_prob": 0.0005522658466361463}, {"id": 78, "seek": 55644, "start": 566.6, "end": 582.0400000000001, "text": " expanded to like C4 plus 3. So this would actually go into the SMC register x0 before you call the", "tokens": [50872, 14342, 281, 411, 383, 19, 1804, 805, 13, 407, 341, 576, 767, 352, 666, 264, 13115, 34, 7280, 2031, 15, 949, 291, 818, 264, 51644], "temperature": 0.0, "avg_logprob": -0.19325800503001495, "compression_ratio": 1.3472222222222223, "no_speech_prob": 0.0005522658466361463}, {"id": 79, "seek": 58204, "start": 582.04, "end": 593.9599999999999, "text": " SMC instruction. Now there are multiple callers of the SMC instruction as well as multiple handlers.", "tokens": [50364, 13115, 34, 10951, 13, 823, 456, 366, 3866, 818, 433, 295, 264, 13115, 34, 10951, 382, 731, 382, 3866, 1011, 11977, 13, 50960], "temperature": 0.0, "avg_logprob": -0.1744123578071594, "compression_ratio": 1.6779661016949152, "no_speech_prob": 0.0023797801695764065}, {"id": 80, "seek": 58204, "start": 594.8399999999999, "end": 602.28, "text": " There are callers in UBOOT. This is all built around this FV call that see SMC call and HVC call", "tokens": [51004, 821, 366, 818, 433, 294, 624, 33, 3783, 51, 13, 639, 307, 439, 3094, 926, 341, 479, 53, 818, 300, 536, 13115, 34, 818, 293, 389, 53, 34, 818, 51376], "temperature": 0.0, "avg_logprob": -0.1744123578071594, "compression_ratio": 1.6779661016949152, "no_speech_prob": 0.0023797801695764065}, {"id": 81, "seek": 58204, "start": 602.28, "end": 610.28, "text": " implementation. In Linux the PSCI implementation lives in driver's firmware PSCI PSCI. The handlers", "tokens": [51376, 11420, 13, 682, 18734, 264, 8168, 25240, 11420, 2909, 294, 6787, 311, 30289, 8168, 25240, 8168, 25240, 13, 440, 1011, 11977, 51776], "temperature": 0.0, "avg_logprob": -0.1744123578071594, "compression_ratio": 1.6779661016949152, "no_speech_prob": 0.0023797801695764065}, {"id": 82, "seek": 61028, "start": 610.28, "end": 621.0, "text": " are either in ATF or in UBOOT itself. The UBOOT SMC callers are all built around this SMC call", "tokens": [50364, 366, 2139, 294, 8872, 37, 420, 294, 624, 33, 3783, 51, 2564, 13, 440, 624, 33, 3783, 51, 13115, 34, 818, 433, 366, 439, 3094, 926, 341, 13115, 34, 818, 50900], "temperature": 0.0, "avg_logprob": -0.08450812327710888, "compression_ratio": 1.5813953488372092, "no_speech_prob": 0.0009237417834810913}, {"id": 83, "seek": 61028, "start": 622.28, "end": 627.48, "text": " function. So like anything in UBOOT which does PSCI interaction is essentially SMC call", "tokens": [50964, 2445, 13, 407, 411, 1340, 294, 624, 33, 3783, 51, 597, 775, 8168, 25240, 9285, 307, 4476, 13115, 34, 818, 51224], "temperature": 0.0, "avg_logprob": -0.08450812327710888, "compression_ratio": 1.5813953488372092, "no_speech_prob": 0.0009237417834810913}, {"id": 84, "seek": 61028, "start": 628.68, "end": 635.48, "text": " PSCI function name and then some parameters for the PSCI function. If you look at the SMC", "tokens": [51284, 8168, 25240, 2445, 1315, 293, 550, 512, 9834, 337, 264, 8168, 25240, 2445, 13, 759, 291, 574, 412, 264, 13115, 34, 51624], "temperature": 0.0, "avg_logprob": -0.08450812327710888, "compression_ratio": 1.5813953488372092, "no_speech_prob": 0.0009237417834810913}, {"id": 85, "seek": 63548, "start": 635.48, "end": 642.04, "text": " call and UBOOT actually it very much copies what's in the SMC CC. So that means set up register", "tokens": [50364, 818, 293, 624, 33, 3783, 51, 767, 309, 588, 709, 14341, 437, 311, 294, 264, 13115, 34, 12630, 13, 407, 300, 1355, 992, 493, 7280, 50692], "temperature": 0.0, "avg_logprob": -0.13481943230879934, "compression_ratio": 1.5561497326203209, "no_speech_prob": 0.016528049483895302}, {"id": 86, "seek": 63548, "start": 642.04, "end": 649.32, "text": " x0 with function ID, set up a couple of parameter registers x1 to x6, then trigger the SMC instruction.", "tokens": [50692, 2031, 15, 365, 2445, 7348, 11, 992, 493, 257, 1916, 295, 13075, 38351, 2031, 16, 281, 2031, 21, 11, 550, 7875, 264, 13115, 34, 10951, 13, 51056], "temperature": 0.0, "avg_logprob": -0.13481943230879934, "compression_ratio": 1.5561497326203209, "no_speech_prob": 0.016528049483895302}, {"id": 87, "seek": 63548, "start": 650.04, "end": 656.2, "text": " Once the SMC instruction request is done the execution will return past the SMC instruction", "tokens": [51092, 3443, 264, 13115, 34, 10951, 5308, 307, 1096, 264, 15058, 486, 2736, 1791, 264, 13115, 34, 10951, 51400], "temperature": 0.0, "avg_logprob": -0.13481943230879934, "compression_ratio": 1.5561497326203209, "no_speech_prob": 0.016528049483895302}, {"id": 88, "seek": 65620, "start": 657.0, "end": 665.6400000000001, "text": " and continue here where the UBOOT code will collect the registers which were set up by the", "tokens": [50404, 293, 2354, 510, 689, 264, 624, 33, 3783, 51, 3089, 486, 2500, 264, 38351, 597, 645, 992, 493, 538, 264, 50836], "temperature": 0.0, "avg_logprob": -0.09385082938454369, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.01346405316144228}, {"id": 89, "seek": 65620, "start": 665.6400000000001, "end": 670.44, "text": " secure monitor firmware as the return values from the SMC instruction and then you can use them", "tokens": [50836, 7144, 6002, 30289, 382, 264, 2736, 4190, 490, 264, 13115, 34, 10951, 293, 550, 291, 393, 764, 552, 51076], "temperature": 0.0, "avg_logprob": -0.09385082938454369, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.01346405316144228}, {"id": 90, "seek": 65620, "start": 670.44, "end": 678.36, "text": " in the UBOOT code. There is a matching HVC call a little bit further in this FV call that see", "tokens": [51076, 294, 264, 624, 33, 3783, 51, 3089, 13, 821, 307, 257, 14324, 389, 53, 34, 818, 257, 707, 857, 3052, 294, 341, 479, 53, 818, 300, 536, 51472], "temperature": 0.0, "avg_logprob": -0.09385082938454369, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.01346405316144228}, {"id": 91, "seek": 65620, "start": 678.36, "end": 683.0, "text": " in UBOOT if you want to look it up which is used for the EL2 HVC call.", "tokens": [51472, 294, 624, 33, 3783, 51, 498, 291, 528, 281, 574, 309, 493, 597, 307, 1143, 337, 264, 14426, 17, 389, 53, 34, 818, 13, 51704], "temperature": 0.0, "avg_logprob": -0.09385082938454369, "compression_ratio": 1.588235294117647, "no_speech_prob": 0.01346405316144228}, {"id": 92, "seek": 68300, "start": 683.88, "end": 691.08, "text": " UBOOT has the bonus thing that it actually has a command which is called NSMC. So in the UBOOT", "tokens": [50408, 624, 33, 3783, 51, 575, 264, 10882, 551, 300, 309, 767, 575, 257, 5622, 597, 307, 1219, 15943, 39261, 13, 407, 294, 264, 624, 33, 3783, 51, 50768], "temperature": 0.0, "avg_logprob": -0.08144459128379822, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.0008957545505836606}, {"id": 93, "seek": 68300, "start": 691.08, "end": 700.04, "text": " command line you can experiment with the SMC calls and it's a command which takes seven parameters", "tokens": [50768, 5622, 1622, 291, 393, 5120, 365, 264, 13115, 34, 5498, 293, 309, 311, 257, 5622, 597, 2516, 3407, 9834, 51216], "temperature": 0.0, "avg_logprob": -0.08144459128379822, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.0008957545505836606}, {"id": 94, "seek": 68300, "start": 700.04, "end": 706.6, "text": " up to seven parameters. The first parameter is the SMC function ID and then the six additional", "tokens": [51216, 493, 281, 3407, 9834, 13, 440, 700, 13075, 307, 264, 13115, 34, 2445, 7348, 293, 550, 264, 2309, 4497, 51544], "temperature": 0.0, "avg_logprob": -0.08144459128379822, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.0008957545505836606}, {"id": 95, "seek": 68300, "start": 706.6, "end": 712.68, "text": " parameters are the parameters for the SMC function. So if you want to do like a PSCI call", "tokens": [51544, 9834, 366, 264, 9834, 337, 264, 13115, 34, 2445, 13, 407, 498, 291, 528, 281, 360, 411, 257, 8168, 25240, 818, 51848], "temperature": 0.0, "avg_logprob": -0.08144459128379822, "compression_ratio": 1.7830188679245282, "no_speech_prob": 0.0008957545505836606}, {"id": 96, "seek": 71268, "start": 712.68, "end": 718.04, "text": " I think this one is like PSCI version here you can do it like from the UBOOT command line and", "tokens": [50364, 286, 519, 341, 472, 307, 411, 8168, 25240, 3037, 510, 291, 393, 360, 309, 411, 490, 264, 624, 33, 3783, 51, 5622, 1622, 293, 50632], "temperature": 0.0, "avg_logprob": -0.08951848230244201, "compression_ratio": 1.5245901639344261, "no_speech_prob": 0.0008025910356082022}, {"id": 97, "seek": 71268, "start": 718.04, "end": 728.3599999999999, "text": " you can experiment with this all you want. The return value from the SMC command is four values", "tokens": [50632, 291, 393, 5120, 365, 341, 439, 291, 528, 13, 440, 2736, 2158, 490, 264, 13115, 34, 5622, 307, 1451, 4190, 51148], "temperature": 0.0, "avg_logprob": -0.08951848230244201, "compression_ratio": 1.5245901639344261, "no_speech_prob": 0.0008025910356082022}, {"id": 98, "seek": 71268, "start": 728.3599999999999, "end": 739.24, "text": " which is the x0 x1 x3 and x0 x1 x2 and x3 CPU registers. So you can then analyze what you", "tokens": [51148, 597, 307, 264, 2031, 15, 2031, 16, 2031, 18, 293, 2031, 15, 2031, 16, 2031, 17, 293, 2031, 18, 13199, 38351, 13, 407, 291, 393, 550, 12477, 437, 291, 51692], "temperature": 0.0, "avg_logprob": -0.08951848230244201, "compression_ratio": 1.5245901639344261, "no_speech_prob": 0.0008025910356082022}, {"id": 99, "seek": 73924, "start": 739.24, "end": 748.12, "text": " got out of the SMC call if it didn't fail obviously. As for the Linux kernel there is this", "tokens": [50364, 658, 484, 295, 264, 13115, 34, 818, 498, 309, 994, 380, 3061, 2745, 13, 1018, 337, 264, 18734, 28256, 456, 307, 341, 50808], "temperature": 0.0, "avg_logprob": -0.05733441222797741, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.01059003360569477}, {"id": 100, "seek": 73924, "start": 748.12, "end": 755.4, "text": " additional thing in Linux then when the PSCI firmware driver is probing Linux has to figure out", "tokens": [50808, 4497, 551, 294, 18734, 550, 562, 264, 8168, 25240, 30289, 6787, 307, 1239, 278, 18734, 575, 281, 2573, 484, 51172], "temperature": 0.0, "avg_logprob": -0.05733441222797741, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.01059003360569477}, {"id": 101, "seek": 73924, "start": 755.4, "end": 760.76, "text": " whether it is running on bare metal or in virtualization. So if Linux is running on bare metal", "tokens": [51172, 1968, 309, 307, 2614, 322, 6949, 5760, 420, 294, 6374, 2144, 13, 407, 498, 18734, 307, 2614, 322, 6949, 5760, 51440], "temperature": 0.0, "avg_logprob": -0.05733441222797741, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.01059003360569477}, {"id": 102, "seek": 73924, "start": 760.76, "end": 766.12, "text": " then it uses the SMC instruction to communicate with the secure monitor firmware otherwise it's", "tokens": [51440, 550, 309, 4960, 264, 13115, 34, 10951, 281, 7890, 365, 264, 7144, 6002, 30289, 5911, 309, 311, 51708], "temperature": 0.0, "avg_logprob": -0.05733441222797741, "compression_ratio": 1.6607929515418502, "no_speech_prob": 0.01059003360569477}, {"id": 103, "seek": 76612, "start": 766.12, "end": 771.5600000000001, "text": " using the HVC instruction if it's running in virtualization to communicate with the OS that's", "tokens": [50364, 1228, 264, 389, 53, 34, 10951, 498, 309, 311, 2614, 294, 6374, 2144, 281, 7890, 365, 264, 12731, 300, 311, 50636], "temperature": 0.0, "avg_logprob": -0.07257412501743861, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.0016114494064822793}, {"id": 104, "seek": 76612, "start": 771.5600000000001, "end": 779.72, "text": " running on the bare metal. But beyond that the PSCI firmware driver in Linux just exposes the PSCI", "tokens": [50636, 2614, 322, 264, 6949, 5760, 13, 583, 4399, 300, 264, 8168, 25240, 30289, 6787, 294, 18734, 445, 1278, 4201, 264, 8168, 25240, 51044], "temperature": 0.0, "avg_logprob": -0.07257412501743861, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.0016114494064822793}, {"id": 105, "seek": 76612, "start": 779.72, "end": 790.84, "text": " functions as a wrapper around SMC calls and the actual SMC instruction call and the setup of the", "tokens": [51044, 6828, 382, 257, 46906, 926, 13115, 34, 5498, 293, 264, 3539, 13115, 34, 10951, 818, 293, 264, 8657, 295, 264, 51600], "temperature": 0.0, "avg_logprob": -0.07257412501743861, "compression_ratio": 1.5621621621621622, "no_speech_prob": 0.0016114494064822793}, {"id": 106, "seek": 79084, "start": 790.84, "end": 800.84, "text": " x0 all the way to x6 registers. This is implemented in smccc call.s in Rx64 so it's very much yet", "tokens": [50364, 2031, 15, 439, 264, 636, 281, 2031, 21, 38351, 13, 639, 307, 12270, 294, 899, 1914, 66, 818, 13, 82, 294, 497, 87, 19395, 370, 309, 311, 588, 709, 1939, 50864], "temperature": 0.0, "avg_logprob": -0.13828841550850574, "compression_ratio": 1.4129353233830846, "no_speech_prob": 0.005604293197393417}, {"id": 107, "seek": 79084, "start": 800.84, "end": 806.6800000000001, "text": " again a wrapper around the SMC instruction no matter whether it's UBOOT whether it's Linux.", "tokens": [50864, 797, 257, 46906, 926, 264, 13115, 34, 10951, 572, 1871, 1968, 309, 311, 624, 33, 3783, 51, 1968, 309, 311, 18734, 13, 51156], "temperature": 0.0, "avg_logprob": -0.13828841550850574, "compression_ratio": 1.4129353233830846, "no_speech_prob": 0.005604293197393417}, {"id": 108, "seek": 79084, "start": 809.88, "end": 816.6800000000001, "text": " But now let's talk about the more interesting part which are the handlers and for one to be an", "tokens": [51316, 583, 586, 718, 311, 751, 466, 264, 544, 1880, 644, 597, 366, 264, 1011, 11977, 293, 337, 472, 281, 312, 364, 51656], "temperature": 0.0, "avg_logprob": -0.13828841550850574, "compression_ratio": 1.4129353233830846, "no_speech_prob": 0.005604293197393417}, {"id": 109, "seek": 81668, "start": 816.68, "end": 825.64, "text": " SMC handler the CPU core has to fulfill a couple of requirements. The main requirement to handle", "tokens": [50364, 13115, 34, 41967, 264, 13199, 4965, 575, 281, 13875, 257, 1916, 295, 7728, 13, 440, 2135, 11695, 281, 4813, 50812], "temperature": 0.0, "avg_logprob": -0.08329480968109548, "compression_ratio": 1.695906432748538, "no_speech_prob": 0.003083805786445737}, {"id": 110, "seek": 81668, "start": 826.52, "end": 833.0799999999999, "text": " SMC exceptions is to be able to even receive the exceptions. So the CPU core basically has to be", "tokens": [50856, 13115, 34, 22847, 307, 281, 312, 1075, 281, 754, 4774, 264, 22847, 13, 407, 264, 13199, 4965, 1936, 575, 281, 312, 51184], "temperature": 0.0, "avg_logprob": -0.08329480968109548, "compression_ratio": 1.695906432748538, "no_speech_prob": 0.003083805786445737}, {"id": 111, "seek": 81668, "start": 833.0799999999999, "end": 841.3199999999999, "text": " able to receive exception in EL3 if it wants to handle SMC. If you are on an SMP system you also", "tokens": [51184, 1075, 281, 4774, 11183, 294, 14426, 18, 498, 309, 2738, 281, 4813, 13115, 34, 13, 759, 291, 366, 322, 364, 13115, 47, 1185, 291, 611, 51596], "temperature": 0.0, "avg_logprob": -0.08329480968109548, "compression_ratio": 1.695906432748538, "no_speech_prob": 0.003083805786445737}, {"id": 112, "seek": 84132, "start": 841.32, "end": 848.36, "text": " have to be able to receive IPIs inter processor interrupts because in order to bring up secondary", "tokens": [50364, 362, 281, 312, 1075, 281, 4774, 8671, 6802, 728, 15321, 12729, 82, 570, 294, 1668, 281, 1565, 493, 11396, 50716], "temperature": 0.0, "avg_logprob": -0.07762809900137094, "compression_ratio": 1.7763975155279503, "no_speech_prob": 0.01001504436135292}, {"id": 113, "seek": 84132, "start": 848.36, "end": 854.6800000000001, "text": " cores it is necessary for the secondary cores to be able to receive IPIs to break them out of", "tokens": [50716, 24826, 309, 307, 4818, 337, 264, 11396, 24826, 281, 312, 1075, 281, 4774, 8671, 6802, 281, 1821, 552, 484, 295, 51032], "temperature": 0.0, "avg_logprob": -0.07762809900137094, "compression_ratio": 1.7763975155279503, "no_speech_prob": 0.01001504436135292}, {"id": 114, "seek": 84132, "start": 857.6400000000001, "end": 864.7600000000001, "text": " a loop in the PSCI provider firmware because the OS is not immediately ready for the secondary", "tokens": [51180, 257, 6367, 294, 264, 8168, 25240, 12398, 30289, 570, 264, 12731, 307, 406, 4258, 1919, 337, 264, 11396, 51536], "temperature": 0.0, "avg_logprob": -0.07762809900137094, "compression_ratio": 1.7763975155279503, "no_speech_prob": 0.01001504436135292}, {"id": 115, "seek": 86476, "start": 864.76, "end": 874.76, "text": " cores. I'll explain that in a bit. In UBOOT most of this PSCI and synchronous exception handling", "tokens": [50364, 24826, 13, 286, 603, 2903, 300, 294, 257, 857, 13, 682, 624, 33, 3783, 51, 881, 295, 341, 8168, 25240, 293, 44743, 11183, 13175, 50864], "temperature": 0.0, "avg_logprob": -0.1152043903575224, "compression_ratio": 1.7023255813953488, "no_speech_prob": 0.009807364083826542}, {"id": 116, "seek": 86476, "start": 874.76, "end": 880.28, "text": " code is actually in place already and it's all generic code. So the UBOOT entry point", "tokens": [50864, 3089, 307, 767, 294, 1081, 1217, 293, 309, 311, 439, 19577, 3089, 13, 407, 264, 624, 33, 3783, 51, 8729, 935, 51140], "temperature": 0.0, "avg_logprob": -0.1152043903575224, "compression_ratio": 1.7023255813953488, "no_speech_prob": 0.009807364083826542}, {"id": 117, "seek": 86476, "start": 881.96, "end": 887.48, "text": " the UBOOT entry point is very much here in the startup.s and the PSCI synchronous exception", "tokens": [51224, 264, 624, 33, 3783, 51, 8729, 935, 307, 588, 709, 510, 294, 264, 18578, 13, 82, 293, 264, 8168, 25240, 44743, 11183, 51500], "temperature": 0.0, "avg_logprob": -0.1152043903575224, "compression_ratio": 1.7023255813953488, "no_speech_prob": 0.009807364083826542}, {"id": 118, "seek": 86476, "start": 887.48, "end": 894.52, "text": " handling code is here in PSCI.s. It's there both for ARM32 and ARM64 it's just in different", "tokens": [51500, 13175, 3089, 307, 510, 294, 8168, 25240, 13, 82, 13, 467, 311, 456, 1293, 337, 45209, 11440, 293, 45209, 19395, 309, 311, 445, 294, 819, 51852], "temperature": 0.0, "avg_logprob": -0.1152043903575224, "compression_ratio": 1.7023255813953488, "no_speech_prob": 0.009807364083826542}, {"id": 119, "seek": 89452, "start": 894.52, "end": 901.72, "text": " subdirectories. All you as a user actually have to implement is the PSCI.C which are the C callbacks", "tokens": [50364, 1422, 18267, 1672, 530, 13, 1057, 291, 382, 257, 4195, 767, 362, 281, 4445, 307, 264, 8168, 25240, 13, 34, 597, 366, 264, 383, 818, 17758, 50724], "temperature": 0.0, "avg_logprob": -0.14635770385329788, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.004240632988512516}, {"id": 120, "seek": 89452, "start": 901.72, "end": 911.16, "text": " of the actual PSCI functionality which perform the stuff which the PSCI function are supposed to do", "tokens": [50724, 295, 264, 3539, 8168, 25240, 14980, 597, 2042, 264, 1507, 597, 264, 8168, 25240, 2445, 366, 3442, 281, 360, 51196], "temperature": 0.0, "avg_logprob": -0.14635770385329788, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.004240632988512516}, {"id": 121, "seek": 89452, "start": 911.16, "end": 919.56, "text": " with the hardware like start the CPU core, stop the CPU core. So all this stuff is generic,", "tokens": [51196, 365, 264, 8837, 411, 722, 264, 13199, 4965, 11, 1590, 264, 13199, 4965, 13, 407, 439, 341, 1507, 307, 19577, 11, 51616], "temperature": 0.0, "avg_logprob": -0.14635770385329788, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.004240632988512516}, {"id": 122, "seek": 91956, "start": 919.56, "end": 927.4, "text": " all this stuff is so specific and if you decide to implement PSCI provider in UBOOT you have to fill", "tokens": [50364, 439, 341, 1507, 307, 370, 2685, 293, 498, 291, 4536, 281, 4445, 8168, 25240, 12398, 294, 624, 33, 3783, 51, 291, 362, 281, 2836, 50756], "temperature": 0.0, "avg_logprob": -0.06397279878941978, "compression_ratio": 1.5425531914893618, "no_speech_prob": 0.0016507662367075682}, {"id": 123, "seek": 91956, "start": 927.4, "end": 937.2399999999999, "text": " that in. Now if a UBOOT is configured as a PSCI provider then UBOOT is running in EL3 that means", "tokens": [50756, 300, 294, 13, 823, 498, 257, 624, 33, 3783, 51, 307, 30538, 382, 257, 8168, 25240, 12398, 550, 624, 33, 3783, 51, 307, 2614, 294, 14426, 18, 300, 1355, 51248], "temperature": 0.0, "avg_logprob": -0.06397279878941978, "compression_ratio": 1.5425531914893618, "no_speech_prob": 0.0016507662367075682}, {"id": 124, "seek": 91956, "start": 937.2399999999999, "end": 944.1999999999999, "text": " in the highest execution level, exception level. That means UBOOT is not able to perform any", "tokens": [51248, 294, 264, 6343, 15058, 1496, 11, 11183, 1496, 13, 663, 1355, 624, 33, 3783, 51, 307, 406, 1075, 281, 2042, 604, 51596], "temperature": 0.0, "avg_logprob": -0.06397279878941978, "compression_ratio": 1.5425531914893618, "no_speech_prob": 0.0016507662367075682}, {"id": 125, "seek": 94420, "start": 945.1600000000001, "end": 950.2800000000001, "text": " SMC calls so you have to make sure there are none because otherwise the system would just hang on", "tokens": [50412, 13115, 34, 5498, 370, 291, 362, 281, 652, 988, 456, 366, 6022, 570, 5911, 264, 1185, 576, 445, 3967, 322, 50668], "temperature": 0.0, "avg_logprob": -0.07978305250111192, "compression_ratio": 1.552, "no_speech_prob": 0.0035691061057150364}, {"id": 126, "seek": 94420, "start": 950.2800000000001, "end": 958.12, "text": " boot. The OS will be running in EL2 and it will be able to do SMC calls into the UBOOT synchronous", "tokens": [50668, 11450, 13, 440, 12731, 486, 312, 2614, 294, 14426, 17, 293, 309, 486, 312, 1075, 281, 360, 13115, 34, 5498, 666, 264, 624, 33, 3783, 51, 44743, 51060], "temperature": 0.0, "avg_logprob": -0.07978305250111192, "compression_ratio": 1.552, "no_speech_prob": 0.0035691061057150364}, {"id": 127, "seek": 94420, "start": 958.12, "end": 963.72, "text": " exception handler so this is something to keep in mind. Beyond that if UBOOT is configured to be a", "tokens": [51060, 11183, 41967, 370, 341, 307, 746, 281, 1066, 294, 1575, 13, 19707, 300, 498, 624, 33, 3783, 51, 307, 30538, 281, 312, 257, 51340], "temperature": 0.0, "avg_logprob": -0.07978305250111192, "compression_ratio": 1.552, "no_speech_prob": 0.0035691061057150364}, {"id": 128, "seek": 94420, "start": 963.72, "end": 970.44, "text": " PSCI provider there is only really a little bit of additional setup when the UBOOT starts up", "tokens": [51340, 8168, 25240, 12398, 456, 307, 787, 534, 257, 707, 857, 295, 4497, 8657, 562, 264, 624, 33, 3783, 51, 3719, 493, 51676], "temperature": 0.0, "avg_logprob": -0.07978305250111192, "compression_ratio": 1.552, "no_speech_prob": 0.0035691061057150364}, {"id": 129, "seek": 97044, "start": 971.32, "end": 977.5600000000001, "text": " in this MV8 setup PSCI and this code does basically that it takes", "tokens": [50408, 294, 341, 17663, 23, 8657, 8168, 25240, 293, 341, 3089, 775, 1936, 300, 309, 2516, 50720], "temperature": 0.0, "avg_logprob": -0.16217327117919922, "compression_ratio": 1.4655172413793103, "no_speech_prob": 0.009740903042256832}, {"id": 130, "seek": 97044, "start": 979.4000000000001, "end": 986.44, "text": " parts of UBOOT which are marked with attribute secure which is essentially the PSCI handling", "tokens": [50812, 3166, 295, 624, 33, 3783, 51, 597, 366, 12658, 365, 19667, 7144, 597, 307, 4476, 264, 8168, 25240, 13175, 51164], "temperature": 0.0, "avg_logprob": -0.16217327117919922, "compression_ratio": 1.4655172413793103, "no_speech_prob": 0.009740903042256832}, {"id": 131, "seek": 97044, "start": 986.44, "end": 994.2, "text": " code. It copies it into an SRAM then it setups MMU tables and flags this SRAM with a secure bit.", "tokens": [51164, 3089, 13, 467, 14341, 309, 666, 364, 20840, 2865, 550, 309, 46832, 34191, 52, 8020, 293, 23265, 341, 20840, 2865, 365, 257, 7144, 857, 13, 51552], "temperature": 0.0, "avg_logprob": -0.16217327117919922, "compression_ratio": 1.4655172413793103, "no_speech_prob": 0.009740903042256832}, {"id": 132, "seek": 99420, "start": 994.9200000000001, "end": 1001.5600000000001, "text": " That means no code running in not EL3 that means anything lower than EL3", "tokens": [50400, 663, 1355, 572, 3089, 2614, 294, 406, 14426, 18, 300, 1355, 1340, 3126, 813, 14426, 18, 50732], "temperature": 0.0, "avg_logprob": -0.0843520285208014, "compression_ratio": 1.764102564102564, "no_speech_prob": 0.0013842773623764515}, {"id": 133, "seek": 99420, "start": 1001.5600000000001, "end": 1009.8000000000001, "text": " will be able to modify this secure handling code. Finally the UBOOT sets up an exception", "tokens": [50732, 486, 312, 1075, 281, 16927, 341, 7144, 13175, 3089, 13, 6288, 264, 624, 33, 3783, 51, 6352, 493, 364, 11183, 51144], "temperature": 0.0, "avg_logprob": -0.0843520285208014, "compression_ratio": 1.764102564102564, "no_speech_prob": 0.0013842773623764515}, {"id": 134, "seek": 99420, "start": 1009.8000000000001, "end": 1015.96, "text": " vectors so that when the synchronous exception happens it will land in the UBOOT synchronous", "tokens": [51144, 18875, 370, 300, 562, 264, 44743, 11183, 2314, 309, 486, 2117, 294, 264, 624, 33, 3783, 51, 44743, 51452], "temperature": 0.0, "avg_logprob": -0.0843520285208014, "compression_ratio": 1.764102564102564, "no_speech_prob": 0.0013842773623764515}, {"id": 135, "seek": 99420, "start": 1015.96, "end": 1022.44, "text": " exception handler and then enter the PSCI code. When such a synchronous exception happens", "tokens": [51452, 11183, 41967, 293, 550, 3242, 264, 8168, 25240, 3089, 13, 1133, 1270, 257, 44743, 11183, 2314, 51776], "temperature": 0.0, "avg_logprob": -0.0843520285208014, "compression_ratio": 1.764102564102564, "no_speech_prob": 0.0013842773623764515}, {"id": 136, "seek": 102420, "start": 1024.6000000000001, "end": 1032.44, "text": " the UBOOT synchronous exception handler is entered so when like an OS does", "tokens": [50384, 264, 624, 33, 3783, 51, 44743, 11183, 41967, 307, 9065, 370, 562, 411, 364, 12731, 775, 50776], "temperature": 0.0, "avg_logprob": -0.12239069030398414, "compression_ratio": 1.618811881188119, "no_speech_prob": 0.001262914389371872}, {"id": 137, "seek": 102420, "start": 1034.44, "end": 1041.48, "text": " SMC call it will land here in the MV8 PSCI.S handle thing", "tokens": [50876, 13115, 34, 818, 309, 486, 2117, 510, 294, 264, 17663, 23, 8168, 25240, 13, 50, 4813, 551, 51228], "temperature": 0.0, "avg_logprob": -0.12239069030398414, "compression_ratio": 1.618811881188119, "no_speech_prob": 0.001262914389371872}, {"id": 138, "seek": 102420, "start": 1042.68, "end": 1047.96, "text": " and at that point the synchronous exception can be anything so first we have to figure out whether", "tokens": [51288, 293, 412, 300, 935, 264, 44743, 11183, 393, 312, 1340, 370, 700, 321, 362, 281, 2573, 484, 1968, 51552], "temperature": 0.0, "avg_logprob": -0.12239069030398414, "compression_ratio": 1.618811881188119, "no_speech_prob": 0.001262914389371872}, {"id": 139, "seek": 102420, "start": 1047.96, "end": 1053.96, "text": " this is even an SMC at all or it could be a hardware fault it could be an unknown SMC exception", "tokens": [51552, 341, 307, 754, 364, 13115, 34, 412, 439, 420, 309, 727, 312, 257, 8837, 7441, 309, 727, 312, 364, 9841, 13115, 34, 11183, 51852], "temperature": 0.0, "avg_logprob": -0.12239069030398414, "compression_ratio": 1.618811881188119, "no_speech_prob": 0.001262914389371872}, {"id": 140, "seek": 105396, "start": 1053.96, "end": 1059.72, "text": " which we cannot even handle. If it is an SMC exception we need to figure out whether it's", "tokens": [50364, 597, 321, 2644, 754, 4813, 13, 759, 309, 307, 364, 13115, 34, 11183, 321, 643, 281, 2573, 484, 1968, 309, 311, 50652], "temperature": 0.0, "avg_logprob": -0.1015112606095679, "compression_ratio": 1.6153846153846154, "no_speech_prob": 0.0014298256719484925}, {"id": 141, "seek": 105396, "start": 1059.72, "end": 1069.32, "text": " 32-bit one or 64-bit one assuming it's an SMC 64 on MV8 we still need to figure out whether", "tokens": [50652, 8858, 12, 5260, 472, 420, 12145, 12, 5260, 472, 11926, 309, 311, 364, 13115, 34, 12145, 322, 17663, 23, 321, 920, 643, 281, 2573, 484, 1968, 51132], "temperature": 0.0, "avg_logprob": -0.1015112606095679, "compression_ratio": 1.6153846153846154, "no_speech_prob": 0.0014298256719484925}, {"id": 142, "seek": 105396, "start": 1069.32, "end": 1077.48, "text": " this is a even a PSCI exception or it could be another type of an SMC. If it is a PSCI then", "tokens": [51132, 341, 307, 257, 754, 257, 8168, 25240, 11183, 420, 309, 727, 312, 1071, 2010, 295, 364, 13115, 34, 13, 759, 309, 307, 257, 8168, 25240, 550, 51540], "temperature": 0.0, "avg_logprob": -0.1015112606095679, "compression_ratio": 1.6153846153846154, "no_speech_prob": 0.0014298256719484925}, {"id": 143, "seek": 107748, "start": 1077.48, "end": 1087.0, "text": " UBOOT looks up the callback function which implements the PSCI function ID if it even exists", "tokens": [50364, 624, 33, 3783, 51, 1542, 493, 264, 818, 3207, 2445, 597, 704, 17988, 264, 8168, 25240, 2445, 7348, 498, 309, 754, 8198, 50840], "temperature": 0.0, "avg_logprob": -0.07727326844867907, "compression_ratio": 1.6936936936936937, "no_speech_prob": 0.004069012124091387}, {"id": 144, "seek": 107748, "start": 1087.0, "end": 1094.44, "text": " in UBOOT and if it does then it sets up C runtime environment and jumps onto the C function which", "tokens": [50840, 294, 624, 33, 3783, 51, 293, 498, 309, 775, 550, 309, 6352, 493, 383, 34474, 2823, 293, 16704, 3911, 264, 383, 2445, 597, 51212], "temperature": 0.0, "avg_logprob": -0.07727326844867907, "compression_ratio": 1.6936936936936937, "no_speech_prob": 0.004069012124091387}, {"id": 145, "seek": 107748, "start": 1094.44, "end": 1101.0, "text": " then looks very much like this and in this C function you can just do like a write into a", "tokens": [51212, 550, 1542, 588, 709, 411, 341, 293, 294, 341, 383, 2445, 291, 393, 445, 360, 411, 257, 2464, 666, 257, 51540], "temperature": 0.0, "avg_logprob": -0.07727326844867907, "compression_ratio": 1.6936936936936937, "no_speech_prob": 0.004069012124091387}, {"id": 146, "seek": 107748, "start": 1101.0, "end": 1107.0, "text": " register and for example in this case power of the system and like you don't have to care about", "tokens": [51540, 7280, 293, 337, 1365, 294, 341, 1389, 1347, 295, 264, 1185, 293, 411, 291, 500, 380, 362, 281, 1127, 466, 51840], "temperature": 0.0, "avg_logprob": -0.07727326844867907, "compression_ratio": 1.6936936936936937, "no_speech_prob": 0.004069012124091387}, {"id": 147, "seek": 110700, "start": 1107.0, "end": 1112.36, "text": " the assembler before that all you have to care about with the PSCI provider is very much this", "tokens": [50364, 264, 8438, 1918, 949, 300, 439, 291, 362, 281, 1127, 466, 365, 264, 8168, 25240, 12398, 307, 588, 709, 341, 50632], "temperature": 0.0, "avg_logprob": -0.06619469712420208, "compression_ratio": 1.665137614678899, "no_speech_prob": 0.0012004408054053783}, {"id": 148, "seek": 110700, "start": 1112.36, "end": 1118.6, "text": " because this is so specific and this is something you have to implement. Now on SMP", "tokens": [50632, 570, 341, 307, 370, 2685, 293, 341, 307, 746, 291, 362, 281, 4445, 13, 823, 322, 318, 12224, 50944], "temperature": 0.0, "avg_logprob": -0.06619469712420208, "compression_ratio": 1.665137614678899, "no_speech_prob": 0.0012004408054053783}, {"id": 149, "seek": 110700, "start": 1120.36, "end": 1127.64, "text": " there is this additional problem in that when the operating system running in EL2 requests", "tokens": [51032, 456, 307, 341, 4497, 1154, 294, 300, 562, 264, 7447, 1185, 2614, 294, 14426, 17, 12475, 51396], "temperature": 0.0, "avg_logprob": -0.06619469712420208, "compression_ratio": 1.665137614678899, "no_speech_prob": 0.0012004408054053783}, {"id": 150, "seek": 110700, "start": 1127.64, "end": 1133.08, "text": " from the PSCI provider that it wants to bring up secondary core the operating system will pass", "tokens": [51396, 490, 264, 8168, 25240, 12398, 300, 309, 2738, 281, 1565, 493, 11396, 4965, 264, 7447, 1185, 486, 1320, 51668], "temperature": 0.0, "avg_logprob": -0.06619469712420208, "compression_ratio": 1.665137614678899, "no_speech_prob": 0.0012004408054053783}, {"id": 151, "seek": 113308, "start": 1133.08, "end": 1140.6, "text": " through the PSCI a pointer for the OS entry point but you cannot just turn on the secondary core", "tokens": [50364, 807, 264, 8168, 25240, 257, 23918, 337, 264, 12731, 8729, 935, 457, 291, 2644, 445, 1261, 322, 264, 11396, 4965, 50740], "temperature": 0.0, "avg_logprob": -0.056432185786785466, "compression_ratio": 1.80859375, "no_speech_prob": 0.003695371560752392}, {"id": 152, "seek": 113308, "start": 1140.6, "end": 1145.56, "text": " which will start up in EL3 and point it into the OS entry point because this would be a", "tokens": [50740, 597, 486, 722, 493, 294, 14426, 18, 293, 935, 309, 666, 264, 12731, 8729, 935, 570, 341, 576, 312, 257, 50988], "temperature": 0.0, "avg_logprob": -0.056432185786785466, "compression_ratio": 1.80859375, "no_speech_prob": 0.003695371560752392}, {"id": 153, "seek": 113308, "start": 1145.56, "end": 1150.6799999999998, "text": " security violation you would essentially start the CPU core which is running in the highest", "tokens": [50988, 3825, 22840, 291, 576, 4476, 722, 264, 13199, 4965, 597, 307, 2614, 294, 264, 6343, 51244], "temperature": 0.0, "avg_logprob": -0.056432185786785466, "compression_ratio": 1.80859375, "no_speech_prob": 0.003695371560752392}, {"id": 154, "seek": 113308, "start": 1150.6799999999998, "end": 1155.32, "text": " privilege level and make it enter the operating system in some sort of a highest privilege level", "tokens": [51244, 12122, 1496, 293, 652, 309, 3242, 264, 7447, 1185, 294, 512, 1333, 295, 257, 6343, 12122, 1496, 51476], "temperature": 0.0, "avg_logprob": -0.056432185786785466, "compression_ratio": 1.80859375, "no_speech_prob": 0.003695371560752392}, {"id": 155, "seek": 113308, "start": 1155.32, "end": 1160.4399999999998, "text": " state even though the OS is running in lower privilege state so what happens there is the", "tokens": [51476, 1785, 754, 1673, 264, 12731, 307, 2614, 294, 3126, 12122, 1785, 370, 437, 2314, 456, 307, 264, 51732], "temperature": 0.0, "avg_logprob": -0.056432185786785466, "compression_ratio": 1.80859375, "no_speech_prob": 0.003695371560752392}, {"id": 156, "seek": 116044, "start": 1160.44, "end": 1169.0800000000002, "text": " CPU core actually has to enter Uboot in the Uboot init code the CPU core gets configured gets set in", "tokens": [50364, 13199, 4965, 767, 575, 281, 3242, 624, 1763, 310, 294, 264, 624, 1763, 310, 3157, 3089, 264, 13199, 4965, 2170, 30538, 2170, 992, 294, 50796], "temperature": 0.0, "avg_logprob": -0.0998559062545364, "compression_ratio": 1.793939393939394, "no_speech_prob": 0.0015409925254061818}, {"id": 157, "seek": 116044, "start": 1169.0800000000002, "end": 1178.28, "text": " a defined state so that it can enter the OS the CPU core GIC the interrupt controller registers are", "tokens": [50796, 257, 7642, 1785, 370, 300, 309, 393, 3242, 264, 12731, 264, 13199, 4965, 460, 2532, 264, 12729, 10561, 38351, 366, 51256], "temperature": 0.0, "avg_logprob": -0.0998559062545364, "compression_ratio": 1.793939393939394, "no_speech_prob": 0.0015409925254061818}, {"id": 158, "seek": 116044, "start": 1178.28, "end": 1186.76, "text": " configured so that it can receive an IPI then the CPU core drops into EL2 and then the CPU core", "tokens": [51256, 30538, 370, 300, 309, 393, 4774, 364, 8671, 40, 550, 264, 13199, 4965, 11438, 666, 14426, 17, 293, 550, 264, 13199, 4965, 51680], "temperature": 0.0, "avg_logprob": -0.0998559062545364, "compression_ratio": 1.793939393939394, "no_speech_prob": 0.0015409925254061818}, {"id": 159, "seek": 118676, "start": 1186.76, "end": 1191.96, "text": " starts spinning and waiting for an IPI so that when the operating system is actually ready", "tokens": [50364, 3719, 15640, 293, 3806, 337, 364, 8671, 40, 370, 300, 562, 264, 7447, 1185, 307, 767, 1919, 50624], "temperature": 0.0, "avg_logprob": -0.06388286501169205, "compression_ratio": 1.8741721854304636, "no_speech_prob": 0.0021248410921543837}, {"id": 160, "seek": 118676, "start": 1192.68, "end": 1201.32, "text": " to receive the CPU core it can ping it with an IPI and the CPU core will then be released to the", "tokens": [50660, 281, 4774, 264, 13199, 4965, 309, 393, 26151, 309, 365, 364, 8671, 40, 293, 264, 13199, 4965, 486, 550, 312, 4736, 281, 264, 51092], "temperature": 0.0, "avg_logprob": -0.06388286501169205, "compression_ratio": 1.8741721854304636, "no_speech_prob": 0.0021248410921543837}, {"id": 161, "seek": 118676, "start": 1201.32, "end": 1205.56, "text": " operating system and it jumps to the operating system entry point and then the operating system", "tokens": [51092, 7447, 1185, 293, 309, 16704, 281, 264, 7447, 1185, 8729, 935, 293, 550, 264, 7447, 1185, 51304], "temperature": 0.0, "avg_logprob": -0.06388286501169205, "compression_ratio": 1.8741721854304636, "no_speech_prob": 0.0021248410921543837}, {"id": 162, "seek": 120556, "start": 1205.56, "end": 1214.9199999999998, "text": " runs on two cores so this is the detail with an smp finally here is a summary of", "tokens": [50364, 6676, 322, 732, 24826, 370, 341, 307, 264, 2607, 365, 364, 262, 2455, 2721, 510, 307, 257, 12691, 295, 50832], "temperature": 0.0, "avg_logprob": -0.10836283365885417, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.010449187830090523}, {"id": 163, "seek": 120556, "start": 1216.44, "end": 1222.36, "text": " what to do in case you want to use Uboot as a psci provider so you have to look up the", "tokens": [50908, 437, 281, 360, 294, 1389, 291, 528, 281, 764, 624, 1763, 310, 382, 257, 18815, 537, 12398, 370, 291, 362, 281, 574, 493, 264, 51204], "temperature": 0.0, "avg_logprob": -0.10836283365885417, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.010449187830090523}, {"id": 164, "seek": 120556, "start": 1222.36, "end": 1227.0, "text": " gig distributor and redistributor base this is something which you find out in your SOC", "tokens": [51204, 8741, 49192, 293, 36198, 2024, 22163, 3096, 341, 307, 746, 597, 291, 915, 484, 294, 428, 10621, 34, 51436], "temperature": 0.0, "avg_logprob": -0.10836283365885417, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.010449187830090523}, {"id": 165, "seek": 120556, "start": 1227.0, "end": 1232.2, "text": " datasheet or if there is a linux device today it's already there and define these two macros gig", "tokens": [51436, 20377, 38164, 420, 498, 456, 307, 257, 22896, 2449, 4302, 965, 309, 311, 1217, 456, 293, 6964, 613, 732, 7912, 2635, 8741, 51696], "temperature": 0.0, "avg_logprob": -0.10836283365885417, "compression_ratio": 1.614678899082569, "no_speech_prob": 0.010449187830090523}, {"id": 166, "seek": 123220, "start": 1232.2, "end": 1238.8400000000001, "text": " debase and gigar base then you have to make sure that your DRAM is marked as non-secure because", "tokens": [50364, 3001, 651, 293, 8741, 289, 3096, 550, 291, 362, 281, 652, 988, 300, 428, 12118, 2865, 307, 12658, 382, 2107, 12, 8159, 540, 570, 50696], "temperature": 0.0, "avg_logprob": -0.12607197139574133, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.0021353731863200665}, {"id": 167, "seek": 123220, "start": 1238.8400000000001, "end": 1245.56, "text": " sometimes it is marked as secure and if it is marked as secure in the MMU tables then your OS", "tokens": [50696, 2171, 309, 307, 12658, 382, 7144, 293, 498, 309, 307, 12658, 382, 7144, 294, 264, 34191, 52, 8020, 550, 428, 12731, 51032], "temperature": 0.0, "avg_logprob": -0.12607197139574133, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.0021353731863200665}, {"id": 168, "seek": 123220, "start": 1245.56, "end": 1251.16, "text": " will not be able to access DRAM and it will crash you potentially have to configure other", "tokens": [51032, 486, 406, 312, 1075, 281, 2105, 12118, 2865, 293, 309, 486, 8252, 291, 7263, 362, 281, 22162, 661, 51312], "temperature": 0.0, "avg_logprob": -0.12607197139574133, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.0021353731863200665}, {"id": 169, "seek": 123220, "start": 1251.16, "end": 1257.16, "text": " security related registers of the CPU this is again SOC specific you have to look it up in", "tokens": [51312, 3825, 4077, 38351, 295, 264, 13199, 341, 307, 797, 10621, 34, 2685, 291, 362, 281, 574, 309, 493, 294, 51612], "temperature": 0.0, "avg_logprob": -0.12607197139574133, "compression_ratio": 1.7209302325581395, "no_speech_prob": 0.0021353731863200665}, {"id": 170, "seek": 125716, "start": 1257.16, "end": 1265.24, "text": " your SOC datasheet then finally the main part of the implementation is fill in your psci.c", "tokens": [50364, 428, 10621, 34, 20377, 38164, 550, 2721, 264, 2135, 644, 295, 264, 11420, 307, 2836, 294, 428, 18815, 537, 13, 66, 50768], "temperature": 0.0, "avg_logprob": -0.12494766010957606, "compression_ratio": 1.6057142857142856, "no_speech_prob": 0.0037846879567950964}, {"id": 171, "seek": 125716, "start": 1265.24, "end": 1273.96, "text": " callback implementation against SOC specific and then remove the previews pl31 psci implementation", "tokens": [50768, 818, 3207, 11420, 1970, 10621, 34, 2685, 293, 550, 4159, 264, 14281, 82, 499, 12967, 18815, 537, 11420, 51204], "temperature": 0.0, "avg_logprob": -0.12494766010957606, "compression_ratio": 1.6057142857142856, "no_speech_prob": 0.0037846879567950964}, {"id": 172, "seek": 125716, "start": 1273.96, "end": 1281.88, "text": " block which potentially was atf enable these Uboot config options give or take in the Uboot", "tokens": [51204, 3461, 597, 7263, 390, 412, 69, 9528, 613, 624, 1763, 310, 6662, 3956, 976, 420, 747, 294, 264, 624, 1763, 310, 51600], "temperature": 0.0, "avg_logprob": -0.12494766010957606, "compression_ratio": 1.6057142857142856, "no_speech_prob": 0.0037846879567950964}, {"id": 173, "seek": 128188, "start": 1281.88, "end": 1290.1200000000001, "text": " port config and compile and then it should basically work and in case it doesn't work", "tokens": [50364, 2436, 6662, 293, 31413, 293, 550, 309, 820, 1936, 589, 293, 294, 1389, 309, 1177, 380, 589, 50776], "temperature": 0.0, "avg_logprob": -0.08931641048855252, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.0028835765551775694}, {"id": 174, "seek": 128188, "start": 1290.1200000000001, "end": 1296.1200000000001, "text": " Uboot has the debug UART functionality so if you have two UARTs on your machine you can point the", "tokens": [50776, 624, 1763, 310, 575, 264, 24083, 624, 15118, 14980, 370, 498, 291, 362, 732, 624, 15118, 82, 322, 428, 3479, 291, 393, 935, 264, 51076], "temperature": 0.0, "avg_logprob": -0.08931641048855252, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.0028835765551775694}, {"id": 175, "seek": 128188, "start": 1296.1200000000001, "end": 1302.44, "text": " debug UART into the other UART not the console UART and use this dedicated lightweight printing", "tokens": [51076, 24083, 624, 15118, 666, 264, 661, 624, 15118, 406, 264, 11076, 624, 15118, 293, 764, 341, 8374, 22052, 14699, 51392], "temperature": 0.0, "avg_logprob": -0.08931641048855252, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.0028835765551775694}, {"id": 176, "seek": 128188, "start": 1302.44, "end": 1311.8000000000002, "text": " mechanism to essentially print some sort of debug output from the Uboot psci provider the secure part", "tokens": [51392, 7513, 281, 4476, 4482, 512, 1333, 295, 24083, 5598, 490, 264, 624, 1763, 310, 18815, 537, 12398, 264, 7144, 644, 51860], "temperature": 0.0, "avg_logprob": -0.08931641048855252, "compression_ratio": 1.6858407079646018, "no_speech_prob": 0.0028835765551775694}, {"id": 177, "seek": 131180, "start": 1311.8, "end": 1317.24, "text": " even while the Linux kernel is running it is possible to get some debug UART prints out of this", "tokens": [50364, 754, 1339, 264, 18734, 28256, 307, 2614, 309, 307, 1944, 281, 483, 512, 24083, 624, 15118, 22305, 484, 295, 341, 50636], "temperature": 0.0, "avg_logprob": -0.06482246298539011, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.002492060186341405}, {"id": 178, "seek": 131180, "start": 1318.84, "end": 1324.68, "text": " here are the config options which you used for that okay and now since I am through my slides", "tokens": [50716, 510, 366, 264, 6662, 3956, 597, 291, 1143, 337, 300, 1392, 293, 586, 1670, 286, 669, 807, 452, 9788, 51008], "temperature": 0.0, "avg_logprob": -0.06482246298539011, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.002492060186341405}, {"id": 179, "seek": 131180, "start": 1325.3999999999999, "end": 1334.68, "text": " I promised an example so this will be very boring here is Uboot and if you are familiar with Uboot", "tokens": [51044, 286, 10768, 364, 1365, 370, 341, 486, 312, 588, 9989, 510, 307, 624, 1763, 310, 293, 498, 291, 366, 4963, 365, 624, 1763, 310, 51508], "temperature": 0.0, "avg_logprob": -0.06482246298539011, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.002492060186341405}, {"id": 180, "seek": 131180, "start": 1334.68, "end": 1340.04, "text": " this is how it looks and it just looks all the same except if you are familiar with Uboot on", "tokens": [51508, 341, 307, 577, 309, 1542, 293, 309, 445, 1542, 439, 264, 912, 3993, 498, 291, 366, 4963, 365, 624, 1763, 310, 322, 51776], "temperature": 0.0, "avg_logprob": -0.06482246298539011, "compression_ratio": 1.7008928571428572, "no_speech_prob": 0.002492060186341405}, {"id": 181, "seek": 134004, "start": 1340.04, "end": 1347.3999999999999, "text": " imx8m plus or imx8m in general you may notice that there is no notice here the notice comes from", "tokens": [50364, 566, 87, 23, 76, 1804, 420, 566, 87, 23, 76, 294, 2674, 291, 815, 3449, 300, 456, 307, 572, 3449, 510, 264, 3449, 1487, 490, 50732], "temperature": 0.0, "avg_logprob": -0.09076299667358398, "compression_ratio": 1.8224299065420562, "no_speech_prob": 0.006798180751502514}, {"id": 182, "seek": 134004, "start": 1347.3999999999999, "end": 1353.24, "text": " the atfpl31 blob and the blob is not there because the Uboot is the provider of that functionality", "tokens": [50732, 264, 412, 69, 564, 12967, 46115, 293, 264, 46115, 307, 406, 456, 570, 264, 624, 1763, 310, 307, 264, 12398, 295, 300, 14980, 51024], "temperature": 0.0, "avg_logprob": -0.09076299667358398, "compression_ratio": 1.8224299065420562, "no_speech_prob": 0.006798180751502514}, {"id": 183, "seek": 134004, "start": 1353.24, "end": 1358.84, "text": " now but beyond that I can boot the Linux kernel all the same the Linux kernel detects that there", "tokens": [51024, 586, 457, 4399, 300, 286, 393, 11450, 264, 18734, 28256, 439, 264, 912, 264, 18734, 28256, 5531, 82, 300, 456, 51304], "temperature": 0.0, "avg_logprob": -0.09076299667358398, "compression_ratio": 1.8224299065420562, "no_speech_prob": 0.006798180751502514}, {"id": 184, "seek": 134004, "start": 1358.84, "end": 1365.48, "text": " is a psci interface in the firmware which is now provided by the Uboot the Linux kernel brings up", "tokens": [51304, 307, 257, 18815, 537, 9226, 294, 264, 30289, 597, 307, 586, 5649, 538, 264, 624, 1763, 310, 264, 18734, 28256, 5607, 493, 51636], "temperature": 0.0, "avg_logprob": -0.09076299667358398, "compression_ratio": 1.8224299065420562, "no_speech_prob": 0.006798180751502514}, {"id": 185, "seek": 136548, "start": 1365.48, "end": 1370.84, "text": " the cpu course the cpu course show up in proc cpu info and the cpu course just work", "tokens": [50364, 264, 269, 34859, 1164, 264, 269, 34859, 1164, 855, 493, 294, 9510, 269, 34859, 13614, 293, 264, 269, 34859, 1164, 445, 589, 50632], "temperature": 0.0, "avg_logprob": -0.08956306120928596, "compression_ratio": 1.7380952380952381, "no_speech_prob": 0.009933625347912312}, {"id": 186, "seek": 136548, "start": 1372.2, "end": 1378.28, "text": " and that's actually all there is to show it's exactly the same as it was with the blob except", "tokens": [50700, 293, 300, 311, 767, 439, 456, 307, 281, 855, 309, 311, 2293, 264, 912, 382, 309, 390, 365, 264, 46115, 3993, 51004], "temperature": 0.0, "avg_logprob": -0.08956306120928596, "compression_ratio": 1.7380952380952381, "no_speech_prob": 0.009933625347912312}, {"id": 187, "seek": 136548, "start": 1378.28, "end": 1386.3600000000001, "text": " now you have one less entry in the s-point so you no longer need the atfpl31 blob which is", "tokens": [51004, 586, 291, 362, 472, 1570, 8729, 294, 264, 262, 12, 6053, 370, 291, 572, 2854, 643, 264, 412, 69, 564, 12967, 46115, 597, 307, 51408], "temperature": 0.0, "avg_logprob": -0.08956306120928596, "compression_ratio": 1.7380952380952381, "no_speech_prob": 0.009933625347912312}, {"id": 188, "seek": 136548, "start": 1386.3600000000001, "end": 1391.16, "text": " bundled with Uboot because Uboot can do it now for you and by the way this stuff is now upstream", "tokens": [51408, 13882, 1493, 365, 624, 1763, 310, 570, 624, 1763, 310, 393, 360, 309, 586, 337, 291, 293, 538, 264, 636, 341, 1507, 307, 586, 33915, 51648], "temperature": 0.0, "avg_logprob": -0.08956306120928596, "compression_ratio": 1.7380952380952381, "no_speech_prob": 0.009933625347912312}, {"id": 189, "seek": 139116, "start": 1391.16, "end": 1398.68, "text": " since two days ago in case you enable the debug uart you will see some sort of a debug", "tokens": [50364, 1670, 732, 1708, 2057, 294, 1389, 291, 9528, 264, 24083, 344, 446, 291, 486, 536, 512, 1333, 295, 257, 24083, 50740], "temperature": 0.0, "avg_logprob": -0.12401861958689504, "compression_ratio": 1.5988372093023255, "no_speech_prob": 0.005690902005881071}, {"id": 190, "seek": 139116, "start": 1398.68, "end": 1408.8400000000001, "text": " print out of the secure part of Uboot for example here is psci cpu 164 this is the Linux kernel", "tokens": [50740, 4482, 484, 295, 264, 7144, 644, 295, 624, 1763, 310, 337, 1365, 510, 307, 18815, 537, 269, 34859, 3165, 19, 341, 307, 264, 18734, 28256, 51248], "temperature": 0.0, "avg_logprob": -0.12401861958689504, "compression_ratio": 1.5988372093023255, "no_speech_prob": 0.005690902005881071}, {"id": 191, "seek": 139116, "start": 1408.8400000000001, "end": 1416.6000000000001, "text": " sending the psci request to Uboot and Uboot just brings up the cpu code for the Linux kernel", "tokens": [51248, 7750, 264, 18815, 537, 5308, 281, 624, 1763, 310, 293, 624, 1763, 310, 445, 5607, 493, 264, 269, 34859, 3089, 337, 264, 18734, 28256, 51636], "temperature": 0.0, "avg_logprob": -0.12401861958689504, "compression_ratio": 1.5988372093023255, "no_speech_prob": 0.005690902005881071}, {"id": 192, "seek": 141660, "start": 1417.24, "end": 1418.76, "text": " and that's it thank you for your attention", "tokens": [50396, 293, 300, 311, 309, 1309, 291, 337, 428, 3202, 50472], "temperature": 0.0, "avg_logprob": -0.11462276776631673, "compression_ratio": 1.5562913907284768, "no_speech_prob": 0.004265320021659136}, {"id": 193, "seek": 141660, "start": 1429.08, "end": 1429.9599999999998, "text": " questions yeah", "tokens": [50988, 1651, 1338, 51032], "temperature": 0.0, "avg_logprob": -0.11462276776631673, "compression_ratio": 1.5562913907284768, "no_speech_prob": 0.004265320021659136}, {"id": 194, "seek": 141660, "start": 1432.36, "end": 1438.36, "text": " so if you have an existing atf implementing psci and you want to move to Uboot you have to", "tokens": [51152, 370, 498, 291, 362, 364, 6741, 412, 69, 18114, 18815, 537, 293, 291, 528, 281, 1286, 281, 624, 1763, 310, 291, 362, 281, 51452], "temperature": 0.0, "avg_logprob": -0.11462276776631673, "compression_ratio": 1.5562913907284768, "no_speech_prob": 0.004265320021659136}, {"id": 195, "seek": 141660, "start": 1438.36, "end": 1445.1599999999999, "text": " convert everything at once there's no way to like step by step move functionality over", "tokens": [51452, 7620, 1203, 412, 1564, 456, 311, 572, 636, 281, 411, 1823, 538, 1823, 1286, 14980, 670, 51792], "temperature": 0.0, "avg_logprob": -0.11462276776631673, "compression_ratio": 1.5562913907284768, "no_speech_prob": 0.004265320021659136}, {"id": 196, "seek": 144516, "start": 1445.16, "end": 1449.5600000000002, "text": " so you see the functionality is actually super simple i mean all you have to do is like turn on", "tokens": [50364, 370, 291, 536, 264, 14980, 307, 767, 1687, 2199, 741, 914, 439, 291, 362, 281, 360, 307, 411, 1261, 322, 50584], "temperature": 0.0, "avg_logprob": -0.12459862950336502, "compression_ratio": 1.7421052631578948, "no_speech_prob": 0.003011655528098345}, {"id": 197, "seek": 144516, "start": 1449.5600000000002, "end": 1457.48, "text": " cpu code turn off cpu code and suspend and power off and reset and this is like 200 lines of code", "tokens": [50584, 269, 34859, 3089, 1261, 766, 269, 34859, 3089, 293, 42546, 293, 1347, 766, 293, 14322, 293, 341, 307, 411, 2331, 3876, 295, 3089, 50980], "temperature": 0.0, "avg_logprob": -0.12459862950336502, "compression_ratio": 1.7421052631578948, "no_speech_prob": 0.003011655528098345}, {"id": 198, "seek": 144516, "start": 1458.3600000000001, "end": 1464.0400000000002, "text": " so it's like super simple really um and it's actually all now upstream for imx 8m", "tokens": [51024, 370, 309, 311, 411, 1687, 2199, 534, 1105, 293, 309, 311, 767, 439, 586, 33915, 337, 566, 87, 1649, 76, 51308], "temperature": 0.0, "avg_logprob": -0.12459862950336502, "compression_ratio": 1.7421052631578948, "no_speech_prob": 0.003011655528098345}, {"id": 199, "seek": 144516, "start": 1465.4, "end": 1468.68, "text": " plus so we can actually just use that as an inspiration", "tokens": [51376, 1804, 370, 321, 393, 767, 445, 764, 300, 382, 364, 10249, 51540], "temperature": 0.0, "avg_logprob": -0.12459862950336502, "compression_ratio": 1.7421052631578948, "no_speech_prob": 0.003011655528098345}], "language": "en"}