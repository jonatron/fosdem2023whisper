{"text": " Hello? Okay. Now it works. Kind of, right? Okay. So hello everyone. Welcome to Security Dev Room and we've got our next talk about key lime and thermal attestation which will be given by Anderson and Thorsen. Okay. So welcome. Sorry about the trouble. So I'm Anderson as I am a software engineer at Red Hat and I'm here with Thorsen. Yeah, I'm Thorsen and I'm a maintainer of Linux distribution for school and universities and I'm also a maintainer of key lime. Yeah, so we are here to talk about remote attestation with key lime. So let's get started. Imagine you are like a car vendor who maintains and updates the systems running in cars but you want to make sure that the systems in the cars were not modified so that you can check if the customer is still eligible to receive the latest updates or something like that. Or you are a software company building software in the cloud but you want to make sure that the build tooling was not modified or you are a telecom company that wants to make sure that the systems you deployed that controls antennas they were not modified. So what all these cases have in common is first they are remote, second you don't really have full control of the systems in the world. So the question is how can you check that the system was not modified in the in the world. So our way would be if you could somehow get some information about the system and then check if it's what you expected from that. And of course in case it's not then you would want to have a way to react on that. So if you can do that continuously get the information checked then you have like monitoring of the integrity of the system. So that's what one of the things the remote attestation can provide is to check remote integrity, remote machine integrity, how it works. So you have a trusted entity running in some controlled environment and then you have a trusted agent on the other side running on the monitored system and you ask for the information to that agent and gets back some information called a quote then you can verify that that agent is running in a machine in a state that you trust. So that comes with the problem of trust. So how can you trust the machine or the agent running in some machine that you don't control. So you don't really trust directly the agent but you trust on a hardware root of trust which is the trusted platform model or TPM. What are the TPMs? They are pieces of hardware that can perform crypto operations such as generating keys, signing data and it has this special key and certificate called endorsement key which are generated during manufacturing. So the manufacturer generates the key and publishes the CA certificate so that you can verify that it is legitimate. And then this EK, the endorsement keys can't sign data directly but you can generate the attestation keys that are associated with that endorsement key in a way that you can verify the origin of some assigned data so that you can make sure that that data was signed by that specific TPM. So and another important thing that the TPM has are the platform conversion registers which are special registers designed to store measurements about the system and in a way that you can verify the integrity. So how these measurements are done? During boot, each step of the boot is measured by the UFI into the TPM via the PCR extend operation. So each step the boot process goes, you get a hash of the binary or the software that is running and extend into a PCR. I will explain that soon. And so during boot, the UFI is responsible for measuring the boot steps into the TPM and after boot, then the kernel integrity measurement architecture or IMA will measure any open file that matches a policy you can configure the IMA and it will measure the files open into a PCR as well. So if you have the information like the state of the PCR and the event log or all the operations, extend operations that were performed, then you can verify the integrity of the machine. So how this PCR extend algorithm works is kind of simple. You'll get the old value stored in the PCR, concatenated with the measurement from the data. So this measurement is basically a hash. So you concatenate the old value with the hash of the measurement, calculate the hash of all of these and put back into the PCR. So that's done for each step. So of course these PCRs, if you know a bit of TPM, they don't match the actual numbers, but this is just for illustration. So all of these, after measuring all these steps, you have the final value in the PCR that you can calculate like a called golden value, which you calculate like the hash of all the PCR values and you have a representation of the state of the machine and that can be verified. So how key lime works. So in the left side, you have trusted entity where you like probably a machine that you control where you run the verifier side of the key lime. It's a server and on the right side, you have the monitored system. It is remote. You don't have complete control of it, but the agent has access to the TPM installed in that machine and so the server can verify, the verifier can request a state to the agent. Then the agent will access the TPM to get the quote, meaning the PCR values and also together with the event logs or all the PCR extend operations that were performed and throw it back to the verifier. And then the verifier can verify first the origin of that piece of data because it's signed by the AK key. So you can make sure that that data came from that machine that contains that TPM and you can verify the identity of the TPM using the EK certificate. And with the values you obtained for the PCRs and the event log, you can replay all the extend operations so that in the end, you can get the values that it should have. And so with all these information, you can verify the integrity of the machine. Since you also got the information from AIMA, like all the files that were open and matched some policy, the AIMA will calculate the hash of open files that match some policy and extend to the PCR. So you get this log containing the file names and the matching hashes. So you can also with some policy engine verify the integrity of individual files in the remote machine. So you can like a full integrity view of the remote machine. So with that information, the verifier can check. If it's okay, it's okay. The attestation was successful. But if it was not, it doesn't match what you expected, then it's a failure. So in case of failure, we have a revocation framework, which is a way to, so you can configure some actions to the verifier, some script that it can run to perform some action. It can be some webhooks. So if some attestation fails, it sends some request to some webhook, or you can notify the agents directly via REST API, and send some payload to the trigger some operation there. The simplest scenario, for example, if you had a cluster with various machines, and one of them failed attestation, you cannot find the others to remove that node from the cluster by blocking the network connectivity, for example. So that's how key lime works in general. So now I'm passing the mic to Thor. He will continue with the real world stuff. Yeah. So now we heard how key lime works, and we want to show that you can use that in production, and what are the challenges that you will run into if you want to try that. We have three main scenarios there. We have first policy creation, then the monitoring, and then how to react on that. So the first part is, we want to create policies for our system. For that, we need to know what is actually on our system, and what are our systems. So from a software side perspective, it's normal that we integrate, we have a CI CD pipeline, we get what data gets into that, and we want to save the hashes there. But we need also a lot of other stuff. We want to know what packages are installed, where they end up on our system, have their signatures, can we verify that? That is what we normally want to have, and either this information is already provided by the distribution, or we need to generate that on our own. Then on the hardware side, we need to know what kind of hardware we're running. So as we said, we have the EK, so the endorsement key, we need to at least know that to trust the TPM in some regard. And then ideally, we want to also know what firmware is running on that device, and which configuration do we have. For example, do we allow CQB to be disabled and enabled? Do we have our own keys on there? And stuff like that. So if you have all that information, we can go to the other side, which is the monitoring. That part is implemented by KeyLine. You can, if you have all the necessary information, we provide documentation and tools to generate a policy for that, and you can feed it in that, and it's all there. The challenge that you run into here is that for many of you, probably IMA, measured boot, and TPMs are new. And if you run into issues, then you also try, need to try understand how that works to debug it. So that is a challenge you run into, that you still need a good understanding of those technologies to make your life easier. But yeah, that is mostly solved by KeyLine. And then we come to the non-technical side, which is we need to react somehow when we have a revocation failure. So is that a lot actually relevant for us? Because if we have like file changes in TAMP, we don't really care. But then who needs to be notified if you have that? Then how do we tie that in our current monitoring infrastructure? For example, like with the web hooks. And lastly, if you are a company and you're, it's a potential security breach if KeyLine fails in the way that you configured it. So there are service agreements in place, which need you notify and how do you respond for that. So, but going now from the general part to actual examples, I work on the Linux distribution that does exams for schools and universities called Lensdijk. And we developed with the University of Applied Sciences and Arts Northwestern Switzerland, also called FANV, a system called Kampler, which is secure, bring your own device exams. So what is the problem here? The students want to bring their own device, their own notebook into the lecture hall and want to write their exams on that. We don't want to touch their operating system. So we do something what we call bring your own hardware. They bring their own hardware and we boot a live Linux system on that system and remotely attest if that system is running correctly. So what do we have? We have our hardware, which has a hard drive and a TPM. Now we boot the distribution called Lensdijk. And on that we have the KeyLine agent running and also Imr and our measured boot stuff. And now the interesting part is we just care about the TPM. We don't care about the hard drive and what is on that system otherwise. So now we have the actual server solution. So we register to the exam system. And this also includes that we register to KeyLine. Then we check in return if the system is actually in a trustworthy state. And if that's the case, we release the exam files, which is in our case normally RDP session, which then connects to the cloud where the people are actually writing their exams. So why are we doing that this way? The first one is that we guarantee that the environment for every student is the same because they only provide their hardware and it's basically terminal to connect to the actual exam. So if there's computing intensive stuff, then it doesn't really matter. And also because they only bring their own hardware and don't need to install monitoring software on their system to write the exam, we don't care what they does on that. We don't want to know it's first for privacy and also to make setup way easier. Now back to a more traditional scenario that more of you are probably familiar with the cloud. And there we have the example that IBM uses this for hypervisor attestation. And they don't use runtime attestations or not anymore. They use measure boot to see if the hypervisor booted up correctly. So their challenges were that implementing the actual response procedures, so the procedure from we have an alert to how do we deal with that now. That is the difficult part because the one is the technical side, but how do we structure our teams in a way that we can guarantee that. Then also the other ones are eliminating false positives that ties into the first point because if a human needs to react, then we want to have no false positives and also no false negatives ideally. And false negatives are for security very, very bad. So we don't want to have that. And lastly is keeping the policies up to date. Even if you roll your own distribution and are big enough, it's very difficult to be up to date on that policies and integrate them automatically. And lastly, they have an escalation chain just for illustration purposes. They use key lime to monitor that, tie that into their JIRA system, and then have an actual person react on the other side. So and then one point from a distribution. So in this case from SUSE, I asked them and they integrated key lime into pretty much any product. So it's an open SUSE today. If you want to use it in microS, there's instruction to do that. And then also in SUSE Enterprise Linux and an ALP. Their challenges also we're like integrating it with as a Linux fully and making IMA usable. So do we have signatures? How do we provide the hashes? And the general thing for distribution is how do we provide robust policies in general? Because we want users to try out the technology and want to experiment with that. But how do we give them the starting point? And that is still a very difficult because as we saw, there are many data points that needs to be collected. And that is a challenge that they're trying to solve actively by making, getting the signatures and the hashes easier. Yeah. So to say for the end, try remote attestation today. The technology that you need to do that is pretty much in every device that you have like in a notebook that you can use. So you can find Keelem at Keelem.dev. And yeah, thank you. So do we have questions? Lots of questions. Thank you for a great presentation. One question. You talked a lot about the verification side of the processing. You talked a lot about the verification side, but to have the golden values or the PCRs in your verified system, you need to provision them. So I was not sure the distribution side of things was how do you manage that in Keelem? Could you shed some light on that? Yeah. So with the golden values, we have the values in the TPM and then they're also tied to an event log and IMA and like a measure boot. And we solve the issue that we don't actually need golden values by having a policy engine basically that verifies the logs itself checks if that those match the values, but then we check the logs and not the end value. So and then the distribution can help because they can provide like a lot of the signatures already and which files are in which packages and how they end up. That makes the life for the distribution easier. Yes, sir. What is the performance of such a check? How much time does it take and how much data is required for such a monitoring? From what I saw, I don't have like a benchmarks for that, but it's pretty quick, like 200 milliseconds, something like that. So the round trip from the request to the response is like 200 milliseconds in my test, but of course it's on my machine, right? We don't have benchmarks for the performance. Yeah, so it heavily also depends what you want to test. If you just have measured boot, it's the crow time on the hardware TPM maximum to a second, and then it's like a couple of most megabytes of a single digits that you have at data that is transferred. You had said that one of the challenges of implementation was dealing with false positives and maybe false negatives. Can you give some examples of when that would occur? Yeah, because we are still talking over the network. That is like a false positive if the network connection goes down. And the other one is it's kind of a false positive and not really is if your policy is not up to date. For the system, it's not a false positive in the traditional sense, but it's in the false positive because we don't want that alert actually to happen. For the university use case, how do you know that you're actually talking to the real TPM in the laptop? So we have two ways. First, we verify against the hardware manufacturer. So they have a CA that we can verify against. And also we can enroll the notebooks directly. So we check if the devices, which I forgot to say that the university part is still proof of concept. So we are currently working on it, but it's not rolled out like large scale. How do you make sure that an alert event, a new change happened? How do you make sure that it's not intercepted over the network? Sorry, once again. How do you make sure that when there's an event saying that there's a change on the machine, a new measurement that appears? How do you make sure that the event is not intercepted in the network between the monitored machine and the trusted system? So is the question, how do we deal with the losing connection between the agent, the monitored system and the verifier? Losing connection or having maybe something in between, making sure that it does not go to the trusted system. There's something in between that makes sure that you're never going to be notified that a system is going to be compromised or just became compromised. Did you get that? Yes. So if we have a blocking connection between the agent and the verifier side, then we get a timeout and then the agent gets automatically distressed. And if you said like from the notification system itself, if you say we notify all the other agents, of course, then there is an issue if you cannot reach to them on a trusted channel, then it's basically game over in that direction. So you need to get your revocation alerts if you want to guarantee them all the time through a trusted channel. So the trust boundary is for the attestation part that we see that, but the revocation part, if you want to reach that, then it needs to go through a trusted channel. Yeah. So continuing on this question, actually, I think, how do you make sure that your actual verifiers connect to the right agent and you don't have a man in the middle attack that's happening and rerouting this to a fake agent and fake TPM? Yeah. So that's tied with the EK certificate. So you trust the manufacturer because when they manufacture the TPM, they will create this key that cannot be modified or removed in any way. So it provides the identity to the TPM. So when you get the information from the TPM or from some agent, you can verify that that data came from the TPM that has some EK key because it's signed and you can verify the origin using the CA certificate provided by the manufacturer. So you can check that the TPM is exactly the one you expected using the EK certificate. Okay. Thank you for the talk. Thank you for all the questions. We are out of the diamond. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 17.12, "text": " Hello? Okay. Now it works. Kind of, right? Okay. So hello everyone. Welcome to Security", "tokens": [2425, 30, 1033, 13, 823, 309, 1985, 13, 9242, 295, 11, 558, 30, 1033, 13, 407, 7751, 1518, 13, 4027, 281, 11164], "temperature": 0.0, "avg_logprob": -0.42774910622454704, "compression_ratio": 1.2517985611510791, "no_speech_prob": 0.5888171195983887}, {"id": 1, "seek": 0, "start": 17.12, "end": 22.88, "text": " Dev Room and we've got our next talk about key lime and thermal attestation which will", "tokens": [9096, 19190, 293, 321, 600, 658, 527, 958, 751, 466, 2141, 22035, 293, 15070, 951, 377, 399, 597, 486], "temperature": 0.0, "avg_logprob": -0.42774910622454704, "compression_ratio": 1.2517985611510791, "no_speech_prob": 0.5888171195983887}, {"id": 2, "seek": 2288, "start": 22.88, "end": 35.56, "text": " be given by Anderson and Thorsen. Okay. So welcome. Sorry about the trouble. So I'm Anderson", "tokens": [312, 2212, 538, 18768, 293, 334, 830, 268, 13, 1033, 13, 407, 2928, 13, 4919, 466, 264, 5253, 13, 407, 286, 478, 18768], "temperature": 0.0, "avg_logprob": -0.35488181114196776, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.001102979527786374}, {"id": 3, "seek": 2288, "start": 35.56, "end": 41.96, "text": " as I am a software engineer at Red Hat and I'm here with Thorsen. Yeah, I'm Thorsen and I'm a", "tokens": [382, 286, 669, 257, 4722, 11403, 412, 4477, 15867, 293, 286, 478, 510, 365, 334, 830, 268, 13, 865, 11, 286, 478, 334, 830, 268, 293, 286, 478, 257], "temperature": 0.0, "avg_logprob": -0.35488181114196776, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.001102979527786374}, {"id": 4, "seek": 2288, "start": 41.96, "end": 47.0, "text": " maintainer of Linux distribution for school and universities and I'm also a maintainer of key lime.", "tokens": [6909, 260, 295, 18734, 7316, 337, 1395, 293, 11779, 293, 286, 478, 611, 257, 6909, 260, 295, 2141, 22035, 13], "temperature": 0.0, "avg_logprob": -0.35488181114196776, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.001102979527786374}, {"id": 5, "seek": 4700, "start": 47.0, "end": 52.72, "text": " Yeah, so we are here to talk about remote attestation with key lime. So let's get started.", "tokens": [865, 11, 370, 321, 366, 510, 281, 751, 466, 8607, 951, 377, 399, 365, 2141, 22035, 13, 407, 718, 311, 483, 1409, 13], "temperature": 0.0, "avg_logprob": -0.13296912761216753, "compression_ratio": 1.626086956521739, "no_speech_prob": 7.60869515943341e-05}, {"id": 6, "seek": 4700, "start": 52.72, "end": 60.2, "text": " Imagine you are like a car vendor who maintains and updates the systems running in cars but you", "tokens": [11739, 291, 366, 411, 257, 1032, 24321, 567, 33385, 293, 9205, 264, 3652, 2614, 294, 5163, 457, 291], "temperature": 0.0, "avg_logprob": -0.13296912761216753, "compression_ratio": 1.626086956521739, "no_speech_prob": 7.60869515943341e-05}, {"id": 7, "seek": 4700, "start": 60.2, "end": 66.92, "text": " want to make sure that the systems in the cars were not modified so that you can check if the", "tokens": [528, 281, 652, 988, 300, 264, 3652, 294, 264, 5163, 645, 406, 15873, 370, 300, 291, 393, 1520, 498, 264], "temperature": 0.0, "avg_logprob": -0.13296912761216753, "compression_ratio": 1.626086956521739, "no_speech_prob": 7.60869515943341e-05}, {"id": 8, "seek": 4700, "start": 66.92, "end": 73.32, "text": " customer is still eligible to receive the latest updates or something like that. Or you are a", "tokens": [5474, 307, 920, 14728, 281, 4774, 264, 6792, 9205, 420, 746, 411, 300, 13, 1610, 291, 366, 257], "temperature": 0.0, "avg_logprob": -0.13296912761216753, "compression_ratio": 1.626086956521739, "no_speech_prob": 7.60869515943341e-05}, {"id": 9, "seek": 7332, "start": 73.32, "end": 80.6, "text": " software company building software in the cloud but you want to make sure that the build tooling", "tokens": [4722, 2237, 2390, 4722, 294, 264, 4588, 457, 291, 528, 281, 652, 988, 300, 264, 1322, 46593], "temperature": 0.0, "avg_logprob": -0.14973068237304688, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.00010409261449240148}, {"id": 10, "seek": 7332, "start": 80.6, "end": 87.44, "text": " was not modified or you are a telecom company that wants to make sure that the systems you deployed", "tokens": [390, 406, 15873, 420, 291, 366, 257, 4304, 1112, 2237, 300, 2738, 281, 652, 988, 300, 264, 3652, 291, 17826], "temperature": 0.0, "avg_logprob": -0.14973068237304688, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.00010409261449240148}, {"id": 11, "seek": 7332, "start": 87.44, "end": 97.16, "text": " that controls antennas they were not modified. So what all these cases have in common is first", "tokens": [300, 9003, 18858, 18979, 436, 645, 406, 15873, 13, 407, 437, 439, 613, 3331, 362, 294, 2689, 307, 700], "temperature": 0.0, "avg_logprob": -0.14973068237304688, "compression_ratio": 1.7636363636363637, "no_speech_prob": 0.00010409261449240148}, {"id": 12, "seek": 9716, "start": 97.16, "end": 105.11999999999999, "text": " they are remote, second you don't really have full control of the systems in the world. So the", "tokens": [436, 366, 8607, 11, 1150, 291, 500, 380, 534, 362, 1577, 1969, 295, 264, 3652, 294, 264, 1002, 13, 407, 264], "temperature": 0.0, "avg_logprob": -0.12582854948182037, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.0001243340811925009}, {"id": 13, "seek": 9716, "start": 105.11999999999999, "end": 113.36, "text": " question is how can you check that the system was not modified in the in the world. So our way", "tokens": [1168, 307, 577, 393, 291, 1520, 300, 264, 1185, 390, 406, 15873, 294, 264, 294, 264, 1002, 13, 407, 527, 636], "temperature": 0.0, "avg_logprob": -0.12582854948182037, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.0001243340811925009}, {"id": 14, "seek": 9716, "start": 113.36, "end": 120.19999999999999, "text": " would be if you could somehow get some information about the system and then check if it's what", "tokens": [576, 312, 498, 291, 727, 6063, 483, 512, 1589, 466, 264, 1185, 293, 550, 1520, 498, 309, 311, 437], "temperature": 0.0, "avg_logprob": -0.12582854948182037, "compression_ratio": 1.6764705882352942, "no_speech_prob": 0.0001243340811925009}, {"id": 15, "seek": 12020, "start": 120.2, "end": 128.84, "text": " you expected from that. And of course in case it's not then you would want to have a way to", "tokens": [291, 5176, 490, 300, 13, 400, 295, 1164, 294, 1389, 309, 311, 406, 550, 291, 576, 528, 281, 362, 257, 636, 281], "temperature": 0.0, "avg_logprob": -0.14237749754492915, "compression_ratio": 1.6176470588235294, "no_speech_prob": 4.735306720249355e-05}, {"id": 16, "seek": 12020, "start": 128.84, "end": 137.08, "text": " react on that. So if you can do that continuously get the information checked then you have like", "tokens": [4515, 322, 300, 13, 407, 498, 291, 393, 360, 300, 15684, 483, 264, 1589, 10033, 550, 291, 362, 411], "temperature": 0.0, "avg_logprob": -0.14237749754492915, "compression_ratio": 1.6176470588235294, "no_speech_prob": 4.735306720249355e-05}, {"id": 17, "seek": 12020, "start": 137.08, "end": 145.92000000000002, "text": " monitoring of the integrity of the system. So that's what one of the things the remote", "tokens": [11028, 295, 264, 16000, 295, 264, 1185, 13, 407, 300, 311, 437, 472, 295, 264, 721, 264, 8607], "temperature": 0.0, "avg_logprob": -0.14237749754492915, "compression_ratio": 1.6176470588235294, "no_speech_prob": 4.735306720249355e-05}, {"id": 18, "seek": 14592, "start": 145.92, "end": 154.67999999999998, "text": " attestation can provide is to check remote integrity, remote machine integrity, how it works. So you", "tokens": [951, 377, 399, 393, 2893, 307, 281, 1520, 8607, 16000, 11, 8607, 3479, 16000, 11, 577, 309, 1985, 13, 407, 291], "temperature": 0.0, "avg_logprob": -0.17082455044700987, "compression_ratio": 1.7117647058823529, "no_speech_prob": 6.263714749366045e-05}, {"id": 19, "seek": 14592, "start": 154.67999999999998, "end": 162.04, "text": " have a trusted entity running in some controlled environment and then you have a trusted agent", "tokens": [362, 257, 16034, 13977, 2614, 294, 512, 10164, 2823, 293, 550, 291, 362, 257, 16034, 9461], "temperature": 0.0, "avg_logprob": -0.17082455044700987, "compression_ratio": 1.7117647058823529, "no_speech_prob": 6.263714749366045e-05}, {"id": 20, "seek": 14592, "start": 162.04, "end": 169.56, "text": " on the other side running on the monitored system and you ask for the information to that agent", "tokens": [322, 264, 661, 1252, 2614, 322, 264, 36255, 1185, 293, 291, 1029, 337, 264, 1589, 281, 300, 9461], "temperature": 0.0, "avg_logprob": -0.17082455044700987, "compression_ratio": 1.7117647058823529, "no_speech_prob": 6.263714749366045e-05}, {"id": 21, "seek": 16956, "start": 169.56, "end": 178.56, "text": " and gets back some information called a quote then you can verify that that agent is running in a", "tokens": [293, 2170, 646, 512, 1589, 1219, 257, 6513, 550, 291, 393, 16888, 300, 300, 9461, 307, 2614, 294, 257], "temperature": 0.0, "avg_logprob": -0.11592490332467216, "compression_ratio": 1.7865853658536586, "no_speech_prob": 3.5124889109283686e-05}, {"id": 22, "seek": 16956, "start": 178.56, "end": 188.72, "text": " machine in a state that you trust. So that comes with the problem of trust. So how can you trust", "tokens": [3479, 294, 257, 1785, 300, 291, 3361, 13, 407, 300, 1487, 365, 264, 1154, 295, 3361, 13, 407, 577, 393, 291, 3361], "temperature": 0.0, "avg_logprob": -0.11592490332467216, "compression_ratio": 1.7865853658536586, "no_speech_prob": 3.5124889109283686e-05}, {"id": 23, "seek": 16956, "start": 188.72, "end": 196.32, "text": " the machine or the agent running in some machine that you don't control. So you don't really trust", "tokens": [264, 3479, 420, 264, 9461, 2614, 294, 512, 3479, 300, 291, 500, 380, 1969, 13, 407, 291, 500, 380, 534, 3361], "temperature": 0.0, "avg_logprob": -0.11592490332467216, "compression_ratio": 1.7865853658536586, "no_speech_prob": 3.5124889109283686e-05}, {"id": 24, "seek": 19632, "start": 196.32, "end": 204.44, "text": " directly the agent but you trust on a hardware root of trust which is the trusted platform model", "tokens": [3838, 264, 9461, 457, 291, 3361, 322, 257, 8837, 5593, 295, 3361, 597, 307, 264, 16034, 3663, 2316], "temperature": 0.0, "avg_logprob": -0.18729289128230167, "compression_ratio": 1.5265957446808511, "no_speech_prob": 2.3808552214177325e-05}, {"id": 25, "seek": 19632, "start": 204.44, "end": 213.84, "text": " or TPM. What are the TPMs? They are pieces of hardware that can perform crypto operations such", "tokens": [420, 314, 18819, 13, 708, 366, 264, 314, 18819, 82, 30, 814, 366, 3755, 295, 8837, 300, 393, 2042, 17240, 7705, 1270], "temperature": 0.0, "avg_logprob": -0.18729289128230167, "compression_ratio": 1.5265957446808511, "no_speech_prob": 2.3808552214177325e-05}, {"id": 26, "seek": 19632, "start": 213.84, "end": 222.95999999999998, "text": " as generating keys, signing data and it has this special key and certificate called endorsement", "tokens": [382, 17746, 9317, 11, 13393, 1412, 293, 309, 575, 341, 2121, 2141, 293, 15953, 1219, 29228, 518], "temperature": 0.0, "avg_logprob": -0.18729289128230167, "compression_ratio": 1.5265957446808511, "no_speech_prob": 2.3808552214177325e-05}, {"id": 27, "seek": 22296, "start": 222.96, "end": 232.04000000000002, "text": " key which are generated during manufacturing. So the manufacturer generates the key and publishes", "tokens": [2141, 597, 366, 10833, 1830, 11096, 13, 407, 264, 18022, 23815, 264, 2141, 293, 11374, 279], "temperature": 0.0, "avg_logprob": -0.18739567697048187, "compression_ratio": 1.575268817204301, "no_speech_prob": 3.3897169487318024e-05}, {"id": 28, "seek": 22296, "start": 232.04000000000002, "end": 242.72, "text": " the CA certificate so that you can verify that it is legitimate. And then this EK, the endorsement", "tokens": [264, 22852, 15953, 370, 300, 291, 393, 16888, 300, 309, 307, 17956, 13, 400, 550, 341, 46078, 11, 264, 29228, 518], "temperature": 0.0, "avg_logprob": -0.18739567697048187, "compression_ratio": 1.575268817204301, "no_speech_prob": 3.3897169487318024e-05}, {"id": 29, "seek": 22296, "start": 242.72, "end": 249.36, "text": " keys can't sign data directly but you can generate the attestation keys that are associated with", "tokens": [9317, 393, 380, 1465, 1412, 3838, 457, 291, 393, 8460, 264, 951, 377, 399, 9317, 300, 366, 6615, 365], "temperature": 0.0, "avg_logprob": -0.18739567697048187, "compression_ratio": 1.575268817204301, "no_speech_prob": 3.3897169487318024e-05}, {"id": 30, "seek": 24936, "start": 249.36, "end": 257.68, "text": " that endorsement key in a way that you can verify the origin of some assigned data so that you can", "tokens": [300, 29228, 518, 2141, 294, 257, 636, 300, 291, 393, 16888, 264, 4957, 295, 512, 13279, 1412, 370, 300, 291, 393], "temperature": 0.0, "avg_logprob": -0.14514055848121643, "compression_ratio": 1.6744186046511629, "no_speech_prob": 2.9373910365393385e-05}, {"id": 31, "seek": 24936, "start": 257.68, "end": 267.40000000000003, "text": " make sure that that data was signed by that specific TPM. So and another important thing that the", "tokens": [652, 988, 300, 300, 1412, 390, 8175, 538, 300, 2685, 314, 18819, 13, 407, 293, 1071, 1021, 551, 300, 264], "temperature": 0.0, "avg_logprob": -0.14514055848121643, "compression_ratio": 1.6744186046511629, "no_speech_prob": 2.9373910365393385e-05}, {"id": 32, "seek": 24936, "start": 267.40000000000003, "end": 275.64, "text": " TPM has are the platform conversion registers which are special registers designed to store", "tokens": [314, 18819, 575, 366, 264, 3663, 14298, 38351, 597, 366, 2121, 38351, 4761, 281, 3531], "temperature": 0.0, "avg_logprob": -0.14514055848121643, "compression_ratio": 1.6744186046511629, "no_speech_prob": 2.9373910365393385e-05}, {"id": 33, "seek": 27564, "start": 275.64, "end": 285.12, "text": " measurements about the system and in a way that you can verify the integrity. So how these", "tokens": [15383, 466, 264, 1185, 293, 294, 257, 636, 300, 291, 393, 16888, 264, 16000, 13, 407, 577, 613], "temperature": 0.0, "avg_logprob": -0.11717321561730426, "compression_ratio": 1.362962962962963, "no_speech_prob": 5.774619057774544e-05}, {"id": 34, "seek": 27564, "start": 285.12, "end": 295.44, "text": " measurements are done? During boot, each step of the boot is measured by the UFI into the TPM", "tokens": [15383, 366, 1096, 30, 6842, 11450, 11, 1184, 1823, 295, 264, 11450, 307, 12690, 538, 264, 624, 38568, 666, 264, 314, 18819], "temperature": 0.0, "avg_logprob": -0.11717321561730426, "compression_ratio": 1.362962962962963, "no_speech_prob": 5.774619057774544e-05}, {"id": 35, "seek": 29544, "start": 295.44, "end": 306.48, "text": " via the PCR extend operation. So each step the boot process goes, you get a hash of the binary", "tokens": [5766, 264, 44022, 10101, 6916, 13, 407, 1184, 1823, 264, 11450, 1399, 1709, 11, 291, 483, 257, 22019, 295, 264, 17434], "temperature": 0.0, "avg_logprob": -0.1698621908823649, "compression_ratio": 1.3695652173913044, "no_speech_prob": 9.706934361020103e-05}, {"id": 36, "seek": 29544, "start": 306.48, "end": 318.12, "text": " or the software that is running and extend into a PCR. I will explain that soon. And so during", "tokens": [420, 264, 4722, 300, 307, 2614, 293, 10101, 666, 257, 44022, 13, 286, 486, 2903, 300, 2321, 13, 400, 370, 1830], "temperature": 0.0, "avg_logprob": -0.1698621908823649, "compression_ratio": 1.3695652173913044, "no_speech_prob": 9.706934361020103e-05}, {"id": 37, "seek": 31812, "start": 318.12, "end": 326.56, "text": " boot, the UFI is responsible for measuring the boot steps into the TPM and after boot, then the", "tokens": [11450, 11, 264, 624, 38568, 307, 6250, 337, 13389, 264, 11450, 4439, 666, 264, 314, 18819, 293, 934, 11450, 11, 550, 264], "temperature": 0.0, "avg_logprob": -0.19388964556265567, "compression_ratio": 1.5372340425531914, "no_speech_prob": 4.118827200727537e-05}, {"id": 38, "seek": 31812, "start": 326.56, "end": 334.6, "text": " kernel integrity measurement architecture or IMA will measure any open file that matches a policy", "tokens": [28256, 16000, 13160, 9482, 420, 286, 9998, 486, 3481, 604, 1269, 3991, 300, 10676, 257, 3897], "temperature": 0.0, "avg_logprob": -0.19388964556265567, "compression_ratio": 1.5372340425531914, "no_speech_prob": 4.118827200727537e-05}, {"id": 39, "seek": 31812, "start": 334.6, "end": 345.24, "text": " you can configure the IMA and it will measure the files open into a PCR as well. So if you have", "tokens": [291, 393, 22162, 264, 286, 9998, 293, 309, 486, 3481, 264, 7098, 1269, 666, 257, 44022, 382, 731, 13, 407, 498, 291, 362], "temperature": 0.0, "avg_logprob": -0.19388964556265567, "compression_ratio": 1.5372340425531914, "no_speech_prob": 4.118827200727537e-05}, {"id": 40, "seek": 34524, "start": 345.24, "end": 354.24, "text": " the information like the state of the PCR and the event log or all the operations, extend", "tokens": [264, 1589, 411, 264, 1785, 295, 264, 44022, 293, 264, 2280, 3565, 420, 439, 264, 7705, 11, 10101], "temperature": 0.0, "avg_logprob": -0.15209415555000305, "compression_ratio": 1.5423728813559323, "no_speech_prob": 6.733510963385925e-05}, {"id": 41, "seek": 34524, "start": 354.24, "end": 360.96000000000004, "text": " operations that were performed, then you can verify the integrity of the machine. So how this", "tokens": [7705, 300, 645, 10332, 11, 550, 291, 393, 16888, 264, 16000, 295, 264, 3479, 13, 407, 577, 341], "temperature": 0.0, "avg_logprob": -0.15209415555000305, "compression_ratio": 1.5423728813559323, "no_speech_prob": 6.733510963385925e-05}, {"id": 42, "seek": 34524, "start": 360.96000000000004, "end": 368.76, "text": " PCR extend algorithm works is kind of simple. You'll get the old value stored in the PCR,", "tokens": [44022, 10101, 9284, 1985, 307, 733, 295, 2199, 13, 509, 603, 483, 264, 1331, 2158, 12187, 294, 264, 44022, 11], "temperature": 0.0, "avg_logprob": -0.15209415555000305, "compression_ratio": 1.5423728813559323, "no_speech_prob": 6.733510963385925e-05}, {"id": 43, "seek": 36876, "start": 368.76, "end": 378.8, "text": " concatenated with the measurement from the data. So this measurement is basically a hash. So you", "tokens": [1588, 7186, 770, 365, 264, 13160, 490, 264, 1412, 13, 407, 341, 13160, 307, 1936, 257, 22019, 13, 407, 291], "temperature": 0.0, "avg_logprob": -0.10267268056454866, "compression_ratio": 1.6754385964912282, "no_speech_prob": 4.632749187294394e-05}, {"id": 44, "seek": 36876, "start": 378.8, "end": 385.64, "text": " concatenate the old value with the hash of the measurement, calculate the hash of all of these", "tokens": [1588, 7186, 473, 264, 1331, 2158, 365, 264, 22019, 295, 264, 13160, 11, 8873, 264, 22019, 295, 439, 295, 613], "temperature": 0.0, "avg_logprob": -0.10267268056454866, "compression_ratio": 1.6754385964912282, "no_speech_prob": 4.632749187294394e-05}, {"id": 45, "seek": 38564, "start": 385.64, "end": 399.76, "text": " and put back into the PCR. So that's done for each step. So of course these PCRs, if you know a bit", "tokens": [293, 829, 646, 666, 264, 44022, 13, 407, 300, 311, 1096, 337, 1184, 1823, 13, 407, 295, 1164, 613, 44022, 82, 11, 498, 291, 458, 257, 857], "temperature": 0.0, "avg_logprob": -0.1404455586483604, "compression_ratio": 1.3611111111111112, "no_speech_prob": 9.481744200456887e-05}, {"id": 46, "seek": 38564, "start": 399.76, "end": 407.56, "text": " of TPM, they don't match the actual numbers, but this is just for illustration. So all of these,", "tokens": [295, 314, 18819, 11, 436, 500, 380, 2995, 264, 3539, 3547, 11, 457, 341, 307, 445, 337, 22645, 13, 407, 439, 295, 613, 11], "temperature": 0.0, "avg_logprob": -0.1404455586483604, "compression_ratio": 1.3611111111111112, "no_speech_prob": 9.481744200456887e-05}, {"id": 47, "seek": 40756, "start": 407.56, "end": 417.08, "text": " after measuring all these steps, you have the final value in the PCR that you can calculate", "tokens": [934, 13389, 439, 613, 4439, 11, 291, 362, 264, 2572, 2158, 294, 264, 44022, 300, 291, 393, 8873], "temperature": 0.0, "avg_logprob": -0.1660006607280058, "compression_ratio": 1.6457142857142857, "no_speech_prob": 3.874661706504412e-05}, {"id": 48, "seek": 40756, "start": 417.08, "end": 425.28, "text": " like a called golden value, which you calculate like the hash of all the PCR values and you have a", "tokens": [411, 257, 1219, 9729, 2158, 11, 597, 291, 8873, 411, 264, 22019, 295, 439, 264, 44022, 4190, 293, 291, 362, 257], "temperature": 0.0, "avg_logprob": -0.1660006607280058, "compression_ratio": 1.6457142857142857, "no_speech_prob": 3.874661706504412e-05}, {"id": 49, "seek": 40756, "start": 425.28, "end": 436.84000000000003, "text": " representation of the state of the machine and that can be verified. So how key lime works. So in", "tokens": [10290, 295, 264, 1785, 295, 264, 3479, 293, 300, 393, 312, 31197, 13, 407, 577, 2141, 22035, 1985, 13, 407, 294], "temperature": 0.0, "avg_logprob": -0.1660006607280058, "compression_ratio": 1.6457142857142857, "no_speech_prob": 3.874661706504412e-05}, {"id": 50, "seek": 43684, "start": 436.84, "end": 444.59999999999997, "text": " the left side, you have trusted entity where you like probably a machine that you control where you", "tokens": [264, 1411, 1252, 11, 291, 362, 16034, 13977, 689, 291, 411, 1391, 257, 3479, 300, 291, 1969, 689, 291], "temperature": 0.0, "avg_logprob": -0.1365147551445112, "compression_ratio": 1.6166666666666667, "no_speech_prob": 4.578224616125226e-05}, {"id": 51, "seek": 43684, "start": 444.59999999999997, "end": 453.55999999999995, "text": " run the verifier side of the key lime. It's a server and on the right side, you have the monitored", "tokens": [1190, 264, 1306, 9902, 1252, 295, 264, 2141, 22035, 13, 467, 311, 257, 7154, 293, 322, 264, 558, 1252, 11, 291, 362, 264, 36255], "temperature": 0.0, "avg_logprob": -0.1365147551445112, "compression_ratio": 1.6166666666666667, "no_speech_prob": 4.578224616125226e-05}, {"id": 52, "seek": 43684, "start": 453.55999999999995, "end": 459.55999999999995, "text": " system. It is remote. You don't have complete control of it, but the agent has access to the", "tokens": [1185, 13, 467, 307, 8607, 13, 509, 500, 380, 362, 3566, 1969, 295, 309, 11, 457, 264, 9461, 575, 2105, 281, 264], "temperature": 0.0, "avg_logprob": -0.1365147551445112, "compression_ratio": 1.6166666666666667, "no_speech_prob": 4.578224616125226e-05}, {"id": 53, "seek": 45956, "start": 459.56, "end": 470.24, "text": " TPM installed in that machine and so the server can verify, the verifier can request a state to the", "tokens": [314, 18819, 8899, 294, 300, 3479, 293, 370, 264, 7154, 393, 16888, 11, 264, 1306, 9902, 393, 5308, 257, 1785, 281, 264], "temperature": 0.0, "avg_logprob": -0.13744301726852637, "compression_ratio": 1.5561497326203209, "no_speech_prob": 3.4714557841653004e-05}, {"id": 54, "seek": 45956, "start": 470.24, "end": 478.28, "text": " agent. Then the agent will access the TPM to get the quote, meaning the PCR values and also", "tokens": [9461, 13, 1396, 264, 9461, 486, 2105, 264, 314, 18819, 281, 483, 264, 6513, 11, 3620, 264, 44022, 4190, 293, 611], "temperature": 0.0, "avg_logprob": -0.13744301726852637, "compression_ratio": 1.5561497326203209, "no_speech_prob": 3.4714557841653004e-05}, {"id": 55, "seek": 45956, "start": 478.28, "end": 488.2, "text": " together with the event logs or all the PCR extend operations that were performed and throw it back", "tokens": [1214, 365, 264, 2280, 20820, 420, 439, 264, 44022, 10101, 7705, 300, 645, 10332, 293, 3507, 309, 646], "temperature": 0.0, "avg_logprob": -0.13744301726852637, "compression_ratio": 1.5561497326203209, "no_speech_prob": 3.4714557841653004e-05}, {"id": 56, "seek": 48820, "start": 488.2, "end": 501.36, "text": " to the verifier. And then the verifier can verify first the origin of that piece of data because", "tokens": [281, 264, 1306, 9902, 13, 400, 550, 264, 1306, 9902, 393, 16888, 700, 264, 4957, 295, 300, 2522, 295, 1412, 570], "temperature": 0.0, "avg_logprob": -0.14148791848796688, "compression_ratio": 1.6153846153846154, "no_speech_prob": 4.242923387209885e-05}, {"id": 57, "seek": 48820, "start": 501.36, "end": 508.0, "text": " it's signed by the AK key. So you can make sure that that data came from that machine that contains", "tokens": [309, 311, 8175, 538, 264, 24789, 2141, 13, 407, 291, 393, 652, 988, 300, 300, 1412, 1361, 490, 300, 3479, 300, 8306], "temperature": 0.0, "avg_logprob": -0.14148791848796688, "compression_ratio": 1.6153846153846154, "no_speech_prob": 4.242923387209885e-05}, {"id": 58, "seek": 48820, "start": 508.0, "end": 516.04, "text": " that TPM and you can verify the identity of the TPM using the EK certificate. And with the values", "tokens": [300, 314, 18819, 293, 291, 393, 16888, 264, 6575, 295, 264, 314, 18819, 1228, 264, 46078, 15953, 13, 400, 365, 264, 4190], "temperature": 0.0, "avg_logprob": -0.14148791848796688, "compression_ratio": 1.6153846153846154, "no_speech_prob": 4.242923387209885e-05}, {"id": 59, "seek": 51604, "start": 516.04, "end": 525.68, "text": " you obtained for the PCRs and the event log, you can replay all the extend operations so that in", "tokens": [291, 14879, 337, 264, 44022, 82, 293, 264, 2280, 3565, 11, 291, 393, 23836, 439, 264, 10101, 7705, 370, 300, 294], "temperature": 0.0, "avg_logprob": -0.15433328681521946, "compression_ratio": 1.6, "no_speech_prob": 5.078533649793826e-05}, {"id": 60, "seek": 51604, "start": 525.68, "end": 532.68, "text": " the end, you can get the values that it should have. And so with all these information, you can", "tokens": [264, 917, 11, 291, 393, 483, 264, 4190, 300, 309, 820, 362, 13, 400, 370, 365, 439, 613, 1589, 11, 291, 393], "temperature": 0.0, "avg_logprob": -0.15433328681521946, "compression_ratio": 1.6, "no_speech_prob": 5.078533649793826e-05}, {"id": 61, "seek": 51604, "start": 532.68, "end": 543.04, "text": " verify the integrity of the machine. Since you also got the information from AIMA, like all the", "tokens": [16888, 264, 16000, 295, 264, 3479, 13, 4162, 291, 611, 658, 264, 1589, 490, 316, 6324, 32, 11, 411, 439, 264], "temperature": 0.0, "avg_logprob": -0.15433328681521946, "compression_ratio": 1.6, "no_speech_prob": 5.078533649793826e-05}, {"id": 62, "seek": 54304, "start": 543.04, "end": 552.8399999999999, "text": " files that were open and matched some policy, the AIMA will calculate the hash of open files", "tokens": [7098, 300, 645, 1269, 293, 21447, 512, 3897, 11, 264, 316, 6324, 32, 486, 8873, 264, 22019, 295, 1269, 7098], "temperature": 0.0, "avg_logprob": -0.1465326367002545, "compression_ratio": 1.6045197740112995, "no_speech_prob": 0.0002794951433315873}, {"id": 63, "seek": 54304, "start": 552.8399999999999, "end": 560.16, "text": " that match some policy and extend to the PCR. So you get this log containing the file names and", "tokens": [300, 2995, 512, 3897, 293, 10101, 281, 264, 44022, 13, 407, 291, 483, 341, 3565, 19273, 264, 3991, 5288, 293], "temperature": 0.0, "avg_logprob": -0.1465326367002545, "compression_ratio": 1.6045197740112995, "no_speech_prob": 0.0002794951433315873}, {"id": 64, "seek": 54304, "start": 560.16, "end": 569.92, "text": " the matching hashes. So you can also with some policy engine verify the integrity of individual", "tokens": [264, 14324, 575, 8076, 13, 407, 291, 393, 611, 365, 512, 3897, 2848, 16888, 264, 16000, 295, 2609], "temperature": 0.0, "avg_logprob": -0.1465326367002545, "compression_ratio": 1.6045197740112995, "no_speech_prob": 0.0002794951433315873}, {"id": 65, "seek": 56992, "start": 569.92, "end": 582.12, "text": " files in the remote machine. So you can like a full integrity view of the remote machine. So with", "tokens": [7098, 294, 264, 8607, 3479, 13, 407, 291, 393, 411, 257, 1577, 16000, 1910, 295, 264, 8607, 3479, 13, 407, 365], "temperature": 0.0, "avg_logprob": -0.12192826393323067, "compression_ratio": 1.5714285714285714, "no_speech_prob": 1.2081382010364905e-05}, {"id": 66, "seek": 56992, "start": 582.12, "end": 589.0799999999999, "text": " that information, the verifier can check. If it's okay, it's okay. The attestation was successful.", "tokens": [300, 1589, 11, 264, 1306, 9902, 393, 1520, 13, 759, 309, 311, 1392, 11, 309, 311, 1392, 13, 440, 951, 377, 399, 390, 4406, 13], "temperature": 0.0, "avg_logprob": -0.12192826393323067, "compression_ratio": 1.5714285714285714, "no_speech_prob": 1.2081382010364905e-05}, {"id": 67, "seek": 56992, "start": 589.0799999999999, "end": 595.9599999999999, "text": " But if it was not, it doesn't match what you expected, then it's a failure. So in case of", "tokens": [583, 498, 309, 390, 406, 11, 309, 1177, 380, 2995, 437, 291, 5176, 11, 550, 309, 311, 257, 7763, 13, 407, 294, 1389, 295], "temperature": 0.0, "avg_logprob": -0.12192826393323067, "compression_ratio": 1.5714285714285714, "no_speech_prob": 1.2081382010364905e-05}, {"id": 68, "seek": 59596, "start": 595.96, "end": 606.08, "text": " failure, we have a revocation framework, which is a way to, so you can configure some actions to", "tokens": [7763, 11, 321, 362, 257, 3698, 27943, 8388, 11, 597, 307, 257, 636, 281, 11, 370, 291, 393, 22162, 512, 5909, 281], "temperature": 0.0, "avg_logprob": -0.1430088678995768, "compression_ratio": 1.6473988439306357, "no_speech_prob": 7.216921949293464e-05}, {"id": 69, "seek": 59596, "start": 606.08, "end": 613.96, "text": " the verifier, some script that it can run to perform some action. It can be some webhooks. So", "tokens": [264, 1306, 9902, 11, 512, 5755, 300, 309, 393, 1190, 281, 2042, 512, 3069, 13, 467, 393, 312, 512, 3670, 71, 1212, 82, 13, 407], "temperature": 0.0, "avg_logprob": -0.1430088678995768, "compression_ratio": 1.6473988439306357, "no_speech_prob": 7.216921949293464e-05}, {"id": 70, "seek": 59596, "start": 613.96, "end": 620.72, "text": " if some attestation fails, it sends some request to some webhook, or you can notify the agents", "tokens": [498, 512, 951, 377, 399, 18199, 11, 309, 14790, 512, 5308, 281, 512, 3670, 71, 1212, 11, 420, 291, 393, 36560, 264, 12554], "temperature": 0.0, "avg_logprob": -0.1430088678995768, "compression_ratio": 1.6473988439306357, "no_speech_prob": 7.216921949293464e-05}, {"id": 71, "seek": 62072, "start": 620.72, "end": 628.36, "text": " directly via REST API, and send some payload to the trigger some operation there. The simplest", "tokens": [3838, 5766, 497, 14497, 9362, 11, 293, 2845, 512, 30918, 281, 264, 7875, 512, 6916, 456, 13, 440, 22811], "temperature": 0.0, "avg_logprob": -0.20785734626684296, "compression_ratio": 1.5601659751037344, "no_speech_prob": 6.441882578656077e-05}, {"id": 72, "seek": 62072, "start": 628.36, "end": 634.24, "text": " scenario, for example, if you had a cluster with various machines, and one of them failed", "tokens": [9005, 11, 337, 1365, 11, 498, 291, 632, 257, 13630, 365, 3683, 8379, 11, 293, 472, 295, 552, 7612], "temperature": 0.0, "avg_logprob": -0.20785734626684296, "compression_ratio": 1.5601659751037344, "no_speech_prob": 6.441882578656077e-05}, {"id": 73, "seek": 62072, "start": 634.24, "end": 640.96, "text": " attestation, you cannot find the others to remove that node from the cluster by blocking the", "tokens": [951, 377, 399, 11, 291, 2644, 915, 264, 2357, 281, 4159, 300, 9984, 490, 264, 13630, 538, 17776, 264], "temperature": 0.0, "avg_logprob": -0.20785734626684296, "compression_ratio": 1.5601659751037344, "no_speech_prob": 6.441882578656077e-05}, {"id": 74, "seek": 62072, "start": 640.96, "end": 648.6, "text": " network connectivity, for example. So that's how key lime works in general. So now I'm passing the", "tokens": [3209, 21095, 11, 337, 1365, 13, 407, 300, 311, 577, 2141, 22035, 1985, 294, 2674, 13, 407, 586, 286, 478, 8437, 264], "temperature": 0.0, "avg_logprob": -0.20785734626684296, "compression_ratio": 1.5601659751037344, "no_speech_prob": 6.441882578656077e-05}, {"id": 75, "seek": 64860, "start": 648.6, "end": 657.5600000000001, "text": " mic to Thor. He will continue with the real world stuff. Yeah. So now we heard how key lime works,", "tokens": [3123, 281, 17777, 13, 634, 486, 2354, 365, 264, 957, 1002, 1507, 13, 865, 13, 407, 586, 321, 2198, 577, 2141, 22035, 1985, 11], "temperature": 0.0, "avg_logprob": -0.14059471757444617, "compression_ratio": 1.591160220994475, "no_speech_prob": 0.00020557096286211163}, {"id": 76, "seek": 64860, "start": 657.5600000000001, "end": 665.32, "text": " and we want to show that you can use that in production, and what are the challenges that you", "tokens": [293, 321, 528, 281, 855, 300, 291, 393, 764, 300, 294, 4265, 11, 293, 437, 366, 264, 4759, 300, 291], "temperature": 0.0, "avg_logprob": -0.14059471757444617, "compression_ratio": 1.591160220994475, "no_speech_prob": 0.00020557096286211163}, {"id": 77, "seek": 64860, "start": 665.32, "end": 672.76, "text": " will run into if you want to try that. We have three main scenarios there. We have first policy", "tokens": [486, 1190, 666, 498, 291, 528, 281, 853, 300, 13, 492, 362, 1045, 2135, 15077, 456, 13, 492, 362, 700, 3897], "temperature": 0.0, "avg_logprob": -0.14059471757444617, "compression_ratio": 1.591160220994475, "no_speech_prob": 0.00020557096286211163}, {"id": 78, "seek": 67276, "start": 672.76, "end": 680.52, "text": " creation, then the monitoring, and then how to react on that. So the first part is, we want to", "tokens": [8016, 11, 550, 264, 11028, 11, 293, 550, 577, 281, 4515, 322, 300, 13, 407, 264, 700, 644, 307, 11, 321, 528, 281], "temperature": 0.0, "avg_logprob": -0.14868488498762542, "compression_ratio": 1.719298245614035, "no_speech_prob": 8.335422171512619e-05}, {"id": 79, "seek": 67276, "start": 680.52, "end": 687.48, "text": " create policies for our system. For that, we need to know what is actually on our system, and what", "tokens": [1884, 7657, 337, 527, 1185, 13, 1171, 300, 11, 321, 643, 281, 458, 437, 307, 767, 322, 527, 1185, 11, 293, 437], "temperature": 0.0, "avg_logprob": -0.14868488498762542, "compression_ratio": 1.719298245614035, "no_speech_prob": 8.335422171512619e-05}, {"id": 80, "seek": 67276, "start": 687.48, "end": 694.36, "text": " are our systems. So from a software side perspective, it's normal that we integrate, we have a CI CD", "tokens": [366, 527, 3652, 13, 407, 490, 257, 4722, 1252, 4585, 11, 309, 311, 2710, 300, 321, 13365, 11, 321, 362, 257, 37777, 6743], "temperature": 0.0, "avg_logprob": -0.14868488498762542, "compression_ratio": 1.719298245614035, "no_speech_prob": 8.335422171512619e-05}, {"id": 81, "seek": 67276, "start": 694.36, "end": 700.0, "text": " pipeline, we get what data gets into that, and we want to save the hashes there. But we need also", "tokens": [15517, 11, 321, 483, 437, 1412, 2170, 666, 300, 11, 293, 321, 528, 281, 3155, 264, 575, 8076, 456, 13, 583, 321, 643, 611], "temperature": 0.0, "avg_logprob": -0.14868488498762542, "compression_ratio": 1.719298245614035, "no_speech_prob": 8.335422171512619e-05}, {"id": 82, "seek": 70000, "start": 700.0, "end": 706.04, "text": " a lot of other stuff. We want to know what packages are installed, where they end up on our system,", "tokens": [257, 688, 295, 661, 1507, 13, 492, 528, 281, 458, 437, 17401, 366, 8899, 11, 689, 436, 917, 493, 322, 527, 1185, 11], "temperature": 0.0, "avg_logprob": -0.12139753419525769, "compression_ratio": 1.6822033898305084, "no_speech_prob": 7.349465158767998e-05}, {"id": 83, "seek": 70000, "start": 706.04, "end": 712.88, "text": " have their signatures, can we verify that? That is what we normally want to have, and either this", "tokens": [362, 641, 32322, 11, 393, 321, 16888, 300, 30, 663, 307, 437, 321, 5646, 528, 281, 362, 11, 293, 2139, 341], "temperature": 0.0, "avg_logprob": -0.12139753419525769, "compression_ratio": 1.6822033898305084, "no_speech_prob": 7.349465158767998e-05}, {"id": 84, "seek": 70000, "start": 712.88, "end": 719.16, "text": " information is already provided by the distribution, or we need to generate that on our own. Then on", "tokens": [1589, 307, 1217, 5649, 538, 264, 7316, 11, 420, 321, 643, 281, 8460, 300, 322, 527, 1065, 13, 1396, 322], "temperature": 0.0, "avg_logprob": -0.12139753419525769, "compression_ratio": 1.6822033898305084, "no_speech_prob": 7.349465158767998e-05}, {"id": 85, "seek": 70000, "start": 719.16, "end": 724.28, "text": " the hardware side, we need to know what kind of hardware we're running. So as we said, we have the", "tokens": [264, 8837, 1252, 11, 321, 643, 281, 458, 437, 733, 295, 8837, 321, 434, 2614, 13, 407, 382, 321, 848, 11, 321, 362, 264], "temperature": 0.0, "avg_logprob": -0.12139753419525769, "compression_ratio": 1.6822033898305084, "no_speech_prob": 7.349465158767998e-05}, {"id": 86, "seek": 72428, "start": 724.28, "end": 731.0799999999999, "text": " EK, so the endorsement key, we need to at least know that to trust the TPM in some regard. And then", "tokens": [46078, 11, 370, 264, 29228, 518, 2141, 11, 321, 643, 281, 412, 1935, 458, 300, 281, 3361, 264, 314, 18819, 294, 512, 3843, 13, 400, 550], "temperature": 0.0, "avg_logprob": -0.15764877171192354, "compression_ratio": 1.5867768595041323, "no_speech_prob": 1.4049081983102951e-05}, {"id": 87, "seek": 72428, "start": 731.0799999999999, "end": 735.9599999999999, "text": " ideally, we want to also know what firmware is running on that device, and which configuration do", "tokens": [22915, 11, 321, 528, 281, 611, 458, 437, 30289, 307, 2614, 322, 300, 4302, 11, 293, 597, 11694, 360], "temperature": 0.0, "avg_logprob": -0.15764877171192354, "compression_ratio": 1.5867768595041323, "no_speech_prob": 1.4049081983102951e-05}, {"id": 88, "seek": 72428, "start": 735.9599999999999, "end": 742.24, "text": " we have. For example, do we allow CQB to be disabled and enabled? Do we have our own keys on", "tokens": [321, 362, 13, 1171, 1365, 11, 360, 321, 2089, 383, 48, 33, 281, 312, 15191, 293, 15172, 30, 1144, 321, 362, 527, 1065, 9317, 322], "temperature": 0.0, "avg_logprob": -0.15764877171192354, "compression_ratio": 1.5867768595041323, "no_speech_prob": 1.4049081983102951e-05}, {"id": 89, "seek": 72428, "start": 742.24, "end": 749.4399999999999, "text": " there? And stuff like that. So if you have all that information, we can go to the other side,", "tokens": [456, 30, 400, 1507, 411, 300, 13, 407, 498, 291, 362, 439, 300, 1589, 11, 321, 393, 352, 281, 264, 661, 1252, 11], "temperature": 0.0, "avg_logprob": -0.15764877171192354, "compression_ratio": 1.5867768595041323, "no_speech_prob": 1.4049081983102951e-05}, {"id": 90, "seek": 74944, "start": 749.44, "end": 756.6800000000001, "text": " which is the monitoring. That part is implemented by KeyLine. You can, if you have all the necessary", "tokens": [597, 307, 264, 11028, 13, 663, 644, 307, 12270, 538, 12759, 43, 533, 13, 509, 393, 11, 498, 291, 362, 439, 264, 4818], "temperature": 0.0, "avg_logprob": -0.18544360307546762, "compression_ratio": 1.6296296296296295, "no_speech_prob": 8.071475167525932e-05}, {"id": 91, "seek": 74944, "start": 756.6800000000001, "end": 761.6400000000001, "text": " information, we provide documentation and tools to generate a policy for that, and you can feed it", "tokens": [1589, 11, 321, 2893, 14333, 293, 3873, 281, 8460, 257, 3897, 337, 300, 11, 293, 291, 393, 3154, 309], "temperature": 0.0, "avg_logprob": -0.18544360307546762, "compression_ratio": 1.6296296296296295, "no_speech_prob": 8.071475167525932e-05}, {"id": 92, "seek": 74944, "start": 761.6400000000001, "end": 769.32, "text": " in that, and it's all there. The challenge that you run into here is that for many of you, probably", "tokens": [294, 300, 11, 293, 309, 311, 439, 456, 13, 440, 3430, 300, 291, 1190, 666, 510, 307, 300, 337, 867, 295, 291, 11, 1391], "temperature": 0.0, "avg_logprob": -0.18544360307546762, "compression_ratio": 1.6296296296296295, "no_speech_prob": 8.071475167525932e-05}, {"id": 93, "seek": 74944, "start": 769.32, "end": 778.0400000000001, "text": " IMA, measured boot, and TPMs are new. And if you run into issues, then you also try, need to try", "tokens": [286, 9998, 11, 12690, 11450, 11, 293, 314, 18819, 82, 366, 777, 13, 400, 498, 291, 1190, 666, 2663, 11, 550, 291, 611, 853, 11, 643, 281, 853], "temperature": 0.0, "avg_logprob": -0.18544360307546762, "compression_ratio": 1.6296296296296295, "no_speech_prob": 8.071475167525932e-05}, {"id": 94, "seek": 77804, "start": 778.04, "end": 784.56, "text": " understand how that works to debug it. So that is a challenge you run into, that you still need a", "tokens": [1223, 577, 300, 1985, 281, 24083, 309, 13, 407, 300, 307, 257, 3430, 291, 1190, 666, 11, 300, 291, 920, 643, 257], "temperature": 0.0, "avg_logprob": -0.1334184764586773, "compression_ratio": 1.6099585062240664, "no_speech_prob": 4.051559517392889e-05}, {"id": 95, "seek": 77804, "start": 784.56, "end": 791.92, "text": " good understanding of those technologies to make your life easier. But yeah, that is mostly solved", "tokens": [665, 3701, 295, 729, 7943, 281, 652, 428, 993, 3571, 13, 583, 1338, 11, 300, 307, 5240, 13041], "temperature": 0.0, "avg_logprob": -0.1334184764586773, "compression_ratio": 1.6099585062240664, "no_speech_prob": 4.051559517392889e-05}, {"id": 96, "seek": 77804, "start": 791.92, "end": 798.88, "text": " by KeyLine. And then we come to the non-technical side, which is we need to react somehow when we", "tokens": [538, 12759, 43, 533, 13, 400, 550, 321, 808, 281, 264, 2107, 12, 29113, 804, 1252, 11, 597, 307, 321, 643, 281, 4515, 6063, 562, 321], "temperature": 0.0, "avg_logprob": -0.1334184764586773, "compression_ratio": 1.6099585062240664, "no_speech_prob": 4.051559517392889e-05}, {"id": 97, "seek": 77804, "start": 798.88, "end": 805.8, "text": " have a revocation failure. So is that a lot actually relevant for us? Because if we have like", "tokens": [362, 257, 3698, 27943, 7763, 13, 407, 307, 300, 257, 688, 767, 7340, 337, 505, 30, 1436, 498, 321, 362, 411], "temperature": 0.0, "avg_logprob": -0.1334184764586773, "compression_ratio": 1.6099585062240664, "no_speech_prob": 4.051559517392889e-05}, {"id": 98, "seek": 80580, "start": 805.8, "end": 812.04, "text": " file changes in TAMP, we don't really care. But then who needs to be notified if you have that?", "tokens": [3991, 2962, 294, 314, 2865, 47, 11, 321, 500, 380, 534, 1127, 13, 583, 550, 567, 2203, 281, 312, 18013, 498, 291, 362, 300, 30], "temperature": 0.0, "avg_logprob": -0.2140875446553133, "compression_ratio": 1.5019455252918288, "no_speech_prob": 8.717383025214076e-05}, {"id": 99, "seek": 80580, "start": 812.04, "end": 817.1999999999999, "text": " Then how do we tie that in our current monitoring infrastructure? For example, like with the web", "tokens": [1396, 577, 360, 321, 7582, 300, 294, 527, 2190, 11028, 6896, 30, 1171, 1365, 11, 411, 365, 264, 3670], "temperature": 0.0, "avg_logprob": -0.2140875446553133, "compression_ratio": 1.5019455252918288, "no_speech_prob": 8.717383025214076e-05}, {"id": 100, "seek": 80580, "start": 817.1999999999999, "end": 823.3199999999999, "text": " hooks. And lastly, if you are a company and you're, it's a potential security breach if KeyLine", "tokens": [26485, 13, 400, 16386, 11, 498, 291, 366, 257, 2237, 293, 291, 434, 11, 309, 311, 257, 3995, 3825, 31086, 498, 12759, 43, 533], "temperature": 0.0, "avg_logprob": -0.2140875446553133, "compression_ratio": 1.5019455252918288, "no_speech_prob": 8.717383025214076e-05}, {"id": 101, "seek": 80580, "start": 823.3199999999999, "end": 828.52, "text": " fails in the way that you configured it. So there are service agreements in place, which need you", "tokens": [18199, 294, 264, 636, 300, 291, 30538, 309, 13, 407, 456, 366, 2643, 21422, 294, 1081, 11, 597, 643, 291], "temperature": 0.0, "avg_logprob": -0.2140875446553133, "compression_ratio": 1.5019455252918288, "no_speech_prob": 8.717383025214076e-05}, {"id": 102, "seek": 82852, "start": 828.52, "end": 837.04, "text": " notify and how do you respond for that. So, but going now from the general part to actual examples,", "tokens": [36560, 293, 577, 360, 291, 4196, 337, 300, 13, 407, 11, 457, 516, 586, 490, 264, 2674, 644, 281, 3539, 5110, 11], "temperature": 0.0, "avg_logprob": -0.23738796527569112, "compression_ratio": 1.4517766497461928, "no_speech_prob": 4.059227285324596e-05}, {"id": 103, "seek": 82852, "start": 837.04, "end": 846.4399999999999, "text": " I work on the Linux distribution that does exams for schools and universities called Lensdijk.", "tokens": [286, 589, 322, 264, 18734, 7316, 300, 775, 20514, 337, 4656, 293, 11779, 1219, 441, 694, 67, 6940, 13], "temperature": 0.0, "avg_logprob": -0.23738796527569112, "compression_ratio": 1.4517766497461928, "no_speech_prob": 4.059227285324596e-05}, {"id": 104, "seek": 82852, "start": 846.4399999999999, "end": 853.0, "text": " And we developed with the University of Applied Sciences and Arts Northwestern Switzerland,", "tokens": [400, 321, 4743, 365, 264, 3535, 295, 3132, 39459, 21108, 293, 12407, 26068, 1248, 23312, 11], "temperature": 0.0, "avg_logprob": -0.23738796527569112, "compression_ratio": 1.4517766497461928, "no_speech_prob": 4.059227285324596e-05}, {"id": 105, "seek": 85300, "start": 853.0, "end": 862.44, "text": " also called FANV, a system called Kampler, which is secure, bring your own device exams. So what", "tokens": [611, 1219, 479, 1770, 53, 11, 257, 1185, 1219, 591, 1215, 1918, 11, 597, 307, 7144, 11, 1565, 428, 1065, 4302, 20514, 13, 407, 437], "temperature": 0.0, "avg_logprob": -0.19426556851001495, "compression_ratio": 1.7649769585253456, "no_speech_prob": 7.794547127559781e-05}, {"id": 106, "seek": 85300, "start": 862.44, "end": 867.76, "text": " is the problem here? The students want to bring their own device, their own notebook into the", "tokens": [307, 264, 1154, 510, 30, 440, 1731, 528, 281, 1565, 641, 1065, 4302, 11, 641, 1065, 21060, 666, 264], "temperature": 0.0, "avg_logprob": -0.19426556851001495, "compression_ratio": 1.7649769585253456, "no_speech_prob": 7.794547127559781e-05}, {"id": 107, "seek": 85300, "start": 867.76, "end": 873.24, "text": " lecture hall and want to write their exams on that. We don't want to touch their operating system.", "tokens": [7991, 6500, 293, 528, 281, 2464, 641, 20514, 322, 300, 13, 492, 500, 380, 528, 281, 2557, 641, 7447, 1185, 13], "temperature": 0.0, "avg_logprob": -0.19426556851001495, "compression_ratio": 1.7649769585253456, "no_speech_prob": 7.794547127559781e-05}, {"id": 108, "seek": 85300, "start": 873.24, "end": 877.84, "text": " So we do something what we call bring your own hardware. They bring their own hardware and we", "tokens": [407, 321, 360, 746, 437, 321, 818, 1565, 428, 1065, 8837, 13, 814, 1565, 641, 1065, 8837, 293, 321], "temperature": 0.0, "avg_logprob": -0.19426556851001495, "compression_ratio": 1.7649769585253456, "no_speech_prob": 7.794547127559781e-05}, {"id": 109, "seek": 87784, "start": 877.84, "end": 885.52, "text": " boot a live Linux system on that system and remotely attest if that system is running correctly. So", "tokens": [11450, 257, 1621, 18734, 1185, 322, 300, 1185, 293, 20824, 951, 377, 498, 300, 1185, 307, 2614, 8944, 13, 407], "temperature": 0.0, "avg_logprob": -0.13774393137218882, "compression_ratio": 1.6458333333333333, "no_speech_prob": 4.243332296027802e-05}, {"id": 110, "seek": 87784, "start": 885.52, "end": 892.12, "text": " what do we have? We have our hardware, which has a hard drive and a TPM. Now we boot the distribution", "tokens": [437, 360, 321, 362, 30, 492, 362, 527, 8837, 11, 597, 575, 257, 1152, 3332, 293, 257, 314, 18819, 13, 823, 321, 11450, 264, 7316], "temperature": 0.0, "avg_logprob": -0.13774393137218882, "compression_ratio": 1.6458333333333333, "no_speech_prob": 4.243332296027802e-05}, {"id": 111, "seek": 87784, "start": 892.12, "end": 897.88, "text": " called Lensdijk. And on that we have the KeyLine agent running and also Imr and our measured boot", "tokens": [1219, 441, 694, 67, 6940, 13, 400, 322, 300, 321, 362, 264, 12759, 43, 533, 9461, 2614, 293, 611, 4331, 81, 293, 527, 12690, 11450], "temperature": 0.0, "avg_logprob": -0.13774393137218882, "compression_ratio": 1.6458333333333333, "no_speech_prob": 4.243332296027802e-05}, {"id": 112, "seek": 87784, "start": 897.88, "end": 904.4000000000001, "text": " stuff. And now the interesting part is we just care about the TPM. We don't care about the hard", "tokens": [1507, 13, 400, 586, 264, 1880, 644, 307, 321, 445, 1127, 466, 264, 314, 18819, 13, 492, 500, 380, 1127, 466, 264, 1152], "temperature": 0.0, "avg_logprob": -0.13774393137218882, "compression_ratio": 1.6458333333333333, "no_speech_prob": 4.243332296027802e-05}, {"id": 113, "seek": 90440, "start": 904.4, "end": 913.9599999999999, "text": " drive and what is on that system otherwise. So now we have the actual server solution. So we", "tokens": [3332, 293, 437, 307, 322, 300, 1185, 5911, 13, 407, 586, 321, 362, 264, 3539, 7154, 3827, 13, 407, 321], "temperature": 0.0, "avg_logprob": -0.09387970642304756, "compression_ratio": 1.6067415730337078, "no_speech_prob": 6.378115358529612e-05}, {"id": 114, "seek": 90440, "start": 913.9599999999999, "end": 922.04, "text": " register to the exam system. And this also includes that we register to KeyLine. Then we check in", "tokens": [7280, 281, 264, 1139, 1185, 13, 400, 341, 611, 5974, 300, 321, 7280, 281, 12759, 43, 533, 13, 1396, 321, 1520, 294], "temperature": 0.0, "avg_logprob": -0.09387970642304756, "compression_ratio": 1.6067415730337078, "no_speech_prob": 6.378115358529612e-05}, {"id": 115, "seek": 90440, "start": 922.04, "end": 927.92, "text": " return if the system is actually in a trustworthy state. And if that's the case, we release the", "tokens": [2736, 498, 264, 1185, 307, 767, 294, 257, 39714, 1785, 13, 400, 498, 300, 311, 264, 1389, 11, 321, 4374, 264], "temperature": 0.0, "avg_logprob": -0.09387970642304756, "compression_ratio": 1.6067415730337078, "no_speech_prob": 6.378115358529612e-05}, {"id": 116, "seek": 92792, "start": 927.92, "end": 935.8, "text": " exam files, which is in our case normally RDP session, which then connects to the cloud where", "tokens": [1139, 7098, 11, 597, 307, 294, 527, 1389, 5646, 497, 11373, 5481, 11, 597, 550, 16967, 281, 264, 4588, 689], "temperature": 0.0, "avg_logprob": -0.11899242401123047, "compression_ratio": 1.5240641711229947, "no_speech_prob": 1.5918511053314433e-05}, {"id": 117, "seek": 92792, "start": 935.8, "end": 945.56, "text": " the people are actually writing their exams. So why are we doing that this way? The first one is", "tokens": [264, 561, 366, 767, 3579, 641, 20514, 13, 407, 983, 366, 321, 884, 300, 341, 636, 30, 440, 700, 472, 307], "temperature": 0.0, "avg_logprob": -0.11899242401123047, "compression_ratio": 1.5240641711229947, "no_speech_prob": 1.5918511053314433e-05}, {"id": 118, "seek": 92792, "start": 945.56, "end": 952.48, "text": " that we guarantee that the environment for every student is the same because they only provide", "tokens": [300, 321, 10815, 300, 264, 2823, 337, 633, 3107, 307, 264, 912, 570, 436, 787, 2893], "temperature": 0.0, "avg_logprob": -0.11899242401123047, "compression_ratio": 1.5240641711229947, "no_speech_prob": 1.5918511053314433e-05}, {"id": 119, "seek": 95248, "start": 952.48, "end": 958.32, "text": " their hardware and it's basically terminal to connect to the actual exam. So if there's computing", "tokens": [641, 8837, 293, 309, 311, 1936, 14709, 281, 1745, 281, 264, 3539, 1139, 13, 407, 498, 456, 311, 15866], "temperature": 0.0, "avg_logprob": -0.12140944798787436, "compression_ratio": 1.6768558951965065, "no_speech_prob": 2.83395766018657e-05}, {"id": 120, "seek": 95248, "start": 958.32, "end": 964.48, "text": " intensive stuff, then it doesn't really matter. And also because they only bring their own hardware", "tokens": [18957, 1507, 11, 550, 309, 1177, 380, 534, 1871, 13, 400, 611, 570, 436, 787, 1565, 641, 1065, 8837], "temperature": 0.0, "avg_logprob": -0.12140944798787436, "compression_ratio": 1.6768558951965065, "no_speech_prob": 2.83395766018657e-05}, {"id": 121, "seek": 95248, "start": 964.48, "end": 971.76, "text": " and don't need to install monitoring software on their system to write the exam, we don't care", "tokens": [293, 500, 380, 643, 281, 3625, 11028, 4722, 322, 641, 1185, 281, 2464, 264, 1139, 11, 321, 500, 380, 1127], "temperature": 0.0, "avg_logprob": -0.12140944798787436, "compression_ratio": 1.6768558951965065, "no_speech_prob": 2.83395766018657e-05}, {"id": 122, "seek": 95248, "start": 971.76, "end": 977.5600000000001, "text": " what they does on that. We don't want to know it's first for privacy and also to make setup", "tokens": [437, 436, 775, 322, 300, 13, 492, 500, 380, 528, 281, 458, 309, 311, 700, 337, 11427, 293, 611, 281, 652, 8657], "temperature": 0.0, "avg_logprob": -0.12140944798787436, "compression_ratio": 1.6768558951965065, "no_speech_prob": 2.83395766018657e-05}, {"id": 123, "seek": 97756, "start": 977.56, "end": 986.28, "text": " way easier. Now back to a more traditional scenario that more of you are probably familiar with the", "tokens": [636, 3571, 13, 823, 646, 281, 257, 544, 5164, 9005, 300, 544, 295, 291, 366, 1391, 4963, 365, 264], "temperature": 0.0, "avg_logprob": -0.21328667626864667, "compression_ratio": 1.545945945945946, "no_speech_prob": 2.790207145153545e-05}, {"id": 124, "seek": 97756, "start": 986.28, "end": 992.68, "text": " cloud. And there we have the example that IBM uses this for hypervisor attestation. And they", "tokens": [4588, 13, 400, 456, 321, 362, 264, 1365, 300, 23487, 4960, 341, 337, 9848, 16457, 951, 377, 399, 13, 400, 436], "temperature": 0.0, "avg_logprob": -0.21328667626864667, "compression_ratio": 1.545945945945946, "no_speech_prob": 2.790207145153545e-05}, {"id": 125, "seek": 97756, "start": 992.68, "end": 1000.7199999999999, "text": " don't use runtime attestations or not anymore. They use measure boot to see if the hypervisor", "tokens": [500, 380, 764, 34474, 951, 377, 763, 420, 406, 3602, 13, 814, 764, 3481, 11450, 281, 536, 498, 264, 9848, 16457], "temperature": 0.0, "avg_logprob": -0.21328667626864667, "compression_ratio": 1.545945945945946, "no_speech_prob": 2.790207145153545e-05}, {"id": 126, "seek": 100072, "start": 1000.72, "end": 1009.72, "text": " booted up correctly. So their challenges were that implementing the actual response procedures,", "tokens": [11450, 292, 493, 8944, 13, 407, 641, 4759, 645, 300, 18114, 264, 3539, 4134, 13846, 11], "temperature": 0.0, "avg_logprob": -0.14470467638613574, "compression_ratio": 1.5824175824175823, "no_speech_prob": 5.982949733152054e-05}, {"id": 127, "seek": 100072, "start": 1009.72, "end": 1019.44, "text": " so the procedure from we have an alert to how do we deal with that now. That is the difficult part", "tokens": [370, 264, 10747, 490, 321, 362, 364, 9615, 281, 577, 360, 321, 2028, 365, 300, 586, 13, 663, 307, 264, 2252, 644], "temperature": 0.0, "avg_logprob": -0.14470467638613574, "compression_ratio": 1.5824175824175823, "no_speech_prob": 5.982949733152054e-05}, {"id": 128, "seek": 100072, "start": 1019.44, "end": 1024.6000000000001, "text": " because the one is the technical side, but how do we structure our teams in a way that we can", "tokens": [570, 264, 472, 307, 264, 6191, 1252, 11, 457, 577, 360, 321, 3877, 527, 5491, 294, 257, 636, 300, 321, 393], "temperature": 0.0, "avg_logprob": -0.14470467638613574, "compression_ratio": 1.5824175824175823, "no_speech_prob": 5.982949733152054e-05}, {"id": 129, "seek": 102460, "start": 1024.6, "end": 1032.04, "text": " guarantee that. Then also the other ones are eliminating false positives that ties into the", "tokens": [10815, 300, 13, 1396, 611, 264, 661, 2306, 366, 31203, 7908, 35127, 300, 14039, 666, 264], "temperature": 0.0, "avg_logprob": -0.15931859883395108, "compression_ratio": 1.71875, "no_speech_prob": 5.290851549943909e-05}, {"id": 130, "seek": 102460, "start": 1032.04, "end": 1038.3999999999999, "text": " first point because if a human needs to react, then we want to have no false positives and also", "tokens": [700, 935, 570, 498, 257, 1952, 2203, 281, 4515, 11, 550, 321, 528, 281, 362, 572, 7908, 35127, 293, 611], "temperature": 0.0, "avg_logprob": -0.15931859883395108, "compression_ratio": 1.71875, "no_speech_prob": 5.290851549943909e-05}, {"id": 131, "seek": 102460, "start": 1038.3999999999999, "end": 1044.84, "text": " no false negatives ideally. And false negatives are for security very, very bad. So we don't want", "tokens": [572, 7908, 40019, 22915, 13, 400, 7908, 40019, 366, 337, 3825, 588, 11, 588, 1578, 13, 407, 321, 500, 380, 528], "temperature": 0.0, "avg_logprob": -0.15931859883395108, "compression_ratio": 1.71875, "no_speech_prob": 5.290851549943909e-05}, {"id": 132, "seek": 102460, "start": 1044.84, "end": 1051.4399999999998, "text": " to have that. And lastly is keeping the policies up to date. Even if you roll your own distribution", "tokens": [281, 362, 300, 13, 400, 16386, 307, 5145, 264, 7657, 493, 281, 4002, 13, 2754, 498, 291, 3373, 428, 1065, 7316], "temperature": 0.0, "avg_logprob": -0.15931859883395108, "compression_ratio": 1.71875, "no_speech_prob": 5.290851549943909e-05}, {"id": 133, "seek": 105144, "start": 1051.44, "end": 1057.6000000000001, "text": " and are big enough, it's very difficult to be up to date on that policies and integrate them", "tokens": [293, 366, 955, 1547, 11, 309, 311, 588, 2252, 281, 312, 493, 281, 4002, 322, 300, 7657, 293, 13365, 552], "temperature": 0.0, "avg_logprob": -0.21383119398547756, "compression_ratio": 1.556910569105691, "no_speech_prob": 6.676874909317121e-05}, {"id": 134, "seek": 105144, "start": 1057.6000000000001, "end": 1063.92, "text": " automatically. And lastly, they have an escalation chain just for illustration purposes. They use", "tokens": [6772, 13, 400, 16386, 11, 436, 362, 364, 17871, 399, 5021, 445, 337, 22645, 9932, 13, 814, 764], "temperature": 0.0, "avg_logprob": -0.21383119398547756, "compression_ratio": 1.556910569105691, "no_speech_prob": 6.676874909317121e-05}, {"id": 135, "seek": 105144, "start": 1063.92, "end": 1070.1200000000001, "text": " key lime to monitor that, tie that into their JIRA system, and then have an actual person react", "tokens": [2141, 22035, 281, 6002, 300, 11, 7582, 300, 666, 641, 50172, 3750, 1185, 11, 293, 550, 362, 364, 3539, 954, 4515], "temperature": 0.0, "avg_logprob": -0.21383119398547756, "compression_ratio": 1.556910569105691, "no_speech_prob": 6.676874909317121e-05}, {"id": 136, "seek": 105144, "start": 1070.1200000000001, "end": 1079.48, "text": " on the other side. So and then one point from a distribution. So in this case from SUSE, I asked", "tokens": [322, 264, 661, 1252, 13, 407, 293, 550, 472, 935, 490, 257, 7316, 13, 407, 294, 341, 1389, 490, 40117, 36, 11, 286, 2351], "temperature": 0.0, "avg_logprob": -0.21383119398547756, "compression_ratio": 1.556910569105691, "no_speech_prob": 6.676874909317121e-05}, {"id": 137, "seek": 107948, "start": 1079.48, "end": 1086.44, "text": " them and they integrated key lime into pretty much any product. So it's an open SUSE today. If you", "tokens": [552, 293, 436, 10919, 2141, 22035, 666, 1238, 709, 604, 1674, 13, 407, 309, 311, 364, 1269, 40117, 36, 965, 13, 759, 291], "temperature": 0.0, "avg_logprob": -0.20056797759701508, "compression_ratio": 1.528, "no_speech_prob": 4.189071842120029e-05}, {"id": 138, "seek": 107948, "start": 1086.44, "end": 1092.04, "text": " want to use it in microS, there's instruction to do that. And then also in SUSE Enterprise Linux", "tokens": [528, 281, 764, 309, 294, 4532, 50, 11, 456, 311, 10951, 281, 360, 300, 13, 400, 550, 611, 294, 40117, 36, 26696, 18734], "temperature": 0.0, "avg_logprob": -0.20056797759701508, "compression_ratio": 1.528, "no_speech_prob": 4.189071842120029e-05}, {"id": 139, "seek": 107948, "start": 1092.04, "end": 1100.32, "text": " and an ALP. Their challenges also we're like integrating it with as a Linux fully and making", "tokens": [293, 364, 7056, 47, 13, 6710, 4759, 611, 321, 434, 411, 26889, 309, 365, 382, 257, 18734, 4498, 293, 1455], "temperature": 0.0, "avg_logprob": -0.20056797759701508, "compression_ratio": 1.528, "no_speech_prob": 4.189071842120029e-05}, {"id": 140, "seek": 107948, "start": 1100.32, "end": 1109.16, "text": " IMA usable. So do we have signatures? How do we provide the hashes? And the general thing for", "tokens": [286, 9998, 29975, 13, 407, 360, 321, 362, 32322, 30, 1012, 360, 321, 2893, 264, 575, 8076, 30, 400, 264, 2674, 551, 337], "temperature": 0.0, "avg_logprob": -0.20056797759701508, "compression_ratio": 1.528, "no_speech_prob": 4.189071842120029e-05}, {"id": 141, "seek": 110916, "start": 1109.16, "end": 1118.88, "text": " distribution is how do we provide robust policies in general? Because we want users to try out", "tokens": [7316, 307, 577, 360, 321, 2893, 13956, 7657, 294, 2674, 30, 1436, 321, 528, 5022, 281, 853, 484], "temperature": 0.0, "avg_logprob": -0.11392974853515625, "compression_ratio": 1.6212765957446809, "no_speech_prob": 4.0635783079778776e-05}, {"id": 142, "seek": 110916, "start": 1118.88, "end": 1125.6000000000001, "text": " the technology and want to experiment with that. But how do we give them the starting point? And", "tokens": [264, 2899, 293, 528, 281, 5120, 365, 300, 13, 583, 577, 360, 321, 976, 552, 264, 2891, 935, 30, 400], "temperature": 0.0, "avg_logprob": -0.11392974853515625, "compression_ratio": 1.6212765957446809, "no_speech_prob": 4.0635783079778776e-05}, {"id": 143, "seek": 110916, "start": 1125.6000000000001, "end": 1130.3200000000002, "text": " that is still a very difficult because as we saw, there are many data points that needs to be", "tokens": [300, 307, 920, 257, 588, 2252, 570, 382, 321, 1866, 11, 456, 366, 867, 1412, 2793, 300, 2203, 281, 312], "temperature": 0.0, "avg_logprob": -0.11392974853515625, "compression_ratio": 1.6212765957446809, "no_speech_prob": 4.0635783079778776e-05}, {"id": 144, "seek": 110916, "start": 1130.3200000000002, "end": 1135.76, "text": " collected. And that is a challenge that they're trying to solve actively by making, getting the", "tokens": [11087, 13, 400, 300, 307, 257, 3430, 300, 436, 434, 1382, 281, 5039, 13022, 538, 1455, 11, 1242, 264], "temperature": 0.0, "avg_logprob": -0.11392974853515625, "compression_ratio": 1.6212765957446809, "no_speech_prob": 4.0635783079778776e-05}, {"id": 145, "seek": 113576, "start": 1135.76, "end": 1145.6, "text": " signatures and the hashes easier. Yeah. So to say for the end, try remote attestation today. The", "tokens": [32322, 293, 264, 575, 8076, 3571, 13, 865, 13, 407, 281, 584, 337, 264, 917, 11, 853, 8607, 951, 377, 399, 965, 13, 440], "temperature": 0.0, "avg_logprob": -0.15657076835632325, "compression_ratio": 1.4202898550724639, "no_speech_prob": 3.8128866435727105e-05}, {"id": 146, "seek": 113576, "start": 1145.6, "end": 1153.12, "text": " technology that you need to do that is pretty much in every device that you have like in a notebook", "tokens": [2899, 300, 291, 643, 281, 360, 300, 307, 1238, 709, 294, 633, 4302, 300, 291, 362, 411, 294, 257, 21060], "temperature": 0.0, "avg_logprob": -0.15657076835632325, "compression_ratio": 1.4202898550724639, "no_speech_prob": 3.8128866435727105e-05}, {"id": 147, "seek": 115312, "start": 1153.12, "end": 1167.8799999999999, "text": " that you can use. So you can find Keelem at Keelem.dev. And yeah, thank you. So do we have", "tokens": [300, 291, 393, 764, 13, 407, 291, 393, 915, 591, 1653, 10386, 412, 591, 1653, 10386, 13, 40343, 13, 400, 1338, 11, 1309, 291, 13, 407, 360, 321, 362], "temperature": 0.0, "avg_logprob": -0.24854435744108977, "compression_ratio": 1.4186046511627908, "no_speech_prob": 0.00015431706560775638}, {"id": 148, "seek": 115312, "start": 1167.8799999999999, "end": 1180.12, "text": " questions? Lots of questions. Thank you for a great presentation. One question. You talked a", "tokens": [1651, 30, 15908, 295, 1651, 13, 1044, 291, 337, 257, 869, 5860, 13, 1485, 1168, 13, 509, 2825, 257], "temperature": 0.0, "avg_logprob": -0.24854435744108977, "compression_ratio": 1.4186046511627908, "no_speech_prob": 0.00015431706560775638}, {"id": 149, "seek": 118012, "start": 1180.12, "end": 1185.8, "text": " lot about the verification side of the processing. You talked a lot about the verification side,", "tokens": [688, 466, 264, 30206, 1252, 295, 264, 9007, 13, 509, 2825, 257, 688, 466, 264, 30206, 1252, 11], "temperature": 0.0, "avg_logprob": -0.14481237530708313, "compression_ratio": 1.7545454545454546, "no_speech_prob": 0.001652120496146381}, {"id": 150, "seek": 118012, "start": 1185.8, "end": 1193.56, "text": " but to have the golden values or the PCRs in your verified system, you need to provision them. So I", "tokens": [457, 281, 362, 264, 9729, 4190, 420, 264, 44022, 82, 294, 428, 31197, 1185, 11, 291, 643, 281, 17225, 552, 13, 407, 286], "temperature": 0.0, "avg_logprob": -0.14481237530708313, "compression_ratio": 1.7545454545454546, "no_speech_prob": 0.001652120496146381}, {"id": 151, "seek": 118012, "start": 1193.56, "end": 1200.52, "text": " was not sure the distribution side of things was how do you manage that in Keelem? Could you shed", "tokens": [390, 406, 988, 264, 7316, 1252, 295, 721, 390, 577, 360, 291, 3067, 300, 294, 591, 1653, 10386, 30, 7497, 291, 14951], "temperature": 0.0, "avg_logprob": -0.14481237530708313, "compression_ratio": 1.7545454545454546, "no_speech_prob": 0.001652120496146381}, {"id": 152, "seek": 118012, "start": 1200.52, "end": 1209.52, "text": " some light on that? Yeah. So with the golden values, we have the values in the TPM and then", "tokens": [512, 1442, 322, 300, 30, 865, 13, 407, 365, 264, 9729, 4190, 11, 321, 362, 264, 4190, 294, 264, 314, 18819, 293, 550], "temperature": 0.0, "avg_logprob": -0.14481237530708313, "compression_ratio": 1.7545454545454546, "no_speech_prob": 0.001652120496146381}, {"id": 153, "seek": 120952, "start": 1209.52, "end": 1215.76, "text": " they're also tied to an event log and IMA and like a measure boot. And we solve the issue that we", "tokens": [436, 434, 611, 9601, 281, 364, 2280, 3565, 293, 286, 9998, 293, 411, 257, 3481, 11450, 13, 400, 321, 5039, 264, 2734, 300, 321], "temperature": 0.0, "avg_logprob": -0.21087267133924698, "compression_ratio": 1.6355932203389831, "no_speech_prob": 4.3901574827032164e-05}, {"id": 154, "seek": 120952, "start": 1215.76, "end": 1221.76, "text": " don't actually need golden values by having a policy engine basically that verifies the logs", "tokens": [500, 380, 767, 643, 9729, 4190, 538, 1419, 257, 3897, 2848, 1936, 300, 1306, 11221, 264, 20820], "temperature": 0.0, "avg_logprob": -0.21087267133924698, "compression_ratio": 1.6355932203389831, "no_speech_prob": 4.3901574827032164e-05}, {"id": 155, "seek": 120952, "start": 1221.76, "end": 1228.52, "text": " itself checks if that those match the values, but then we check the logs and not the end value. So", "tokens": [2564, 13834, 498, 300, 729, 2995, 264, 4190, 11, 457, 550, 321, 1520, 264, 20820, 293, 406, 264, 917, 2158, 13, 407], "temperature": 0.0, "avg_logprob": -0.21087267133924698, "compression_ratio": 1.6355932203389831, "no_speech_prob": 4.3901574827032164e-05}, {"id": 156, "seek": 120952, "start": 1228.52, "end": 1233.6399999999999, "text": " and then the distribution can help because they can provide like a lot of the signatures already", "tokens": [293, 550, 264, 7316, 393, 854, 570, 436, 393, 2893, 411, 257, 688, 295, 264, 32322, 1217], "temperature": 0.0, "avg_logprob": -0.21087267133924698, "compression_ratio": 1.6355932203389831, "no_speech_prob": 4.3901574827032164e-05}, {"id": 157, "seek": 123364, "start": 1233.64, "end": 1240.16, "text": " and which files are in which packages and how they end up. That makes the life for the distribution", "tokens": [293, 597, 7098, 366, 294, 597, 17401, 293, 577, 436, 917, 493, 13, 663, 1669, 264, 993, 337, 264, 7316], "temperature": 0.0, "avg_logprob": -0.2112015151977539, "compression_ratio": 1.510204081632653, "no_speech_prob": 0.0011252376716583967}, {"id": 158, "seek": 123364, "start": 1240.16, "end": 1251.3600000000001, "text": " easier. Yes, sir. What is the performance of such a check? How much time does it take and how much", "tokens": [3571, 13, 1079, 11, 4735, 13, 708, 307, 264, 3389, 295, 1270, 257, 1520, 30, 1012, 709, 565, 775, 309, 747, 293, 577, 709], "temperature": 0.0, "avg_logprob": -0.2112015151977539, "compression_ratio": 1.510204081632653, "no_speech_prob": 0.0011252376716583967}, {"id": 159, "seek": 123364, "start": 1251.3600000000001, "end": 1261.44, "text": " data is required for such a monitoring? From what I saw, I don't have like a benchmarks for that,", "tokens": [1412, 307, 4739, 337, 1270, 257, 11028, 30, 3358, 437, 286, 1866, 11, 286, 500, 380, 362, 411, 257, 43751, 337, 300, 11], "temperature": 0.0, "avg_logprob": -0.2112015151977539, "compression_ratio": 1.510204081632653, "no_speech_prob": 0.0011252376716583967}, {"id": 160, "seek": 126144, "start": 1261.44, "end": 1273.1200000000001, "text": " but it's pretty quick, like 200 milliseconds, something like that. So the round trip from the", "tokens": [457, 309, 311, 1238, 1702, 11, 411, 2331, 34184, 11, 746, 411, 300, 13, 407, 264, 3098, 4931, 490, 264], "temperature": 0.0, "avg_logprob": -0.18362397207340725, "compression_ratio": 1.5077720207253886, "no_speech_prob": 0.00032923350227065384}, {"id": 161, "seek": 126144, "start": 1273.1200000000001, "end": 1280.6000000000001, "text": " request to the response is like 200 milliseconds in my test, but of course it's on my machine, right?", "tokens": [5308, 281, 264, 4134, 307, 411, 2331, 34184, 294, 452, 1500, 11, 457, 295, 1164, 309, 311, 322, 452, 3479, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.18362397207340725, "compression_ratio": 1.5077720207253886, "no_speech_prob": 0.00032923350227065384}, {"id": 162, "seek": 126144, "start": 1280.6000000000001, "end": 1287.28, "text": " We don't have benchmarks for the performance. Yeah, so it heavily also depends what you want to", "tokens": [492, 500, 380, 362, 43751, 337, 264, 3389, 13, 865, 11, 370, 309, 10950, 611, 5946, 437, 291, 528, 281], "temperature": 0.0, "avg_logprob": -0.18362397207340725, "compression_ratio": 1.5077720207253886, "no_speech_prob": 0.00032923350227065384}, {"id": 163, "seek": 128728, "start": 1287.28, "end": 1293.12, "text": " test. If you just have measured boot, it's the crow time on the hardware TPM maximum to a second,", "tokens": [1500, 13, 759, 291, 445, 362, 12690, 11450, 11, 309, 311, 264, 6401, 565, 322, 264, 8837, 314, 18819, 6674, 281, 257, 1150, 11], "temperature": 0.0, "avg_logprob": -0.19237499446659298, "compression_ratio": 1.5720164609053497, "no_speech_prob": 6.285819108597934e-05}, {"id": 164, "seek": 128728, "start": 1293.12, "end": 1300.44, "text": " and then it's like a couple of most megabytes of a single digits that you have at data that is", "tokens": [293, 550, 309, 311, 411, 257, 1916, 295, 881, 10816, 24538, 295, 257, 2167, 27011, 300, 291, 362, 412, 1412, 300, 307], "temperature": 0.0, "avg_logprob": -0.19237499446659298, "compression_ratio": 1.5720164609053497, "no_speech_prob": 6.285819108597934e-05}, {"id": 165, "seek": 128728, "start": 1300.44, "end": 1307.52, "text": " transferred. You had said that one of the challenges of implementation was dealing with false", "tokens": [15809, 13, 509, 632, 848, 300, 472, 295, 264, 4759, 295, 11420, 390, 6260, 365, 7908], "temperature": 0.0, "avg_logprob": -0.19237499446659298, "compression_ratio": 1.5720164609053497, "no_speech_prob": 6.285819108597934e-05}, {"id": 166, "seek": 128728, "start": 1307.52, "end": 1314.44, "text": " positives and maybe false negatives. Can you give some examples of when that would occur? Yeah,", "tokens": [35127, 293, 1310, 7908, 40019, 13, 1664, 291, 976, 512, 5110, 295, 562, 300, 576, 5160, 30, 865, 11], "temperature": 0.0, "avg_logprob": -0.19237499446659298, "compression_ratio": 1.5720164609053497, "no_speech_prob": 6.285819108597934e-05}, {"id": 167, "seek": 131444, "start": 1314.44, "end": 1321.92, "text": " because we are still talking over the network. That is like a false positive if the network", "tokens": [570, 321, 366, 920, 1417, 670, 264, 3209, 13, 663, 307, 411, 257, 7908, 3353, 498, 264, 3209], "temperature": 0.0, "avg_logprob": -0.14819049835205078, "compression_ratio": 1.8333333333333333, "no_speech_prob": 4.2553976527415216e-05}, {"id": 168, "seek": 131444, "start": 1321.92, "end": 1327.56, "text": " connection goes down. And the other one is it's kind of a false positive and not really is if", "tokens": [4984, 1709, 760, 13, 400, 264, 661, 472, 307, 309, 311, 733, 295, 257, 7908, 3353, 293, 406, 534, 307, 498], "temperature": 0.0, "avg_logprob": -0.14819049835205078, "compression_ratio": 1.8333333333333333, "no_speech_prob": 4.2553976527415216e-05}, {"id": 169, "seek": 131444, "start": 1327.56, "end": 1333.8, "text": " your policy is not up to date. For the system, it's not a false positive in the traditional sense,", "tokens": [428, 3897, 307, 406, 493, 281, 4002, 13, 1171, 264, 1185, 11, 309, 311, 406, 257, 7908, 3353, 294, 264, 5164, 2020, 11], "temperature": 0.0, "avg_logprob": -0.14819049835205078, "compression_ratio": 1.8333333333333333, "no_speech_prob": 4.2553976527415216e-05}, {"id": 170, "seek": 131444, "start": 1333.8, "end": 1339.52, "text": " but it's in the false positive because we don't want that alert actually to happen. For the", "tokens": [457, 309, 311, 294, 264, 7908, 3353, 570, 321, 500, 380, 528, 300, 9615, 767, 281, 1051, 13, 1171, 264], "temperature": 0.0, "avg_logprob": -0.14819049835205078, "compression_ratio": 1.8333333333333333, "no_speech_prob": 4.2553976527415216e-05}, {"id": 171, "seek": 131444, "start": 1339.52, "end": 1344.0800000000002, "text": " university use case, how do you know that you're actually talking to the real TPM in the laptop?", "tokens": [5454, 764, 1389, 11, 577, 360, 291, 458, 300, 291, 434, 767, 1417, 281, 264, 957, 314, 18819, 294, 264, 10732, 30], "temperature": 0.0, "avg_logprob": -0.14819049835205078, "compression_ratio": 1.8333333333333333, "no_speech_prob": 4.2553976527415216e-05}, {"id": 172, "seek": 134408, "start": 1344.08, "end": 1355.48, "text": " So we have two ways. First, we verify against the hardware manufacturer. So they have a CA that", "tokens": [407, 321, 362, 732, 2098, 13, 2386, 11, 321, 16888, 1970, 264, 8837, 18022, 13, 407, 436, 362, 257, 22852, 300], "temperature": 0.0, "avg_logprob": -0.18602907484856204, "compression_ratio": 1.543010752688172, "no_speech_prob": 0.00010627736628521234}, {"id": 173, "seek": 134408, "start": 1355.48, "end": 1362.04, "text": " we can verify against. And also we can enroll the notebooks directly. So we check if the devices,", "tokens": [321, 393, 16888, 1970, 13, 400, 611, 321, 393, 12266, 264, 43782, 3838, 13, 407, 321, 1520, 498, 264, 5759, 11], "temperature": 0.0, "avg_logprob": -0.18602907484856204, "compression_ratio": 1.543010752688172, "no_speech_prob": 0.00010627736628521234}, {"id": 174, "seek": 134408, "start": 1362.04, "end": 1368.32, "text": " which I forgot to say that the university part is still proof of concept. So we are currently", "tokens": [597, 286, 5298, 281, 584, 300, 264, 5454, 644, 307, 920, 8177, 295, 3410, 13, 407, 321, 366, 4362], "temperature": 0.0, "avg_logprob": -0.18602907484856204, "compression_ratio": 1.543010752688172, "no_speech_prob": 0.00010627736628521234}, {"id": 175, "seek": 136832, "start": 1368.32, "end": 1380.9199999999998, "text": " working on it, but it's not rolled out like large scale. How do you make sure that an alert event,", "tokens": [1364, 322, 309, 11, 457, 309, 311, 406, 14306, 484, 411, 2416, 4373, 13, 1012, 360, 291, 652, 988, 300, 364, 9615, 2280, 11], "temperature": 0.0, "avg_logprob": -0.14657604066949143, "compression_ratio": 1.7839506172839505, "no_speech_prob": 0.0004638315294869244}, {"id": 176, "seek": 136832, "start": 1380.9199999999998, "end": 1388.3999999999999, "text": " a new change happened? How do you make sure that it's not intercepted over the network? Sorry,", "tokens": [257, 777, 1319, 2011, 30, 1012, 360, 291, 652, 988, 300, 309, 311, 406, 24700, 292, 670, 264, 3209, 30, 4919, 11], "temperature": 0.0, "avg_logprob": -0.14657604066949143, "compression_ratio": 1.7839506172839505, "no_speech_prob": 0.0004638315294869244}, {"id": 177, "seek": 136832, "start": 1388.3999999999999, "end": 1395.9199999999998, "text": " once again. How do you make sure that when there's an event saying that there's a change on the", "tokens": [1564, 797, 13, 1012, 360, 291, 652, 988, 300, 562, 456, 311, 364, 2280, 1566, 300, 456, 311, 257, 1319, 322, 264], "temperature": 0.0, "avg_logprob": -0.14657604066949143, "compression_ratio": 1.7839506172839505, "no_speech_prob": 0.0004638315294869244}, {"id": 178, "seek": 139592, "start": 1395.92, "end": 1401.44, "text": " machine, a new measurement that appears? How do you make sure that the event is not intercepted", "tokens": [3479, 11, 257, 777, 13160, 300, 7038, 30, 1012, 360, 291, 652, 988, 300, 264, 2280, 307, 406, 24700, 292], "temperature": 0.0, "avg_logprob": -0.13660868933034498, "compression_ratio": 1.813397129186603, "no_speech_prob": 0.0003530298126861453}, {"id": 179, "seek": 139592, "start": 1401.44, "end": 1409.04, "text": " in the network between the monitored machine and the trusted system? So is the question,", "tokens": [294, 264, 3209, 1296, 264, 36255, 3479, 293, 264, 16034, 1185, 30, 407, 307, 264, 1168, 11], "temperature": 0.0, "avg_logprob": -0.13660868933034498, "compression_ratio": 1.813397129186603, "no_speech_prob": 0.0003530298126861453}, {"id": 180, "seek": 139592, "start": 1409.04, "end": 1416.3200000000002, "text": " how do we deal with the losing connection between the agent, the monitored system and the verifier?", "tokens": [577, 360, 321, 2028, 365, 264, 7027, 4984, 1296, 264, 9461, 11, 264, 36255, 1185, 293, 264, 1306, 9902, 30], "temperature": 0.0, "avg_logprob": -0.13660868933034498, "compression_ratio": 1.813397129186603, "no_speech_prob": 0.0003530298126861453}, {"id": 181, "seek": 139592, "start": 1416.3200000000002, "end": 1423.5600000000002, "text": " Losing connection or having maybe something in between, making sure that it does not go to the", "tokens": [441, 6110, 4984, 420, 1419, 1310, 746, 294, 1296, 11, 1455, 988, 300, 309, 775, 406, 352, 281, 264], "temperature": 0.0, "avg_logprob": -0.13660868933034498, "compression_ratio": 1.813397129186603, "no_speech_prob": 0.0003530298126861453}, {"id": 182, "seek": 142356, "start": 1423.56, "end": 1430.72, "text": " trusted system. There's something in between that makes sure that you're never going to be", "tokens": [16034, 1185, 13, 821, 311, 746, 294, 1296, 300, 1669, 988, 300, 291, 434, 1128, 516, 281, 312], "temperature": 0.0, "avg_logprob": -0.22230747767857142, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0002146730403183028}, {"id": 183, "seek": 142356, "start": 1430.72, "end": 1436.24, "text": " notified that a system is going to be compromised or just became compromised.", "tokens": [18013, 300, 257, 1185, 307, 516, 281, 312, 32463, 420, 445, 3062, 32463, 13], "temperature": 0.0, "avg_logprob": -0.22230747767857142, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0002146730403183028}, {"id": 184, "seek": 142356, "start": 1436.24, "end": 1445.72, "text": " Did you get that? Yes. So if we have a blocking connection between the agent and the verifier", "tokens": [2589, 291, 483, 300, 30, 1079, 13, 407, 498, 321, 362, 257, 17776, 4984, 1296, 264, 9461, 293, 264, 1306, 9902], "temperature": 0.0, "avg_logprob": -0.22230747767857142, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0002146730403183028}, {"id": 185, "seek": 142356, "start": 1445.72, "end": 1451.84, "text": " side, then we get a timeout and then the agent gets automatically distressed. And if you said", "tokens": [1252, 11, 550, 321, 483, 257, 565, 346, 293, 550, 264, 9461, 2170, 6772, 1483, 3805, 13, 400, 498, 291, 848], "temperature": 0.0, "avg_logprob": -0.22230747767857142, "compression_ratio": 1.6872037914691944, "no_speech_prob": 0.0002146730403183028}, {"id": 186, "seek": 145184, "start": 1451.84, "end": 1458.3999999999999, "text": " like from the notification system itself, if you say we notify all the other agents, of course,", "tokens": [411, 490, 264, 11554, 1185, 2564, 11, 498, 291, 584, 321, 36560, 439, 264, 661, 12554, 11, 295, 1164, 11], "temperature": 0.0, "avg_logprob": -0.1410381218482708, "compression_ratio": 1.9233870967741935, "no_speech_prob": 4.585344868246466e-05}, {"id": 187, "seek": 145184, "start": 1458.3999999999999, "end": 1462.9599999999998, "text": " then there is an issue if you cannot reach to them on a trusted channel, then it's basically", "tokens": [550, 456, 307, 364, 2734, 498, 291, 2644, 2524, 281, 552, 322, 257, 16034, 2269, 11, 550, 309, 311, 1936], "temperature": 0.0, "avg_logprob": -0.1410381218482708, "compression_ratio": 1.9233870967741935, "no_speech_prob": 4.585344868246466e-05}, {"id": 188, "seek": 145184, "start": 1462.9599999999998, "end": 1468.0, "text": " game over in that direction. So you need to get your revocation alerts if you want to guarantee", "tokens": [1216, 670, 294, 300, 3513, 13, 407, 291, 643, 281, 483, 428, 3698, 27943, 28061, 498, 291, 528, 281, 10815], "temperature": 0.0, "avg_logprob": -0.1410381218482708, "compression_ratio": 1.9233870967741935, "no_speech_prob": 4.585344868246466e-05}, {"id": 189, "seek": 145184, "start": 1468.0, "end": 1473.36, "text": " them all the time through a trusted channel. So the trust boundary is for the attestation part", "tokens": [552, 439, 264, 565, 807, 257, 16034, 2269, 13, 407, 264, 3361, 12866, 307, 337, 264, 951, 377, 399, 644], "temperature": 0.0, "avg_logprob": -0.1410381218482708, "compression_ratio": 1.9233870967741935, "no_speech_prob": 4.585344868246466e-05}, {"id": 190, "seek": 145184, "start": 1473.36, "end": 1478.9599999999998, "text": " that we see that, but the revocation part, if you want to reach that, then it needs to go through", "tokens": [300, 321, 536, 300, 11, 457, 264, 3698, 27943, 644, 11, 498, 291, 528, 281, 2524, 300, 11, 550, 309, 2203, 281, 352, 807], "temperature": 0.0, "avg_logprob": -0.1410381218482708, "compression_ratio": 1.9233870967741935, "no_speech_prob": 4.585344868246466e-05}, {"id": 191, "seek": 147896, "start": 1478.96, "end": 1485.88, "text": " a trusted channel. Yeah. So continuing on this question, actually, I think, how do you make", "tokens": [257, 16034, 2269, 13, 865, 13, 407, 9289, 322, 341, 1168, 11, 767, 11, 286, 519, 11, 577, 360, 291, 652], "temperature": 0.0, "avg_logprob": -0.17338118023342555, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.000888410781044513}, {"id": 192, "seek": 147896, "start": 1485.88, "end": 1491.24, "text": " sure that your actual verifiers connect to the right agent and you don't have a man in the middle", "tokens": [988, 300, 428, 3539, 1306, 23463, 1745, 281, 264, 558, 9461, 293, 291, 500, 380, 362, 257, 587, 294, 264, 2808], "temperature": 0.0, "avg_logprob": -0.17338118023342555, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.000888410781044513}, {"id": 193, "seek": 147896, "start": 1491.24, "end": 1498.16, "text": " attack that's happening and rerouting this to a fake agent and fake TPM? Yeah. So that's tied", "tokens": [2690, 300, 311, 2737, 293, 43819, 24500, 341, 281, 257, 7592, 9461, 293, 7592, 314, 18819, 30, 865, 13, 407, 300, 311, 9601], "temperature": 0.0, "avg_logprob": -0.17338118023342555, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.000888410781044513}, {"id": 194, "seek": 147896, "start": 1498.16, "end": 1505.0, "text": " with the EK certificate. So you trust the manufacturer because when they manufacture the", "tokens": [365, 264, 46078, 15953, 13, 407, 291, 3361, 264, 18022, 570, 562, 436, 27400, 264], "temperature": 0.0, "avg_logprob": -0.17338118023342555, "compression_ratio": 1.617391304347826, "no_speech_prob": 0.000888410781044513}, {"id": 195, "seek": 150500, "start": 1505.0, "end": 1512.68, "text": " TPM, they will create this key that cannot be modified or removed in any way. So it provides", "tokens": [314, 18819, 11, 436, 486, 1884, 341, 2141, 300, 2644, 312, 15873, 420, 7261, 294, 604, 636, 13, 407, 309, 6417], "temperature": 0.0, "avg_logprob": -0.08952447159649575, "compression_ratio": 1.558659217877095, "no_speech_prob": 8.745044760871679e-05}, {"id": 196, "seek": 150500, "start": 1512.68, "end": 1519.88, "text": " the identity to the TPM. So when you get the information from the TPM or from some agent,", "tokens": [264, 6575, 281, 264, 314, 18819, 13, 407, 562, 291, 483, 264, 1589, 490, 264, 314, 18819, 420, 490, 512, 9461, 11], "temperature": 0.0, "avg_logprob": -0.08952447159649575, "compression_ratio": 1.558659217877095, "no_speech_prob": 8.745044760871679e-05}, {"id": 197, "seek": 150500, "start": 1519.88, "end": 1529.92, "text": " you can verify that that data came from the TPM that has some EK key because it's signed and you", "tokens": [291, 393, 16888, 300, 300, 1412, 1361, 490, 264, 314, 18819, 300, 575, 512, 46078, 2141, 570, 309, 311, 8175, 293, 291], "temperature": 0.0, "avg_logprob": -0.08952447159649575, "compression_ratio": 1.558659217877095, "no_speech_prob": 8.745044760871679e-05}, {"id": 198, "seek": 152992, "start": 1529.92, "end": 1539.6000000000001, "text": " can verify the origin using the CA certificate provided by the manufacturer. So you can check that", "tokens": [393, 16888, 264, 4957, 1228, 264, 22852, 15953, 5649, 538, 264, 18022, 13, 407, 291, 393, 1520, 300], "temperature": 0.0, "avg_logprob": -0.16188389914376394, "compression_ratio": 1.5925925925925926, "no_speech_prob": 0.00011532068310771137}, {"id": 199, "seek": 152992, "start": 1539.6000000000001, "end": 1546.48, "text": " the TPM is exactly the one you expected using the EK certificate. Okay. Thank you for the talk.", "tokens": [264, 314, 18819, 307, 2293, 264, 472, 291, 5176, 1228, 264, 46078, 15953, 13, 1033, 13, 1044, 291, 337, 264, 751, 13], "temperature": 0.0, "avg_logprob": -0.16188389914376394, "compression_ratio": 1.5925925925925926, "no_speech_prob": 0.00011532068310771137}, {"id": 200, "seek": 154648, "start": 1546.48, "end": 1560.24, "text": " Thank you for all the questions. We are out of the diamond. Thank you.", "tokens": [50364, 1044, 291, 337, 439, 264, 1651, 13, 492, 366, 484, 295, 264, 16059, 13, 1044, 291, 13, 51052], "temperature": 0.0, "avg_logprob": -0.2687401056289673, "compression_ratio": 1.0144927536231885, "no_speech_prob": 0.0004421296762302518}], "language": "en"}