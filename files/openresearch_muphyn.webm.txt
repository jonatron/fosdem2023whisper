[00:00.000 --> 00:12.440]  Hello everyone, I'm Dylan Fiverr and I'm a research engineer at CERF Technique, a research
[00:12.440 --> 00:15.440]  center in Mons in Belgium.
[00:15.440 --> 00:20.720]  Today I will present you the software Muffin, which is a graphical tool for modeling and
[00:20.720 --> 00:25.400]  simulating multi-physics systems.
[00:25.400 --> 00:31.160]  So the project started with a research project.
[00:31.160 --> 00:40.440]  It is a collaboration with Thales-Alenia Space, so it's a research project funded by the Wallonia,
[00:40.440 --> 00:45.400]  so a public fund of Belgium.
[00:45.400 --> 00:51.440]  And the goal of the project is the development of a simulation method to assist in the design
[00:51.440 --> 00:56.760]  of mechatronic chains with a complete multi-physics model.
[00:56.760 --> 01:02.960]  So in other terms, what are the goals of the project?
[01:02.960 --> 01:09.600]  It exists different kinds of multi-physics simulations of Tuer, the global variable simulation
[01:09.600 --> 01:19.240]  type like OpenModelica, which simulates a system by item like a motor etc.
[01:19.240 --> 01:28.520]  Then we have a local variable simulation like Finite Element Simulation for a multi-physics
[01:28.520 --> 01:30.400]  system.
[01:30.400 --> 01:38.880]  And both types of simulations are not compatible with each other, so the research project tried
[01:38.880 --> 01:54.880]  to find another way to simulate a multi-physics model with using electrical analogous modeling.
[01:54.880 --> 01:59.840]  So the method we want to develop is a simulation in three points.
[01:59.840 --> 02:06.680]  So the first step is to convert physical system to electrical analogous system.
[02:06.680 --> 02:13.640]  The second step is to convert those electrical analogous model to numerical model.
[02:13.640 --> 02:21.840]  And the last step is reducing numerical model with evaluating the influence of each part
[02:21.840 --> 02:27.280]  of the system to the rest of the system.
[02:27.280 --> 02:36.200]  Then a second point, a more important point for our research is the Times Square Adaptive
[02:36.200 --> 02:37.920]  Model Reduction.
[02:37.920 --> 02:39.960]  So how to explain that?
[02:39.960 --> 02:49.520]  In a system we have a low inertia part in the system and high inertia, so low inertia
[02:49.520 --> 02:59.400]  part of the system are a part of the system that evolve quickly in the time and high inertia
[02:59.400 --> 03:03.240]  evolve slowly with the time.
[03:03.240 --> 03:18.000]  So when we simulate each one, we don't require the same step size, sorry.
[03:18.000 --> 03:25.120]  When we make a simulation, a physical simulation, we have to find an optimal step size.
[03:25.120 --> 03:31.360]  If we have a too large step size, the accuracy will decrease.
[03:31.360 --> 03:36.720]  And if we have a smaller step size, we will have a sufficient accuracy.
[03:36.720 --> 03:47.720]  But if the step size is too much small, the time to execute the simulation will be increased
[03:47.720 --> 03:51.960]  for a little gain of accuracy.
[03:51.960 --> 04:02.840]  So we have a multiple inertia part in a multi-physics system and we want to find a way to optimize
[04:02.840 --> 04:10.400]  the simulation by using different Times Square in the system.
[04:10.400 --> 04:22.960]  So for the project, we have some requirements when we will choose the simulation software.
[04:22.960 --> 04:26.760]  We need a multi-physics simulation software.
[04:26.760 --> 04:40.280]  This one must be adaptable so it must be able to adapt the model as a function of the
[04:40.880 --> 04:45.720]  condition of simulation, like the time, et cetera.
[04:45.720 --> 04:51.920]  And last but not least, the application must be user-friendly.
[04:51.920 --> 05:01.080]  So we have a simulink with MATLAB or XCOS with SILAB that would be a very, very good
[05:01.080 --> 05:07.240]  application for the project.
[05:07.240 --> 05:19.360]  That simulink is expensive, is a closed source software and not exactly adapted to our requirement.
[05:19.360 --> 05:28.520]  And it's a closed source software so we couldn't modify MATLAB like we wanted.
[05:28.520 --> 05:35.080]  And for XCOS, it's not user-friendly and like MATLAB, it doesn't exactly fit with the
[05:35.080 --> 05:36.640]  project requirement.
[05:36.640 --> 05:46.600]  So we decided to develop our own software that leverages existing powerful Python libraries.
[05:46.600 --> 05:50.880]  Here is an overview of our application.
[05:50.880 --> 05:58.920]  It is being used in a regulation system and here we have an example of results for this
[05:58.920 --> 06:01.920]  regulation system.
[06:01.920 --> 06:10.440]  So the software, it's a graphical tool for modeling and simulating multi-physics system.
[06:10.440 --> 06:17.840]  Here is a quick demonstration of how to use the application.
[06:17.840 --> 06:26.800]  So to build the simulation graph, it's just a drag-and-drop from a box library to a scheme
[06:26.800 --> 06:37.160]  drawing and then once the simulation graph is done, you can easily launch the simulation.
[06:37.160 --> 06:46.440]  We can use multiple project at the same time, save and load, project, etc.
[06:46.440 --> 06:49.120]  So what is the application?
[06:49.120 --> 06:52.560]  The application is a simulation graph builder.
[06:52.560 --> 07:03.160]  We have provided some default libraries to use the application if you install it on your
[07:03.160 --> 07:18.520]  computer but you can easily add your own process boxes and can solve all the simulations you've
[07:18.520 --> 07:21.220]  been building in the application.
[07:21.220 --> 07:28.180]  We have implemented some default simulation solvers but you can also add your custom simulation
[07:28.180 --> 07:32.460]  solvers.
[07:32.460 --> 07:40.380]  So we have here is a list of default boxes in the application.
[07:40.380 --> 07:46.500]  We have a math application like addition, multiplication, derivative, etc., signal processing
[07:46.500 --> 07:55.620]  with transfer function, etc., sources, and other like a graph displayer and also open
[07:55.620 --> 08:01.140]  modeling simulation embedder, etc.
[08:01.140 --> 08:07.700]  So if you want to install the application on your PC and want to create your own library
[08:07.700 --> 08:13.100]  of boxes.
[08:13.100 --> 08:24.660]  If we want to create our own box, we have to know that a box is defined by two files.
[08:24.660 --> 08:29.580]  The first one is a description file written in YAML.
[08:29.580 --> 08:35.420]  The second one is a code file written in Python.
[08:35.420 --> 08:41.380]  And there is one condition to make it as a box.
[08:41.380 --> 08:48.220]  It's that both files must share the same base file name.
[08:48.220 --> 08:50.220]  So how to create a box?
[08:50.220 --> 08:51.460]  I will take an example.
[08:51.460 --> 09:01.860]  I will create a box that displays a graphic data in a graph.
[09:01.860 --> 09:12.380]  The goal of the box is to display data in a two-axis plot in X-axis the time and the
[09:12.380 --> 09:15.620]  Y-axis the value.
[09:15.620 --> 09:22.420]  The box must be able to display data from one or more sources.
[09:22.420 --> 09:29.380]  And the graph must be displayed at the end of the simulation.
[09:29.380 --> 09:37.700]  There is how the box must behave during the simulation and at the end of the simulation.
[09:37.700 --> 09:39.620]  So how to create the box?
[09:39.620 --> 09:46.700]  The first step is to define the metadata of the box with the box name, the library name,
[09:46.700 --> 09:54.380]  version, author, and creation date, just a metadata of the box.
[09:54.380 --> 09:59.380]  Then we will define the characteristic of the box.
[09:59.380 --> 10:06.780]  What I mean by characteristic is all the inputs, all the outputs of the box and the parameters.
[10:06.780 --> 10:15.220]  So for the box, for the graphical box, we need three parameters, the title, the label
[10:15.220 --> 10:20.300]  for Y-axis and the label for X-axis.
[10:20.300 --> 10:30.180]  We must define the type of the parameter and we can define a default value.
[10:30.180 --> 10:34.540]  For the outputs, the box doesn't require any outputs.
[10:34.540 --> 10:38.420]  And for the inputs, we have three conditions.
[10:38.420 --> 10:44.460]  The first one, we have defined a default count of inputs to one.
[10:44.460 --> 10:51.380]  So the box, by default, will have one input.
[10:51.380 --> 10:54.500]  The number of inputs must be unlimited.
[10:54.500 --> 11:02.460]  So we must write the parameter is infinite to true.
[11:02.460 --> 11:07.820]  And the number of inputs must be not limited.
[11:07.820 --> 11:12.900]  This means we can define a range of number of inputs.
[11:12.900 --> 11:19.540]  So we can limit, for example, the number of inputs from one to five, for example.
[11:19.540 --> 11:24.700]  But in this case, we won't define any limit.
[11:24.700 --> 11:29.540]  The next step is to define a behavior.
[11:29.540 --> 11:36.460]  So to define the behavior of the box, we write a Python file.
[11:36.460 --> 11:39.340]  We write a Python file.
[11:39.340 --> 11:49.700]  When we write a Python file, we can use all of the available Python libraries.
[11:49.700 --> 11:52.660]  We have to define three functions.
[11:52.660 --> 12:08.620]  The first one, an init function.
[12:08.620 --> 12:13.580]  In our case, this function will init the plot.
[12:13.580 --> 12:18.180]  The second one is during the simulation, what will the box do?
[12:18.180 --> 12:21.820]  What is the process inside the box during the simulation?
[12:21.820 --> 12:25.300]  In our case, it's saving data.
[12:25.300 --> 12:30.020]  And what will the box will do after the simulation?
[12:30.020 --> 12:36.180]  And in our case, it's plot the data.
[12:36.180 --> 12:43.940]  Then the next step is to connect the description file and the code file, the Python file, to
[12:43.940 --> 12:45.740]  connect both.
[12:45.740 --> 12:55.060]  We will only have to write the name of the associated function.
[12:55.060 --> 12:58.340]  Then we have created a box.
[12:58.340 --> 13:01.340]  Now we want to add it in a library.
[13:01.340 --> 13:04.140]  So a library is just a collection of boxes.
[13:04.140 --> 13:11.620]  And in practical, a library is just a folder containing YAML file and Python file.
[13:11.620 --> 13:21.260]  So now a library is a folder that doesn't accept subdirectories.
[13:21.260 --> 13:30.660]  We can't, at the time, we can't put our file in subdirectories.
[13:30.660 --> 13:33.380]  It won't be recognized.
[13:33.380 --> 13:34.780]  So we have our folder.
[13:34.780 --> 13:47.900]  We add our first box with our two files, a second one, et cetera, and it's all we make
[13:47.900 --> 13:50.900]  a library.
[13:50.900 --> 13:59.700]  Another feature we added to Muffin is an IPython interaction.
[13:59.700 --> 14:03.940]  So Muffin can be run in an IPython session.
[14:03.940 --> 14:11.540]  Which means that Muffin can access to all the IPython variables, all variables declared
[14:11.540 --> 14:15.300]  in the IPython environment.
[14:15.300 --> 14:21.380]  We can use all these variables as simulation parameters.
[14:21.380 --> 14:23.860]  And the access to variable is dynamic.
[14:23.860 --> 14:34.900]  It means that if we can launch the application at the beginning of the session, declare variables
[14:34.900 --> 14:39.260]  in the IPython and use it dynamically.
[14:39.260 --> 14:48.340]  So if I launch a first simulation with some parameters, I update it after one simulation.
[14:48.340 --> 14:55.220]  If I launch a second simulation, the second simulation will take the new value into account
[14:55.220 --> 14:59.180]  for the new simulation.
[14:59.180 --> 15:04.340]  How to use it in an IPython session?
[15:04.340 --> 15:10.620]  The first step is to load the Muffin extension with the command load text.
[15:10.620 --> 15:14.940]  And then just run the Muffin command.
[15:14.940 --> 15:19.380]  Here is a demonstration of how it works.
[15:19.380 --> 15:27.860]  So we have firstly declared our parameter in a notebook.
[15:27.860 --> 15:35.620]  We will create a simulation with two assigned signals.
[15:35.620 --> 15:54.660]  And then we will configure all the parameters.
[15:54.660 --> 15:59.940]  We have implemented some information for the user.
[15:59.940 --> 16:22.660]  When he writes a wrong variable name, the application will give the information to the user.
[16:22.660 --> 16:30.380]  So here we have all of both signals, the first one at 10 hertz with an amplitude of 10.
[16:30.380 --> 16:35.380]  And the second one at 5 hertz with an amplitude of 7.
[16:35.380 --> 16:39.700]  I will launch the demonstration.
[16:39.700 --> 16:45.580]  Then we will update the value of the second signal, the amplitude of the second signal
[16:45.580 --> 16:53.500]  only, and we have a signal with the new values.
[16:53.500 --> 16:59.940]  We have implemented all those control features like saving and loading projects, working
[16:59.940 --> 17:11.860]  with multiple projects at the same time, copy and past boxes and cut also, delete in box,
[17:11.860 --> 17:16.500]  then cancel action, etc.
[17:16.500 --> 17:30.740]  So in conclusion, we have developed our own multi-physics simulation software.
[17:30.740 --> 17:37.540]  The advantage of this application is that the application is entirely coded in Python.
[17:37.540 --> 17:43.940]  So we have access to many powerful libraries like NumPy, SciPy, etc., for the application
[17:43.940 --> 17:50.540]  and for the custom processing boxes and simulation solvers.
[17:50.540 --> 17:53.860]  The application is very adaptive.
[17:53.860 --> 18:01.260]  What I mean by that is that you can easily implement your own custom boxes and custom
[18:01.260 --> 18:04.260]  simulation solvers.
[18:04.260 --> 18:09.420]  And the application can be associated to an IPython environment.
[18:09.420 --> 18:21.140]  So Mephine offers a Python alternative to Matlab plus Simulink.
[18:21.140 --> 18:27.620]  These advantages of the application, it's written in a scripting language.
[18:27.620 --> 18:32.660]  So we have a higher solving times.
[18:32.660 --> 18:39.380]  It's a young application at the time, so we need more time to offer a lot of features
[18:39.380 --> 18:45.180]  and we need more users to improve the experience.
[18:45.180 --> 18:46.980]  So what's next?
[18:46.980 --> 18:51.580]  We will have to work on compatibility.
[18:51.580 --> 18:59.300]  We want to make the transition from PyQt5 to PyQt6 and we want to add more interactivity
[18:59.300 --> 19:09.260]  with the user to improve the user friendliness of the application.
[19:09.260 --> 19:18.300]  Here is a list of the contributors of the project and here is the links of the project.
[19:18.300 --> 19:26.620]  If you want to read all the source code, you have a link to the GitLab and if you want
[19:26.620 --> 19:34.500]  to try the application, we have a package available on PyP.
[19:34.500 --> 19:43.820]  If you want to try to install it directly in your Python, you can use PIP install Mephine.
[19:43.820 --> 19:47.020]  So thank you for your attention.
[19:47.020 --> 19:57.020]  If you have some questions.
[19:57.020 --> 20:15.020]  You said you go through electrical analogies to make the calculation, you use the electrical
[20:15.020 --> 20:17.020]  equation, right?
[20:17.020 --> 20:18.020]  Sorry?
[20:18.020 --> 20:19.020]  Can you repeat?
[20:19.020 --> 20:20.020]  I will repeat after you.
[20:20.020 --> 20:27.020]  At the beginning of the presentation, you said you come from physical?
[20:27.020 --> 20:39.620]  Yes, we want to make a Mechatronics simulation and we want to convert all the parts of the
[20:39.620 --> 20:48.820]  system to electrical analogies.
[20:48.820 --> 21:03.660]  We don't use any, at the time we don't use any software like, sorry, I'm a bit stressed.
[21:03.660 --> 21:12.420]  Electrical simulation, I don't remember the name, but the cons with those software is
[21:12.420 --> 21:15.940]  that the model is not dynamic.
[21:15.940 --> 21:27.740]  We can't try a lot of sets easily, but the game of our application is to, with the time,
[21:27.740 --> 21:35.340]  make a box to create an interface to other multiphysics applications.
[21:35.340 --> 21:40.860]  We don't want to replace those applications, we just want to create an interface to those
[21:40.860 --> 21:43.860]  applications to use it in our research project.
[21:43.860 --> 21:51.660]  If I can rebound on that, because in part of the project, the idea is a lot of process
[21:51.660 --> 21:58.260]  can be simulated with impedance like printing, like thermistors, mechanical stuff.
[21:58.260 --> 22:06.660]  You have already an analog between the physical aspect and the electrical impedance stuff.
[22:06.660 --> 22:12.460]  My question was, do you use electrical equations because they are simpler to solve than physical
[22:12.460 --> 22:13.460]  equations?
[22:13.460 --> 22:21.460]  Sorry guys, there is a stream, if you can't hear you, you have to go through the mic.
[22:21.460 --> 22:24.460]  Maybe you can go instead and use the mic if you want to answer that question.
[22:24.460 --> 22:25.460]  Oh, you can repeat.
[22:25.460 --> 22:26.460]  Yeah, that would be great.
[22:26.460 --> 22:27.460]  If you could at least summarize.
[22:27.460 --> 22:36.460]  The goal of the project is to use electrical equations.
[22:37.260 --> 22:47.260]  The goal of the application is to improve the comprehension of the system.
[22:47.260 --> 22:54.260]  Do you plan to make it very untimely, or accelerate the trial process?
[22:54.260 --> 22:57.260]  Sorry, I don't have heard the...
[22:57.260 --> 23:09.060]  Can we in the future make value in the entrance, like the boxes, and change directly the value
[23:09.060 --> 23:19.060]  and see the code directly with its play button?
[23:19.060 --> 23:23.060]  Sorry, I don't have heard the question.
[23:23.860 --> 23:28.860]  I'm a bit...
[23:28.860 --> 23:31.860]  Can you do a real-time simulation?
[23:31.860 --> 23:36.860]  No, the simulation...
[23:36.860 --> 23:39.860]  Can we do a real-time simulation?
[23:39.860 --> 23:41.860]  For now, it's not possible.
[23:41.860 --> 23:44.860]  We want to implement that in the future.
[23:44.860 --> 23:50.860]  For now, the application, we just run the initialization function, then run the simulation
[23:51.660 --> 23:54.660]  and the ending function.
[23:54.660 --> 23:59.660]  And all the functions are run in one time.
[23:59.660 --> 24:07.660]  So at the time, we don't have implemented a real-time overview of the simulation.
[24:07.660 --> 24:12.660]  But we plan in the future to add this feature.
[24:21.660 --> 24:29.660]  In the beginning, you talked about the slow pass and the high inertia and lower inertia
[24:29.660 --> 24:31.660]  pass of your simulations.
[24:31.660 --> 24:40.660]  And you said that your software was designed to deal with local viable solutions and verbal
[24:40.660 --> 24:43.660]  viable simulations.
[24:43.660 --> 24:48.660]  How does that translate into what you've shown us?
[24:48.660 --> 24:51.660]  Where is the global viable part?
[24:51.660 --> 24:54.660]  So I repeat the question.
[24:54.660 --> 25:02.660]  I've said that we have in the system low inertia part and high inertia part.
[25:02.660 --> 25:11.660]  And also local viable simulation software and global viable software.
[25:11.660 --> 25:17.660]  And how does this translate into what you've shown us?
[25:18.660 --> 25:23.660]  Or does it implement it in the application?
[25:23.660 --> 25:25.660]  Yeah, where is it in the application?
[25:25.660 --> 25:29.660]  How does this concept translate into the application in showness?
[25:35.660 --> 25:38.660]  At the time, it's not implemented.
[25:38.660 --> 25:41.660]  It's the background of the project.
[25:42.660 --> 25:47.660]  But it leads to scheduler problems.
[25:47.660 --> 25:50.660]  So the idea is we want to have two schedulers.
[25:50.660 --> 25:56.660]  And since then at this time, you might forget all those things.
[25:58.660 --> 26:01.660]  Discussion can go on in the course.
[26:01.660 --> 26:03.660]  It's a great part of the first day.
[26:03.660 --> 26:05.660]  So go on with the discussion.
[26:05.660 --> 26:08.660]  We should switch speakers now.
[26:08.660 --> 26:10.660]  Thank you.
[26:11.660 --> 26:14.660]  Thank you.
