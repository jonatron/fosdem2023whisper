{"text": " So, hey everyone, Daniel Almeida here from Colabra, and today we're going to be talking a little bit about stateless decoder virtualization using Verdeo Video and Rust, and mainly about what's the status of Verdeo Video in general. There's been this huge hiatus, and different companies now have different downstream patches going on, but recently there's been this new push to get everything upstream. There's been new conversation taking place in the mailing lists, so I think this is a good time to actually do a recap on the Verdeo Video device, and also to showcase how we're using Rust in our own criminalized implementation as Colabra has been working closely with the criminalized engineers to make this happen, so without further ado, I think we can get started. And the first question I think mainly everyone should ask themselves is like, why are we doing this, and how this is important, and the reason why is basically, I think it's two-fold. So, the first thing is that video data is this massive share of the internet traffic. There was some data that was collected by Cisco that predicted that by 2022, 82% of all consumer internet traffic would be like video-related data, up from 77% in 2018, so video data is this huge share of traffic, so this is one thing. The other thing is this new use case for Chromebooks, wherein you can purchase a Chromebook, so a laptop, an ultrabook of sorts, and then you can run Android applications on it, thanks to this ArcVM virtualization layer that they have going on that will transparently virtualize the Android apps so that you can use them on your Chromebook in a somewhat transparent way. This means that a user can use like Netflix, YouTube, and games, and things from the apps in the Play Store, and this makes the device much more useful in general. The idea is that these devices, these Chromebook devices are usually, they are capable of hardware accelerated video decoding, and if they can do that in a hardware accelerated way, it's a good idea to expose this capability to Android apps as well, so that Android apps can benefit from the hardware in the machine. With that said, before we can explore this a tad more, we should be talking a little bit about Viferal 2 memory to memory devices, and I have this figure here, which I've taken from Hans Rikul, the Viferal 2 maintainer, thanks Hans, and it just shows a codec device in the middle, and it's in the middle of two queues, so on the left side, you guys can see what we call the output queue, and on the right side, you guys can see what we call the capture queue, and the idea is that these two queues, they contain buffers, and a user space app will be continuously queuing and dequeuing buffers from these two queues, and the idea is for a decoder, which is the actual type of codec device I want to talk about, we could talk about encoders, but let's just focus on decoders for this presentation. The idea is that for a decoder device, user space applications are going to be queuing bitstream buffers on the output queue, so buffers containing compressed data using some codecs, so VP9, H264, HEVC, and this data will be eventually processed by the device, and then the device will be placing this data on the capture queue, on the buffers in the capture queue, and then eventually the user space app will be able to dequeue these buffers containing the decoder data, so this is a loop that takes place while the device is decoding, and there's also this finite state machine that drives the device as well, so one of the questions that one may make is why is there is this finite state machine in place, and the reason why is this model where we have two queues and the codec device in the middle, it's not sufficient to express some different kind of scenarios, so for instance if you're playing video and you want to do a seek to another position, something that happens very often, you're watching a given portion of a video, then you want to watch a different portion for whatever reason, that's called a seek, and the previous model with only the two queues, it's not capable of expressing that, so the idea is that you'll have a number of different states, and you can transition between these states by issuing ioctals against the video device node that you've presumably previously opened, so think like slash devs slash video zero or something along these lines, you will be opening this video node, and then you'll be issuing ioctals against this video node to transition between states, and eventually you're going to be in the decoding state where a decoding loop is going to take place, and then you'll be queuing and dequeuing buffers for the codec to process. With that said, I want to talk a little bit more about the differences between a stateful and a stateless architecture, and the main difference basically boils down to who's keeping track of the decoding state, so when you're decoding video, there's some state that somebody has to keep track of, usually the set of the decoded picture buffers, among other stuff, and in a stateful architecture, the driver or the firmware will be the piece that's going to be keeping track of that, whereas in a stateless architecture, the guest user space will be the actual program that's going to be keeping track of the decoding state, so in a stateless architecture, the device is just this clean slate that you serve program with some metadata that you extract from the beat stream, and it'll just process that one frame, whereas in a stateful architecture, you just send in data, and the device will be acting as a black box, where you just send it data, and eventually it's going to give you back decoded frames, so it's a different approach to do video decoding in general. With that said, we can talk a little bit about Verdeo Video, so Verdeo Video was initially developed by Google in Open Synergy, and Vistix is the latest submission upstream, there's a kernel driver submission for that, it refers to Verdeo Video version 3, and the Google has downstream patches to use that driver within Chrome OS, so using their own implementation basically, and in Verdeo Video, we basically have two vert cues, vert cues are like this, it's a cue where you can sort of communicate by exchanging memory, this is a Verdeo serve concept, and the idea is that we have two cues in Verdeo Video, one is the command cue, where we'll be pushing data from the driver to the device, so from guest to the host device for processing, we're going to be pushing data, pushing commands, and then we have the event cue where we have the opposite communication taking place, so that the host can inform the guest of things like dynamic resolution changes, or errors, or something along these lines. So the reason we were speaking about stateful and stateless implementations in Viferal 2 memory to memory devices is that the Verdeo Video kernel driver exposes itself as a Viferal 2 stateful device, and why Viferal 2 stateful? Well, first of all, it's a mature interface, it cover cases where the underlying decoder IP is not within a GPU, there are approaches out there that are trying just to like virtualize VA API, or something along these lines, but we really wanted to cater as well for the case where the decoder IP is not within a GPU, because we have devices where this is precisely the case, and also a black box approach is really useful, because we just want to send it data, and we wanted to do its decoding in the background without the guest application being aware that there's this entire virtualization layer going on in the background, and this driver is also heavily based on the Verdeo GPU, which is also upstream in the Linux kernel. So the idea for the kernel driver is really simple, it translates from the Viferal 2 iOctals to Verdeo Video Commands. So the guest user space app will be, as we said, previously issuing Viferal 2 iOctals against this video device node, so that it can sort of change states to eventually end up in the decoding state, and also so that it can be, while it's in the decoding state, so that it can be queuing and dequeuing buffers in that decoding loop. So whenever the device issue iOctals against the video node, the kernel driver will be translating that into Verdeo Video Commands, and then placing these commands in the command queue for further processing by the host device, and by doing this translation, it ends up implementing the Viferal 2 Stateful Finite Stay Machine, and so that a guest user space app doesn't really have to know that there's any virtualization taking place, it just submits iOctals, submits data in the buffers, and eventually it's able to dequeue buffers with the decoded data in them. So here's a small example just to drive home what I'm trying to say here, we have one iOctal being issued by the guest user space in this figure, and in this particular case it's video C create buffs or rec buffs, it's another call as well rec buffs, which is just a way for the guest to say that, or for a user space app to save to Viferal 2 that he wants to allocate buffers. So the Verdeo Video Kernel Driver, which is again a Viferal 2 Stateful device, will intercept that call, it will translate that call into some Verdeo Video Command, it'll place that command in the command queue for processing by the host, and then the host will be talking to this question mark box somehow to process this Verdeo Video Command resource create into something useful. So here's the architecture thus far, we have a, in the guest we have a guest user space app issuing iOctals against the Verdeo Video Kernel Driver, the Verdeo Video Kernel Driver translating these iOctals into Verdeo Video Specific Commands. For our use case here, we have CrossVM which is Google's virtual machine manager, taking these commands in the command queue, dequeuing them, and then processing them using this question mark shaded box in the host. Eventually this shaded box will be somehow decoding the video data, and it'll be piping the the frames back to CrossVM, and then CrossVM will be pushing the frames back using the the virtual queues back to the Verdeo Video Kernel Driver, and then the Verdeo Video Kernel Driver can make the frames available to the guest user space application, which can be like gstreamer, or ffmpeg, or you know other apps. So, and now we have to talk a little bit about what is that shaded question mark box, and these are like CrossVM decoder backends. So what is CrossVM in the first place? Well, CrossVM is this virtual machine manager that's shipped with GromoS, and it's the cornerstone of GromoS virtualization layer. So it's when, for instance, when you're running Android apps in the background, it's CrossVM that's going to be providing the virtualization for it, and it has this huge focus on security. So it's written in Rust, and it's focused on Verdeo devices. And the main idea here being that CrossVM as a virtual machine manager really has no idea how to decode video. This is a very different thing from what it was built to do, so it has to interface with something to get that video data decoded. And that's something which I've denoted with that shaded question mark box, that's something is what we call a back end for CrossVM. So we have like three different backends going on nowadays for CrossVM, the first of which being LibVDA. So the idea with LibVDA is pretty simple. LibVDA is just this library that lets you interface with the Chromium GPU process to actually decode video data. So most of us here know that Chromium is this very mature project with a very mature video decoding stack. So the idea is simple, just use Chromium, ask Chromium to decode data, bam, there you go. But this has a major issue, which is like we have a virtual machine manager which is written in Rust with a focus on security and memory safety and everything, linking against a web browser which is a very different kind of software, which is also by the way not written in Rust. So this is a problem, this is something that the Chromium engineers wanted to do away with, which is why we have like CrossCodeX going on, which is our own crate written in Rust. We also have like an FFM pack back end using the FFM pack software decoders. It's used only for testing so that you can test the radio video implementation in CrossVM without necessarily owning a Chromebook device, you can test that with a regular laptop if you're using the FFM pack back end and also if you're using CrossCodeX. So the idea of FFM pack is just to use it just for testing and we're not integrating it like the hardware like Acceleration and FFM pack because again FFM pack is this huge project written in C which brings us to the topic of CrossCodeX which is our solution. CrossCodeX is basically a crate, a library written in Rust to do video decoding in safe Rust with all the guarantees that the Rust language provide to us, so memory safety, so on and so forth. It's not published on crates.io yet because it's heavily working progress and it contains all the pieces that are necessary in order to do video decoding. So mainly parsers which is where we're going to be extracting the metadata to drive the decoder, the decoder logic which is the piece that's going to be keeping track of things like of the state right which is what we've talked about previously, so things like the set of reference frames and any other kind of information that you have to keep track of between frames and also it itself contains backends as we will see shortly. Currently we have a VA API backend so CrossCodeX will itself use the VA API driver in the system to get a video decoded and they're also working on another backend which is the Vifero 2 stateless backend. So here is a more complete picture I think, so everything in this picture is just that shaded question mark box from earlier, so here you guys can see we have CrossVM, CrossVM will be using for now, CrossVM will be using like CrossCodeX to decode video, CrossCodeX will be using the VA API CrossCodeX backend, it'll be talking to the VA API implementation in the system which will be talking to the VA API driver, so Intel Media Driver or Mesa depending on what graphics card you're using that's going to be talking to DRM in the host kernel and then up until now nobody really knows how to decode video data, but once DRM starts talking with the GPU then the GPU knows how to decode video because it has an IP in there, a circuitry that is specialized in video decoding so the GPU will be doing the video decoding and eventually getting the raw decoded data and then the data will be pushed all the way back until it gets to CrossVM, then when it gets to CrossVM we'll be pushing the data back to the radio video kernel driver in the guest now and then the radio video kernel driver in the guest can make the decoded data available to the guest user space application. So here's some backlog, we still have to upstream the radio video protocol, as I said there's been this new push to get everything upstream, Google is collaborating again with open synergy so that we can get video upstream because it's not upstream yet, we plan on adding more codec support because thus far we only have VP8, VP9 and H264 supported and most people want to see HEVC and AV1 which is like the state of the art for like video decoders. Encoder support for cross codecs in particular while a radio video itself has encoder support, the Google's implementation which involves like cross codecs does not the cross codecs grade does not have encoder support yet, you can encode using libvda which which again is this path that uses the the Chromium GPU process to do video encoding, it's and this is already used in production so it can be used but there's no supporting cross codecs properly yet and we're also working on a referral to stateless back-end in cross codecs so that we can support like more devices. So just a quick summary, Google is already using radio video in production through libvda, we've been working with Chromium as engineers so that the libvda dependency can be removed because Google really wants this to be using Rust, to be using safe Rust code in order to do the video decoding, we plan to upstream radio video like collaboration and working together with Google and working together with other industry players, we plan on upstreaming the radio video protocol and for Google in particular this improves the experience for Chromebook users and not only that but this is like only one application for radio video in general, other companies can can benefit from the radio video work that's been done here to use radio video for their own projects and their own use cases. So that was it, that was basically what I had to say about radio video, I hope that was informative and yeah, thank you very much!", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 14.76, "text": " So, hey everyone, Daniel Almeida here from Colabra, and today we're going to be talking", "tokens": [50364, 407, 11, 4177, 1518, 11, 8033, 967, 1398, 2887, 510, 490, 4004, 455, 424, 11, 293, 965, 321, 434, 516, 281, 312, 1417, 51102], "temperature": 0.0, "avg_logprob": -0.25930339097976685, "compression_ratio": 1.434782608695652, "no_speech_prob": 0.24304769933223724}, {"id": 1, "seek": 0, "start": 14.76, "end": 20.68, "text": " a little bit about stateless decoder virtualization using Verdeo Video and Rust, and mainly about", "tokens": [51102, 257, 707, 857, 466, 2219, 4272, 979, 19866, 6374, 2144, 1228, 4281, 1479, 78, 9777, 293, 34952, 11, 293, 8704, 466, 51398], "temperature": 0.0, "avg_logprob": -0.25930339097976685, "compression_ratio": 1.434782608695652, "no_speech_prob": 0.24304769933223724}, {"id": 2, "seek": 0, "start": 20.68, "end": 23.96, "text": " what's the status of Verdeo Video in general.", "tokens": [51398, 437, 311, 264, 6558, 295, 4281, 1479, 78, 9777, 294, 2674, 13, 51562], "temperature": 0.0, "avg_logprob": -0.25930339097976685, "compression_ratio": 1.434782608695652, "no_speech_prob": 0.24304769933223724}, {"id": 3, "seek": 2396, "start": 23.96, "end": 31.400000000000002, "text": " There's been this huge hiatus, and different companies now have different downstream patches", "tokens": [50364, 821, 311, 668, 341, 2603, 4879, 37926, 11, 293, 819, 3431, 586, 362, 819, 30621, 26531, 50736], "temperature": 0.0, "avg_logprob": -0.17540275349336512, "compression_ratio": 1.6716981132075472, "no_speech_prob": 0.7046940326690674}, {"id": 4, "seek": 2396, "start": 31.400000000000002, "end": 35.92, "text": " going on, but recently there's been this new push to get everything upstream.", "tokens": [50736, 516, 322, 11, 457, 3938, 456, 311, 668, 341, 777, 2944, 281, 483, 1203, 33915, 13, 50962], "temperature": 0.0, "avg_logprob": -0.17540275349336512, "compression_ratio": 1.6716981132075472, "no_speech_prob": 0.7046940326690674}, {"id": 5, "seek": 2396, "start": 35.92, "end": 39.64, "text": " There's been new conversation taking place in the mailing lists, so I think this is a", "tokens": [50962, 821, 311, 668, 777, 3761, 1940, 1081, 294, 264, 41612, 14511, 11, 370, 286, 519, 341, 307, 257, 51148], "temperature": 0.0, "avg_logprob": -0.17540275349336512, "compression_ratio": 1.6716981132075472, "no_speech_prob": 0.7046940326690674}, {"id": 6, "seek": 2396, "start": 39.64, "end": 47.760000000000005, "text": " good time to actually do a recap on the Verdeo Video device, and also to showcase how we're", "tokens": [51148, 665, 565, 281, 767, 360, 257, 20928, 322, 264, 4281, 1479, 78, 9777, 4302, 11, 293, 611, 281, 20388, 577, 321, 434, 51554], "temperature": 0.0, "avg_logprob": -0.17540275349336512, "compression_ratio": 1.6716981132075472, "no_speech_prob": 0.7046940326690674}, {"id": 7, "seek": 2396, "start": 47.760000000000005, "end": 53.24, "text": " using Rust in our own criminalized implementation as Colabra has been working closely with the", "tokens": [51554, 1228, 34952, 294, 527, 1065, 8628, 1602, 11420, 382, 4004, 455, 424, 575, 668, 1364, 8185, 365, 264, 51828], "temperature": 0.0, "avg_logprob": -0.17540275349336512, "compression_ratio": 1.6716981132075472, "no_speech_prob": 0.7046940326690674}, {"id": 8, "seek": 5324, "start": 53.24, "end": 58.92, "text": " criminalized engineers to make this happen, so without further ado, I think we can get", "tokens": [50364, 8628, 1602, 11955, 281, 652, 341, 1051, 11, 370, 1553, 3052, 22450, 11, 286, 519, 321, 393, 483, 50648], "temperature": 0.0, "avg_logprob": -0.2813133526873845, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.08874892443418503}, {"id": 9, "seek": 5324, "start": 58.92, "end": 60.24, "text": " started.", "tokens": [50648, 1409, 13, 50714], "temperature": 0.0, "avg_logprob": -0.2813133526873845, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.08874892443418503}, {"id": 10, "seek": 5324, "start": 60.24, "end": 66.92, "text": " And the first question I think mainly everyone should ask themselves is like, why are we", "tokens": [50714, 400, 264, 700, 1168, 286, 519, 8704, 1518, 820, 1029, 2969, 307, 411, 11, 983, 366, 321, 51048], "temperature": 0.0, "avg_logprob": -0.2813133526873845, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.08874892443418503}, {"id": 11, "seek": 5324, "start": 66.92, "end": 72.96000000000001, "text": " doing this, and how this is important, and the reason why is basically, I think it's", "tokens": [51048, 884, 341, 11, 293, 577, 341, 307, 1021, 11, 293, 264, 1778, 983, 307, 1936, 11, 286, 519, 309, 311, 51350], "temperature": 0.0, "avg_logprob": -0.2813133526873845, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.08874892443418503}, {"id": 12, "seek": 5324, "start": 72.96000000000001, "end": 73.96000000000001, "text": " two-fold.", "tokens": [51350, 732, 12, 18353, 13, 51400], "temperature": 0.0, "avg_logprob": -0.2813133526873845, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.08874892443418503}, {"id": 13, "seek": 5324, "start": 73.96000000000001, "end": 79.52000000000001, "text": " So, the first thing is that video data is this massive share of the internet traffic.", "tokens": [51400, 407, 11, 264, 700, 551, 307, 300, 960, 1412, 307, 341, 5994, 2073, 295, 264, 4705, 6419, 13, 51678], "temperature": 0.0, "avg_logprob": -0.2813133526873845, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.08874892443418503}, {"id": 14, "seek": 7952, "start": 79.52, "end": 85.39999999999999, "text": " There was some data that was collected by Cisco that predicted that by 2022, 82% of", "tokens": [50364, 821, 390, 512, 1412, 300, 390, 11087, 538, 38528, 300, 19147, 300, 538, 20229, 11, 29097, 4, 295, 50658], "temperature": 0.0, "avg_logprob": -0.162487363240805, "compression_ratio": 1.5545023696682465, "no_speech_prob": 0.18467436730861664}, {"id": 15, "seek": 7952, "start": 85.39999999999999, "end": 97.03999999999999, "text": " all consumer internet traffic would be like video-related data, up from 77% in 2018, so", "tokens": [50658, 439, 9711, 4705, 6419, 576, 312, 411, 960, 12, 12004, 1412, 11, 493, 490, 25546, 4, 294, 6096, 11, 370, 51240], "temperature": 0.0, "avg_logprob": -0.162487363240805, "compression_ratio": 1.5545023696682465, "no_speech_prob": 0.18467436730861664}, {"id": 16, "seek": 7952, "start": 97.03999999999999, "end": 102.75999999999999, "text": " video data is this huge share of traffic, so this is one thing.", "tokens": [51240, 960, 1412, 307, 341, 2603, 2073, 295, 6419, 11, 370, 341, 307, 472, 551, 13, 51526], "temperature": 0.0, "avg_logprob": -0.162487363240805, "compression_ratio": 1.5545023696682465, "no_speech_prob": 0.18467436730861664}, {"id": 17, "seek": 7952, "start": 102.75999999999999, "end": 109.44, "text": " The other thing is this new use case for Chromebooks, wherein you can purchase a Chromebook,", "tokens": [51526, 440, 661, 551, 307, 341, 777, 764, 1389, 337, 15327, 15170, 11, 43531, 291, 393, 8110, 257, 15327, 2939, 11, 51860], "temperature": 0.0, "avg_logprob": -0.162487363240805, "compression_ratio": 1.5545023696682465, "no_speech_prob": 0.18467436730861664}, {"id": 18, "seek": 10944, "start": 109.44, "end": 116.28, "text": " so a laptop, an ultrabook of sorts, and then you can run Android applications on it, thanks", "tokens": [50364, 370, 257, 10732, 11, 364, 14808, 2939, 295, 7527, 11, 293, 550, 291, 393, 1190, 8853, 5821, 322, 309, 11, 3231, 50706], "temperature": 0.0, "avg_logprob": -0.1970062255859375, "compression_ratio": 1.660633484162896, "no_speech_prob": 0.12580493092536926}, {"id": 19, "seek": 10944, "start": 116.28, "end": 123.16, "text": " to this ArcVM virtualization layer that they have going on that will transparently virtualize", "tokens": [50706, 281, 341, 21727, 53, 44, 6374, 2144, 4583, 300, 436, 362, 516, 322, 300, 486, 7132, 6420, 6374, 1125, 51050], "temperature": 0.0, "avg_logprob": -0.1970062255859375, "compression_ratio": 1.660633484162896, "no_speech_prob": 0.12580493092536926}, {"id": 20, "seek": 10944, "start": 123.16, "end": 130.16, "text": " the Android apps so that you can use them on your Chromebook in a somewhat transparent", "tokens": [51050, 264, 8853, 7733, 370, 300, 291, 393, 764, 552, 322, 428, 15327, 2939, 294, 257, 8344, 12737, 51400], "temperature": 0.0, "avg_logprob": -0.1970062255859375, "compression_ratio": 1.660633484162896, "no_speech_prob": 0.12580493092536926}, {"id": 21, "seek": 10944, "start": 130.16, "end": 131.6, "text": " way.", "tokens": [51400, 636, 13, 51472], "temperature": 0.0, "avg_logprob": -0.1970062255859375, "compression_ratio": 1.660633484162896, "no_speech_prob": 0.12580493092536926}, {"id": 22, "seek": 10944, "start": 131.6, "end": 138.2, "text": " This means that a user can use like Netflix, YouTube, and games, and things from the apps", "tokens": [51472, 639, 1355, 300, 257, 4195, 393, 764, 411, 12778, 11, 3088, 11, 293, 2813, 11, 293, 721, 490, 264, 7733, 51802], "temperature": 0.0, "avg_logprob": -0.1970062255859375, "compression_ratio": 1.660633484162896, "no_speech_prob": 0.12580493092536926}, {"id": 23, "seek": 13820, "start": 138.23999999999998, "end": 143.76, "text": " in the Play Store, and this makes the device much more useful in general.", "tokens": [50366, 294, 264, 5506, 17242, 11, 293, 341, 1669, 264, 4302, 709, 544, 4420, 294, 2674, 13, 50642], "temperature": 0.0, "avg_logprob": -0.17166255867999533, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.31375429034233093}, {"id": 24, "seek": 13820, "start": 143.76, "end": 148.83999999999997, "text": " The idea is that these devices, these Chromebook devices are usually, they are capable of hardware", "tokens": [50642, 440, 1558, 307, 300, 613, 5759, 11, 613, 15327, 2939, 5759, 366, 2673, 11, 436, 366, 8189, 295, 8837, 50896], "temperature": 0.0, "avg_logprob": -0.17166255867999533, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.31375429034233093}, {"id": 25, "seek": 13820, "start": 148.83999999999997, "end": 155.12, "text": " accelerated video decoding, and if they can do that in a hardware accelerated way, it's", "tokens": [50896, 29763, 960, 979, 8616, 11, 293, 498, 436, 393, 360, 300, 294, 257, 8837, 29763, 636, 11, 309, 311, 51210], "temperature": 0.0, "avg_logprob": -0.17166255867999533, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.31375429034233093}, {"id": 26, "seek": 13820, "start": 155.12, "end": 161.35999999999999, "text": " a good idea to expose this capability to Android apps as well, so that Android apps can benefit", "tokens": [51210, 257, 665, 1558, 281, 19219, 341, 13759, 281, 8853, 7733, 382, 731, 11, 370, 300, 8853, 7733, 393, 5121, 51522], "temperature": 0.0, "avg_logprob": -0.17166255867999533, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.31375429034233093}, {"id": 27, "seek": 13820, "start": 161.35999999999999, "end": 165.51999999999998, "text": " from the hardware in the machine.", "tokens": [51522, 490, 264, 8837, 294, 264, 3479, 13, 51730], "temperature": 0.0, "avg_logprob": -0.17166255867999533, "compression_ratio": 1.7333333333333334, "no_speech_prob": 0.31375429034233093}, {"id": 28, "seek": 16552, "start": 165.52, "end": 170.0, "text": " With that said, before we can explore this a tad more, we should be talking a little", "tokens": [50364, 2022, 300, 848, 11, 949, 321, 393, 6839, 341, 257, 29622, 544, 11, 321, 820, 312, 1417, 257, 707, 50588], "temperature": 0.0, "avg_logprob": -0.18257686956142022, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.6874805688858032}, {"id": 29, "seek": 16552, "start": 170.0, "end": 176.60000000000002, "text": " bit about Viferal 2 memory to memory devices, and I have this figure here, which I've taken", "tokens": [50588, 857, 466, 691, 351, 2790, 568, 4675, 281, 4675, 5759, 11, 293, 286, 362, 341, 2573, 510, 11, 597, 286, 600, 2726, 50918], "temperature": 0.0, "avg_logprob": -0.18257686956142022, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.6874805688858032}, {"id": 30, "seek": 16552, "start": 176.60000000000002, "end": 182.20000000000002, "text": " from Hans Rikul, the Viferal 2 maintainer, thanks Hans, and it just shows a codec device", "tokens": [50918, 490, 17926, 497, 1035, 425, 11, 264, 691, 351, 2790, 568, 6909, 260, 11, 3231, 17926, 11, 293, 309, 445, 3110, 257, 3089, 66, 4302, 51198], "temperature": 0.0, "avg_logprob": -0.18257686956142022, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.6874805688858032}, {"id": 31, "seek": 16552, "start": 182.20000000000002, "end": 186.56, "text": " in the middle, and it's in the middle of two queues, so on the left side, you guys can", "tokens": [51198, 294, 264, 2808, 11, 293, 309, 311, 294, 264, 2808, 295, 732, 631, 1247, 11, 370, 322, 264, 1411, 1252, 11, 291, 1074, 393, 51416], "temperature": 0.0, "avg_logprob": -0.18257686956142022, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.6874805688858032}, {"id": 32, "seek": 16552, "start": 186.56, "end": 190.52, "text": " see what we call the output queue, and on the right side, you guys can see what we call", "tokens": [51416, 536, 437, 321, 818, 264, 5598, 18639, 11, 293, 322, 264, 558, 1252, 11, 291, 1074, 393, 536, 437, 321, 818, 51614], "temperature": 0.0, "avg_logprob": -0.18257686956142022, "compression_ratio": 1.8181818181818181, "no_speech_prob": 0.6874805688858032}, {"id": 33, "seek": 19052, "start": 190.52, "end": 197.76000000000002, "text": " the capture queue, and the idea is that these two queues, they contain buffers, and a user", "tokens": [50364, 264, 7983, 18639, 11, 293, 264, 1558, 307, 300, 613, 732, 631, 1247, 11, 436, 5304, 9204, 433, 11, 293, 257, 4195, 50726], "temperature": 0.0, "avg_logprob": -0.10572438438733418, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.5152833461761475}, {"id": 34, "seek": 19052, "start": 197.76000000000002, "end": 204.84, "text": " space app will be continuously queuing and dequeuing buffers from these two queues, and", "tokens": [50726, 1901, 724, 486, 312, 15684, 631, 9635, 293, 368, 1077, 9635, 9204, 433, 490, 613, 732, 631, 1247, 11, 293, 51080], "temperature": 0.0, "avg_logprob": -0.10572438438733418, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.5152833461761475}, {"id": 35, "seek": 19052, "start": 204.84, "end": 211.08, "text": " the idea is for a decoder, which is the actual type of codec device I want to talk about,", "tokens": [51080, 264, 1558, 307, 337, 257, 979, 19866, 11, 597, 307, 264, 3539, 2010, 295, 3089, 66, 4302, 286, 528, 281, 751, 466, 11, 51392], "temperature": 0.0, "avg_logprob": -0.10572438438733418, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.5152833461761475}, {"id": 36, "seek": 19052, "start": 211.08, "end": 216.44, "text": " we could talk about encoders, but let's just focus on decoders for this presentation.", "tokens": [51392, 321, 727, 751, 466, 2058, 378, 433, 11, 457, 718, 311, 445, 1879, 322, 979, 378, 433, 337, 341, 5860, 13, 51660], "temperature": 0.0, "avg_logprob": -0.10572438438733418, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.5152833461761475}, {"id": 37, "seek": 21644, "start": 216.44, "end": 221.4, "text": " The idea is that for a decoder device, user space applications are going to be queuing", "tokens": [50364, 440, 1558, 307, 300, 337, 257, 979, 19866, 4302, 11, 4195, 1901, 5821, 366, 516, 281, 312, 631, 9635, 50612], "temperature": 0.0, "avg_logprob": -0.13157541855521823, "compression_ratio": 1.6587677725118484, "no_speech_prob": 0.2449330985546112}, {"id": 38, "seek": 21644, "start": 221.4, "end": 228.56, "text": " bitstream buffers on the output queue, so buffers containing compressed data using some", "tokens": [50612, 857, 9291, 9204, 433, 322, 264, 5598, 18639, 11, 370, 9204, 433, 19273, 30353, 1412, 1228, 512, 50970], "temperature": 0.0, "avg_logprob": -0.13157541855521823, "compression_ratio": 1.6587677725118484, "no_speech_prob": 0.2449330985546112}, {"id": 39, "seek": 21644, "start": 228.56, "end": 236.44, "text": " codecs, so VP9, H264, HEVC, and this data will be eventually processed by the device,", "tokens": [50970, 3089, 14368, 11, 370, 35812, 24, 11, 389, 10880, 19, 11, 11827, 53, 34, 11, 293, 341, 1412, 486, 312, 4728, 18846, 538, 264, 4302, 11, 51364], "temperature": 0.0, "avg_logprob": -0.13157541855521823, "compression_ratio": 1.6587677725118484, "no_speech_prob": 0.2449330985546112}, {"id": 40, "seek": 21644, "start": 236.44, "end": 241.52, "text": " and then the device will be placing this data on the capture queue, on the buffers in the", "tokens": [51364, 293, 550, 264, 4302, 486, 312, 17221, 341, 1412, 322, 264, 7983, 18639, 11, 322, 264, 9204, 433, 294, 264, 51618], "temperature": 0.0, "avg_logprob": -0.13157541855521823, "compression_ratio": 1.6587677725118484, "no_speech_prob": 0.2449330985546112}, {"id": 41, "seek": 24152, "start": 241.52, "end": 247.12, "text": " capture queue, and then eventually the user space app will be able to dequeue these buffers", "tokens": [50364, 7983, 18639, 11, 293, 550, 4728, 264, 4195, 1901, 724, 486, 312, 1075, 281, 368, 1077, 622, 613, 9204, 433, 50644], "temperature": 0.0, "avg_logprob": -0.16152215278011628, "compression_ratio": 1.7939698492462313, "no_speech_prob": 0.4297897219657898}, {"id": 42, "seek": 24152, "start": 247.12, "end": 254.08, "text": " containing the decoder data, so this is a loop that takes place while the device is decoding,", "tokens": [50644, 19273, 264, 979, 19866, 1412, 11, 370, 341, 307, 257, 6367, 300, 2516, 1081, 1339, 264, 4302, 307, 979, 8616, 11, 50992], "temperature": 0.0, "avg_logprob": -0.16152215278011628, "compression_ratio": 1.7939698492462313, "no_speech_prob": 0.4297897219657898}, {"id": 43, "seek": 24152, "start": 254.08, "end": 261.12, "text": " and there's also this finite state machine that drives the device as well, so one of", "tokens": [50992, 293, 456, 311, 611, 341, 19362, 1785, 3479, 300, 11754, 264, 4302, 382, 731, 11, 370, 472, 295, 51344], "temperature": 0.0, "avg_logprob": -0.16152215278011628, "compression_ratio": 1.7939698492462313, "no_speech_prob": 0.4297897219657898}, {"id": 44, "seek": 24152, "start": 261.12, "end": 268.04, "text": " the questions that one may make is why is there is this finite state machine in place,", "tokens": [51344, 264, 1651, 300, 472, 815, 652, 307, 983, 307, 456, 307, 341, 19362, 1785, 3479, 294, 1081, 11, 51690], "temperature": 0.0, "avg_logprob": -0.16152215278011628, "compression_ratio": 1.7939698492462313, "no_speech_prob": 0.4297897219657898}, {"id": 45, "seek": 26804, "start": 268.04, "end": 275.28000000000003, "text": " and the reason why is this model where we have two queues and the codec device in the", "tokens": [50364, 293, 264, 1778, 983, 307, 341, 2316, 689, 321, 362, 732, 631, 1247, 293, 264, 3089, 66, 4302, 294, 264, 50726], "temperature": 0.0, "avg_logprob": -0.14601328739753136, "compression_ratio": 1.7804878048780488, "no_speech_prob": 0.15191543102264404}, {"id": 46, "seek": 26804, "start": 275.28000000000003, "end": 282.76000000000005, "text": " middle, it's not sufficient to express some different kind of scenarios, so for instance", "tokens": [50726, 2808, 11, 309, 311, 406, 11563, 281, 5109, 512, 819, 733, 295, 15077, 11, 370, 337, 5197, 51100], "temperature": 0.0, "avg_logprob": -0.14601328739753136, "compression_ratio": 1.7804878048780488, "no_speech_prob": 0.15191543102264404}, {"id": 47, "seek": 26804, "start": 282.76000000000005, "end": 286.56, "text": " if you're playing video and you want to do a seek to another position, something that", "tokens": [51100, 498, 291, 434, 2433, 960, 293, 291, 528, 281, 360, 257, 8075, 281, 1071, 2535, 11, 746, 300, 51290], "temperature": 0.0, "avg_logprob": -0.14601328739753136, "compression_ratio": 1.7804878048780488, "no_speech_prob": 0.15191543102264404}, {"id": 48, "seek": 26804, "start": 286.56, "end": 290.36, "text": " happens very often, you're watching a given portion of a video, then you want to watch", "tokens": [51290, 2314, 588, 2049, 11, 291, 434, 1976, 257, 2212, 8044, 295, 257, 960, 11, 550, 291, 528, 281, 1159, 51480], "temperature": 0.0, "avg_logprob": -0.14601328739753136, "compression_ratio": 1.7804878048780488, "no_speech_prob": 0.15191543102264404}, {"id": 49, "seek": 26804, "start": 290.36, "end": 297.20000000000005, "text": " a different portion for whatever reason, that's called a seek, and the previous model with", "tokens": [51480, 257, 819, 8044, 337, 2035, 1778, 11, 300, 311, 1219, 257, 8075, 11, 293, 264, 3894, 2316, 365, 51822], "temperature": 0.0, "avg_logprob": -0.14601328739753136, "compression_ratio": 1.7804878048780488, "no_speech_prob": 0.15191543102264404}, {"id": 50, "seek": 29720, "start": 297.24, "end": 303.32, "text": " only the two queues, it's not capable of expressing that, so the idea is that you'll have a number", "tokens": [50366, 787, 264, 732, 631, 1247, 11, 309, 311, 406, 8189, 295, 22171, 300, 11, 370, 264, 1558, 307, 300, 291, 603, 362, 257, 1230, 50670], "temperature": 0.0, "avg_logprob": -0.1634334849419995, "compression_ratio": 1.9401709401709402, "no_speech_prob": 0.18696647882461548}, {"id": 51, "seek": 29720, "start": 303.32, "end": 309.03999999999996, "text": " of different states, and you can transition between these states by issuing ioctals against", "tokens": [50670, 295, 819, 4368, 11, 293, 291, 393, 6034, 1296, 613, 4368, 538, 43214, 741, 905, 83, 1124, 1970, 50956], "temperature": 0.0, "avg_logprob": -0.1634334849419995, "compression_ratio": 1.9401709401709402, "no_speech_prob": 0.18696647882461548}, {"id": 52, "seek": 29720, "start": 309.03999999999996, "end": 314.8, "text": " the video device node that you've presumably previously opened, so think like slash devs", "tokens": [50956, 264, 960, 4302, 9984, 300, 291, 600, 26742, 8046, 5625, 11, 370, 519, 411, 17330, 1905, 82, 51244], "temperature": 0.0, "avg_logprob": -0.1634334849419995, "compression_ratio": 1.9401709401709402, "no_speech_prob": 0.18696647882461548}, {"id": 53, "seek": 29720, "start": 314.8, "end": 320.15999999999997, "text": " slash video zero or something along these lines, you will be opening this video node,", "tokens": [51244, 17330, 960, 4018, 420, 746, 2051, 613, 3876, 11, 291, 486, 312, 5193, 341, 960, 9984, 11, 51512], "temperature": 0.0, "avg_logprob": -0.1634334849419995, "compression_ratio": 1.9401709401709402, "no_speech_prob": 0.18696647882461548}, {"id": 54, "seek": 29720, "start": 320.15999999999997, "end": 325.36, "text": " and then you'll be issuing ioctals against this video node to transition between states,", "tokens": [51512, 293, 550, 291, 603, 312, 43214, 741, 905, 83, 1124, 1970, 341, 960, 9984, 281, 6034, 1296, 4368, 11, 51772], "temperature": 0.0, "avg_logprob": -0.1634334849419995, "compression_ratio": 1.9401709401709402, "no_speech_prob": 0.18696647882461548}, {"id": 55, "seek": 32536, "start": 325.36, "end": 329.40000000000003, "text": " and eventually you're going to be in the decoding state where a decoding loop is going to take", "tokens": [50364, 293, 4728, 291, 434, 516, 281, 312, 294, 264, 979, 8616, 1785, 689, 257, 979, 8616, 6367, 307, 516, 281, 747, 50566], "temperature": 0.0, "avg_logprob": -0.12993999889918736, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.027577098459005356}, {"id": 56, "seek": 32536, "start": 329.40000000000003, "end": 336.68, "text": " place, and then you'll be queuing and dequeuing buffers for the codec to process.", "tokens": [50566, 1081, 11, 293, 550, 291, 603, 312, 631, 9635, 293, 368, 1077, 9635, 9204, 433, 337, 264, 3089, 66, 281, 1399, 13, 50930], "temperature": 0.0, "avg_logprob": -0.12993999889918736, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.027577098459005356}, {"id": 57, "seek": 32536, "start": 336.68, "end": 340.92, "text": " With that said, I want to talk a little bit more about the differences between a stateful", "tokens": [50930, 2022, 300, 848, 11, 286, 528, 281, 751, 257, 707, 857, 544, 466, 264, 7300, 1296, 257, 1785, 906, 51142], "temperature": 0.0, "avg_logprob": -0.12993999889918736, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.027577098459005356}, {"id": 58, "seek": 32536, "start": 340.92, "end": 345.56, "text": " and a stateless architecture, and the main difference basically boils down to who's keeping", "tokens": [51142, 293, 257, 2219, 4272, 9482, 11, 293, 264, 2135, 2649, 1936, 35049, 760, 281, 567, 311, 5145, 51374], "temperature": 0.0, "avg_logprob": -0.12993999889918736, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.027577098459005356}, {"id": 59, "seek": 32536, "start": 345.56, "end": 352.44, "text": " track of the decoding state, so when you're decoding video, there's some state that somebody", "tokens": [51374, 2837, 295, 264, 979, 8616, 1785, 11, 370, 562, 291, 434, 979, 8616, 960, 11, 456, 311, 512, 1785, 300, 2618, 51718], "temperature": 0.0, "avg_logprob": -0.12993999889918736, "compression_ratio": 1.825910931174089, "no_speech_prob": 0.027577098459005356}, {"id": 60, "seek": 35244, "start": 352.44, "end": 358.4, "text": " has to keep track of, usually the set of the decoded picture buffers, among other stuff,", "tokens": [50364, 575, 281, 1066, 2837, 295, 11, 2673, 264, 992, 295, 264, 979, 12340, 3036, 9204, 433, 11, 3654, 661, 1507, 11, 50662], "temperature": 0.0, "avg_logprob": -0.15761200297962535, "compression_ratio": 2.039647577092511, "no_speech_prob": 0.03513926640152931}, {"id": 61, "seek": 35244, "start": 358.4, "end": 363.56, "text": " and in a stateful architecture, the driver or the firmware will be the piece that's going to be", "tokens": [50662, 293, 294, 257, 1785, 906, 9482, 11, 264, 6787, 420, 264, 30289, 486, 312, 264, 2522, 300, 311, 516, 281, 312, 50920], "temperature": 0.0, "avg_logprob": -0.15761200297962535, "compression_ratio": 2.039647577092511, "no_speech_prob": 0.03513926640152931}, {"id": 62, "seek": 35244, "start": 363.56, "end": 370.15999999999997, "text": " keeping track of that, whereas in a stateless architecture, the guest user space will be", "tokens": [50920, 5145, 2837, 295, 300, 11, 9735, 294, 257, 2219, 4272, 9482, 11, 264, 8341, 4195, 1901, 486, 312, 51250], "temperature": 0.0, "avg_logprob": -0.15761200297962535, "compression_ratio": 2.039647577092511, "no_speech_prob": 0.03513926640152931}, {"id": 63, "seek": 35244, "start": 370.15999999999997, "end": 375.92, "text": " the actual program that's going to be keeping track of the decoding state, so in a stateless", "tokens": [51250, 264, 3539, 1461, 300, 311, 516, 281, 312, 5145, 2837, 295, 264, 979, 8616, 1785, 11, 370, 294, 257, 2219, 4272, 51538], "temperature": 0.0, "avg_logprob": -0.15761200297962535, "compression_ratio": 2.039647577092511, "no_speech_prob": 0.03513926640152931}, {"id": 64, "seek": 35244, "start": 375.92, "end": 381.12, "text": " architecture, the device is just this clean slate that you serve program with some metadata that", "tokens": [51538, 9482, 11, 264, 4302, 307, 445, 341, 2541, 39118, 300, 291, 4596, 1461, 365, 512, 26603, 300, 51798], "temperature": 0.0, "avg_logprob": -0.15761200297962535, "compression_ratio": 2.039647577092511, "no_speech_prob": 0.03513926640152931}, {"id": 65, "seek": 38112, "start": 381.12, "end": 387.68, "text": " you extract from the beat stream, and it'll just process that one frame, whereas in a stateful", "tokens": [50364, 291, 8947, 490, 264, 4224, 4309, 11, 293, 309, 603, 445, 1399, 300, 472, 3920, 11, 9735, 294, 257, 1785, 906, 50692], "temperature": 0.0, "avg_logprob": -0.16794901544397528, "compression_ratio": 1.673170731707317, "no_speech_prob": 0.09531104564666748}, {"id": 66, "seek": 38112, "start": 387.68, "end": 393.6, "text": " architecture, you just send in data, and the device will be acting as a black box,", "tokens": [50692, 9482, 11, 291, 445, 2845, 294, 1412, 11, 293, 264, 4302, 486, 312, 6577, 382, 257, 2211, 2424, 11, 50988], "temperature": 0.0, "avg_logprob": -0.16794901544397528, "compression_ratio": 1.673170731707317, "no_speech_prob": 0.09531104564666748}, {"id": 67, "seek": 38112, "start": 393.6, "end": 398.44, "text": " where you just send it data, and eventually it's going to give you back decoded frames,", "tokens": [50988, 689, 291, 445, 2845, 309, 1412, 11, 293, 4728, 309, 311, 516, 281, 976, 291, 646, 979, 12340, 12083, 11, 51230], "temperature": 0.0, "avg_logprob": -0.16794901544397528, "compression_ratio": 1.673170731707317, "no_speech_prob": 0.09531104564666748}, {"id": 68, "seek": 38112, "start": 398.44, "end": 406.84000000000003, "text": " so it's a different approach to do video decoding in general. With that said,", "tokens": [51230, 370, 309, 311, 257, 819, 3109, 281, 360, 960, 979, 8616, 294, 2674, 13, 2022, 300, 848, 11, 51650], "temperature": 0.0, "avg_logprob": -0.16794901544397528, "compression_ratio": 1.673170731707317, "no_speech_prob": 0.09531104564666748}, {"id": 69, "seek": 40684, "start": 407.15999999999997, "end": 412.32, "text": " we can talk a little bit about Verdeo Video, so Verdeo Video was initially developed by Google", "tokens": [50380, 321, 393, 751, 257, 707, 857, 466, 4281, 1479, 78, 9777, 11, 370, 4281, 1479, 78, 9777, 390, 9105, 4743, 538, 3329, 50638], "temperature": 0.0, "avg_logprob": -0.2231092760639806, "compression_ratio": 1.6359649122807018, "no_speech_prob": 0.22251108288764954}, {"id": 70, "seek": 40684, "start": 412.32, "end": 418.59999999999997, "text": " in Open Synergy, and Vistix is the latest submission upstream, there's a kernel driver", "tokens": [50638, 294, 7238, 3902, 1193, 1480, 11, 293, 691, 468, 970, 307, 264, 6792, 23689, 33915, 11, 456, 311, 257, 28256, 6787, 50952], "temperature": 0.0, "avg_logprob": -0.2231092760639806, "compression_ratio": 1.6359649122807018, "no_speech_prob": 0.22251108288764954}, {"id": 71, "seek": 40684, "start": 418.59999999999997, "end": 425.28, "text": " submission for that, it refers to Verdeo Video version 3, and the Google has downstream patches", "tokens": [50952, 23689, 337, 300, 11, 309, 14942, 281, 4281, 1479, 78, 9777, 3037, 805, 11, 293, 264, 3329, 575, 30621, 26531, 51286], "temperature": 0.0, "avg_logprob": -0.2231092760639806, "compression_ratio": 1.6359649122807018, "no_speech_prob": 0.22251108288764954}, {"id": 72, "seek": 40684, "start": 425.28, "end": 435.84, "text": " to use that driver within Chrome OS, so using their own implementation basically, and in Verdeo", "tokens": [51286, 281, 764, 300, 6787, 1951, 15327, 12731, 11, 370, 1228, 641, 1065, 11420, 1936, 11, 293, 294, 4281, 1479, 78, 51814], "temperature": 0.0, "avg_logprob": -0.2231092760639806, "compression_ratio": 1.6359649122807018, "no_speech_prob": 0.22251108288764954}, {"id": 73, "seek": 43584, "start": 435.84, "end": 442.88, "text": " Video, we basically have two vert cues, vert cues are like this, it's a cue where you can sort of", "tokens": [50364, 9777, 11, 321, 1936, 362, 732, 6509, 32192, 11, 6509, 32192, 366, 411, 341, 11, 309, 311, 257, 22656, 689, 291, 393, 1333, 295, 50716], "temperature": 0.0, "avg_logprob": -0.17560800231329285, "compression_ratio": 1.7522935779816513, "no_speech_prob": 0.12930968403816223}, {"id": 74, "seek": 43584, "start": 442.88, "end": 449.84, "text": " communicate by exchanging memory, this is a Verdeo serve concept, and the idea is that we have two", "tokens": [50716, 7890, 538, 6210, 9741, 4675, 11, 341, 307, 257, 4281, 1479, 78, 4596, 3410, 11, 293, 264, 1558, 307, 300, 321, 362, 732, 51064], "temperature": 0.0, "avg_logprob": -0.17560800231329285, "compression_ratio": 1.7522935779816513, "no_speech_prob": 0.12930968403816223}, {"id": 75, "seek": 43584, "start": 449.84, "end": 456.0, "text": " cues in Verdeo Video, one is the command cue, where we'll be pushing data from the driver to the", "tokens": [51064, 32192, 294, 4281, 1479, 78, 9777, 11, 472, 307, 264, 5622, 22656, 11, 689, 321, 603, 312, 7380, 1412, 490, 264, 6787, 281, 264, 51372], "temperature": 0.0, "avg_logprob": -0.17560800231329285, "compression_ratio": 1.7522935779816513, "no_speech_prob": 0.12930968403816223}, {"id": 76, "seek": 43584, "start": 456.0, "end": 461.88, "text": " device, so from guest to the host device for processing, we're going to be pushing data,", "tokens": [51372, 4302, 11, 370, 490, 8341, 281, 264, 3975, 4302, 337, 9007, 11, 321, 434, 516, 281, 312, 7380, 1412, 11, 51666], "temperature": 0.0, "avg_logprob": -0.17560800231329285, "compression_ratio": 1.7522935779816513, "no_speech_prob": 0.12930968403816223}, {"id": 77, "seek": 46188, "start": 462.08, "end": 468.76, "text": " pushing commands, and then we have the event cue where we have the opposite communication taking", "tokens": [50374, 7380, 16901, 11, 293, 550, 321, 362, 264, 2280, 22656, 689, 321, 362, 264, 6182, 6101, 1940, 50708], "temperature": 0.0, "avg_logprob": -0.21219541968368902, "compression_ratio": 1.6788990825688073, "no_speech_prob": 0.022623732686042786}, {"id": 78, "seek": 46188, "start": 468.76, "end": 477.2, "text": " place, so that the host can inform the guest of things like dynamic resolution changes,", "tokens": [50708, 1081, 11, 370, 300, 264, 3975, 393, 1356, 264, 8341, 295, 721, 411, 8546, 8669, 2962, 11, 51130], "temperature": 0.0, "avg_logprob": -0.21219541968368902, "compression_ratio": 1.6788990825688073, "no_speech_prob": 0.022623732686042786}, {"id": 79, "seek": 46188, "start": 477.2, "end": 485.88, "text": " or errors, or something along these lines. So the reason we were speaking about stateful", "tokens": [51130, 420, 13603, 11, 420, 746, 2051, 613, 3876, 13, 407, 264, 1778, 321, 645, 4124, 466, 1785, 906, 51564], "temperature": 0.0, "avg_logprob": -0.21219541968368902, "compression_ratio": 1.6788990825688073, "no_speech_prob": 0.022623732686042786}, {"id": 80, "seek": 46188, "start": 485.88, "end": 491.2, "text": " and stateless implementations in Viferal 2 memory to memory devices is that the Verdeo Video", "tokens": [51564, 293, 2219, 4272, 4445, 763, 294, 691, 351, 2790, 568, 4675, 281, 4675, 5759, 307, 300, 264, 4281, 1479, 78, 9777, 51830], "temperature": 0.0, "avg_logprob": -0.21219541968368902, "compression_ratio": 1.6788990825688073, "no_speech_prob": 0.022623732686042786}, {"id": 81, "seek": 49188, "start": 492.08, "end": 499.32, "text": " kernel driver exposes itself as a Viferal 2 stateful device, and why Viferal 2 stateful? Well,", "tokens": [50374, 28256, 6787, 1278, 4201, 2564, 382, 257, 691, 351, 2790, 568, 1785, 906, 4302, 11, 293, 983, 691, 351, 2790, 568, 1785, 906, 30, 1042, 11, 50736], "temperature": 0.0, "avg_logprob": -0.15468868613243103, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.025947820395231247}, {"id": 82, "seek": 49188, "start": 499.32, "end": 505.08, "text": " first of all, it's a mature interface, it cover cases where the underlying decoder IP is not", "tokens": [50736, 700, 295, 439, 11, 309, 311, 257, 14442, 9226, 11, 309, 2060, 3331, 689, 264, 14217, 979, 19866, 8671, 307, 406, 51024], "temperature": 0.0, "avg_logprob": -0.15468868613243103, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.025947820395231247}, {"id": 83, "seek": 49188, "start": 505.08, "end": 511.2, "text": " within a GPU, there are approaches out there that are trying just to like virtualize VA API,", "tokens": [51024, 1951, 257, 18407, 11, 456, 366, 11587, 484, 456, 300, 366, 1382, 445, 281, 411, 6374, 1125, 18527, 9362, 11, 51330], "temperature": 0.0, "avg_logprob": -0.15468868613243103, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.025947820395231247}, {"id": 84, "seek": 49188, "start": 511.2, "end": 516.36, "text": " or something along these lines, but we really wanted to cater as well for the case where the", "tokens": [51330, 420, 746, 2051, 613, 3876, 11, 457, 321, 534, 1415, 281, 21557, 382, 731, 337, 264, 1389, 689, 264, 51588], "temperature": 0.0, "avg_logprob": -0.15468868613243103, "compression_ratio": 1.5541666666666667, "no_speech_prob": 0.025947820395231247}, {"id": 85, "seek": 51636, "start": 516.36, "end": 522.0, "text": " decoder IP is not within a GPU, because we have devices where this is precisely the case,", "tokens": [50364, 979, 19866, 8671, 307, 406, 1951, 257, 18407, 11, 570, 321, 362, 5759, 689, 341, 307, 13402, 264, 1389, 11, 50646], "temperature": 0.0, "avg_logprob": -0.1699953190115995, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.09944286942481995}, {"id": 86, "seek": 51636, "start": 522.0, "end": 527.72, "text": " and also a black box approach is really useful, because we just want to send it data, and we", "tokens": [50646, 293, 611, 257, 2211, 2424, 3109, 307, 534, 4420, 11, 570, 321, 445, 528, 281, 2845, 309, 1412, 11, 293, 321, 50932], "temperature": 0.0, "avg_logprob": -0.1699953190115995, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.09944286942481995}, {"id": 87, "seek": 51636, "start": 527.72, "end": 537.48, "text": " wanted to do its decoding in the background without the guest application being aware that", "tokens": [50932, 1415, 281, 360, 1080, 979, 8616, 294, 264, 3678, 1553, 264, 8341, 3861, 885, 3650, 300, 51420], "temperature": 0.0, "avg_logprob": -0.1699953190115995, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.09944286942481995}, {"id": 88, "seek": 51636, "start": 537.48, "end": 543.12, "text": " there's this entire virtualization layer going on in the background, and this driver is also heavily", "tokens": [51420, 456, 311, 341, 2302, 6374, 2144, 4583, 516, 322, 294, 264, 3678, 11, 293, 341, 6787, 307, 611, 10950, 51702], "temperature": 0.0, "avg_logprob": -0.1699953190115995, "compression_ratio": 1.6771300448430493, "no_speech_prob": 0.09944286942481995}, {"id": 89, "seek": 54312, "start": 543.12, "end": 549.84, "text": " based on the Verdeo GPU, which is also upstream in the Linux kernel. So the idea for the kernel", "tokens": [50364, 2361, 322, 264, 4281, 1479, 78, 18407, 11, 597, 307, 611, 33915, 294, 264, 18734, 28256, 13, 407, 264, 1558, 337, 264, 28256, 50700], "temperature": 0.0, "avg_logprob": -0.16480997696663569, "compression_ratio": 1.59915611814346, "no_speech_prob": 0.018542323261499405}, {"id": 90, "seek": 54312, "start": 549.84, "end": 555.16, "text": " driver is really simple, it translates from the Viferal 2 iOctals to Verdeo Video Commands. So", "tokens": [50700, 6787, 307, 534, 2199, 11, 309, 28468, 490, 264, 691, 351, 2790, 568, 741, 46, 349, 1124, 281, 4281, 1479, 78, 9777, 3046, 2967, 13, 407, 50966], "temperature": 0.0, "avg_logprob": -0.16480997696663569, "compression_ratio": 1.59915611814346, "no_speech_prob": 0.018542323261499405}, {"id": 91, "seek": 54312, "start": 555.16, "end": 562.5600000000001, "text": " the guest user space app will be, as we said, previously issuing Viferal 2 iOctals against", "tokens": [50966, 264, 8341, 4195, 1901, 724, 486, 312, 11, 382, 321, 848, 11, 8046, 43214, 691, 351, 2790, 568, 741, 46, 349, 1124, 1970, 51336], "temperature": 0.0, "avg_logprob": -0.16480997696663569, "compression_ratio": 1.59915611814346, "no_speech_prob": 0.018542323261499405}, {"id": 92, "seek": 54312, "start": 562.5600000000001, "end": 570.24, "text": " this video device node, so that it can sort of change states to eventually end up in the decoding", "tokens": [51336, 341, 960, 4302, 9984, 11, 370, 300, 309, 393, 1333, 295, 1319, 4368, 281, 4728, 917, 493, 294, 264, 979, 8616, 51720], "temperature": 0.0, "avg_logprob": -0.16480997696663569, "compression_ratio": 1.59915611814346, "no_speech_prob": 0.018542323261499405}, {"id": 93, "seek": 57024, "start": 570.24, "end": 577.6, "text": " state, and also so that it can be, while it's in the decoding state, so that it can be queuing and", "tokens": [50364, 1785, 11, 293, 611, 370, 300, 309, 393, 312, 11, 1339, 309, 311, 294, 264, 979, 8616, 1785, 11, 370, 300, 309, 393, 312, 631, 9635, 293, 50732], "temperature": 0.0, "avg_logprob": -0.1525240625653948, "compression_ratio": 1.7824074074074074, "no_speech_prob": 0.020017189905047417}, {"id": 94, "seek": 57024, "start": 577.6, "end": 585.36, "text": " dequeuing buffers in that decoding loop. So whenever the device issue iOctals against the video", "tokens": [50732, 368, 1077, 9635, 9204, 433, 294, 300, 979, 8616, 6367, 13, 407, 5699, 264, 4302, 2734, 741, 46, 349, 1124, 1970, 264, 960, 51120], "temperature": 0.0, "avg_logprob": -0.1525240625653948, "compression_ratio": 1.7824074074074074, "no_speech_prob": 0.020017189905047417}, {"id": 95, "seek": 57024, "start": 585.36, "end": 593.32, "text": " node, the kernel driver will be translating that into Verdeo Video Commands, and then placing these", "tokens": [51120, 9984, 11, 264, 28256, 6787, 486, 312, 35030, 300, 666, 4281, 1479, 78, 9777, 3046, 2967, 11, 293, 550, 17221, 613, 51518], "temperature": 0.0, "avg_logprob": -0.1525240625653948, "compression_ratio": 1.7824074074074074, "no_speech_prob": 0.020017189905047417}, {"id": 96, "seek": 57024, "start": 593.32, "end": 598.92, "text": " commands in the command queue for further processing by the host device, and by doing this", "tokens": [51518, 16901, 294, 264, 5622, 18639, 337, 3052, 9007, 538, 264, 3975, 4302, 11, 293, 538, 884, 341, 51798], "temperature": 0.0, "avg_logprob": -0.1525240625653948, "compression_ratio": 1.7824074074074074, "no_speech_prob": 0.020017189905047417}, {"id": 97, "seek": 59892, "start": 598.9599999999999, "end": 605.76, "text": " translation, it ends up implementing the Viferal 2 Stateful Finite Stay Machine, and so that a guest", "tokens": [50366, 12853, 11, 309, 5314, 493, 18114, 264, 691, 351, 2790, 568, 4533, 906, 3773, 642, 8691, 22155, 11, 293, 370, 300, 257, 8341, 50706], "temperature": 0.0, "avg_logprob": -0.18341800144740514, "compression_ratio": 1.6, "no_speech_prob": 0.008575623854994774}, {"id": 98, "seek": 59892, "start": 605.76, "end": 609.7199999999999, "text": " user space app doesn't really have to know that there's any virtualization taking place, it just", "tokens": [50706, 4195, 1901, 724, 1177, 380, 534, 362, 281, 458, 300, 456, 311, 604, 6374, 2144, 1940, 1081, 11, 309, 445, 50904], "temperature": 0.0, "avg_logprob": -0.18341800144740514, "compression_ratio": 1.6, "no_speech_prob": 0.008575623854994774}, {"id": 99, "seek": 59892, "start": 609.7199999999999, "end": 616.1999999999999, "text": " submits iOctals, submits data in the buffers, and eventually it's able to dequeue buffers with", "tokens": [50904, 8286, 1208, 741, 46, 349, 1124, 11, 8286, 1208, 1412, 294, 264, 9204, 433, 11, 293, 4728, 309, 311, 1075, 281, 368, 1077, 622, 9204, 433, 365, 51228], "temperature": 0.0, "avg_logprob": -0.18341800144740514, "compression_ratio": 1.6, "no_speech_prob": 0.008575623854994774}, {"id": 100, "seek": 59892, "start": 616.1999999999999, "end": 625.8399999999999, "text": " the decoded data in them. So here's a small example just to drive home what I'm trying to say here,", "tokens": [51228, 264, 979, 12340, 1412, 294, 552, 13, 407, 510, 311, 257, 1359, 1365, 445, 281, 3332, 1280, 437, 286, 478, 1382, 281, 584, 510, 11, 51710], "temperature": 0.0, "avg_logprob": -0.18341800144740514, "compression_ratio": 1.6, "no_speech_prob": 0.008575623854994774}, {"id": 101, "seek": 62584, "start": 626.08, "end": 632.48, "text": " we have one iOctal being issued by the guest user space in this figure, and in this particular case", "tokens": [50376, 321, 362, 472, 741, 46, 349, 304, 885, 14379, 538, 264, 8341, 4195, 1901, 294, 341, 2573, 11, 293, 294, 341, 1729, 1389, 50696], "temperature": 0.0, "avg_logprob": -0.1771574373598452, "compression_ratio": 1.6899563318777293, "no_speech_prob": 0.029751498252153397}, {"id": 102, "seek": 62584, "start": 632.48, "end": 638.1600000000001, "text": " it's video C create buffs or rec buffs, it's another call as well rec buffs, which is just a way for", "tokens": [50696, 309, 311, 960, 383, 1884, 50164, 420, 850, 50164, 11, 309, 311, 1071, 818, 382, 731, 850, 50164, 11, 597, 307, 445, 257, 636, 337, 50980], "temperature": 0.0, "avg_logprob": -0.1771574373598452, "compression_ratio": 1.6899563318777293, "no_speech_prob": 0.029751498252153397}, {"id": 103, "seek": 62584, "start": 638.1600000000001, "end": 645.12, "text": " the guest to say that, or for a user space app to save to Viferal 2 that he wants to allocate", "tokens": [50980, 264, 8341, 281, 584, 300, 11, 420, 337, 257, 4195, 1901, 724, 281, 3155, 281, 691, 351, 2790, 568, 300, 415, 2738, 281, 35713, 51328], "temperature": 0.0, "avg_logprob": -0.1771574373598452, "compression_ratio": 1.6899563318777293, "no_speech_prob": 0.029751498252153397}, {"id": 104, "seek": 62584, "start": 645.12, "end": 652.32, "text": " buffers. So the Verdeo Video Kernel Driver, which is again a Viferal 2 Stateful device, will", "tokens": [51328, 9204, 433, 13, 407, 264, 4281, 1479, 78, 9777, 40224, 338, 36048, 11, 597, 307, 797, 257, 691, 351, 2790, 568, 4533, 906, 4302, 11, 486, 51688], "temperature": 0.0, "avg_logprob": -0.1771574373598452, "compression_ratio": 1.6899563318777293, "no_speech_prob": 0.029751498252153397}, {"id": 105, "seek": 65232, "start": 652.32, "end": 658.4000000000001, "text": " intercept that call, it will translate that call into some Verdeo Video Command, it'll place that", "tokens": [50364, 24700, 300, 818, 11, 309, 486, 13799, 300, 818, 666, 512, 4281, 1479, 78, 9777, 17901, 11, 309, 603, 1081, 300, 50668], "temperature": 0.0, "avg_logprob": -0.1193807495964898, "compression_ratio": 1.7953488372093023, "no_speech_prob": 0.0025112805888056755}, {"id": 106, "seek": 65232, "start": 658.4000000000001, "end": 664.08, "text": " command in the command queue for processing by the host, and then the host will be talking to", "tokens": [50668, 5622, 294, 264, 5622, 18639, 337, 9007, 538, 264, 3975, 11, 293, 550, 264, 3975, 486, 312, 1417, 281, 50952], "temperature": 0.0, "avg_logprob": -0.1193807495964898, "compression_ratio": 1.7953488372093023, "no_speech_prob": 0.0025112805888056755}, {"id": 107, "seek": 65232, "start": 664.08, "end": 670.08, "text": " this question mark box somehow to process this Verdeo Video Command resource create into something", "tokens": [50952, 341, 1168, 1491, 2424, 6063, 281, 1399, 341, 4281, 1479, 78, 9777, 17901, 7684, 1884, 666, 746, 51252], "temperature": 0.0, "avg_logprob": -0.1193807495964898, "compression_ratio": 1.7953488372093023, "no_speech_prob": 0.0025112805888056755}, {"id": 108, "seek": 65232, "start": 670.08, "end": 677.44, "text": " useful. So here's the architecture thus far, we have a, in the guest we have a guest user space", "tokens": [51252, 4420, 13, 407, 510, 311, 264, 9482, 8807, 1400, 11, 321, 362, 257, 11, 294, 264, 8341, 321, 362, 257, 8341, 4195, 1901, 51620], "temperature": 0.0, "avg_logprob": -0.1193807495964898, "compression_ratio": 1.7953488372093023, "no_speech_prob": 0.0025112805888056755}, {"id": 109, "seek": 67744, "start": 677.44, "end": 682.32, "text": " app issuing iOctals against the Verdeo Video Kernel Driver, the Verdeo Video Kernel Driver", "tokens": [50364, 724, 43214, 741, 46, 349, 1124, 1970, 264, 4281, 1479, 78, 9777, 40224, 338, 36048, 11, 264, 4281, 1479, 78, 9777, 40224, 338, 36048, 50608], "temperature": 0.0, "avg_logprob": -0.16040273507436117, "compression_ratio": 1.7242990654205608, "no_speech_prob": 0.05919113755226135}, {"id": 110, "seek": 67744, "start": 682.32, "end": 689.84, "text": " translating these iOctals into Verdeo Video Specific Commands. For our use case here, we have CrossVM", "tokens": [50608, 35030, 613, 741, 46, 349, 1124, 666, 4281, 1479, 78, 9777, 20484, 1089, 3046, 2967, 13, 1171, 527, 764, 1389, 510, 11, 321, 362, 11623, 53, 44, 50984], "temperature": 0.0, "avg_logprob": -0.16040273507436117, "compression_ratio": 1.7242990654205608, "no_speech_prob": 0.05919113755226135}, {"id": 111, "seek": 67744, "start": 689.84, "end": 696.5600000000001, "text": " which is Google's virtual machine manager, taking these commands in the command queue,", "tokens": [50984, 597, 307, 3329, 311, 6374, 3479, 6598, 11, 1940, 613, 16901, 294, 264, 5622, 18639, 11, 51320], "temperature": 0.0, "avg_logprob": -0.16040273507436117, "compression_ratio": 1.7242990654205608, "no_speech_prob": 0.05919113755226135}, {"id": 112, "seek": 67744, "start": 696.5600000000001, "end": 702.72, "text": " dequeuing them, and then processing them using this question mark shaded box in the host.", "tokens": [51320, 368, 1077, 9635, 552, 11, 293, 550, 9007, 552, 1228, 341, 1168, 1491, 48067, 2424, 294, 264, 3975, 13, 51628], "temperature": 0.0, "avg_logprob": -0.16040273507436117, "compression_ratio": 1.7242990654205608, "no_speech_prob": 0.05919113755226135}, {"id": 113, "seek": 70272, "start": 703.6800000000001, "end": 711.36, "text": " Eventually this shaded box will be somehow decoding the video data, and it'll be piping the", "tokens": [50412, 17586, 341, 48067, 2424, 486, 312, 6063, 979, 8616, 264, 960, 1412, 11, 293, 309, 603, 312, 35204, 264, 50796], "temperature": 0.0, "avg_logprob": -0.19150796187551397, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.006797280628234148}, {"id": 114, "seek": 70272, "start": 711.36, "end": 716.32, "text": " the frames back to CrossVM, and then CrossVM will be pushing the frames back using the", "tokens": [50796, 264, 12083, 646, 281, 11623, 53, 44, 11, 293, 550, 11623, 53, 44, 486, 312, 7380, 264, 12083, 646, 1228, 264, 51044], "temperature": 0.0, "avg_logprob": -0.19150796187551397, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.006797280628234148}, {"id": 115, "seek": 70272, "start": 717.36, "end": 722.0, "text": " the virtual queues back to the Verdeo Video Kernel Driver, and then the Verdeo Video Kernel Driver", "tokens": [51096, 264, 6374, 631, 1247, 646, 281, 264, 4281, 1479, 78, 9777, 40224, 338, 36048, 11, 293, 550, 264, 4281, 1479, 78, 9777, 40224, 338, 36048, 51328], "temperature": 0.0, "avg_logprob": -0.19150796187551397, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.006797280628234148}, {"id": 116, "seek": 70272, "start": 722.0, "end": 728.24, "text": " can make the frames available to the guest user space application, which can be like gstreamer,", "tokens": [51328, 393, 652, 264, 12083, 2435, 281, 264, 8341, 4195, 1901, 3861, 11, 597, 393, 312, 411, 290, 9291, 260, 11, 51640], "temperature": 0.0, "avg_logprob": -0.19150796187551397, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.006797280628234148}, {"id": 117, "seek": 72824, "start": 728.32, "end": 740.0, "text": " or ffmpeg, or you know other apps. So, and now we have to talk a little bit about what is that", "tokens": [50368, 420, 283, 69, 76, 494, 70, 11, 420, 291, 458, 661, 7733, 13, 407, 11, 293, 586, 321, 362, 281, 751, 257, 707, 857, 466, 437, 307, 300, 50952], "temperature": 0.0, "avg_logprob": -0.15130430314599014, "compression_ratio": 1.4479166666666667, "no_speech_prob": 0.025176241993904114}, {"id": 118, "seek": 72824, "start": 740.0, "end": 747.6, "text": " shaded question mark box, and these are like CrossVM decoder backends. So what is CrossVM in", "tokens": [50952, 48067, 1168, 1491, 2424, 11, 293, 613, 366, 411, 11623, 53, 44, 979, 19866, 646, 2581, 13, 407, 437, 307, 11623, 53, 44, 294, 51332], "temperature": 0.0, "avg_logprob": -0.15130430314599014, "compression_ratio": 1.4479166666666667, "no_speech_prob": 0.025176241993904114}, {"id": 119, "seek": 72824, "start": 747.6, "end": 752.4, "text": " the first place? Well, CrossVM is this virtual machine manager that's shipped with GromoS,", "tokens": [51332, 264, 700, 1081, 30, 1042, 11, 11623, 53, 44, 307, 341, 6374, 3479, 6598, 300, 311, 25312, 365, 2606, 13395, 50, 11, 51572], "temperature": 0.0, "avg_logprob": -0.15130430314599014, "compression_ratio": 1.4479166666666667, "no_speech_prob": 0.025176241993904114}, {"id": 120, "seek": 75240, "start": 752.48, "end": 760.48, "text": " and it's the cornerstone of GromoS virtualization layer. So it's when, for instance, when you're", "tokens": [50368, 293, 309, 311, 264, 4538, 11243, 295, 2606, 13395, 50, 6374, 2144, 4583, 13, 407, 309, 311, 562, 11, 337, 5197, 11, 562, 291, 434, 50768], "temperature": 0.0, "avg_logprob": -0.11887805602129768, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.11754855513572693}, {"id": 121, "seek": 75240, "start": 760.48, "end": 766.8, "text": " running Android apps in the background, it's CrossVM that's going to be providing the virtualization", "tokens": [50768, 2614, 8853, 7733, 294, 264, 3678, 11, 309, 311, 11623, 53, 44, 300, 311, 516, 281, 312, 6530, 264, 6374, 2144, 51084], "temperature": 0.0, "avg_logprob": -0.11887805602129768, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.11754855513572693}, {"id": 122, "seek": 75240, "start": 766.8, "end": 773.12, "text": " for it, and it has this huge focus on security. So it's written in Rust, and it's focused on", "tokens": [51084, 337, 309, 11, 293, 309, 575, 341, 2603, 1879, 322, 3825, 13, 407, 309, 311, 3720, 294, 34952, 11, 293, 309, 311, 5178, 322, 51400], "temperature": 0.0, "avg_logprob": -0.11887805602129768, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.11754855513572693}, {"id": 123, "seek": 75240, "start": 773.12, "end": 780.3199999999999, "text": " Verdeo devices. And the main idea here being that CrossVM as a virtual machine manager really has", "tokens": [51400, 4281, 1479, 78, 5759, 13, 400, 264, 2135, 1558, 510, 885, 300, 11623, 53, 44, 382, 257, 6374, 3479, 6598, 534, 575, 51760], "temperature": 0.0, "avg_logprob": -0.11887805602129768, "compression_ratio": 1.6652360515021458, "no_speech_prob": 0.11754855513572693}, {"id": 124, "seek": 78032, "start": 780.32, "end": 785.2800000000001, "text": " no idea how to decode video. This is a very different thing from what it was built to do,", "tokens": [50364, 572, 1558, 577, 281, 979, 1429, 960, 13, 639, 307, 257, 588, 819, 551, 490, 437, 309, 390, 3094, 281, 360, 11, 50612], "temperature": 0.0, "avg_logprob": -0.08556868167633706, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.010817911475896835}, {"id": 125, "seek": 78032, "start": 785.2800000000001, "end": 790.32, "text": " so it has to interface with something to get that video data decoded. And that's something", "tokens": [50612, 370, 309, 575, 281, 9226, 365, 746, 281, 483, 300, 960, 1412, 979, 12340, 13, 400, 300, 311, 746, 50864], "temperature": 0.0, "avg_logprob": -0.08556868167633706, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.010817911475896835}, {"id": 126, "seek": 78032, "start": 790.32, "end": 795.12, "text": " which I've denoted with that shaded question mark box, that's something is what we call", "tokens": [50864, 597, 286, 600, 1441, 23325, 365, 300, 48067, 1168, 1491, 2424, 11, 300, 311, 746, 307, 437, 321, 818, 51104], "temperature": 0.0, "avg_logprob": -0.08556868167633706, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.010817911475896835}, {"id": 127, "seek": 78032, "start": 796.48, "end": 805.5200000000001, "text": " a back end for CrossVM. So we have like three different backends going on nowadays for CrossVM,", "tokens": [51172, 257, 646, 917, 337, 11623, 53, 44, 13, 407, 321, 362, 411, 1045, 819, 646, 2581, 516, 322, 13434, 337, 11623, 53, 44, 11, 51624], "temperature": 0.0, "avg_logprob": -0.08556868167633706, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.010817911475896835}, {"id": 128, "seek": 80552, "start": 806.0799999999999, "end": 814.8, "text": " the first of which being LibVDA. So the idea with LibVDA is pretty simple. LibVDA is just this", "tokens": [50392, 264, 700, 295, 597, 885, 15834, 53, 7509, 13, 407, 264, 1558, 365, 15834, 53, 7509, 307, 1238, 2199, 13, 15834, 53, 7509, 307, 445, 341, 50828], "temperature": 0.0, "avg_logprob": -0.10236715943845984, "compression_ratio": 1.5359116022099448, "no_speech_prob": 0.01281999982893467}, {"id": 129, "seek": 80552, "start": 814.8, "end": 821.68, "text": " library that lets you interface with the Chromium GPU process to actually decode video data. So", "tokens": [50828, 6405, 300, 6653, 291, 9226, 365, 264, 1721, 298, 2197, 18407, 1399, 281, 767, 979, 1429, 960, 1412, 13, 407, 51172], "temperature": 0.0, "avg_logprob": -0.10236715943845984, "compression_ratio": 1.5359116022099448, "no_speech_prob": 0.01281999982893467}, {"id": 130, "seek": 80552, "start": 823.76, "end": 829.1999999999999, "text": " most of us here know that Chromium is this very mature project with a very mature video", "tokens": [51276, 881, 295, 505, 510, 458, 300, 1721, 298, 2197, 307, 341, 588, 14442, 1716, 365, 257, 588, 14442, 960, 51548], "temperature": 0.0, "avg_logprob": -0.10236715943845984, "compression_ratio": 1.5359116022099448, "no_speech_prob": 0.01281999982893467}, {"id": 131, "seek": 82920, "start": 829.2800000000001, "end": 834.8000000000001, "text": " decoding stack. So the idea is simple, just use Chromium, ask Chromium to decode data,", "tokens": [50368, 979, 8616, 8630, 13, 407, 264, 1558, 307, 2199, 11, 445, 764, 1721, 298, 2197, 11, 1029, 1721, 298, 2197, 281, 979, 1429, 1412, 11, 50644], "temperature": 0.0, "avg_logprob": -0.09673390821977094, "compression_ratio": 1.7063492063492063, "no_speech_prob": 0.17777356505393982}, {"id": 132, "seek": 82920, "start": 834.8000000000001, "end": 840.4000000000001, "text": " bam, there you go. But this has a major issue, which is like we have a virtual machine manager", "tokens": [50644, 18132, 11, 456, 291, 352, 13, 583, 341, 575, 257, 2563, 2734, 11, 597, 307, 411, 321, 362, 257, 6374, 3479, 6598, 50924], "temperature": 0.0, "avg_logprob": -0.09673390821977094, "compression_ratio": 1.7063492063492063, "no_speech_prob": 0.17777356505393982}, {"id": 133, "seek": 82920, "start": 840.4000000000001, "end": 844.96, "text": " which is written in Rust with a focus on security and memory safety and everything,", "tokens": [50924, 597, 307, 3720, 294, 34952, 365, 257, 1879, 322, 3825, 293, 4675, 4514, 293, 1203, 11, 51152], "temperature": 0.0, "avg_logprob": -0.09673390821977094, "compression_ratio": 1.7063492063492063, "no_speech_prob": 0.17777356505393982}, {"id": 134, "seek": 82920, "start": 845.6, "end": 849.2800000000001, "text": " linking against a web browser which is a very different kind of software,", "tokens": [51184, 25775, 1970, 257, 3670, 11185, 597, 307, 257, 588, 819, 733, 295, 4722, 11, 51368], "temperature": 0.0, "avg_logprob": -0.09673390821977094, "compression_ratio": 1.7063492063492063, "no_speech_prob": 0.17777356505393982}, {"id": 135, "seek": 82920, "start": 849.9200000000001, "end": 854.96, "text": " which is also by the way not written in Rust. So this is a problem, this is something that", "tokens": [51400, 597, 307, 611, 538, 264, 636, 406, 3720, 294, 34952, 13, 407, 341, 307, 257, 1154, 11, 341, 307, 746, 300, 51652], "temperature": 0.0, "avg_logprob": -0.09673390821977094, "compression_ratio": 1.7063492063492063, "no_speech_prob": 0.17777356505393982}, {"id": 136, "seek": 85496, "start": 854.96, "end": 860.88, "text": " the Chromium engineers wanted to do away with, which is why we have like CrossCodeX", "tokens": [50364, 264, 1721, 298, 2197, 11955, 1415, 281, 360, 1314, 365, 11, 597, 307, 983, 321, 362, 411, 11623, 34, 1429, 55, 50660], "temperature": 0.0, "avg_logprob": -0.19877340396245322, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.005819819401949644}, {"id": 137, "seek": 85496, "start": 861.9200000000001, "end": 867.84, "text": " going on, which is our own crate written in Rust. We also have like an FFM pack back end using the", "tokens": [50712, 516, 322, 11, 597, 307, 527, 1065, 42426, 3720, 294, 34952, 13, 492, 611, 362, 411, 364, 479, 37, 44, 2844, 646, 917, 1228, 264, 51008], "temperature": 0.0, "avg_logprob": -0.19877340396245322, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.005819819401949644}, {"id": 138, "seek": 85496, "start": 867.84, "end": 875.36, "text": " FFM pack software decoders. It's used only for testing so that you can test the radio video", "tokens": [51008, 479, 37, 44, 2844, 4722, 979, 378, 433, 13, 467, 311, 1143, 787, 337, 4997, 370, 300, 291, 393, 1500, 264, 6477, 960, 51384], "temperature": 0.0, "avg_logprob": -0.19877340396245322, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.005819819401949644}, {"id": 139, "seek": 85496, "start": 875.36, "end": 882.48, "text": " implementation in CrossVM without necessarily owning a Chromebook device, you can test that", "tokens": [51384, 11420, 294, 11623, 53, 44, 1553, 4725, 29820, 257, 15327, 2939, 4302, 11, 291, 393, 1500, 300, 51740], "temperature": 0.0, "avg_logprob": -0.19877340396245322, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.005819819401949644}, {"id": 140, "seek": 88248, "start": 883.28, "end": 891.28, "text": " with a regular laptop if you're using the FFM pack back end and also if you're using CrossCodeX.", "tokens": [50404, 365, 257, 3890, 10732, 498, 291, 434, 1228, 264, 479, 37, 44, 2844, 646, 917, 293, 611, 498, 291, 434, 1228, 11623, 34, 1429, 55, 13, 50804], "temperature": 0.0, "avg_logprob": -0.13050986528396608, "compression_ratio": 1.6201117318435754, "no_speech_prob": 0.004399195779114962}, {"id": 141, "seek": 88248, "start": 892.0, "end": 899.04, "text": " So the idea of FFM pack is just to use it just for testing and we're not integrating it like the", "tokens": [50840, 407, 264, 1558, 295, 479, 37, 44, 2844, 307, 445, 281, 764, 309, 445, 337, 4997, 293, 321, 434, 406, 26889, 309, 411, 264, 51192], "temperature": 0.0, "avg_logprob": -0.13050986528396608, "compression_ratio": 1.6201117318435754, "no_speech_prob": 0.004399195779114962}, {"id": 142, "seek": 88248, "start": 899.04, "end": 906.08, "text": " hardware like Acceleration and FFM pack because again FFM pack is this huge project written in C", "tokens": [51192, 8837, 411, 5725, 16096, 293, 479, 37, 44, 2844, 570, 797, 479, 37, 44, 2844, 307, 341, 2603, 1716, 3720, 294, 383, 51544], "temperature": 0.0, "avg_logprob": -0.13050986528396608, "compression_ratio": 1.6201117318435754, "no_speech_prob": 0.004399195779114962}, {"id": 143, "seek": 90608, "start": 906.88, "end": 913.12, "text": " which brings us to the topic of CrossCodeX which is our solution. CrossCodeX is basically a crate,", "tokens": [50404, 597, 5607, 505, 281, 264, 4829, 295, 11623, 34, 1429, 55, 597, 307, 527, 3827, 13, 11623, 34, 1429, 55, 307, 1936, 257, 42426, 11, 50716], "temperature": 0.0, "avg_logprob": -0.13633407155672708, "compression_ratio": 1.63135593220339, "no_speech_prob": 0.08033403754234314}, {"id": 144, "seek": 90608, "start": 913.12, "end": 921.6800000000001, "text": " a library written in Rust to do video decoding in safe Rust with all the guarantees that the", "tokens": [50716, 257, 6405, 3720, 294, 34952, 281, 360, 960, 979, 8616, 294, 3273, 34952, 365, 439, 264, 32567, 300, 264, 51144], "temperature": 0.0, "avg_logprob": -0.13633407155672708, "compression_ratio": 1.63135593220339, "no_speech_prob": 0.08033403754234314}, {"id": 145, "seek": 90608, "start": 921.6800000000001, "end": 928.5600000000001, "text": " Rust language provide to us, so memory safety, so on and so forth. It's not published on crates.io", "tokens": [51144, 34952, 2856, 2893, 281, 505, 11, 370, 4675, 4514, 11, 370, 322, 293, 370, 5220, 13, 467, 311, 406, 6572, 322, 941, 1024, 13, 1004, 51488], "temperature": 0.0, "avg_logprob": -0.13633407155672708, "compression_ratio": 1.63135593220339, "no_speech_prob": 0.08033403754234314}, {"id": 146, "seek": 90608, "start": 928.5600000000001, "end": 934.5600000000001, "text": " yet because it's heavily working progress and it contains all the pieces that are necessary in", "tokens": [51488, 1939, 570, 309, 311, 10950, 1364, 4205, 293, 309, 8306, 439, 264, 3755, 300, 366, 4818, 294, 51788], "temperature": 0.0, "avg_logprob": -0.13633407155672708, "compression_ratio": 1.63135593220339, "no_speech_prob": 0.08033403754234314}, {"id": 147, "seek": 93456, "start": 934.56, "end": 940.4799999999999, "text": " order to do video decoding. So mainly parsers which is where we're going to be extracting the", "tokens": [50364, 1668, 281, 360, 960, 979, 8616, 13, 407, 8704, 21156, 433, 597, 307, 689, 321, 434, 516, 281, 312, 49844, 264, 50660], "temperature": 0.0, "avg_logprob": -0.09159765243530274, "compression_ratio": 1.7887323943661972, "no_speech_prob": 0.023680824786424637}, {"id": 148, "seek": 93456, "start": 940.4799999999999, "end": 947.68, "text": " metadata to drive the decoder, the decoder logic which is the piece that's going to be keeping", "tokens": [50660, 26603, 281, 3332, 264, 979, 19866, 11, 264, 979, 19866, 9952, 597, 307, 264, 2522, 300, 311, 516, 281, 312, 5145, 51020], "temperature": 0.0, "avg_logprob": -0.09159765243530274, "compression_ratio": 1.7887323943661972, "no_speech_prob": 0.023680824786424637}, {"id": 149, "seek": 93456, "start": 947.68, "end": 952.9599999999999, "text": " track of things like of the state right which is what we've talked about previously, so things like", "tokens": [51020, 2837, 295, 721, 411, 295, 264, 1785, 558, 597, 307, 437, 321, 600, 2825, 466, 8046, 11, 370, 721, 411, 51284], "temperature": 0.0, "avg_logprob": -0.09159765243530274, "compression_ratio": 1.7887323943661972, "no_speech_prob": 0.023680824786424637}, {"id": 150, "seek": 93456, "start": 952.9599999999999, "end": 959.52, "text": " the set of reference frames and any other kind of information that you have to keep track of", "tokens": [51284, 264, 992, 295, 6408, 12083, 293, 604, 661, 733, 295, 1589, 300, 291, 362, 281, 1066, 2837, 295, 51612], "temperature": 0.0, "avg_logprob": -0.09159765243530274, "compression_ratio": 1.7887323943661972, "no_speech_prob": 0.023680824786424637}, {"id": 151, "seek": 95952, "start": 959.52, "end": 968.88, "text": " between frames and also it itself contains backends as we will see shortly. Currently we have a VA API", "tokens": [50364, 1296, 12083, 293, 611, 309, 2564, 8306, 646, 2581, 382, 321, 486, 536, 13392, 13, 19964, 321, 362, 257, 18527, 9362, 50832], "temperature": 0.0, "avg_logprob": -0.1700836181640625, "compression_ratio": 1.5469613259668509, "no_speech_prob": 0.023327989503741264}, {"id": 152, "seek": 95952, "start": 968.88, "end": 977.36, "text": " backend so CrossCodeX will itself use the VA API driver in the system to get a video decoded", "tokens": [50832, 38087, 370, 11623, 34, 1429, 55, 486, 2564, 764, 264, 18527, 9362, 6787, 294, 264, 1185, 281, 483, 257, 960, 979, 12340, 51256], "temperature": 0.0, "avg_logprob": -0.1700836181640625, "compression_ratio": 1.5469613259668509, "no_speech_prob": 0.023327989503741264}, {"id": 153, "seek": 95952, "start": 977.36, "end": 982.64, "text": " and they're also working on another backend which is the Vifero 2 stateless backend.", "tokens": [51256, 293, 436, 434, 611, 1364, 322, 1071, 38087, 597, 307, 264, 691, 351, 2032, 568, 2219, 4272, 38087, 13, 51520], "temperature": 0.0, "avg_logprob": -0.1700836181640625, "compression_ratio": 1.5469613259668509, "no_speech_prob": 0.023327989503741264}, {"id": 154, "seek": 98264, "start": 983.6, "end": 992.96, "text": " So here is a more complete picture I think, so everything in this picture is just that", "tokens": [50412, 407, 510, 307, 257, 544, 3566, 3036, 286, 519, 11, 370, 1203, 294, 341, 3036, 307, 445, 300, 50880], "temperature": 0.0, "avg_logprob": -0.20545604560948624, "compression_ratio": 1.6193181818181819, "no_speech_prob": 0.08631185442209244}, {"id": 155, "seek": 98264, "start": 992.96, "end": 999.36, "text": " shaded question mark box from earlier, so here you guys can see we have CrossVM, CrossVM will be", "tokens": [50880, 48067, 1168, 1491, 2424, 490, 3071, 11, 370, 510, 291, 1074, 393, 536, 321, 362, 11623, 53, 44, 11, 11623, 53, 44, 486, 312, 51200], "temperature": 0.0, "avg_logprob": -0.20545604560948624, "compression_ratio": 1.6193181818181819, "no_speech_prob": 0.08631185442209244}, {"id": 156, "seek": 98264, "start": 999.36, "end": 1008.64, "text": " using for now, CrossVM will be using like CrossCodeX to decode video, CrossCodeX will be using the VA", "tokens": [51200, 1228, 337, 586, 11, 11623, 53, 44, 486, 312, 1228, 411, 11623, 34, 1429, 55, 281, 979, 1429, 960, 11, 11623, 34, 1429, 55, 486, 312, 1228, 264, 18527, 51664], "temperature": 0.0, "avg_logprob": -0.20545604560948624, "compression_ratio": 1.6193181818181819, "no_speech_prob": 0.08631185442209244}, {"id": 157, "seek": 100864, "start": 1008.72, "end": 1014.8, "text": " API CrossCodeX backend, it'll be talking to the VA API implementation in the system which will be", "tokens": [50368, 9362, 11623, 34, 1429, 55, 38087, 11, 309, 603, 312, 1417, 281, 264, 18527, 9362, 11420, 294, 264, 1185, 597, 486, 312, 50672], "temperature": 0.0, "avg_logprob": -0.11737993139969675, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.13113217055797577}, {"id": 158, "seek": 100864, "start": 1014.8, "end": 1022.72, "text": " talking to the VA API driver, so Intel Media Driver or Mesa depending on what graphics card you're", "tokens": [50672, 1417, 281, 264, 18527, 9362, 6787, 11, 370, 19762, 14741, 36048, 420, 376, 13708, 5413, 322, 437, 11837, 2920, 291, 434, 51068], "temperature": 0.0, "avg_logprob": -0.11737993139969675, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.13113217055797577}, {"id": 159, "seek": 100864, "start": 1022.72, "end": 1030.72, "text": " using that's going to be talking to DRM in the host kernel and then up until now nobody really", "tokens": [51068, 1228, 300, 311, 516, 281, 312, 1417, 281, 12118, 44, 294, 264, 3975, 28256, 293, 550, 493, 1826, 586, 5079, 534, 51468], "temperature": 0.0, "avg_logprob": -0.11737993139969675, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.13113217055797577}, {"id": 160, "seek": 100864, "start": 1030.72, "end": 1036.24, "text": " knows how to decode video data, but once DRM starts talking with the GPU then the GPU knows", "tokens": [51468, 3255, 577, 281, 979, 1429, 960, 1412, 11, 457, 1564, 12118, 44, 3719, 1417, 365, 264, 18407, 550, 264, 18407, 3255, 51744], "temperature": 0.0, "avg_logprob": -0.11737993139969675, "compression_ratio": 1.6508620689655173, "no_speech_prob": 0.13113217055797577}, {"id": 161, "seek": 103624, "start": 1036.24, "end": 1042.8, "text": " how to decode video because it has an IP in there, a circuitry that is specialized in video", "tokens": [50364, 577, 281, 979, 1429, 960, 570, 309, 575, 364, 8671, 294, 456, 11, 257, 9048, 627, 300, 307, 19813, 294, 960, 50692], "temperature": 0.0, "avg_logprob": -0.11547829932773236, "compression_ratio": 1.7981220657276995, "no_speech_prob": 0.01743987575173378}, {"id": 162, "seek": 103624, "start": 1042.8, "end": 1049.6, "text": " decoding so the GPU will be doing the video decoding and eventually getting the raw decoded data", "tokens": [50692, 979, 8616, 370, 264, 18407, 486, 312, 884, 264, 960, 979, 8616, 293, 4728, 1242, 264, 8936, 979, 12340, 1412, 51032], "temperature": 0.0, "avg_logprob": -0.11547829932773236, "compression_ratio": 1.7981220657276995, "no_speech_prob": 0.01743987575173378}, {"id": 163, "seek": 103624, "start": 1050.16, "end": 1055.1200000000001, "text": " and then the data will be pushed all the way back until it gets to CrossVM, then when it gets to", "tokens": [51060, 293, 550, 264, 1412, 486, 312, 9152, 439, 264, 636, 646, 1826, 309, 2170, 281, 11623, 53, 44, 11, 550, 562, 309, 2170, 281, 51308], "temperature": 0.0, "avg_logprob": -0.11547829932773236, "compression_ratio": 1.7981220657276995, "no_speech_prob": 0.01743987575173378}, {"id": 164, "seek": 103624, "start": 1055.1200000000001, "end": 1060.16, "text": " CrossVM we'll be pushing the data back to the radio video kernel driver in the guest now and then", "tokens": [51308, 11623, 53, 44, 321, 603, 312, 7380, 264, 1412, 646, 281, 264, 6477, 960, 28256, 6787, 294, 264, 8341, 586, 293, 550, 51560], "temperature": 0.0, "avg_logprob": -0.11547829932773236, "compression_ratio": 1.7981220657276995, "no_speech_prob": 0.01743987575173378}, {"id": 165, "seek": 106016, "start": 1060.16, "end": 1064.96, "text": " the radio video kernel driver in the guest can make the decoded data available to the", "tokens": [50364, 264, 6477, 960, 28256, 6787, 294, 264, 8341, 393, 652, 264, 979, 12340, 1412, 2435, 281, 264, 50604], "temperature": 0.0, "avg_logprob": -0.15248337711196347, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.02716531790792942}, {"id": 166, "seek": 106016, "start": 1067.68, "end": 1074.72, "text": " guest user space application. So here's some backlog, we still have to upstream the radio", "tokens": [50740, 8341, 4195, 1901, 3861, 13, 407, 510, 311, 512, 47364, 11, 321, 920, 362, 281, 33915, 264, 6477, 51092], "temperature": 0.0, "avg_logprob": -0.15248337711196347, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.02716531790792942}, {"id": 167, "seek": 106016, "start": 1074.72, "end": 1080.72, "text": " video protocol, as I said there's been this new push to get everything upstream, Google is collaborating", "tokens": [51092, 960, 10336, 11, 382, 286, 848, 456, 311, 668, 341, 777, 2944, 281, 483, 1203, 33915, 11, 3329, 307, 30188, 51392], "temperature": 0.0, "avg_logprob": -0.15248337711196347, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.02716531790792942}, {"id": 168, "seek": 106016, "start": 1080.72, "end": 1088.88, "text": " again with open synergy so that we can get video upstream because it's not upstream yet,", "tokens": [51392, 797, 365, 1269, 50163, 370, 300, 321, 393, 483, 960, 33915, 570, 309, 311, 406, 33915, 1939, 11, 51800], "temperature": 0.0, "avg_logprob": -0.15248337711196347, "compression_ratio": 1.669683257918552, "no_speech_prob": 0.02716531790792942}, {"id": 169, "seek": 108888, "start": 1088.88, "end": 1094.64, "text": " we plan on adding more codec support because thus far we only have VP8, VP9 and H264", "tokens": [50364, 321, 1393, 322, 5127, 544, 3089, 66, 1406, 570, 8807, 1400, 321, 787, 362, 35812, 23, 11, 35812, 24, 293, 389, 10880, 19, 50652], "temperature": 0.0, "avg_logprob": -0.15601061738055685, "compression_ratio": 1.5859030837004404, "no_speech_prob": 0.008314399048686028}, {"id": 170, "seek": 108888, "start": 1095.44, "end": 1102.48, "text": " supported and most people want to see HEVC and AV1 which is like the state of the art for", "tokens": [50692, 8104, 293, 881, 561, 528, 281, 536, 11827, 53, 34, 293, 30198, 16, 597, 307, 411, 264, 1785, 295, 264, 1523, 337, 51044], "temperature": 0.0, "avg_logprob": -0.15601061738055685, "compression_ratio": 1.5859030837004404, "no_speech_prob": 0.008314399048686028}, {"id": 171, "seek": 108888, "start": 1102.48, "end": 1109.8400000000001, "text": " like video decoders. Encoder support for cross codecs in particular while a radio video itself", "tokens": [51044, 411, 960, 979, 378, 433, 13, 29584, 19866, 1406, 337, 3278, 3089, 14368, 294, 1729, 1339, 257, 6477, 960, 2564, 51412], "temperature": 0.0, "avg_logprob": -0.15601061738055685, "compression_ratio": 1.5859030837004404, "no_speech_prob": 0.008314399048686028}, {"id": 172, "seek": 108888, "start": 1109.8400000000001, "end": 1116.96, "text": " has encoder support, the Google's implementation which involves like cross codecs does not", "tokens": [51412, 575, 2058, 19866, 1406, 11, 264, 3329, 311, 11420, 597, 11626, 411, 3278, 3089, 14368, 775, 406, 51768], "temperature": 0.0, "avg_logprob": -0.15601061738055685, "compression_ratio": 1.5859030837004404, "no_speech_prob": 0.008314399048686028}, {"id": 173, "seek": 111696, "start": 1117.2, "end": 1123.6000000000001, "text": " the cross codecs grade does not have encoder support yet, you can encode using libvda which", "tokens": [50376, 264, 3278, 3089, 14368, 7204, 775, 406, 362, 2058, 19866, 1406, 1939, 11, 291, 393, 2058, 1429, 1228, 22854, 85, 2675, 597, 50696], "temperature": 0.0, "avg_logprob": -0.21539802961452034, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.0035932406317442656}, {"id": 174, "seek": 111696, "start": 1123.6000000000001, "end": 1131.2, "text": " which again is this path that uses the the Chromium GPU process to do video encoding,", "tokens": [50696, 597, 797, 307, 341, 3100, 300, 4960, 264, 264, 1721, 298, 2197, 18407, 1399, 281, 360, 960, 43430, 11, 51076], "temperature": 0.0, "avg_logprob": -0.21539802961452034, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.0035932406317442656}, {"id": 175, "seek": 111696, "start": 1132.32, "end": 1138.24, "text": " it's and this is already used in production so it can be used but there's no supporting cross", "tokens": [51132, 309, 311, 293, 341, 307, 1217, 1143, 294, 4265, 370, 309, 393, 312, 1143, 457, 456, 311, 572, 7231, 3278, 51428], "temperature": 0.0, "avg_logprob": -0.21539802961452034, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.0035932406317442656}, {"id": 176, "seek": 111696, "start": 1138.24, "end": 1143.6000000000001, "text": " codecs properly yet and we're also working on a referral to stateless back-end in cross codecs", "tokens": [51428, 3089, 14368, 6108, 1939, 293, 321, 434, 611, 1364, 322, 257, 33494, 281, 2219, 4272, 646, 12, 521, 294, 3278, 3089, 14368, 51696], "temperature": 0.0, "avg_logprob": -0.21539802961452034, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.0035932406317442656}, {"id": 177, "seek": 114360, "start": 1143.6, "end": 1151.1999999999998, "text": " so that we can support like more devices. So just a quick summary, Google is already using", "tokens": [50364, 370, 300, 321, 393, 1406, 411, 544, 5759, 13, 407, 445, 257, 1702, 12691, 11, 3329, 307, 1217, 1228, 50744], "temperature": 0.0, "avg_logprob": -0.14940239338392622, "compression_ratio": 1.6, "no_speech_prob": 0.005641034804284573}, {"id": 178, "seek": 114360, "start": 1151.1999999999998, "end": 1156.7199999999998, "text": " radio video in production through libvda, we've been working with Chromium as engineers so that", "tokens": [50744, 6477, 960, 294, 4265, 807, 22854, 85, 2675, 11, 321, 600, 668, 1364, 365, 1721, 298, 2197, 382, 11955, 370, 300, 51020], "temperature": 0.0, "avg_logprob": -0.14940239338392622, "compression_ratio": 1.6, "no_speech_prob": 0.005641034804284573}, {"id": 179, "seek": 114360, "start": 1156.7199999999998, "end": 1162.56, "text": " the libvda dependency can be removed because Google really wants this to be using Rust,", "tokens": [51020, 264, 22854, 85, 2675, 33621, 393, 312, 7261, 570, 3329, 534, 2738, 341, 281, 312, 1228, 34952, 11, 51312], "temperature": 0.0, "avg_logprob": -0.14940239338392622, "compression_ratio": 1.6, "no_speech_prob": 0.005641034804284573}, {"id": 180, "seek": 114360, "start": 1162.56, "end": 1169.84, "text": " to be using safe Rust code in order to do the video decoding, we plan to upstream radio video", "tokens": [51312, 281, 312, 1228, 3273, 34952, 3089, 294, 1668, 281, 360, 264, 960, 979, 8616, 11, 321, 1393, 281, 33915, 6477, 960, 51676], "temperature": 0.0, "avg_logprob": -0.14940239338392622, "compression_ratio": 1.6, "no_speech_prob": 0.005641034804284573}, {"id": 181, "seek": 116984, "start": 1169.84, "end": 1174.8, "text": " like collaboration and working together with Google and working together with other industry", "tokens": [50364, 411, 9363, 293, 1364, 1214, 365, 3329, 293, 1364, 1214, 365, 661, 3518, 50612], "temperature": 0.0, "avg_logprob": -0.1235819234476461, "compression_ratio": 1.7850467289719627, "no_speech_prob": 0.06184028089046478}, {"id": 182, "seek": 116984, "start": 1174.8, "end": 1181.76, "text": " players, we plan on upstreaming the radio video protocol and for Google in particular this improves", "tokens": [50612, 4150, 11, 321, 1393, 322, 33915, 278, 264, 6477, 960, 10336, 293, 337, 3329, 294, 1729, 341, 24771, 50960], "temperature": 0.0, "avg_logprob": -0.1235819234476461, "compression_ratio": 1.7850467289719627, "no_speech_prob": 0.06184028089046478}, {"id": 183, "seek": 116984, "start": 1181.76, "end": 1188.24, "text": " the experience for Chromebook users and not only that but this is like only one application for", "tokens": [50960, 264, 1752, 337, 15327, 2939, 5022, 293, 406, 787, 300, 457, 341, 307, 411, 787, 472, 3861, 337, 51284], "temperature": 0.0, "avg_logprob": -0.1235819234476461, "compression_ratio": 1.7850467289719627, "no_speech_prob": 0.06184028089046478}, {"id": 184, "seek": 116984, "start": 1188.24, "end": 1194.3999999999999, "text": " radio video in general, other companies can can benefit from the radio video work that's been", "tokens": [51284, 6477, 960, 294, 2674, 11, 661, 3431, 393, 393, 5121, 490, 264, 6477, 960, 589, 300, 311, 668, 51592], "temperature": 0.0, "avg_logprob": -0.1235819234476461, "compression_ratio": 1.7850467289719627, "no_speech_prob": 0.06184028089046478}, {"id": 185, "seek": 119440, "start": 1194.4, "end": 1200.48, "text": " done here to use radio video for their own projects and their own use cases. So that was", "tokens": [50364, 1096, 510, 281, 764, 6477, 960, 337, 641, 1065, 4455, 293, 641, 1065, 764, 3331, 13, 407, 300, 390, 50668], "temperature": 0.0, "avg_logprob": -0.1838619664030255, "compression_ratio": 1.544776119402985, "no_speech_prob": 0.07365585118532181}, {"id": 186, "seek": 119440, "start": 1200.48, "end": 1206.48, "text": " it, that was basically what I had to say about radio video, I hope that was informative and yeah,", "tokens": [50668, 309, 11, 300, 390, 1936, 437, 286, 632, 281, 584, 466, 6477, 960, 11, 286, 1454, 300, 390, 27759, 293, 1338, 11, 50968], "temperature": 0.0, "avg_logprob": -0.1838619664030255, "compression_ratio": 1.544776119402985, "no_speech_prob": 0.07365585118532181}, {"id": 187, "seek": 119440, "start": 1206.48, "end": 1218.24, "text": " thank you very much!", "tokens": [50968, 1309, 291, 588, 709, 0, 51556], "temperature": 0.0, "avg_logprob": -0.1838619664030255, "compression_ratio": 1.544776119402985, "no_speech_prob": 0.07365585118532181}], "language": "en"}