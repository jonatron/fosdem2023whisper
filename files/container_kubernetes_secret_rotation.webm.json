{"text": " Okay. Our next talk is going to start right now. Mark's already on stage. He's going to talk about automating secrets, rotation, and Kubernetes, and please quiet down so we can understand him. Okay. Hello. Can you hear me? All right. So thank you for joining here today. My name is Mark. I'm an engineer tech lead at Cisco. For the last couple of years, or maybe the better part of the decade, my primary job was helping engineering teams around their business applications and Kubernetes and helping them succeed without having to get into too much details about Kubernetes. Let me start with the story. I'm pretty sure this will sound familiar to a lot of us here. A couple of years ago, I was in the middle of debugging session. It was already the middle of the night. Everyone was tired. And finally, we found a problem. I committed the change, pushed the code, and then suddenly all the buzz went off. We received an e-mail from AWS that a pair of credentials was committed in a public repository. Who did something like that before? Come on. I'm pretty sure it's more than that. There's no shame in that. Everyone has to go through that once. So we obviously had to revoke the credentials, generate a new pair, and deploy it to production. And we were able to do that because we had, like, good secret management pipeline in place. And this kind of hints at why rotating secrets or being able to rotate secrets is important, because if you have an incident like this, you have to be able to act quickly and rotate those secrets and make sure that, well, in a first-case scenario, people may steal your data in a better scenario than AWS. Someone might start mining Bitcoin. But you have to be able to react quickly. Another reason why this is a very important topic is we often have to meet certain compliance requirements that require us to rotate every secret we have, like, every 90 days. I'm pretty sure many of us have to deal with that. But the worst of all, the worst situation of all is when you don't even know that a secret has been leaked. Or maybe an angry ex-employee took something with home. And you don't even know that happened. And they are stealing your data. They are stealing your customer's data. Or they are mining Bitcoin in a better situation. All right. So probably nobody disputes that secret rotation is important. But unfortunately, it comes with its own self-challenges, which often turns people away from actually caring about this. And obviously, secret rotation or managing secrets or configuration is a very complex problem, especially in a Kubernetes environment where you may have multiple different clusters, multiple different in-spaces where you have to deploy these secrets, many different secrets and integration, which means it takes a lot of time to do it right. And it's still an error-prone process. And in an idea scenario, if you screw something up, it may not result in an actual outage or incident. But it may, which is obviously, it would affect the business, which is what we wanted to avoid in the first place by making these secret rotations. So all right. So I'm going to talk about some of the key challenges and why it's important points to that secret rotation should be possible. I mean, it's probably always possible. But I've seen situations where rotating certain secrets would have been very, very hard. Like it would have taken like hours, which is a problem. But so it should be possible. And you should be able to do it relatively quickly. Secret rotation should also be as much automated as possible. Like we are not really trustworthy, like we make mistakes, exhibit A. So it should be ultimately as much as possible. And humans should interact with secrets and secret rotation as little as possible. And finally, secret rotation should happen periodically. Like you shouldn't have a secret that you use for years, because as I mentioned, you don't know if it's been leaked. And if you don't know if it's been leaked, how do you know if your system is secure or not? So how does secret rotation look like in general? We are not even talking about Kubernetes here. First, you need to have a secret store. If you don't have a secret store, then the whole thing is a lot more complex than it should be. You have a secret store where you store your secrets, and then you have some solution to deploy those secrets to your production environment or production environments. Now, when you need to change a secret, depending on what type of secret that is, you have to go to the secret provider, which may be a third-party provider like AWS or GitHub or anything like that. You have to issue a new pair of credentials or generate a new secret, change that in the secret store, and then you need some sort of mechanism to deploy the new secret. That probably should be an automatic process that notices the secret change, and it should deploy the secrets for you in your production environment. Now, in some cases, if you have a secret store that supports that, for example, Hashicorp's vault, your secret store may be able to automatically issue credentials for you, for example, for AWS, your database, or whatever else Hashicorp's vault supports, so you don't even need to do that manually. Hashicorp's vault takes care of that, and that's like the best case scenario. Now, how does this look like in Kubernetes? First of all, you have to decide whether you want to use Kubernetes secrets at all or not. There are options when you don't have to use Kubernetes secrets, but that's probably the easiest way to many secrets in Kubernetes, and the reason why generally people don't like using Kubernetes secrets is because they have this notion that Kubernetes secrets are not secure because they are base 64 encoded, and that's not secure. So that's an entirely different conversation. The bottom line is if you have envelope encryption enabled, which is disabled by default, then you're probably safe using Kubernetes secrets. Now, if you decided to use Kubernetes secrets, then you need something that deploys the secrets from your secret store to Kubernetes, and this could be, for example, the external secrets operator. There are other solutions, but this is probably the one that the community organizes around a lot lately. So external secrets operator is able to synchronize your secrets from an external store, external being to Kubernetes in this case. For example, Hashicorp's vault or AWS secret manager or whatever else you have, external secrets operator is able to synchronize secrets to Kubernetes secrets, and it's also able to pick up changes. It doesn't actively monitor changes, but periodically it takes a look at the secrets, and if something changes, then it synchronizes the changes to Kubernetes. So we have that part covered, and then you can use the Kubernetes secrets, either as environment variables or mount them as files, however you want to use them. Now, the secrets change. What then? So if you mount secrets as files, and your application is able to pick up that change, then you don't have anything to do. Your application will already reload the configuration, and you have the whole thing covered. Now, if your application can't do that, or if your application uses environment variables, you mount secrets as environment variables, but that's a more difficult problem, and for years we didn't really have a solution for that other than manual restarts. A couple of years ago, this component called reloader appeared on the market, which basically watches workloads that have, that references secrets, and it also watches the secrets, obviously, and when it detects a change, it triggers a standard workload rollout, similarly to how you would do that with kubectl rollout, for example. So it may change the annotation of the workload, and that would result in the workload being rolled out, which means that it would run with the new environment variables, and it would remount the secret with the changed file. And if we take a look at the whole process from the previous diagram, we don't have one component that takes care of the deployment, in this case, but we have two, one that synchronizes the secrets from the secrets store to Kubernetes, and the other one that takes care of the rollouts, or making sure that the workloads notice the secret change. Well, let's take a look at a very quick demo, how that looks like in action, and I have a repository prepared, you can go ahead and try it if you want to, and I have a Kubernetes cluster running here with both external secrets and reloader installed, and in addition to that, we have like a simple echo server, which just, I believe it's, yeah, we just output something. So let's take a look at how we configure external secrets first. So as I mentioned, you configure external secrets, or maybe I don't need to mention, I don't know, but you configure external secrets via custom resources, which means you create, can you see it from the back? Okay, cool. So you configure external secrets via custom resource called external secret, and you tell external secrets to, you tell external secrets how to, and from which external store should it synchronize secrets from, and where it should put it. So in this case, we are telling external secrets to synchronize secrets from a store I created and called as fake. This is basically a static secret store in this case. It synchronizes secrets into a secret called full bar, and it's going to synchronize from the fake secret store under the key, from under the key full slash bar to a key under hello in the Kubernetes secret. So let's take a look at, if we do, in fact, have that secret there. So we have a full bar secret. That's good so far. And we have a hello key here. I'm sure if you can see that. Now, if I change this secret right now, this, this is just a command that patches the external or the fake store to change the secret value. If I go back and check the secret value, it should be changed to everyone. Now, if I try to curdle the service again, there are no changes here. So if I manually restart the pod, let's see, do I have the command here? Yeah, I have a rollout command. If I manually restart the pod and restart the port forward as well, then I should see that the secret value is in fact changed. Maybe I haven't shown you, but I do have the application deployment here that references the full bar secret. All right. So now we have the secret synchronization part covered. Now, let's see how it works if I want the workload to be automatically rolled out when the secret changes. So I can annotate the echo server with this reloader annotation, which will make reloader start watching this workload and the secrets mounted in it. So nothing changed yet. I should still see everyone. That's fine. And now let's change the secret again to fuzz them. So if I, yeah, the secret is changed to fuzz them. And if we take a look at the, I probably have to restart this. If we take a look at the service, it should now say hello fuzz them. So in this case, I didn't have to restart the virtual manually because reloader did that for me when I changed the secret. When I changed the secret in the store, that external secret synchronized into the Kubernetes secret and reloader noticed that change, so it rolled out the deployment. So that's what I wanted to show you today. If you have any questions, I'm happy to answer them. Hi. Thanks for your presentation. Can we use a reloader? Can you speak up, please, because I can't hear you. Please stay quiet. Thank you. Can we use reloader without Kubernetes secrets? Because we're one of, can we use reloader without syncing to Kubernetes secrets? I mean, you absolutely can. So with reloader, you can watch either secrets or config maps or both if you want to. But you need to use Kubernetes secrets and config maps. How do you change secrets is up to you. If you don't want to automatically synchronize, you don't have to. You can use reloader just to trigger a reload without using external secrets or synchronized secrets. So if you want to do that manually, you can absolutely do that. Does it answer your question? No. I would like to do something like synchronize secrets right into volumes, for example, like skipping Kubernetes secrets totally, because we don't want to, like, resist that in that CD. So no, probably reloader is not really useful in that case. But I see what you mean. So if you, for example, if you use something like bolt-amp and you grab the secrets directly from within the pod and you want to trigger a reload, then no, reloader can't be used that way. But we are actually working, so I'm from Cisco and before that I was working for Banzai Cloud and we are working on a solution right now exactly for that so we can have, like, a component that watches secrets that have external bolt references and reloads a component or trigger reloads for workloads based on those changes. But none of these tools support that at the moment. So are there some risks of using this method instead of using, for example, a secret vault? I mean, with a secret vault, if you watch for a file and if you watch for a secret that should be written in a file or somewhere, if the secret change vault usually emits a signal like a sig up to reload the process. So what when the secret changes? Usually vault emits a signal, an up signal to reload the process and load the configuration. In this way you are reloading the whole container so there are some risks. The problem is that only works if you talk to a vault directly from your workloads and with the solution you don't have to integrate vault directly, like you can use whatever secret story you want to. And the problem is that vault doesn't actually know where it should set its signal. So in this case you may deploy the secrets to a number of different clusters and the logists wouldn't know where to send those signals. So the minor advantage is that it's fully transparent to the solution. I don't know. We have time for one more question. Any advice about some tools to do the rotation on the other part, like, for example, rotate the standard database credentials, something like that, that will automatically update in the secret store then trigger the workshop? The problem with that is that secret providers, like, there are many different secret providers. So it's really hard to build a central solution for that. But hashicorp vault is one. Hashicorp vault has a bunch of, I think it's called old backends or something like that, that you can use to issue credentials, for example, to a Postgres database. And that credential can actually have a TTL, a deadline. And then after a certain time, hashicorp's vault would issue a new pair of credentials and then external secrets would be able to synchronize those credentials. We actually use that with AWS back end. And that's how we rotate database credentials every 90 days. Okay. Thank you so much for the talk. Thank you for all the questions. Thank you for staying quiet. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 13.0, "text": " Okay. Our next talk is going to start right now. Mark's already on stage. He's going to", "tokens": [1033, 13, 2621, 958, 751, 307, 516, 281, 722, 558, 586, 13, 3934, 311, 1217, 322, 3233, 13, 634, 311, 516, 281], "temperature": 0.0, "avg_logprob": -0.27017439966616424, "compression_ratio": 1.3333333333333333, "no_speech_prob": 0.4843122661113739}, {"id": 1, "seek": 0, "start": 13.0, "end": 18.080000000000002, "text": " talk about automating secrets, rotation, and Kubernetes, and please quiet down so we can", "tokens": [751, 466, 3553, 990, 14093, 11, 12447, 11, 293, 23145, 11, 293, 1767, 5677, 760, 370, 321, 393], "temperature": 0.0, "avg_logprob": -0.27017439966616424, "compression_ratio": 1.3333333333333333, "no_speech_prob": 0.4843122661113739}, {"id": 2, "seek": 1808, "start": 18.08, "end": 41.08, "text": " understand him. Okay. Hello. Can you hear me? All right. So thank you for joining here today. My name is Mark. I'm an engineer", "tokens": [1223, 796, 13, 1033, 13, 2425, 13, 1664, 291, 1568, 385, 30, 1057, 558, 13, 407, 1309, 291, 337, 5549, 510, 965, 13, 1222, 1315, 307, 3934, 13, 286, 478, 364, 11403], "temperature": 0.0, "avg_logprob": -0.2844630877176921, "compression_ratio": 1.1454545454545455, "no_speech_prob": 0.00046959982137195766}, {"id": 3, "seek": 4108, "start": 41.08, "end": 49.08, "text": " tech lead at Cisco. For the last couple of years, or maybe the better part of the decade, my primary job was helping", "tokens": [7553, 1477, 412, 38528, 13, 1171, 264, 1036, 1916, 295, 924, 11, 420, 1310, 264, 1101, 644, 295, 264, 10378, 11, 452, 6194, 1691, 390, 4315], "temperature": 0.0, "avg_logprob": -0.23119965082482447, "compression_ratio": 1.5739130434782609, "no_speech_prob": 0.00033560022711753845}, {"id": 4, "seek": 4108, "start": 49.08, "end": 57.08, "text": " engineering teams around their business applications and Kubernetes and helping them succeed without having to get into too", "tokens": [7043, 5491, 926, 641, 1606, 5821, 293, 23145, 293, 4315, 552, 7754, 1553, 1419, 281, 483, 666, 886], "temperature": 0.0, "avg_logprob": -0.23119965082482447, "compression_ratio": 1.5739130434782609, "no_speech_prob": 0.00033560022711753845}, {"id": 5, "seek": 4108, "start": 57.08, "end": 68.08, "text": " much details about Kubernetes. Let me start with the story. I'm pretty sure this will sound familiar to a lot of us here.", "tokens": [709, 4365, 466, 23145, 13, 961, 385, 722, 365, 264, 1657, 13, 286, 478, 1238, 988, 341, 486, 1626, 4963, 281, 257, 688, 295, 505, 510, 13], "temperature": 0.0, "avg_logprob": -0.23119965082482447, "compression_ratio": 1.5739130434782609, "no_speech_prob": 0.00033560022711753845}, {"id": 6, "seek": 6808, "start": 68.08, "end": 78.08, "text": " A couple of years ago, I was in the middle of debugging session. It was already the middle of the night. Everyone was tired. And finally, we", "tokens": [316, 1916, 295, 924, 2057, 11, 286, 390, 294, 264, 2808, 295, 45592, 5481, 13, 467, 390, 1217, 264, 2808, 295, 264, 1818, 13, 5198, 390, 5868, 13, 400, 2721, 11, 321], "temperature": 0.0, "avg_logprob": -0.19476790926349696, "compression_ratio": 1.4860335195530727, "no_speech_prob": 8.847515709931031e-05}, {"id": 7, "seek": 6808, "start": 78.08, "end": 89.08, "text": " found a problem. I committed the change, pushed the code, and then suddenly all the buzz went off. We received an e-mail from", "tokens": [1352, 257, 1154, 13, 286, 7784, 264, 1319, 11, 9152, 264, 3089, 11, 293, 550, 5800, 439, 264, 13036, 1437, 766, 13, 492, 4613, 364, 308, 12, 11799, 490], "temperature": 0.0, "avg_logprob": -0.19476790926349696, "compression_ratio": 1.4860335195530727, "no_speech_prob": 8.847515709931031e-05}, {"id": 8, "seek": 8908, "start": 89.08, "end": 99.08, "text": " AWS that a pair of credentials was committed in a public repository. Who did something like that before? Come on. I'm pretty", "tokens": [17650, 300, 257, 6119, 295, 27404, 390, 7784, 294, 257, 1908, 25841, 13, 2102, 630, 746, 411, 300, 949, 30, 2492, 322, 13, 286, 478, 1238], "temperature": 0.0, "avg_logprob": -0.14137006067967678, "compression_ratio": 1.5508474576271187, "no_speech_prob": 2.5402079700143076e-05}, {"id": 9, "seek": 8908, "start": 99.08, "end": 109.08, "text": " sure it's more than that. There's no shame in that. Everyone has to go through that once. So we obviously had to revoke the", "tokens": [988, 309, 311, 544, 813, 300, 13, 821, 311, 572, 10069, 294, 300, 13, 5198, 575, 281, 352, 807, 300, 1564, 13, 407, 321, 2745, 632, 281, 3698, 2949, 264], "temperature": 0.0, "avg_logprob": -0.14137006067967678, "compression_ratio": 1.5508474576271187, "no_speech_prob": 2.5402079700143076e-05}, {"id": 10, "seek": 8908, "start": 109.08, "end": 117.08, "text": " credentials, generate a new pair, and deploy it to production. And we were able to do that because we had, like, good", "tokens": [27404, 11, 8460, 257, 777, 6119, 11, 293, 7274, 309, 281, 4265, 13, 400, 321, 645, 1075, 281, 360, 300, 570, 321, 632, 11, 411, 11, 665], "temperature": 0.0, "avg_logprob": -0.14137006067967678, "compression_ratio": 1.5508474576271187, "no_speech_prob": 2.5402079700143076e-05}, {"id": 11, "seek": 11708, "start": 117.08, "end": 125.08, "text": " secret management pipeline in place. And this kind of hints at why rotating secrets or being able to rotate secrets is", "tokens": [4054, 4592, 15517, 294, 1081, 13, 400, 341, 733, 295, 27271, 412, 983, 19627, 14093, 420, 885, 1075, 281, 13121, 14093, 307], "temperature": 0.0, "avg_logprob": -0.1188018031236602, "compression_ratio": 1.6605504587155964, "no_speech_prob": 7.800391176715493e-05}, {"id": 12, "seek": 11708, "start": 125.08, "end": 132.07999999999998, "text": " important, because if you have an incident like this, you have to be able to act quickly and rotate those secrets and make", "tokens": [1021, 11, 570, 498, 291, 362, 364, 9348, 411, 341, 11, 291, 362, 281, 312, 1075, 281, 605, 2661, 293, 13121, 729, 14093, 293, 652], "temperature": 0.0, "avg_logprob": -0.1188018031236602, "compression_ratio": 1.6605504587155964, "no_speech_prob": 7.800391176715493e-05}, {"id": 13, "seek": 11708, "start": 132.07999999999998, "end": 141.07999999999998, "text": " sure that, well, in a first-case scenario, people may steal your data in a better scenario than AWS. Someone might start", "tokens": [988, 300, 11, 731, 11, 294, 257, 700, 12, 9765, 9005, 11, 561, 815, 11009, 428, 1412, 294, 257, 1101, 9005, 813, 17650, 13, 8734, 1062, 722], "temperature": 0.0, "avg_logprob": -0.1188018031236602, "compression_ratio": 1.6605504587155964, "no_speech_prob": 7.800391176715493e-05}, {"id": 14, "seek": 14108, "start": 141.08, "end": 150.08, "text": " mining Bitcoin. But you have to be able to react quickly. Another reason why this is a very important topic is we often have to", "tokens": [15512, 11414, 13, 583, 291, 362, 281, 312, 1075, 281, 4515, 2661, 13, 3996, 1778, 983, 341, 307, 257, 588, 1021, 4829, 307, 321, 2049, 362, 281], "temperature": 0.0, "avg_logprob": -0.08435712920294867, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00010680471314117312}, {"id": 15, "seek": 14108, "start": 150.08, "end": 160.08, "text": " meet certain compliance requirements that require us to rotate every secret we have, like, every 90 days. I'm pretty sure many of", "tokens": [1677, 1629, 15882, 7728, 300, 3651, 505, 281, 13121, 633, 4054, 321, 362, 11, 411, 11, 633, 4289, 1708, 13, 286, 478, 1238, 988, 867, 295], "temperature": 0.0, "avg_logprob": -0.08435712920294867, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00010680471314117312}, {"id": 16, "seek": 14108, "start": 160.08, "end": 169.08, "text": " us have to deal with that. But the worst of all, the worst situation of all is when you don't even know that a secret has", "tokens": [505, 362, 281, 2028, 365, 300, 13, 583, 264, 5855, 295, 439, 11, 264, 5855, 2590, 295, 439, 307, 562, 291, 500, 380, 754, 458, 300, 257, 4054, 575], "temperature": 0.0, "avg_logprob": -0.08435712920294867, "compression_ratio": 1.6406926406926408, "no_speech_prob": 0.00010680471314117312}, {"id": 17, "seek": 16908, "start": 169.08, "end": 177.08, "text": " been leaked. Or maybe an angry ex-employee took something with home. And you don't even know that happened. And they are", "tokens": [668, 31779, 13, 1610, 1310, 364, 6884, 454, 12, 12112, 1653, 1890, 746, 365, 1280, 13, 400, 291, 500, 380, 754, 458, 300, 2011, 13, 400, 436, 366], "temperature": 0.0, "avg_logprob": -0.13437473924854135, "compression_ratio": 1.5898617511520738, "no_speech_prob": 6.400078564183787e-05}, {"id": 18, "seek": 16908, "start": 177.08, "end": 185.08, "text": " stealing your data. They are stealing your customer's data. Or they are mining Bitcoin in a better situation.", "tokens": [19757, 428, 1412, 13, 814, 366, 19757, 428, 5474, 311, 1412, 13, 1610, 436, 366, 15512, 11414, 294, 257, 1101, 2590, 13], "temperature": 0.0, "avg_logprob": -0.13437473924854135, "compression_ratio": 1.5898617511520738, "no_speech_prob": 6.400078564183787e-05}, {"id": 19, "seek": 16908, "start": 185.08, "end": 192.08, "text": " All right. So probably nobody disputes that secret rotation is important. But unfortunately, it comes with its own", "tokens": [1057, 558, 13, 407, 1391, 5079, 39666, 300, 4054, 12447, 307, 1021, 13, 583, 7015, 11, 309, 1487, 365, 1080, 1065], "temperature": 0.0, "avg_logprob": -0.13437473924854135, "compression_ratio": 1.5898617511520738, "no_speech_prob": 6.400078564183787e-05}, {"id": 20, "seek": 19208, "start": 192.08, "end": 201.08, "text": " self-challenges, which often turns people away from actually caring about this. And obviously, secret rotation or managing", "tokens": [2698, 12, 339, 336, 47077, 11, 597, 2049, 4523, 561, 1314, 490, 767, 15365, 466, 341, 13, 400, 2745, 11, 4054, 12447, 420, 11642], "temperature": 0.0, "avg_logprob": -0.1390000581741333, "compression_ratio": 1.6527777777777777, "no_speech_prob": 8.03888397058472e-05}, {"id": 21, "seek": 19208, "start": 201.08, "end": 207.08, "text": " secrets or configuration is a very complex problem, especially in a Kubernetes environment where you may have multiple", "tokens": [14093, 420, 11694, 307, 257, 588, 3997, 1154, 11, 2318, 294, 257, 23145, 2823, 689, 291, 815, 362, 3866], "temperature": 0.0, "avg_logprob": -0.1390000581741333, "compression_ratio": 1.6527777777777777, "no_speech_prob": 8.03888397058472e-05}, {"id": 22, "seek": 19208, "start": 207.08, "end": 213.08, "text": " different clusters, multiple different in-spaces where you have to deploy these secrets, many different secrets and", "tokens": [819, 23313, 11, 3866, 819, 294, 12, 4952, 2116, 689, 291, 362, 281, 7274, 613, 14093, 11, 867, 819, 14093, 293], "temperature": 0.0, "avg_logprob": -0.1390000581741333, "compression_ratio": 1.6527777777777777, "no_speech_prob": 8.03888397058472e-05}, {"id": 23, "seek": 21308, "start": 213.08, "end": 224.08, "text": " integration, which means it takes a lot of time to do it right. And it's still an error-prone process. And in an idea", "tokens": [10980, 11, 597, 1355, 309, 2516, 257, 688, 295, 565, 281, 360, 309, 558, 13, 400, 309, 311, 920, 364, 6713, 12, 1424, 546, 1399, 13, 400, 294, 364, 1558], "temperature": 0.0, "avg_logprob": -0.1411289592365642, "compression_ratio": 1.592920353982301, "no_speech_prob": 6.694313196931034e-05}, {"id": 24, "seek": 21308, "start": 224.08, "end": 233.08, "text": " scenario, if you screw something up, it may not result in an actual outage or incident. But it may, which is obviously, it", "tokens": [9005, 11, 498, 291, 5630, 746, 493, 11, 309, 815, 406, 1874, 294, 364, 3539, 484, 609, 420, 9348, 13, 583, 309, 815, 11, 597, 307, 2745, 11, 309], "temperature": 0.0, "avg_logprob": -0.1411289592365642, "compression_ratio": 1.592920353982301, "no_speech_prob": 6.694313196931034e-05}, {"id": 25, "seek": 21308, "start": 233.08, "end": 241.08, "text": " would affect the business, which is what we wanted to avoid in the first place by making these secret rotations. So all", "tokens": [576, 3345, 264, 1606, 11, 597, 307, 437, 321, 1415, 281, 5042, 294, 264, 700, 1081, 538, 1455, 613, 4054, 44796, 13, 407, 439], "temperature": 0.0, "avg_logprob": -0.1411289592365642, "compression_ratio": 1.592920353982301, "no_speech_prob": 6.694313196931034e-05}, {"id": 26, "seek": 24108, "start": 241.08, "end": 248.08, "text": " right. So I'm going to talk about some of the key challenges and why it's important points to that secret rotation", "tokens": [558, 13, 407, 286, 478, 516, 281, 751, 466, 512, 295, 264, 2141, 4759, 293, 983, 309, 311, 1021, 2793, 281, 300, 4054, 12447], "temperature": 0.0, "avg_logprob": -0.2695910563835731, "compression_ratio": 1.76953125, "no_speech_prob": 0.00011481759429443628}, {"id": 27, "seek": 24108, "start": 248.08, "end": 256.08000000000004, "text": " should be possible. I mean, it's probably always possible. But I've seen situations where rotating certain secrets would", "tokens": [820, 312, 1944, 13, 286, 914, 11, 309, 311, 1391, 1009, 1944, 13, 583, 286, 600, 1612, 6851, 689, 19627, 1629, 14093, 576], "temperature": 0.0, "avg_logprob": -0.2695910563835731, "compression_ratio": 1.76953125, "no_speech_prob": 0.00011481759429443628}, {"id": 28, "seek": 24108, "start": 256.08000000000004, "end": 263.08000000000004, "text": " have been very, very hard. Like it would have taken like hours, which is a problem. But so it should be possible. And", "tokens": [362, 668, 588, 11, 588, 1152, 13, 1743, 309, 576, 362, 2726, 411, 2496, 11, 597, 307, 257, 1154, 13, 583, 370, 309, 820, 312, 1944, 13, 400], "temperature": 0.0, "avg_logprob": -0.2695910563835731, "compression_ratio": 1.76953125, "no_speech_prob": 0.00011481759429443628}, {"id": 29, "seek": 24108, "start": 263.08000000000004, "end": 270.08000000000004, "text": " you should be able to do it relatively quickly. Secret rotation should also be as much automated as", "tokens": [291, 820, 312, 1075, 281, 360, 309, 7226, 2661, 13, 7400, 12447, 820, 611, 312, 382, 709, 18473, 382], "temperature": 0.0, "avg_logprob": -0.2695910563835731, "compression_ratio": 1.76953125, "no_speech_prob": 0.00011481759429443628}, {"id": 30, "seek": 27008, "start": 270.08, "end": 280.08, "text": " possible. Like we are not really trustworthy, like we make mistakes, exhibit A. So it should be ultimately as much as", "tokens": [1944, 13, 1743, 321, 366, 406, 534, 39714, 11, 411, 321, 652, 8038, 11, 20487, 316, 13, 407, 309, 820, 312, 6284, 382, 709, 382], "temperature": 0.0, "avg_logprob": -0.148733461057985, "compression_ratio": 1.7087378640776698, "no_speech_prob": 6.968867819523439e-05}, {"id": 31, "seek": 27008, "start": 280.08, "end": 288.08, "text": " possible. And humans should interact with secrets and secret rotation as little as possible. And finally, secret", "tokens": [1944, 13, 400, 6255, 820, 4648, 365, 14093, 293, 4054, 12447, 382, 707, 382, 1944, 13, 400, 2721, 11, 4054], "temperature": 0.0, "avg_logprob": -0.148733461057985, "compression_ratio": 1.7087378640776698, "no_speech_prob": 6.968867819523439e-05}, {"id": 32, "seek": 27008, "start": 288.08, "end": 295.08, "text": " rotation should happen periodically. Like you shouldn't have a secret that you use for years, because as I mentioned, you", "tokens": [12447, 820, 1051, 38916, 13, 1743, 291, 4659, 380, 362, 257, 4054, 300, 291, 764, 337, 924, 11, 570, 382, 286, 2835, 11, 291], "temperature": 0.0, "avg_logprob": -0.148733461057985, "compression_ratio": 1.7087378640776698, "no_speech_prob": 6.968867819523439e-05}, {"id": 33, "seek": 29508, "start": 295.08, "end": 304.08, "text": " don't know if it's been leaked. And if you don't know if it's been leaked, how do you know if your system is secure or not?", "tokens": [500, 380, 458, 498, 309, 311, 668, 31779, 13, 400, 498, 291, 500, 380, 458, 498, 309, 311, 668, 31779, 11, 577, 360, 291, 458, 498, 428, 1185, 307, 7144, 420, 406, 30], "temperature": 0.0, "avg_logprob": -0.05870297614564287, "compression_ratio": 1.6901408450704225, "no_speech_prob": 2.5014720449689776e-05}, {"id": 34, "seek": 29508, "start": 304.08, "end": 313.08, "text": " So how does secret rotation look like in general? We are not even talking about Kubernetes here. First, you need to", "tokens": [407, 577, 775, 4054, 12447, 574, 411, 294, 2674, 30, 492, 366, 406, 754, 1417, 466, 23145, 510, 13, 2386, 11, 291, 643, 281], "temperature": 0.0, "avg_logprob": -0.05870297614564287, "compression_ratio": 1.6901408450704225, "no_speech_prob": 2.5014720449689776e-05}, {"id": 35, "seek": 29508, "start": 313.08, "end": 320.08, "text": " have a secret store. If you don't have a secret store, then the whole thing is a lot more complex than it should be. You", "tokens": [362, 257, 4054, 3531, 13, 759, 291, 500, 380, 362, 257, 4054, 3531, 11, 550, 264, 1379, 551, 307, 257, 688, 544, 3997, 813, 309, 820, 312, 13, 509], "temperature": 0.0, "avg_logprob": -0.05870297614564287, "compression_ratio": 1.6901408450704225, "no_speech_prob": 2.5014720449689776e-05}, {"id": 36, "seek": 32008, "start": 320.08, "end": 326.08, "text": " have a secret store where you store your secrets, and then you have some solution to deploy those secrets to your production", "tokens": [362, 257, 4054, 3531, 689, 291, 3531, 428, 14093, 11, 293, 550, 291, 362, 512, 3827, 281, 7274, 729, 14093, 281, 428, 4265], "temperature": 0.0, "avg_logprob": -0.09189938631924716, "compression_ratio": 1.9365079365079365, "no_speech_prob": 8.263882773462683e-05}, {"id": 37, "seek": 32008, "start": 326.08, "end": 333.08, "text": " environment or production environments. Now, when you need to change a secret, depending on what type of secret that is,", "tokens": [2823, 420, 4265, 12388, 13, 823, 11, 562, 291, 643, 281, 1319, 257, 4054, 11, 5413, 322, 437, 2010, 295, 4054, 300, 307, 11], "temperature": 0.0, "avg_logprob": -0.09189938631924716, "compression_ratio": 1.9365079365079365, "no_speech_prob": 8.263882773462683e-05}, {"id": 38, "seek": 32008, "start": 333.08, "end": 341.08, "text": " you have to go to the secret provider, which may be a third-party provider like AWS or GitHub or anything like that. You", "tokens": [291, 362, 281, 352, 281, 264, 4054, 12398, 11, 597, 815, 312, 257, 2636, 12, 23409, 12398, 411, 17650, 420, 23331, 420, 1340, 411, 300, 13, 509], "temperature": 0.0, "avg_logprob": -0.09189938631924716, "compression_ratio": 1.9365079365079365, "no_speech_prob": 8.263882773462683e-05}, {"id": 39, "seek": 32008, "start": 341.08, "end": 348.08, "text": " have to issue a new pair of credentials or generate a new secret, change that in the secret store, and then you need some", "tokens": [362, 281, 2734, 257, 777, 6119, 295, 27404, 420, 8460, 257, 777, 4054, 11, 1319, 300, 294, 264, 4054, 3531, 11, 293, 550, 291, 643, 512], "temperature": 0.0, "avg_logprob": -0.09189938631924716, "compression_ratio": 1.9365079365079365, "no_speech_prob": 8.263882773462683e-05}, {"id": 40, "seek": 34808, "start": 348.08, "end": 358.08, "text": " sort of mechanism to deploy the new secret. That probably should be an automatic process that notices the secret", "tokens": [1333, 295, 7513, 281, 7274, 264, 777, 4054, 13, 663, 1391, 820, 312, 364, 12509, 1399, 300, 32978, 264, 4054], "temperature": 0.0, "avg_logprob": -0.13225607554117838, "compression_ratio": 1.625, "no_speech_prob": 3.381674468982965e-05}, {"id": 41, "seek": 34808, "start": 358.08, "end": 364.08, "text": " change, and it should deploy the secrets for you in your production environment. Now, in some cases, if you have a secret", "tokens": [1319, 11, 293, 309, 820, 7274, 264, 14093, 337, 291, 294, 428, 4265, 2823, 13, 823, 11, 294, 512, 3331, 11, 498, 291, 362, 257, 4054], "temperature": 0.0, "avg_logprob": -0.13225607554117838, "compression_ratio": 1.625, "no_speech_prob": 3.381674468982965e-05}, {"id": 42, "seek": 34808, "start": 364.08, "end": 369.08, "text": " store that supports that, for example, Hashicorp's vault, your secret store may be able to", "tokens": [3531, 300, 9346, 300, 11, 337, 1365, 11, 30775, 299, 18703, 311, 27134, 11, 428, 4054, 3531, 815, 312, 1075, 281], "temperature": 0.0, "avg_logprob": -0.13225607554117838, "compression_ratio": 1.625, "no_speech_prob": 3.381674468982965e-05}, {"id": 43, "seek": 36908, "start": 369.08, "end": 378.08, "text": " automatically issue credentials for you, for example, for AWS, your database, or whatever else Hashicorp's vault supports, so you", "tokens": [6772, 2734, 27404, 337, 291, 11, 337, 1365, 11, 337, 17650, 11, 428, 8149, 11, 420, 2035, 1646, 30775, 299, 18703, 311, 27134, 9346, 11, 370, 291], "temperature": 0.0, "avg_logprob": -0.10502881192146464, "compression_ratio": 1.5975103734439835, "no_speech_prob": 1.9275996237411164e-05}, {"id": 44, "seek": 36908, "start": 378.08, "end": 386.08, "text": " don't even need to do that manually. Hashicorp's vault takes care of that, and that's like the best case scenario. Now, how does", "tokens": [500, 380, 754, 643, 281, 360, 300, 16945, 13, 30775, 299, 18703, 311, 27134, 2516, 1127, 295, 300, 11, 293, 300, 311, 411, 264, 1151, 1389, 9005, 13, 823, 11, 577, 775], "temperature": 0.0, "avg_logprob": -0.10502881192146464, "compression_ratio": 1.5975103734439835, "no_speech_prob": 1.9275996237411164e-05}, {"id": 45, "seek": 36908, "start": 386.08, "end": 393.08, "text": " this look like in Kubernetes? First of all, you have to decide whether you want to use Kubernetes secrets at all or not. There", "tokens": [341, 574, 411, 294, 23145, 30, 2386, 295, 439, 11, 291, 362, 281, 4536, 1968, 291, 528, 281, 764, 23145, 14093, 412, 439, 420, 406, 13, 821], "temperature": 0.0, "avg_logprob": -0.10502881192146464, "compression_ratio": 1.5975103734439835, "no_speech_prob": 1.9275996237411164e-05}, {"id": 46, "seek": 39308, "start": 393.08, "end": 401.08, "text": " are options when you don't have to use Kubernetes secrets, but that's probably the easiest way to many secrets in", "tokens": [366, 3956, 562, 291, 500, 380, 362, 281, 764, 23145, 14093, 11, 457, 300, 311, 1391, 264, 12889, 636, 281, 867, 14093, 294], "temperature": 0.0, "avg_logprob": -0.11755489048204924, "compression_ratio": 1.8219895287958114, "no_speech_prob": 2.8074362489860505e-05}, {"id": 47, "seek": 39308, "start": 401.08, "end": 408.08, "text": " Kubernetes, and the reason why generally people don't like using Kubernetes secrets is because they have this notion that", "tokens": [23145, 11, 293, 264, 1778, 983, 5101, 561, 500, 380, 411, 1228, 23145, 14093, 307, 570, 436, 362, 341, 10710, 300], "temperature": 0.0, "avg_logprob": -0.11755489048204924, "compression_ratio": 1.8219895287958114, "no_speech_prob": 2.8074362489860505e-05}, {"id": 48, "seek": 39308, "start": 408.08, "end": 416.08, "text": " Kubernetes secrets are not secure because they are base 64 encoded, and that's not secure. So that's an entirely", "tokens": [23145, 14093, 366, 406, 7144, 570, 436, 366, 3096, 12145, 2058, 12340, 11, 293, 300, 311, 406, 7144, 13, 407, 300, 311, 364, 7696], "temperature": 0.0, "avg_logprob": -0.11755489048204924, "compression_ratio": 1.8219895287958114, "no_speech_prob": 2.8074362489860505e-05}, {"id": 49, "seek": 41608, "start": 416.08, "end": 425.08, "text": " different conversation. The bottom line is if you have envelope encryption enabled, which is disabled by default, then you're", "tokens": [819, 3761, 13, 440, 2767, 1622, 307, 498, 291, 362, 19989, 29575, 15172, 11, 597, 307, 15191, 538, 7576, 11, 550, 291, 434], "temperature": 0.0, "avg_logprob": -0.11928269669816301, "compression_ratio": 1.6761904761904762, "no_speech_prob": 4.705489845946431e-05}, {"id": 50, "seek": 41608, "start": 425.08, "end": 433.08, "text": " probably safe using Kubernetes secrets. Now, if you decided to use Kubernetes secrets, then you need something that", "tokens": [1391, 3273, 1228, 23145, 14093, 13, 823, 11, 498, 291, 3047, 281, 764, 23145, 14093, 11, 550, 291, 643, 746, 300], "temperature": 0.0, "avg_logprob": -0.11928269669816301, "compression_ratio": 1.6761904761904762, "no_speech_prob": 4.705489845946431e-05}, {"id": 51, "seek": 41608, "start": 433.08, "end": 440.08, "text": " deploys the secrets from your secret store to Kubernetes, and this could be, for example, the external secrets", "tokens": [368, 49522, 264, 14093, 490, 428, 4054, 3531, 281, 23145, 11, 293, 341, 727, 312, 11, 337, 1365, 11, 264, 8320, 14093], "temperature": 0.0, "avg_logprob": -0.11928269669816301, "compression_ratio": 1.6761904761904762, "no_speech_prob": 4.705489845946431e-05}, {"id": 52, "seek": 44008, "start": 440.08, "end": 447.08, "text": " operator. There are other solutions, but this is probably the one that the community organizes around a lot lately. So", "tokens": [12973, 13, 821, 366, 661, 6547, 11, 457, 341, 307, 1391, 264, 472, 300, 264, 1768, 4645, 279, 926, 257, 688, 12881, 13, 407], "temperature": 0.0, "avg_logprob": -0.1254873155038568, "compression_ratio": 1.6774193548387097, "no_speech_prob": 5.968682307866402e-05}, {"id": 53, "seek": 44008, "start": 447.08, "end": 456.08, "text": " external secrets operator is able to synchronize your secrets from an external store, external being to Kubernetes in this", "tokens": [8320, 14093, 12973, 307, 1075, 281, 19331, 1125, 428, 14093, 490, 364, 8320, 3531, 11, 8320, 885, 281, 23145, 294, 341], "temperature": 0.0, "avg_logprob": -0.1254873155038568, "compression_ratio": 1.6774193548387097, "no_speech_prob": 5.968682307866402e-05}, {"id": 54, "seek": 44008, "start": 456.08, "end": 463.08, "text": " case. For example, Hashicorp's vault or AWS secret manager or whatever else you have, external secrets operator is able to", "tokens": [1389, 13, 1171, 1365, 11, 30775, 299, 18703, 311, 27134, 420, 17650, 4054, 6598, 420, 2035, 1646, 291, 362, 11, 8320, 14093, 12973, 307, 1075, 281], "temperature": 0.0, "avg_logprob": -0.1254873155038568, "compression_ratio": 1.6774193548387097, "no_speech_prob": 5.968682307866402e-05}, {"id": 55, "seek": 46308, "start": 463.08, "end": 471.08, "text": " synchronize secrets to Kubernetes secrets, and it's also able to pick up changes. It doesn't actively monitor changes, but", "tokens": [19331, 1125, 14093, 281, 23145, 14093, 11, 293, 309, 311, 611, 1075, 281, 1888, 493, 2962, 13, 467, 1177, 380, 13022, 6002, 2962, 11, 457], "temperature": 0.0, "avg_logprob": -0.13131208419799806, "compression_ratio": 1.7548076923076923, "no_speech_prob": 6.48927889415063e-05}, {"id": 56, "seek": 46308, "start": 471.08, "end": 478.08, "text": " periodically it takes a look at the secrets, and if something changes, then it synchronizes the changes to Kubernetes. So", "tokens": [38916, 309, 2516, 257, 574, 412, 264, 14093, 11, 293, 498, 746, 2962, 11, 550, 309, 19331, 5660, 264, 2962, 281, 23145, 13, 407], "temperature": 0.0, "avg_logprob": -0.13131208419799806, "compression_ratio": 1.7548076923076923, "no_speech_prob": 6.48927889415063e-05}, {"id": 57, "seek": 46308, "start": 478.08, "end": 485.08, "text": " we have that part covered, and then you can use the Kubernetes secrets, either as environment variables or mount them as", "tokens": [321, 362, 300, 644, 5343, 11, 293, 550, 291, 393, 764, 264, 23145, 14093, 11, 2139, 382, 2823, 9102, 420, 3746, 552, 382], "temperature": 0.0, "avg_logprob": -0.13131208419799806, "compression_ratio": 1.7548076923076923, "no_speech_prob": 6.48927889415063e-05}, {"id": 58, "seek": 48508, "start": 485.08, "end": 497.08, "text": " files, however you want to use them. Now, the secrets change. What then? So if you mount secrets as files, and your", "tokens": [7098, 11, 4461, 291, 528, 281, 764, 552, 13, 823, 11, 264, 14093, 1319, 13, 708, 550, 30, 407, 498, 291, 3746, 14093, 382, 7098, 11, 293, 428], "temperature": 0.0, "avg_logprob": -0.10813229424612862, "compression_ratio": 1.7512437810945274, "no_speech_prob": 9.50042885961011e-06}, {"id": 59, "seek": 48508, "start": 497.08, "end": 506.08, "text": " application is able to pick up that change, then you don't have anything to do. Your application will already reload the", "tokens": [3861, 307, 1075, 281, 1888, 493, 300, 1319, 11, 550, 291, 500, 380, 362, 1340, 281, 360, 13, 2260, 3861, 486, 1217, 25628, 264], "temperature": 0.0, "avg_logprob": -0.10813229424612862, "compression_ratio": 1.7512437810945274, "no_speech_prob": 9.50042885961011e-06}, {"id": 60, "seek": 48508, "start": 506.08, "end": 513.0799999999999, "text": " configuration, and you have the whole thing covered. Now, if your application can't do that, or if your application", "tokens": [11694, 11, 293, 291, 362, 264, 1379, 551, 5343, 13, 823, 11, 498, 428, 3861, 393, 380, 360, 300, 11, 420, 498, 428, 3861], "temperature": 0.0, "avg_logprob": -0.10813229424612862, "compression_ratio": 1.7512437810945274, "no_speech_prob": 9.50042885961011e-06}, {"id": 61, "seek": 51308, "start": 513.08, "end": 521.08, "text": " uses environment variables, you mount secrets as environment variables, but that's a more difficult problem, and for years we", "tokens": [4960, 2823, 9102, 11, 291, 3746, 14093, 382, 2823, 9102, 11, 457, 300, 311, 257, 544, 2252, 1154, 11, 293, 337, 924, 321], "temperature": 0.0, "avg_logprob": -0.14482016377634815, "compression_ratio": 1.6851851851851851, "no_speech_prob": 5.6768025388009846e-05}, {"id": 62, "seek": 51308, "start": 521.08, "end": 528.08, "text": " didn't really have a solution for that other than manual restarts. A couple of years ago, this component called reloader", "tokens": [994, 380, 534, 362, 257, 3827, 337, 300, 661, 813, 9688, 1472, 11814, 13, 316, 1916, 295, 924, 2057, 11, 341, 6542, 1219, 25628, 260], "temperature": 0.0, "avg_logprob": -0.14482016377634815, "compression_ratio": 1.6851851851851851, "no_speech_prob": 5.6768025388009846e-05}, {"id": 63, "seek": 51308, "start": 528.08, "end": 538.08, "text": " appeared on the market, which basically watches workloads that have, that references secrets, and it also watches the", "tokens": [8516, 322, 264, 2142, 11, 597, 1936, 17062, 32452, 300, 362, 11, 300, 15400, 14093, 11, 293, 309, 611, 17062, 264], "temperature": 0.0, "avg_logprob": -0.14482016377634815, "compression_ratio": 1.6851851851851851, "no_speech_prob": 5.6768025388009846e-05}, {"id": 64, "seek": 53808, "start": 538.08, "end": 546.08, "text": " secrets, obviously, and when it detects a change, it triggers a standard workload rollout, similarly to how you would do", "tokens": [14093, 11, 2745, 11, 293, 562, 309, 5531, 82, 257, 1319, 11, 309, 22827, 257, 3832, 20139, 3373, 346, 11, 14138, 281, 577, 291, 576, 360], "temperature": 0.0, "avg_logprob": -0.13123630074893727, "compression_ratio": 1.7450980392156863, "no_speech_prob": 2.0726203729282133e-05}, {"id": 65, "seek": 53808, "start": 546.08, "end": 552.08, "text": " that with kubectl rollout, for example. So it may change the annotation of the workload, and that would result in the", "tokens": [300, 365, 350, 836, 557, 75, 3373, 346, 11, 337, 1365, 13, 407, 309, 815, 1319, 264, 48654, 295, 264, 20139, 11, 293, 300, 576, 1874, 294, 264], "temperature": 0.0, "avg_logprob": -0.13123630074893727, "compression_ratio": 1.7450980392156863, "no_speech_prob": 2.0726203729282133e-05}, {"id": 66, "seek": 53808, "start": 552.08, "end": 559.08, "text": " workload being rolled out, which means that it would run with the new environment variables, and it would remount the", "tokens": [20139, 885, 14306, 484, 11, 597, 1355, 300, 309, 576, 1190, 365, 264, 777, 2823, 9102, 11, 293, 309, 576, 890, 792, 264], "temperature": 0.0, "avg_logprob": -0.13123630074893727, "compression_ratio": 1.7450980392156863, "no_speech_prob": 2.0726203729282133e-05}, {"id": 67, "seek": 55908, "start": 559.08, "end": 568.08, "text": " secret with the changed file. And if we take a look at the whole process from the previous diagram, we don't have one component that", "tokens": [4054, 365, 264, 3105, 3991, 13, 400, 498, 321, 747, 257, 574, 412, 264, 1379, 1399, 490, 264, 3894, 10686, 11, 321, 500, 380, 362, 472, 6542, 300], "temperature": 0.0, "avg_logprob": -0.12256089378805722, "compression_ratio": 1.7116279069767442, "no_speech_prob": 3.1567691621603444e-05}, {"id": 68, "seek": 55908, "start": 568.08, "end": 575.08, "text": " takes care of the deployment, in this case, but we have two, one that synchronizes the secrets from the secrets store to", "tokens": [2516, 1127, 295, 264, 19317, 11, 294, 341, 1389, 11, 457, 321, 362, 732, 11, 472, 300, 19331, 5660, 264, 14093, 490, 264, 14093, 3531, 281], "temperature": 0.0, "avg_logprob": -0.12256089378805722, "compression_ratio": 1.7116279069767442, "no_speech_prob": 3.1567691621603444e-05}, {"id": 69, "seek": 55908, "start": 575.08, "end": 583.08, "text": " Kubernetes, and the other one that takes care of the rollouts, or making sure that the workloads notice the secret", "tokens": [23145, 11, 293, 264, 661, 472, 300, 2516, 1127, 295, 264, 3373, 7711, 11, 420, 1455, 988, 300, 264, 32452, 3449, 264, 4054], "temperature": 0.0, "avg_logprob": -0.12256089378805722, "compression_ratio": 1.7116279069767442, "no_speech_prob": 3.1567691621603444e-05}, {"id": 70, "seek": 58308, "start": 583.08, "end": 593.08, "text": " change. Well, let's take a look at a very quick demo, how that looks like in action, and I have a repository", "tokens": [1319, 13, 1042, 11, 718, 311, 747, 257, 574, 412, 257, 588, 1702, 10723, 11, 577, 300, 1542, 411, 294, 3069, 11, 293, 286, 362, 257, 25841], "temperature": 0.0, "avg_logprob": -0.17192763631994074, "compression_ratio": 1.5799086757990868, "no_speech_prob": 3.308978921268135e-05}, {"id": 71, "seek": 58308, "start": 593.08, "end": 600.08, "text": " prepared, you can go ahead and try it if you want to, and I have a Kubernetes cluster running here with both external", "tokens": [4927, 11, 291, 393, 352, 2286, 293, 853, 309, 498, 291, 528, 281, 11, 293, 286, 362, 257, 23145, 13630, 2614, 510, 365, 1293, 8320], "temperature": 0.0, "avg_logprob": -0.17192763631994074, "compression_ratio": 1.5799086757990868, "no_speech_prob": 3.308978921268135e-05}, {"id": 72, "seek": 58308, "start": 600.08, "end": 610.08, "text": " secrets and reloader installed, and in addition to that, we have like a simple echo server, which just, I believe it's,", "tokens": [14093, 293, 25628, 260, 8899, 11, 293, 294, 4500, 281, 300, 11, 321, 362, 411, 257, 2199, 14300, 7154, 11, 597, 445, 11, 286, 1697, 309, 311, 11], "temperature": 0.0, "avg_logprob": -0.17192763631994074, "compression_ratio": 1.5799086757990868, "no_speech_prob": 3.308978921268135e-05}, {"id": 73, "seek": 61008, "start": 610.08, "end": 621.08, "text": " yeah, we just output something. So let's take a look at how we configure external secrets first. So as I mentioned,", "tokens": [1338, 11, 321, 445, 5598, 746, 13, 407, 718, 311, 747, 257, 574, 412, 577, 321, 22162, 8320, 14093, 700, 13, 407, 382, 286, 2835, 11], "temperature": 0.0, "avg_logprob": -0.1171774002442877, "compression_ratio": 1.801047120418848, "no_speech_prob": 2.0708548618131317e-05}, {"id": 74, "seek": 61008, "start": 621.08, "end": 627.08, "text": " you configure external secrets, or maybe I don't need to mention, I don't know, but you configure external secrets", "tokens": [291, 22162, 8320, 14093, 11, 420, 1310, 286, 500, 380, 643, 281, 2152, 11, 286, 500, 380, 458, 11, 457, 291, 22162, 8320, 14093], "temperature": 0.0, "avg_logprob": -0.1171774002442877, "compression_ratio": 1.801047120418848, "no_speech_prob": 2.0708548618131317e-05}, {"id": 75, "seek": 61008, "start": 627.08, "end": 636.08, "text": " via custom resources, which means you create, can you see it from the back? Okay, cool. So you configure external", "tokens": [5766, 2375, 3593, 11, 597, 1355, 291, 1884, 11, 393, 291, 536, 309, 490, 264, 646, 30, 1033, 11, 1627, 13, 407, 291, 22162, 8320], "temperature": 0.0, "avg_logprob": -0.1171774002442877, "compression_ratio": 1.801047120418848, "no_speech_prob": 2.0708548618131317e-05}, {"id": 76, "seek": 63608, "start": 636.08, "end": 645.08, "text": " secrets via custom resource called external secret, and you tell external secrets to, you tell external secrets how to,", "tokens": [14093, 5766, 2375, 7684, 1219, 8320, 4054, 11, 293, 291, 980, 8320, 14093, 281, 11, 291, 980, 8320, 14093, 577, 281, 11], "temperature": 0.0, "avg_logprob": -0.10000420228028908, "compression_ratio": 1.9398907103825136, "no_speech_prob": 0.00012137171870563179}, {"id": 77, "seek": 63608, "start": 645.08, "end": 652.08, "text": " and from which external store should it synchronize secrets from, and where it should put it. So in this case, we are", "tokens": [293, 490, 597, 8320, 3531, 820, 309, 19331, 1125, 14093, 490, 11, 293, 689, 309, 820, 829, 309, 13, 407, 294, 341, 1389, 11, 321, 366], "temperature": 0.0, "avg_logprob": -0.10000420228028908, "compression_ratio": 1.9398907103825136, "no_speech_prob": 0.00012137171870563179}, {"id": 78, "seek": 63608, "start": 652.08, "end": 660.08, "text": " telling external secrets to synchronize secrets from a store I created and called as fake. This is basically a static", "tokens": [3585, 8320, 14093, 281, 19331, 1125, 14093, 490, 257, 3531, 286, 2942, 293, 1219, 382, 7592, 13, 639, 307, 1936, 257, 13437], "temperature": 0.0, "avg_logprob": -0.10000420228028908, "compression_ratio": 1.9398907103825136, "no_speech_prob": 0.00012137171870563179}, {"id": 79, "seek": 66008, "start": 660.08, "end": 670.08, "text": " secret store in this case. It synchronizes secrets into a secret called full bar, and it's going to synchronize from the", "tokens": [4054, 3531, 294, 341, 1389, 13, 467, 19331, 5660, 14093, 666, 257, 4054, 1219, 1577, 2159, 11, 293, 309, 311, 516, 281, 19331, 1125, 490, 264], "temperature": 0.0, "avg_logprob": -0.12520325183868408, "compression_ratio": 1.647887323943662, "no_speech_prob": 7.511449075536802e-05}, {"id": 80, "seek": 66008, "start": 670.08, "end": 681.08, "text": " fake secret store under the key, from under the key full slash bar to a key under hello in the Kubernetes secret.", "tokens": [7592, 4054, 3531, 833, 264, 2141, 11, 490, 833, 264, 2141, 1577, 17330, 2159, 281, 257, 2141, 833, 7751, 294, 264, 23145, 4054, 13], "temperature": 0.0, "avg_logprob": -0.12520325183868408, "compression_ratio": 1.647887323943662, "no_speech_prob": 7.511449075536802e-05}, {"id": 81, "seek": 68108, "start": 681.08, "end": 693.08, "text": " So let's take a look at, if we do, in fact, have that secret there. So we have a full bar secret. That's good so far.", "tokens": [407, 718, 311, 747, 257, 574, 412, 11, 498, 321, 360, 11, 294, 1186, 11, 362, 300, 4054, 456, 13, 407, 321, 362, 257, 1577, 2159, 4054, 13, 663, 311, 665, 370, 1400, 13], "temperature": 0.0, "avg_logprob": -0.12803719009178272, "compression_ratio": 1.4671052631578947, "no_speech_prob": 5.7328384173160885e-06}, {"id": 82, "seek": 68108, "start": 693.08, "end": 709.08, "text": " And we have a hello key here. I'm sure if you can see that. Now, if I change this secret right now, this,", "tokens": [400, 321, 362, 257, 7751, 2141, 510, 13, 286, 478, 988, 498, 291, 393, 536, 300, 13, 823, 11, 498, 286, 1319, 341, 4054, 558, 586, 11, 341, 11], "temperature": 0.0, "avg_logprob": -0.12803719009178272, "compression_ratio": 1.4671052631578947, "no_speech_prob": 5.7328384173160885e-06}, {"id": 83, "seek": 70908, "start": 709.08, "end": 720.08, "text": " this is just a command that patches the external or the fake store to change the secret value. If I go back and check the", "tokens": [341, 307, 445, 257, 5622, 300, 26531, 264, 8320, 420, 264, 7592, 3531, 281, 1319, 264, 4054, 2158, 13, 759, 286, 352, 646, 293, 1520, 264], "temperature": 0.0, "avg_logprob": -0.13937615591382224, "compression_ratio": 1.5534591194968554, "no_speech_prob": 1.313905249844538e-05}, {"id": 84, "seek": 70908, "start": 720.08, "end": 731.08, "text": " secret value, it should be changed to everyone. Now, if I try to curdle the service again, there are no changes here. So if I", "tokens": [4054, 2158, 11, 309, 820, 312, 3105, 281, 1518, 13, 823, 11, 498, 286, 853, 281, 1262, 2285, 264, 2643, 797, 11, 456, 366, 572, 2962, 510, 13, 407, 498, 286], "temperature": 0.0, "avg_logprob": -0.13937615591382224, "compression_ratio": 1.5534591194968554, "no_speech_prob": 1.313905249844538e-05}, {"id": 85, "seek": 73108, "start": 731.08, "end": 742.08, "text": " manually restart the pod, let's see, do I have the command here? Yeah, I have a rollout command. If I manually restart the pod", "tokens": [16945, 21022, 264, 2497, 11, 718, 311, 536, 11, 360, 286, 362, 264, 5622, 510, 30, 865, 11, 286, 362, 257, 3373, 346, 5622, 13, 759, 286, 16945, 21022, 264, 2497], "temperature": 0.0, "avg_logprob": -0.1754142064896841, "compression_ratio": 1.5974025974025974, "no_speech_prob": 8.451244866591878e-06}, {"id": 86, "seek": 73108, "start": 742.08, "end": 755.08, "text": " and restart the port forward as well, then I should see that the secret value is in fact changed. Maybe I haven't shown", "tokens": [293, 21022, 264, 2436, 2128, 382, 731, 11, 550, 286, 820, 536, 300, 264, 4054, 2158, 307, 294, 1186, 3105, 13, 2704, 286, 2378, 380, 4898], "temperature": 0.0, "avg_logprob": -0.1754142064896841, "compression_ratio": 1.5974025974025974, "no_speech_prob": 8.451244866591878e-06}, {"id": 87, "seek": 75508, "start": 755.08, "end": 770.08, "text": " you, but I do have the application deployment here that references the full bar secret. All right. So now we have the secret", "tokens": [291, 11, 457, 286, 360, 362, 264, 3861, 19317, 510, 300, 15400, 264, 1577, 2159, 4054, 13, 1057, 558, 13, 407, 586, 321, 362, 264, 4054], "temperature": 0.0, "avg_logprob": -0.10943841097647683, "compression_ratio": 1.432748538011696, "no_speech_prob": 7.932265361887403e-06}, {"id": 88, "seek": 75508, "start": 770.08, "end": 780.08, "text": " synchronization part covered. Now, let's see how it works if I want the workload to be automatically rolled out when the", "tokens": [19331, 2144, 644, 5343, 13, 823, 11, 718, 311, 536, 577, 309, 1985, 498, 286, 528, 264, 20139, 281, 312, 6772, 14306, 484, 562, 264], "temperature": 0.0, "avg_logprob": -0.10943841097647683, "compression_ratio": 1.432748538011696, "no_speech_prob": 7.932265361887403e-06}, {"id": 89, "seek": 78008, "start": 780.08, "end": 791.08, "text": " secret changes. So I can annotate the echo server with this reloader annotation, which will make reloader start", "tokens": [4054, 2962, 13, 407, 286, 393, 25339, 473, 264, 14300, 7154, 365, 341, 25628, 260, 48654, 11, 597, 486, 652, 25628, 260, 722], "temperature": 0.0, "avg_logprob": -0.09471377304622106, "compression_ratio": 1.49375, "no_speech_prob": 4.4860600610263646e-05}, {"id": 90, "seek": 78008, "start": 791.08, "end": 803.08, "text": " watching this workload and the secrets mounted in it. So nothing changed yet. I should still see everyone. That's fine. And now", "tokens": [1976, 341, 20139, 293, 264, 14093, 19138, 294, 309, 13, 407, 1825, 3105, 1939, 13, 286, 820, 920, 536, 1518, 13, 663, 311, 2489, 13, 400, 586], "temperature": 0.0, "avg_logprob": -0.09471377304622106, "compression_ratio": 1.49375, "no_speech_prob": 4.4860600610263646e-05}, {"id": 91, "seek": 80308, "start": 803.08, "end": 819.08, "text": " let's change the secret again to fuzz them. So if I, yeah, the secret is changed to fuzz them. And if we take a look at the,", "tokens": [718, 311, 1319, 264, 4054, 797, 281, 283, 16740, 552, 13, 407, 498, 286, 11, 1338, 11, 264, 4054, 307, 3105, 281, 283, 16740, 552, 13, 400, 498, 321, 747, 257, 574, 412, 264, 11], "temperature": 0.0, "avg_logprob": -0.15223170651329887, "compression_ratio": 1.6896551724137931, "no_speech_prob": 7.0809564931550995e-06}, {"id": 92, "seek": 80308, "start": 819.08, "end": 829.08, "text": " I probably have to restart this. If we take a look at the service, it should now say hello fuzz them. So in this case, I", "tokens": [286, 1391, 362, 281, 21022, 341, 13, 759, 321, 747, 257, 574, 412, 264, 2643, 11, 309, 820, 586, 584, 7751, 283, 16740, 552, 13, 407, 294, 341, 1389, 11, 286], "temperature": 0.0, "avg_logprob": -0.15223170651329887, "compression_ratio": 1.6896551724137931, "no_speech_prob": 7.0809564931550995e-06}, {"id": 93, "seek": 82908, "start": 829.08, "end": 835.08, "text": " didn't have to restart the virtual manually because reloader did that for me when I changed the secret. When I changed the", "tokens": [994, 380, 362, 281, 21022, 264, 6374, 16945, 570, 25628, 260, 630, 300, 337, 385, 562, 286, 3105, 264, 4054, 13, 1133, 286, 3105, 264], "temperature": 0.0, "avg_logprob": -0.14028863209049877, "compression_ratio": 1.6542056074766356, "no_speech_prob": 1.664400588197168e-05}, {"id": 94, "seek": 82908, "start": 835.08, "end": 841.08, "text": " secret in the store, that external secret synchronized into the Kubernetes secret and reloader noticed that", "tokens": [4054, 294, 264, 3531, 11, 300, 8320, 4054, 19331, 1602, 666, 264, 23145, 4054, 293, 25628, 260, 5694, 300], "temperature": 0.0, "avg_logprob": -0.14028863209049877, "compression_ratio": 1.6542056074766356, "no_speech_prob": 1.664400588197168e-05}, {"id": 95, "seek": 82908, "start": 841.08, "end": 852.08, "text": " change, so it rolled out the deployment. So that's what I wanted to show you today. If you have any questions, I'm happy to", "tokens": [1319, 11, 370, 309, 14306, 484, 264, 19317, 13, 407, 300, 311, 437, 286, 1415, 281, 855, 291, 965, 13, 759, 291, 362, 604, 1651, 11, 286, 478, 2055, 281], "temperature": 0.0, "avg_logprob": -0.14028863209049877, "compression_ratio": 1.6542056074766356, "no_speech_prob": 1.664400588197168e-05}, {"id": 96, "seek": 85208, "start": 852.08, "end": 862.08, "text": " answer them.", "tokens": [1867, 552, 13], "temperature": 0.0, "avg_logprob": -0.3535862650190081, "compression_ratio": 0.6, "no_speech_prob": 0.00042862867121584713}, {"id": 97, "seek": 86208, "start": 862.08, "end": 883.08, "text": " Hi. Thanks for your presentation. Can we use a reloader? Can you speak up, please, because I can't hear you. Please stay", "tokens": [2421, 13, 2561, 337, 428, 5860, 13, 1664, 321, 764, 257, 25628, 260, 30, 1664, 291, 1710, 493, 11, 1767, 11, 570, 286, 393, 380, 1568, 291, 13, 2555, 1754], "temperature": 0.0, "avg_logprob": -0.22150453399209416, "compression_ratio": 1.1538461538461537, "no_speech_prob": 0.0034582463558763266}, {"id": 98, "seek": 88308, "start": 883.08, "end": 894.08, "text": " quiet. Thank you. Can we use reloader without Kubernetes secrets? Because we're one of, can we use reloader without", "tokens": [5677, 13, 1044, 291, 13, 1664, 321, 764, 25628, 260, 1553, 23145, 14093, 30, 1436, 321, 434, 472, 295, 11, 393, 321, 764, 25628, 260, 1553], "temperature": 0.0, "avg_logprob": -0.18389269817306333, "compression_ratio": 1.78125, "no_speech_prob": 0.001320266048423946}, {"id": 99, "seek": 88308, "start": 894.08, "end": 903.08, "text": " syncing to Kubernetes secrets? I mean, you absolutely can. So with reloader, you can watch either secrets or", "tokens": [5451, 2175, 281, 23145, 14093, 30, 286, 914, 11, 291, 3122, 393, 13, 407, 365, 25628, 260, 11, 291, 393, 1159, 2139, 14093, 420], "temperature": 0.0, "avg_logprob": -0.18389269817306333, "compression_ratio": 1.78125, "no_speech_prob": 0.001320266048423946}, {"id": 100, "seek": 88308, "start": 903.08, "end": 910.08, "text": " config maps or both if you want to. But you need to use Kubernetes secrets and config maps. How do you change secrets", "tokens": [6662, 11317, 420, 1293, 498, 291, 528, 281, 13, 583, 291, 643, 281, 764, 23145, 14093, 293, 6662, 11317, 13, 1012, 360, 291, 1319, 14093], "temperature": 0.0, "avg_logprob": -0.18389269817306333, "compression_ratio": 1.78125, "no_speech_prob": 0.001320266048423946}, {"id": 101, "seek": 91008, "start": 910.08, "end": 916.08, "text": " is up to you. If you don't want to automatically synchronize, you don't have to. You can use reloader just to trigger", "tokens": [307, 493, 281, 291, 13, 759, 291, 500, 380, 528, 281, 6772, 19331, 1125, 11, 291, 500, 380, 362, 281, 13, 509, 393, 764, 25628, 260, 445, 281, 7875], "temperature": 0.0, "avg_logprob": -0.13063444218165438, "compression_ratio": 1.5469613259668509, "no_speech_prob": 0.00025119155179709196}, {"id": 102, "seek": 91008, "start": 916.08, "end": 921.08, "text": " a reload without using external secrets or synchronized secrets. So if you want to do that manually, you can", "tokens": [257, 25628, 1553, 1228, 8320, 14093, 420, 19331, 1602, 14093, 13, 407, 498, 291, 528, 281, 360, 300, 16945, 11, 291, 393], "temperature": 0.0, "avg_logprob": -0.13063444218165438, "compression_ratio": 1.5469613259668509, "no_speech_prob": 0.00025119155179709196}, {"id": 103, "seek": 91008, "start": 921.08, "end": 936.08, "text": " absolutely do that. Does it answer your question? No.", "tokens": [3122, 360, 300, 13, 4402, 309, 1867, 428, 1168, 30, 883, 13], "temperature": 0.0, "avg_logprob": -0.13063444218165438, "compression_ratio": 1.5469613259668509, "no_speech_prob": 0.00025119155179709196}, {"id": 104, "seek": 93608, "start": 936.08, "end": 945.08, "text": " I would like to do something like synchronize secrets right into volumes, for example, like skipping Kubernetes secrets", "tokens": [286, 576, 411, 281, 360, 746, 411, 19331, 1125, 14093, 558, 666, 22219, 11, 337, 1365, 11, 411, 31533, 23145, 14093], "temperature": 0.0, "avg_logprob": -0.2522789302625154, "compression_ratio": 1.5463917525773196, "no_speech_prob": 0.00041411429992876947}, {"id": 105, "seek": 93608, "start": 945.08, "end": 950.08, "text": " totally, because we don't want to, like, resist that in that CD.", "tokens": [3879, 11, 570, 321, 500, 380, 528, 281, 11, 411, 11, 4597, 300, 294, 300, 6743, 13], "temperature": 0.0, "avg_logprob": -0.2522789302625154, "compression_ratio": 1.5463917525773196, "no_speech_prob": 0.00041411429992876947}, {"id": 106, "seek": 93608, "start": 950.08, "end": 957.08, "text": " So no, probably reloader is not really useful in that case. But I see what you mean. So if you, for example, if you", "tokens": [407, 572, 11, 1391, 25628, 260, 307, 406, 534, 4420, 294, 300, 1389, 13, 583, 286, 536, 437, 291, 914, 13, 407, 498, 291, 11, 337, 1365, 11, 498, 291], "temperature": 0.0, "avg_logprob": -0.2522789302625154, "compression_ratio": 1.5463917525773196, "no_speech_prob": 0.00041411429992876947}, {"id": 107, "seek": 95708, "start": 957.08, "end": 967.08, "text": " use something like bolt-amp and you grab the secrets directly from within the pod and you want to trigger a reload,", "tokens": [764, 746, 411, 13436, 12, 1215, 293, 291, 4444, 264, 14093, 3838, 490, 1951, 264, 2497, 293, 291, 528, 281, 7875, 257, 25628, 11], "temperature": 0.0, "avg_logprob": -0.24944397421444164, "compression_ratio": 1.5933014354066986, "no_speech_prob": 2.2451338736573234e-05}, {"id": 108, "seek": 95708, "start": 967.08, "end": 975.08, "text": " then no, reloader can't be used that way. But we are actually working, so I'm from Cisco and before that I was", "tokens": [550, 572, 11, 25628, 260, 393, 380, 312, 1143, 300, 636, 13, 583, 321, 366, 767, 1364, 11, 370, 286, 478, 490, 38528, 293, 949, 300, 286, 390], "temperature": 0.0, "avg_logprob": -0.24944397421444164, "compression_ratio": 1.5933014354066986, "no_speech_prob": 2.2451338736573234e-05}, {"id": 109, "seek": 95708, "start": 975.08, "end": 981.08, "text": " working for Banzai Cloud and we are working on a solution right now exactly for that so we can have, like,", "tokens": [1364, 337, 363, 3910, 1301, 8061, 293, 321, 366, 1364, 322, 257, 3827, 558, 586, 2293, 337, 300, 370, 321, 393, 362, 11, 411, 11], "temperature": 0.0, "avg_logprob": -0.24944397421444164, "compression_ratio": 1.5933014354066986, "no_speech_prob": 2.2451338736573234e-05}, {"id": 110, "seek": 98108, "start": 981.08, "end": 988.08, "text": " a component that watches secrets that have external bolt references and reloads a component or", "tokens": [257, 6542, 300, 17062, 14093, 300, 362, 8320, 13436, 15400, 293, 25628, 82, 257, 6542, 420], "temperature": 0.0, "avg_logprob": -0.18738218795421513, "compression_ratio": 1.5151515151515151, "no_speech_prob": 0.0009015906834974885}, {"id": 111, "seek": 98108, "start": 988.08, "end": 998.08, "text": " trigger reloads for workloads based on those changes. But none of these tools support that at the moment.", "tokens": [7875, 25628, 82, 337, 32452, 2361, 322, 729, 2962, 13, 583, 6022, 295, 613, 3873, 1406, 300, 412, 264, 1623, 13], "temperature": 0.0, "avg_logprob": -0.18738218795421513, "compression_ratio": 1.5151515151515151, "no_speech_prob": 0.0009015906834974885}, {"id": 112, "seek": 99808, "start": 998.08, "end": 1012.08, "text": " So are there some risks of using this method instead of using, for example, a secret vault? I mean, with a secret", "tokens": [407, 366, 456, 512, 10888, 295, 1228, 341, 3170, 2602, 295, 1228, 11, 337, 1365, 11, 257, 4054, 27134, 30, 286, 914, 11, 365, 257, 4054], "temperature": 0.0, "avg_logprob": -0.1553588164480109, "compression_ratio": 1.589928057553957, "no_speech_prob": 0.000657171884085983}, {"id": 113, "seek": 99808, "start": 1012.08, "end": 1020.08, "text": " vault, if you watch for a file and if you watch for a secret that should be written in a file or somewhere,", "tokens": [27134, 11, 498, 291, 1159, 337, 257, 3991, 293, 498, 291, 1159, 337, 257, 4054, 300, 820, 312, 3720, 294, 257, 3991, 420, 4079, 11], "temperature": 0.0, "avg_logprob": -0.1553588164480109, "compression_ratio": 1.589928057553957, "no_speech_prob": 0.000657171884085983}, {"id": 114, "seek": 102008, "start": 1020.08, "end": 1029.08, "text": " if the secret change vault usually emits a signal like a sig up to reload the process.", "tokens": [498, 264, 4054, 1319, 27134, 2673, 846, 1208, 257, 6358, 411, 257, 4556, 493, 281, 25628, 264, 1399, 13], "temperature": 0.0, "avg_logprob": -0.24313672383626303, "compression_ratio": 1.7607361963190185, "no_speech_prob": 0.0010646285954862833}, {"id": 115, "seek": 102008, "start": 1029.08, "end": 1039.08, "text": " So what when the secret changes? Usually vault emits a signal, an up signal to reload the process and load the", "tokens": [407, 437, 562, 264, 4054, 2962, 30, 11419, 27134, 846, 1208, 257, 6358, 11, 364, 493, 6358, 281, 25628, 264, 1399, 293, 3677, 264], "temperature": 0.0, "avg_logprob": -0.24313672383626303, "compression_ratio": 1.7607361963190185, "no_speech_prob": 0.0010646285954862833}, {"id": 116, "seek": 102008, "start": 1039.08, "end": 1048.08, "text": " configuration. In this way you are reloading the whole container so there are some risks.", "tokens": [11694, 13, 682, 341, 636, 291, 366, 25628, 278, 264, 1379, 10129, 370, 456, 366, 512, 10888, 13], "temperature": 0.0, "avg_logprob": -0.24313672383626303, "compression_ratio": 1.7607361963190185, "no_speech_prob": 0.0010646285954862833}, {"id": 117, "seek": 104808, "start": 1048.08, "end": 1053.08, "text": " The problem is that only works if you talk to a vault directly from your workloads and with the solution you", "tokens": [440, 1154, 307, 300, 787, 1985, 498, 291, 751, 281, 257, 27134, 3838, 490, 428, 32452, 293, 365, 264, 3827, 291], "temperature": 0.0, "avg_logprob": -0.19284804494757402, "compression_ratio": 1.7355371900826446, "no_speech_prob": 0.000332474970491603}, {"id": 118, "seek": 104808, "start": 1053.08, "end": 1060.08, "text": " don't have to integrate vault directly, like you can use whatever secret story you want to. And the problem is that", "tokens": [500, 380, 362, 281, 13365, 27134, 3838, 11, 411, 291, 393, 764, 2035, 4054, 1657, 291, 528, 281, 13, 400, 264, 1154, 307, 300], "temperature": 0.0, "avg_logprob": -0.19284804494757402, "compression_ratio": 1.7355371900826446, "no_speech_prob": 0.000332474970491603}, {"id": 119, "seek": 104808, "start": 1060.08, "end": 1068.08, "text": " vault doesn't actually know where it should set its signal. So in this case you may deploy the secrets to a", "tokens": [27134, 1177, 380, 767, 458, 689, 309, 820, 992, 1080, 6358, 13, 407, 294, 341, 1389, 291, 815, 7274, 264, 14093, 281, 257], "temperature": 0.0, "avg_logprob": -0.19284804494757402, "compression_ratio": 1.7355371900826446, "no_speech_prob": 0.000332474970491603}, {"id": 120, "seek": 104808, "start": 1068.08, "end": 1072.08, "text": " number of different clusters and the logists wouldn't know where to send those signals.", "tokens": [1230, 295, 819, 23313, 293, 264, 3565, 1751, 2759, 380, 458, 689, 281, 2845, 729, 12354, 13], "temperature": 0.0, "avg_logprob": -0.19284804494757402, "compression_ratio": 1.7355371900826446, "no_speech_prob": 0.000332474970491603}, {"id": 121, "seek": 107208, "start": 1072.08, "end": 1078.08, "text": " So the minor advantage is that it's fully transparent to the solution. I don't know.", "tokens": [407, 264, 6696, 5002, 307, 300, 309, 311, 4498, 12737, 281, 264, 3827, 13, 286, 500, 380, 458, 13], "temperature": 0.0, "avg_logprob": -0.23801605610907833, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.004542740061879158}, {"id": 122, "seek": 107208, "start": 1078.08, "end": 1083.08, "text": " We have time for one more question.", "tokens": [492, 362, 565, 337, 472, 544, 1168, 13], "temperature": 0.0, "avg_logprob": -0.23801605610907833, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.004542740061879158}, {"id": 123, "seek": 107208, "start": 1083.08, "end": 1092.08, "text": " Any advice about some tools to do the rotation on the other part, like, for example, rotate the standard database credentials,", "tokens": [2639, 5192, 466, 512, 3873, 281, 360, 264, 12447, 322, 264, 661, 644, 11, 411, 11, 337, 1365, 11, 13121, 264, 3832, 8149, 27404, 11], "temperature": 0.0, "avg_logprob": -0.23801605610907833, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.004542740061879158}, {"id": 124, "seek": 107208, "start": 1092.08, "end": 1099.08, "text": " something like that, that will automatically update in the secret store then trigger the workshop?", "tokens": [746, 411, 300, 11, 300, 486, 6772, 5623, 294, 264, 4054, 3531, 550, 7875, 264, 13541, 30], "temperature": 0.0, "avg_logprob": -0.23801605610907833, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.004542740061879158}, {"id": 125, "seek": 109908, "start": 1099.08, "end": 1104.08, "text": " The problem with that is that secret providers, like, there are many different secret providers.", "tokens": [440, 1154, 365, 300, 307, 300, 4054, 11330, 11, 411, 11, 456, 366, 867, 819, 4054, 11330, 13], "temperature": 0.0, "avg_logprob": -0.23278695285910428, "compression_ratio": 1.6356275303643724, "no_speech_prob": 0.0003182258806191385}, {"id": 126, "seek": 109908, "start": 1104.08, "end": 1110.08, "text": " So it's really hard to build a central solution for that. But hashicorp vault is one.", "tokens": [407, 309, 311, 534, 1152, 281, 1322, 257, 5777, 3827, 337, 300, 13, 583, 22019, 299, 18703, 27134, 307, 472, 13], "temperature": 0.0, "avg_logprob": -0.23278695285910428, "compression_ratio": 1.6356275303643724, "no_speech_prob": 0.0003182258806191385}, {"id": 127, "seek": 109908, "start": 1110.08, "end": 1116.08, "text": " Hashicorp vault has a bunch of, I think it's called old backends or something like that, that you can use to issue", "tokens": [30775, 299, 18703, 27134, 575, 257, 3840, 295, 11, 286, 519, 309, 311, 1219, 1331, 646, 2581, 420, 746, 411, 300, 11, 300, 291, 393, 764, 281, 2734], "temperature": 0.0, "avg_logprob": -0.23278695285910428, "compression_ratio": 1.6356275303643724, "no_speech_prob": 0.0003182258806191385}, {"id": 128, "seek": 109908, "start": 1116.08, "end": 1122.08, "text": " credentials, for example, to a Postgres database. And that credential can actually have a TTL, a deadline.", "tokens": [27404, 11, 337, 1365, 11, 281, 257, 10223, 45189, 8149, 13, 400, 300, 22034, 393, 767, 362, 257, 32576, 43, 11, 257, 20615, 13], "temperature": 0.0, "avg_logprob": -0.23278695285910428, "compression_ratio": 1.6356275303643724, "no_speech_prob": 0.0003182258806191385}, {"id": 129, "seek": 112208, "start": 1122.08, "end": 1129.08, "text": " And then after a certain time, hashicorp's vault would issue a new pair of credentials and then external secrets would be", "tokens": [400, 550, 934, 257, 1629, 565, 11, 22019, 299, 18703, 311, 27134, 576, 2734, 257, 777, 6119, 295, 27404, 293, 550, 8320, 14093, 576, 312], "temperature": 0.0, "avg_logprob": -0.132251639698827, "compression_ratio": 1.6188340807174888, "no_speech_prob": 0.00029802389326505363}, {"id": 130, "seek": 112208, "start": 1129.08, "end": 1133.08, "text": " able to synchronize those credentials. We actually use that with AWS back end.", "tokens": [1075, 281, 19331, 1125, 729, 27404, 13, 492, 767, 764, 300, 365, 17650, 646, 917, 13], "temperature": 0.0, "avg_logprob": -0.132251639698827, "compression_ratio": 1.6188340807174888, "no_speech_prob": 0.00029802389326505363}, {"id": 131, "seek": 112208, "start": 1133.08, "end": 1137.08, "text": " And that's how we rotate database credentials every 90 days.", "tokens": [400, 300, 311, 577, 321, 13121, 8149, 27404, 633, 4289, 1708, 13], "temperature": 0.0, "avg_logprob": -0.132251639698827, "compression_ratio": 1.6188340807174888, "no_speech_prob": 0.00029802389326505363}, {"id": 132, "seek": 112208, "start": 1137.08, "end": 1142.08, "text": " Okay. Thank you so much for the talk. Thank you for all the questions. Thank you for staying quiet.", "tokens": [1033, 13, 1044, 291, 370, 709, 337, 264, 751, 13, 1044, 291, 337, 439, 264, 1651, 13, 1044, 291, 337, 7939, 5677, 13], "temperature": 0.0, "avg_logprob": -0.132251639698827, "compression_ratio": 1.6188340807174888, "no_speech_prob": 0.00029802389326505363}, {"id": 133, "seek": 114208, "start": 1142.08, "end": 1152.08, "text": " Thank you.", "tokens": [50364, 1044, 291, 13, 50864], "temperature": 0.0, "avg_logprob": -0.4658048152923584, "compression_ratio": 0.5555555555555556, "no_speech_prob": 0.0007829364039935172}], "language": "en"}