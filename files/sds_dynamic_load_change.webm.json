{"text": " Okay, good morning, everyone. I want to talk about how we can dynamically change a load of the sort of front system to be a better resident in clouds. I did not move to IBM as part of the Reddit storage moving to IBM. So this is still a Reddit presentation. I don't have the Ceph logo here because it's generic presentation, but it would be highly based on work that I did with others on Ceph. So all the examples would be how this was implementing Ceph and how we could use it. But the concepts are generic and not Ceph specific. So it's a mix. Okay, so we will talk, we want what is optimal cluster performance and why we need optimal cluster performance. It would be just at the beginning. Then I'm going back to explain what we did in Ceph for Riff version. We have a new read balancer which I explained quite shortly. It's not into full details, but it's an infrastructure that could be used to better control the load later. Then some future plans that we already have which are good as examples to what we could do with this infrastructure. And then we'll go to the real problem, how we could actually dynamically change the way the load is spread across Ceph cluster in case we need to do it because other things change in the cluster. How we could fit the way the load is spread in Ceph because of some kind of external change in the conditions that we need to respond to. So, again, just an example. If we have a cluster, we have here nodes and we have three workloads and they are split not totally evenly over the nodes. And if we had bad luck, we could see that some nodes are more loaded than the other nodes. And the problem is, as everyone probably guesses, one node reaches 100% load, then the entire system starts to become slow because we have weakest link in the chain effect. Assuming these workloads cannot respond fast enough, so you get all kinds of cues created and the entire cluster loses its ability to perform well. It still performs, but not that well. So, basically, when we build a cluster and we look from the outside, we want the load to be spread almost evenly. So, when one node reaches 100%, we know the cluster is fully occupied. There is nothing we could do about it. This is another image which shows something which is way better because the nodes, again, it's the same. It's created the same number. The areas of each workloads are the same. And it actually shows the cluster itself is balanced. And we could get, when it fills up, it fills up together, so we use the cluster for the best that we can. So, actually, if we try to look at what we have, we want something flexible with fixed volume. A balloon is what I find. We want something, the performance that we want is the volume, but it should be flexible because we can't control all the workloads. So, if we take, for example, we have on the nodes a backup program which runs in nights, but not at the same time. It gradually goes over all the nodes. So, each one of the nodes gets some kind of peak either in IOs or in network traffic, and it peaks and it's more full than others. And then the others, the other one, and it goes over all the nodes. We can obviously mitigate this. We can say, OK, we allocate some capacity for this backup program so we know that other workloads could run on this node. But if these backup programs work for an hour every day, then we allocate some capacity for one hour and the other 23 hours, it is not used. Probably not used. It's much better if we could incorporate this change, these backup runs over the cluster and move the nodes of the nodes with the backup to other nodes for some time for an hour. Then the backup finishes go to another node, then we move the nodes from back to the original node and we make it. It's way more effective. So, in some sense, we do some kind of over provisioning on the nodes when we know that most of the time we are not over provisioning and when we are over provisioning, we could mitigate this. That's the idea. And the other use case that we could have, that we could get a node coming to full capacity when we didn't plan it, it could be all kinds of failure, NIC problems, all the top of the rack switch problems, other hardware, or if we talk about SEPH, disk failure, all kinds of other stuff could bring to a situation that may be bad but not critical enough to take node down and do full rebuild and all this stuff. So, that's the idea is to have something which is flexible and we could play with it. The problem is that our balloon is built of LEGO bricks and it's not as flexible as we think. So, I want to show the amount of flexibility that we have, that we could play with when we talk about software defined storage system and which are more challenging than other workloads because it's stateful, stateless workloads are easier to manage flexibly. So, we want to go from this, this was the first, this is the copy of the first diagram that I showed and this is where we want to be and I change only the orange workload. It's the same numbers, exactly the same numbers, exactly the same area, orange area but split differently. That's the approach that I want to take but, okay, it's a presentation. I could do miracles in presentation, how I do it in real life and I want to show how we could play assuming SEPH is or software defined storage is the orange one, how we could play with this to a limits. We can't do all the magic that we could do in presentation but we could do reasonable, under some condition, very good work, under other condition, improve the situation not to a perfect solution. So, it's all based on the idea of the SEPH read balancer and the idea today in SEPH, we have, not in SEPH, in every software defined storage, the main balancing requirement is that all the disks are full at the same percentage. The first disk which is full, the system is full. So, this is our basic assumption. Then, what we're doing today, we try to do is that if we have replica 3, then we have XPGs mapped to OSD, X divided by 3 would be primaries. So, the primaries are split evenly on the devices, not evenly split according to the number of the PGs. So, if we have a device with more PGs, it has more primaries. But, we don't have anything that does it, actually what is happening today in SEPH is that we rely on the statistics of crash. It works well for large clusters, it doesn't work well for small cluster. So, the SEPH read balancer comes to fix this and it's what we currently have, more in the next bullet, is for the small clusters where the statistics doesn't play well. So, what we actually did, we added three different things together, create a read balancer, which could actually split the reads evenly across us. This is actually what it does, it splits the primaries as I explained for replica X. One divided by replica X are primaries per OSDs for the PGs. So, it just changes the primaries. So, first of all, we created, it would be part of the RIF version. So, first of all, we created some kind of score. The score represents how well the read is balanced versus the optimum. Optimum is one. If we have a score of two, meaning that under full load of reads, the system would perform half of a good system. If it's three, for example, we have replica three and the score is three. And we have three disks and score is three, it means all the reads are for a single disk. So, it's obviously third of the optimal when the reads split evenly among three disks. So, that's what I have. Score works really well when the read affinity of the devices is high and it's still monotonous, but it's more difficult to explain the numbers when you have a lot of devices with small OSDs. With small read affinity numbers, and I could explain later why it is, it's not a good way to configure the system. It creates all kinds of illegal configuration. You have to do what the user asks you not to do, but that's for side code. Then we have two new commands, PG-UPMAP commands, as we have PG-UPMAP primary and RMPG-UPMAP primary, which actually say, okay, I get an OSD PG, the PG has X OSDs there, make one of them the primary, I tell them which one. So, I could actually change the primary within a PG. And it's metadata only, we don't move data, you must give an OSD, which is part of the PG. If you give OSD, which is not part of the PG, you get an error. So, we are not trying to do anything, it's very cheap, very fast. It just changes the order of the OSDs within the PG, that's everything that it does. And since it's first version, we want to make it opt-in option. So, we have a new command to the OSD MAP tool, which actually calculates everything and spits a script file that you could run in order to get to the perfect distribution. That's what we currently have. So, this is the example of when you run this, you could see smaller clusters, small cluster tend to be less balanced because statistics doesn't play well. So, we have number of primaries for three OSDs, we have 11, 6, 15, obviously, it's not balanced. And after you run it, you get 10, 11, 11, which is obviously the best that you could get. And the number is not one, because the average is 10 and 2 thirds. So, if you could have 10 and 2 thirds, you get a score of one, but it's 1.03 really good. And here, obviously, it's 1.4 because it's 15 divided by 10 and 2 thirds. This is the out file that you could actually run as a script in order to apply the changes. If you look really carefully, you see that we have six changes, but actually we could only have five changes, even maybe four, we could, we should just make this 10. So, we have 11, 10, 11, that's because of its greedy algorithm. Since these commands are really, really very, don't have overhead run really fast, it's not a problem. If we would have need to move data, this would be a totally wrong one because we have two additional data movements. We don't need it, it's really simple, so we didn't try to optimize on the number of changes just to make it come. So, what is the implementation? The implementation is, we have two functions. One of them is, we have one, it's an example, calc desired primary distribution. That's where we go over the configuration and decide what's the final distribution of primary that we want. For OSD, how many primaries we want to be on this OSD? It's really, it's some kind of policy function, it's really simple. Today, it's, it does one divided by replica count, as I said, and it's about 40 lines of code, something really simple. So, adding more policies just for, to understand if you want to add more policies and I'll talk about more policies immediately. If you want to add more policies, then we're talking about tens of lines of code, nothing more than this. Then we have the functions that actually takes the configuration and goes over all the PG's, it's all run by pool. I didn't say this before, it's all run by pool because pool represents a workload and it's important to balance pair workload. It goes over all the PG's on the pool and does its work and switches what it has to switch in order to get into the, what we calculated here. So basically, this is function, this is infrastructure function that could be used, we could add more and I'll talk about more policies. We could add more policies and adding the policy is really something simple and the command is fast. That's, I keep on saying this because I want to talk about dynamic, that's what is behind the dynamic thing. It's a cheap operation that we could run periodically and change things when we want to do it. It's not involved in any, any high overhead or anything, it's just a metadata operation. So we had the very simple read balancer, use case is small clusters, small clusters, it's very important use case for redhead, now IBM, it's for ODF or for CEPH in OpenShift, but there is much more than we could do. So now let's talk about the next, well, we have two use cases. So what we could do more? We have a mechanism, we could change the things, but it's a pretty strong mechanism and we want to use, to use it for further on. So one thing and this is one thing, this is a use case for larger cluster, load, load balance better on heterogeneous system. So you have a large CEPH cluster, you started to work five years ago, you have one terabyte devices, time comes, you need more capacity and it doesn't make sense to buy one terabyte devices anymore and you bought two terabyte devices. Now normally it means that you get twice the workload on the two terabyte devices because you need that the devices would be split, even filled evenly. You could create policies that says that you change gradually and when the smaller devices are not full, you have the same capacity. It doesn't work because every change is movement of data, it's very expensive. So you could in theory create really, really nice policies in practice, the price you pay in order to keep it is too much. Eventually you have device which is twice as large, it gets twice the capacity or you define it as a smaller device, then you lose capacity or it gets twice the load. If it gets twice the load, the smaller devices are working on half the potential load. So just for the numbers, I have a little exercise. So we have devices of same technology, same bandwidth, same IOPS. We have one OSD of two terabytes and four OSDs of one terabyte. So it's like three OSDs of two terabytes if you think about capacity, so one of two terabytes, four of one terabyte. So we have for each a PG, one copy on the large device and two copies on the small devices, a split. So that's the assumption to just show a bit of play with the numbers. And for the convenience, let's assume that we have 100 IOPS, it's just easy. People like to think in round numbers. So under full load, what happens? This device goes to 100 IOPS because that's what it could provide. And these devices get half the load and they would provide each 150 IOPS. So total we have 300 IOPS. And there is nothing we could actually do about it because the requirements to have the capacity split twice here than here is so strong that we can't change it, can't play with it. That's the rules of the game. Once we did it, we are bound in such a configuration. Actually, we had a working cluster and we added one larger disk and all the cluster performs way, way worse than it used to be. So it's not really something that we could do with it and accept, replace all the disks with larger disks or something like this. But if you want to do gradual, we can do with it. Now, there is something that we could do. Let's assume that we have, for now, the read-only, just read-only load. The capacity is still the same, 30 PG is 15, 15, 15. But the 10 primaries here, I moved them and moved them here and split them here. So we have here, when you have only reads, all the devices are fully working under full load. So we moved from 300 IOPS to 500 IOPS, but just very minor change of changing primaries and splitting them differently across the cluster. Now, this is the best that we could get. If we have read-write, obviously, if we have write-only workload, we can't improve using this technique because this technique changes only reads. So if we have write-only, we can't change, and if we have some writes, we can't get as good as this one because eventually this will get all the time, twice writes than the others. So there is limitation to what we could do. So the best potential is for read-only, but we could do also with mixed read-writes. We could get a lot of improvement under full load, a lot. So that's the idea, and this is already planned for the next version. On purpose, we didn't put it on the first version because we want adoption of the feature, but this is, we plan to add two steps for the next version. This is actually better supporting different sizes of devices. So, can we improve on other loads which are not read-only? And I already said this, we can do this, but in order to do this, in order to do good job, we need to understand per pool some characteristics of the workload. And basically the read-write ratio. If we get read-write ratio which is reasonably close to what we actually have, then we could do good improvement in the performance when we have different size devices and mixed workload. Well, I said it, there are limitations what we could do, so I said one thing, we can't improve on write-only using this technique. I've seen this, so it's real thing, but if you use replica three and we, instead of having one terabyte and two terabyte devices, we have one terabyte and five terabyte devices. I've seen this in real life. We can't improve, we can't, well, we can improve, but we can get to optimal performance when we have five terabyte devices and one terabyte devices on the same pool, the numbers are too low. We could reduce it to the minimum, moving all reads out of the five terabyte devices, but eventually when you have enough writes, the system would not perform optimally. So, we covered this. So, another case which was, another case which is, well, it's a no-no, big no-no, don't put SSDs and HDDs on the same pool, everyone knows this. Well, if you could, if you can make sure that you have enough SSDs that, sorry, that every PG is mapped to at least one SSD and then to HDDs, preferably replica three, one SSD, two HDDs, you could actually get the effect of read flash cache without cache misses. You always read from the SSDs and you only write to the HDDs. You could improve on the performance of your system and get really fast read latencies. So, I'm breaking this no-no, but it is important, don't mix the technologies if you can't make sure that all the reads are from the faster device. If you could make, so if you take replica three and you put one-third of your PG's, of your SSDs are SSD capacity, one-third of the capacity is on SSDs, two-third on HDDs. And you could also make sure, whatever techniques you use, it's really easy. You need to change a bit of crush rules, but all the copies, you have one copy on SSD and the other copies on HDDs. You could actually improve your performance dramatically because the bottleneck of HDD would be only for writes and all the reads would get the SSD or NVMe or whatever performance. So, I'm breaking one of the big no-no's here, but if you can't make sure that all the reads are from the fast devices, then you waste, it wouldn't work. Eventually, under full load, you'll get the known weakest link in the chain and it would be blocked. But if you can do it, so this is a way to modernize the devices gradually and not moving all the HDD to SSDs once, one-third in case of replica three could be the first step and you could do it gradually and you don't know to do anything. So, that's another thing that could be with existing, by the way, for this, because it's different technique, you don't need what we did in the read balancer. It's enough to have good crush rules. This could be managed by crush rules differently. Okay, now we come to the dynamic aspect of this. So, the thing is that we have cluster, we build cluster, we know we have the numbers, how the cluster performs, what are the network bandwidths, how devices perform. It all works well until it doesn't. So, we may have problems, hardware problems, and we may have noisy neighbors where we work. As I said, full isolation of neighbors has a cost. If you prevent over provisioning in all costs, well, it has a cost, depending on your workloads, you allocate a lot for temporary workloads. So, in some cases, doing over provisioning of nodes makes sense if you know how to behave. And this is especially in hyperconverged. So, we know that hyperconverged deployment, noisy neighbors, it could be in Kubernetes, we tend to limit, we know how to limit, we use, we tend to limit these CPUs and memories and not network. Obviously, for sort of defense systems, the network is really important. So, noisy neighbor on the network could cause huge performance problems. So, the process, and this is the process is, I want to explain, because it's more than just technical thing. We want to monitor the IO performance from OSD level and up. We want to identify what happens. It could be on OSD level, it could be on node level, it could be on rack level. We need to understand what happens. Then we could tune up the system. We could reduce the load. If the problem is temporary, we don't want to move data. Even if the problem is that we have a faulty nick, and we know that it would take 24 hours to fix it, it may not be worth the effort of, for a node, to move all the data from this node to another node, to other nodes, to the rest of the cluster and then move it back. If we could make sure that we have a faulty nick and until it is fixed, we don't read from this node at all. We just write to it. Maybe we could live with it. So, the idea is that we don't want, the obvious solution is mark OSD is out and move the data and everything fix itself, but it costly, especially if you have a lot of data over the node. So, this is a way to reduce the load temporarily until it is fixed. And then, once you did all your magic, fixed everything, you could go back to the normal. So, and by the way, this is something that is not related to software-defined storage, but it's much easier, all this much easier to do for a stateless application. If we have a web server that gives us the stock exchange quotes, and it doesn't function, one of the servers doesn't function, we change the proxy and we send the request to other servers. It's way more difficult to do with stateful application when you can't exchange every server with every other server and you need, there are more limitations and obviously we talk about storage. It's the most stateful thing that you could think of. So, option one, it's something we thought about even for the rebalances we did. This is what is a very good solution for the stateless part, it's called the power of two. Before you send the request, you randomly select two candidates to get the request, you find out who is more loaded and you send to the one that is less loaded. It does magic. That's really, really good way to move the load from the loaded servers to the unloaded servers and it works. Unfortunately, in order to fix, to do such thing in SEF, you need to go into the data path. Everything that I explained up until now is totally outside of the data path. You have to add things to the data path and to change the clients and we thought about this also in order to do the read balancing, it would be very simple. Every PG, since we have read from non-replicant in SEF now, we could say for every PG, don't send the request to the primary, send it randomly to any of the PG's and automatically you'll get the balance spread. Sorry, for HPG to any of the OSD's, don't send to the primary OSD, just send to whatever you have there. We decided not to do it, it's risky and we don't like to play with the data path. I don't like to play with the data path personally, but it was a mutual decision, not only me. So that's option two, monitor centrally, monitor centrally, obviously, create the policy. This is something that you need to get the function of the policy that knows what to do when you find these discrepancies. You need to understand what you're doing, what you want to achieve, how much time you want to play with this before you decide to move data or maybe you need the human involvement which will tell me, okay, I'm going to fix this, don't do anything. It's a policy you need to do both in the terms of workflow and then program what you need to program for this. The policy function is small, we talked about this, it's nothing. And when the performance changes, first you need to notify operator because we suspect that a lot of the problems could be hardware problems that should be fixed and we need to tell something that we see something bad. And then change primary settings so we remove the load from the less performant OSDs or components to other places. And before monitoring the system and when it's back to normal, we could remove everything and go back to full things. So here is the conclusion, again, it's data path outside of the data path, syncing the metadata, the performance to the clients, which is also something that we didn't want to do, versus the external metadata configuration that we do on the server side, whatever, because we trigger the policy from server side and no change. So that's the idea for, again, this is for how to implement this in the future, but the idea we could, if we measure, if we know what's going on, we could improve to send it some point aside whether this improvement is good enough for us until we fix, or in some cases we decide to move data and don't say don't move data, but don't move it as the default option for every problem. Acknowledgements, Orit, which worked with me a lot on the ideas that I put here, and she's now in IBM. And Laura, which did a lot of the coding with me on this, and actually since my coding skills were a bit rusty, I couldn't do a lot without her. So thanks to Orit and Laura that helped in this project, and I'm done. Questions? Yes, please. Can you use the new OSD map rule that is like released for brief, as I said, like master? Can you use that to generate a list of distribution of the primaries that will be optimal on all the clusters, and use the temporary map feature that is already existing in all our releases to actually apply that policy that this would be optimal. Okay. Basically, I'd like to back forward, but then without. The question was, if you could use the OSD map tool on older classes, and then instead of using the new PG op map use a temporary permit permit temp in order to do it. I think it should, the OSD, you should have a new set cluster with all the new tools because there are some other changes, but you run OSD map tools on a file that generated from the OSD map tools work on configuration file that you take. So you could create a configuration file out of an old cluster and run it with the new OSD map tool. And then so I think actually the primary temp is how we tested this. What is missing is that the new OSD map tool relates on the score. And actually I'm not sure, it not depends on the score, but it uses a score internally. So it should run on a new environment, but I think it should be able to work. I have my information here, or I'll give you my email and send me, I'll verify this. It should work. I'm not 100% sure, but it should work. If it doesn't work, it is a problem. You said that you defined that it's especially good for smaller clusters. How big would you define smaller clusters? See, the question was, what is small cluster and big cluster? The thing is, the way CRUSH works, it uses statistics to do the split to primaries. If you have a cluster in which primaries are not balanced, probably it falls into the smaller side. But if you look at hundreds of OSD, even it's a number of PG's, not number of OSD's. In the past, I did an experiment and I saw that you saw the score here, 1.4. Every time that you double the number of the PG's, roughly the difference from 1 goes by half. So we put 1.4 for 32 PG's, probably around 1.2 for 64. So it's large clusters with pools with large number of PG's, usually somehow balance themselves. But it's a matter of, you need to look, if you have unbalanced pools, it's unbalanced pools. It doesn't matter which cluster you are in. But that's why we do it. But most benefit for the larger pools, the pools with the data, is when you have smaller clusters, it's not worth putting 512 PG's per pool and you work with smaller numbers. If you have 510K or 2K PG's per cluster, probably your score would be pretty good. Would it also be useful for erasure coded pools? The question whether it's good for erasure coded pools, probably not. Well, way, way, way less sufficient. I tried to do the theory behind it. Then maybe really, really little, I don't know. So currently we check in the code, it doesn't work for erasure coded at all because we think it doesn't worth the hassle. So it's tested and it works only on replicables. Okay, my time is up. Thank you very much. It was pleasure being face to face here. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 13.280000000000001, "text": " Okay, good morning, everyone.", "tokens": [1033, 11, 665, 2446, 11, 1518, 13], "temperature": 0.0, "avg_logprob": -0.36822609785126476, "compression_ratio": 1.271186440677966, "no_speech_prob": 0.18792961537837982}, {"id": 1, "seek": 0, "start": 13.280000000000001, "end": 20.32, "text": " I want to talk about how we can dynamically change a load of the sort of front system", "tokens": [286, 528, 281, 751, 466, 577, 321, 393, 43492, 1319, 257, 3677, 295, 264, 1333, 295, 1868, 1185], "temperature": 0.0, "avg_logprob": -0.36822609785126476, "compression_ratio": 1.271186440677966, "no_speech_prob": 0.18792961537837982}, {"id": 2, "seek": 0, "start": 20.32, "end": 27.76, "text": " to be a better resident in clouds.", "tokens": [281, 312, 257, 1101, 10832, 294, 12193, 13], "temperature": 0.0, "avg_logprob": -0.36822609785126476, "compression_ratio": 1.271186440677966, "no_speech_prob": 0.18792961537837982}, {"id": 3, "seek": 2776, "start": 27.76, "end": 34.92, "text": " I did not move to IBM as part of the Reddit storage moving to IBM.", "tokens": [286, 630, 406, 1286, 281, 23487, 382, 644, 295, 264, 32210, 6725, 2684, 281, 23487, 13], "temperature": 0.0, "avg_logprob": -0.19970200856526693, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.0010460567427799106}, {"id": 4, "seek": 2776, "start": 34.92, "end": 37.68, "text": " So this is still a Reddit presentation.", "tokens": [407, 341, 307, 920, 257, 32210, 5860, 13], "temperature": 0.0, "avg_logprob": -0.19970200856526693, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.0010460567427799106}, {"id": 5, "seek": 2776, "start": 37.68, "end": 43.480000000000004, "text": " I don't have the Ceph logo here because it's generic presentation,", "tokens": [286, 500, 380, 362, 264, 383, 595, 71, 9699, 510, 570, 309, 311, 19577, 5860, 11], "temperature": 0.0, "avg_logprob": -0.19970200856526693, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.0010460567427799106}, {"id": 6, "seek": 2776, "start": 43.480000000000004, "end": 49.24, "text": " but it would be highly based on work that I did with others on Ceph.", "tokens": [457, 309, 576, 312, 5405, 2361, 322, 589, 300, 286, 630, 365, 2357, 322, 383, 595, 71, 13], "temperature": 0.0, "avg_logprob": -0.19970200856526693, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.0010460567427799106}, {"id": 7, "seek": 2776, "start": 49.24, "end": 55.28, "text": " So all the examples would be how this was implementing Ceph and how we could use it.", "tokens": [407, 439, 264, 5110, 576, 312, 577, 341, 390, 18114, 383, 595, 71, 293, 577, 321, 727, 764, 309, 13], "temperature": 0.0, "avg_logprob": -0.19970200856526693, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.0010460567427799106}, {"id": 8, "seek": 5528, "start": 55.28, "end": 60.2, "text": " But the concepts are generic and not Ceph specific.", "tokens": [583, 264, 10392, 366, 19577, 293, 406, 383, 595, 71, 2685, 13], "temperature": 0.0, "avg_logprob": -0.18871183748598452, "compression_ratio": 1.5080213903743316, "no_speech_prob": 0.00019818736473098397}, {"id": 9, "seek": 5528, "start": 60.2, "end": 65.16, "text": " So it's a mix.", "tokens": [407, 309, 311, 257, 2890, 13], "temperature": 0.0, "avg_logprob": -0.18871183748598452, "compression_ratio": 1.5080213903743316, "no_speech_prob": 0.00019818736473098397}, {"id": 10, "seek": 5528, "start": 65.16, "end": 72.0, "text": " Okay, so we will talk, we want what is optimal cluster performance", "tokens": [1033, 11, 370, 321, 486, 751, 11, 321, 528, 437, 307, 16252, 13630, 3389], "temperature": 0.0, "avg_logprob": -0.18871183748598452, "compression_ratio": 1.5080213903743316, "no_speech_prob": 0.00019818736473098397}, {"id": 11, "seek": 5528, "start": 72.0, "end": 74.6, "text": " and why we need optimal cluster performance.", "tokens": [293, 983, 321, 643, 16252, 13630, 3389, 13], "temperature": 0.0, "avg_logprob": -0.18871183748598452, "compression_ratio": 1.5080213903743316, "no_speech_prob": 0.00019818736473098397}, {"id": 12, "seek": 5528, "start": 74.6, "end": 77.04, "text": " It would be just at the beginning.", "tokens": [467, 576, 312, 445, 412, 264, 2863, 13], "temperature": 0.0, "avg_logprob": -0.18871183748598452, "compression_ratio": 1.5080213903743316, "no_speech_prob": 0.00019818736473098397}, {"id": 13, "seek": 5528, "start": 77.04, "end": 84.76, "text": " Then I'm going back to explain what we did in Ceph for Riff version.", "tokens": [1396, 286, 478, 516, 646, 281, 2903, 437, 321, 630, 294, 383, 595, 71, 337, 497, 3661, 3037, 13], "temperature": 0.0, "avg_logprob": -0.18871183748598452, "compression_ratio": 1.5080213903743316, "no_speech_prob": 0.00019818736473098397}, {"id": 14, "seek": 8476, "start": 84.76, "end": 91.84, "text": " We have a new read balancer which I explained quite shortly.", "tokens": [492, 362, 257, 777, 1401, 3119, 28347, 597, 286, 8825, 1596, 13392, 13], "temperature": 0.0, "avg_logprob": -0.14852567446433892, "compression_ratio": 1.4484848484848485, "no_speech_prob": 0.0005997771513648331}, {"id": 15, "seek": 8476, "start": 91.84, "end": 97.84, "text": " It's not into full details, but it's an infrastructure that could be used", "tokens": [467, 311, 406, 666, 1577, 4365, 11, 457, 309, 311, 364, 6896, 300, 727, 312, 1143], "temperature": 0.0, "avg_logprob": -0.14852567446433892, "compression_ratio": 1.4484848484848485, "no_speech_prob": 0.0005997771513648331}, {"id": 16, "seek": 8476, "start": 97.84, "end": 102.68, "text": " to better control the load later.", "tokens": [281, 1101, 1969, 264, 3677, 1780, 13], "temperature": 0.0, "avg_logprob": -0.14852567446433892, "compression_ratio": 1.4484848484848485, "no_speech_prob": 0.0005997771513648331}, {"id": 17, "seek": 8476, "start": 102.68, "end": 111.08000000000001, "text": " Then some future plans that we already have which are good as examples", "tokens": [1396, 512, 2027, 5482, 300, 321, 1217, 362, 597, 366, 665, 382, 5110], "temperature": 0.0, "avg_logprob": -0.14852567446433892, "compression_ratio": 1.4484848484848485, "no_speech_prob": 0.0005997771513648331}, {"id": 18, "seek": 11108, "start": 111.08, "end": 115.12, "text": " to what we could do with this infrastructure.", "tokens": [281, 437, 321, 727, 360, 365, 341, 6896, 13], "temperature": 0.0, "avg_logprob": -0.11763078516179865, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.0011944726575165987}, {"id": 19, "seek": 11108, "start": 115.12, "end": 118.28, "text": " And then we'll go to the real problem,", "tokens": [400, 550, 321, 603, 352, 281, 264, 957, 1154, 11], "temperature": 0.0, "avg_logprob": -0.11763078516179865, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.0011944726575165987}, {"id": 20, "seek": 11108, "start": 118.28, "end": 127.44, "text": " how we could actually dynamically change the way the load is spread across Ceph cluster", "tokens": [577, 321, 727, 767, 43492, 1319, 264, 636, 264, 3677, 307, 3974, 2108, 383, 595, 71, 13630], "temperature": 0.0, "avg_logprob": -0.11763078516179865, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.0011944726575165987}, {"id": 21, "seek": 11108, "start": 127.44, "end": 133.88, "text": " in case we need to do it because other things change in the cluster.", "tokens": [294, 1389, 321, 643, 281, 360, 309, 570, 661, 721, 1319, 294, 264, 13630, 13], "temperature": 0.0, "avg_logprob": -0.11763078516179865, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.0011944726575165987}, {"id": 22, "seek": 11108, "start": 133.88, "end": 138.68, "text": " How we could fit the way the load is spread in Ceph", "tokens": [1012, 321, 727, 3318, 264, 636, 264, 3677, 307, 3974, 294, 383, 595, 71], "temperature": 0.0, "avg_logprob": -0.11763078516179865, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.0011944726575165987}, {"id": 23, "seek": 13868, "start": 138.68, "end": 150.64000000000001, "text": " because of some kind of external change in the conditions that we need to respond to.", "tokens": [570, 295, 512, 733, 295, 8320, 1319, 294, 264, 4487, 300, 321, 643, 281, 4196, 281, 13], "temperature": 0.0, "avg_logprob": -0.19848895463787142, "compression_ratio": 1.5031847133757963, "no_speech_prob": 0.0003174611774738878}, {"id": 24, "seek": 13868, "start": 150.64000000000001, "end": 155.24, "text": " So, again, just an example.", "tokens": [407, 11, 797, 11, 445, 364, 1365, 13], "temperature": 0.0, "avg_logprob": -0.19848895463787142, "compression_ratio": 1.5031847133757963, "no_speech_prob": 0.0003174611774738878}, {"id": 25, "seek": 13868, "start": 155.24, "end": 159.20000000000002, "text": " If we have a cluster, we have here nodes and we have three workloads", "tokens": [759, 321, 362, 257, 13630, 11, 321, 362, 510, 13891, 293, 321, 362, 1045, 32452], "temperature": 0.0, "avg_logprob": -0.19848895463787142, "compression_ratio": 1.5031847133757963, "no_speech_prob": 0.0003174611774738878}, {"id": 26, "seek": 13868, "start": 159.20000000000002, "end": 165.68, "text": " and they are split not totally evenly over the nodes.", "tokens": [293, 436, 366, 7472, 406, 3879, 17658, 670, 264, 13891, 13], "temperature": 0.0, "avg_logprob": -0.19848895463787142, "compression_ratio": 1.5031847133757963, "no_speech_prob": 0.0003174611774738878}, {"id": 27, "seek": 16568, "start": 165.68, "end": 172.16, "text": " And if we had bad luck, we could see that some nodes are more loaded than the other nodes.", "tokens": [400, 498, 321, 632, 1578, 3668, 11, 321, 727, 536, 300, 512, 13891, 366, 544, 13210, 813, 264, 661, 13891, 13], "temperature": 0.0, "avg_logprob": -0.18172317504882812, "compression_ratio": 1.58, "no_speech_prob": 0.0008469144813716412}, {"id": 28, "seek": 16568, "start": 172.16, "end": 179.12, "text": " And the problem is, as everyone probably guesses, one node reaches 100% load,", "tokens": [400, 264, 1154, 307, 11, 382, 1518, 1391, 42703, 11, 472, 9984, 14235, 2319, 4, 3677, 11], "temperature": 0.0, "avg_logprob": -0.18172317504882812, "compression_ratio": 1.58, "no_speech_prob": 0.0008469144813716412}, {"id": 29, "seek": 16568, "start": 179.12, "end": 186.08, "text": " then the entire system starts to become slow because we have weakest link in the chain effect.", "tokens": [550, 264, 2302, 1185, 3719, 281, 1813, 2964, 570, 321, 362, 44001, 2113, 294, 264, 5021, 1802, 13], "temperature": 0.0, "avg_logprob": -0.18172317504882812, "compression_ratio": 1.58, "no_speech_prob": 0.0008469144813716412}, {"id": 30, "seek": 16568, "start": 186.08, "end": 193.0, "text": " Assuming these workloads cannot respond fast enough,", "tokens": [6281, 24919, 613, 32452, 2644, 4196, 2370, 1547, 11], "temperature": 0.0, "avg_logprob": -0.18172317504882812, "compression_ratio": 1.58, "no_speech_prob": 0.0008469144813716412}, {"id": 31, "seek": 19300, "start": 193.0, "end": 203.96, "text": " so you get all kinds of cues created and the entire cluster loses its ability to perform well.", "tokens": [370, 291, 483, 439, 3685, 295, 32192, 2942, 293, 264, 2302, 13630, 18293, 1080, 3485, 281, 2042, 731, 13], "temperature": 0.0, "avg_logprob": -0.18086430430412292, "compression_ratio": 1.50920245398773, "no_speech_prob": 0.000456354086054489}, {"id": 32, "seek": 19300, "start": 203.96, "end": 207.0, "text": " It still performs, but not that well.", "tokens": [467, 920, 26213, 11, 457, 406, 300, 731, 13], "temperature": 0.0, "avg_logprob": -0.18086430430412292, "compression_ratio": 1.50920245398773, "no_speech_prob": 0.000456354086054489}, {"id": 33, "seek": 19300, "start": 207.0, "end": 211.92000000000002, "text": " So, basically, when we build a cluster and we look from the outside,", "tokens": [407, 11, 1936, 11, 562, 321, 1322, 257, 13630, 293, 321, 574, 490, 264, 2380, 11], "temperature": 0.0, "avg_logprob": -0.18086430430412292, "compression_ratio": 1.50920245398773, "no_speech_prob": 0.000456354086054489}, {"id": 34, "seek": 19300, "start": 211.92000000000002, "end": 217.04, "text": " we want the load to be spread almost evenly.", "tokens": [321, 528, 264, 3677, 281, 312, 3974, 1920, 17658, 13], "temperature": 0.0, "avg_logprob": -0.18086430430412292, "compression_ratio": 1.50920245398773, "no_speech_prob": 0.000456354086054489}, {"id": 35, "seek": 21704, "start": 217.04, "end": 223.68, "text": " So, when one node reaches 100%, we know the cluster is fully occupied.", "tokens": [407, 11, 562, 472, 9984, 14235, 2319, 8923, 321, 458, 264, 13630, 307, 4498, 19629, 13], "temperature": 0.0, "avg_logprob": -0.1937871165089793, "compression_ratio": 1.5376344086021505, "no_speech_prob": 5.137456173542887e-05}, {"id": 36, "seek": 21704, "start": 223.68, "end": 227.16, "text": " There is nothing we could do about it.", "tokens": [821, 307, 1825, 321, 727, 360, 466, 309, 13], "temperature": 0.0, "avg_logprob": -0.1937871165089793, "compression_ratio": 1.5376344086021505, "no_speech_prob": 5.137456173542887e-05}, {"id": 37, "seek": 21704, "start": 227.16, "end": 234.23999999999998, "text": " This is another image which shows something which is way better", "tokens": [639, 307, 1071, 3256, 597, 3110, 746, 597, 307, 636, 1101], "temperature": 0.0, "avg_logprob": -0.1937871165089793, "compression_ratio": 1.5376344086021505, "no_speech_prob": 5.137456173542887e-05}, {"id": 38, "seek": 21704, "start": 234.23999999999998, "end": 238.64, "text": " because the nodes, again, it's the same.", "tokens": [570, 264, 13891, 11, 797, 11, 309, 311, 264, 912, 13], "temperature": 0.0, "avg_logprob": -0.1937871165089793, "compression_ratio": 1.5376344086021505, "no_speech_prob": 5.137456173542887e-05}, {"id": 39, "seek": 21704, "start": 238.64, "end": 240.28, "text": " It's created the same number.", "tokens": [467, 311, 2942, 264, 912, 1230, 13], "temperature": 0.0, "avg_logprob": -0.1937871165089793, "compression_ratio": 1.5376344086021505, "no_speech_prob": 5.137456173542887e-05}, {"id": 40, "seek": 21704, "start": 240.28, "end": 243.44, "text": " The areas of each workloads are the same.", "tokens": [440, 3179, 295, 1184, 32452, 366, 264, 912, 13], "temperature": 0.0, "avg_logprob": -0.1937871165089793, "compression_ratio": 1.5376344086021505, "no_speech_prob": 5.137456173542887e-05}, {"id": 41, "seek": 24344, "start": 243.44, "end": 251.52, "text": " And it actually shows the cluster itself is balanced.", "tokens": [400, 309, 767, 3110, 264, 13630, 2564, 307, 13902, 13], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 42, "seek": 24344, "start": 251.52, "end": 255.64, "text": " And we could get, when it fills up, it fills up together,", "tokens": [400, 321, 727, 483, 11, 562, 309, 22498, 493, 11, 309, 22498, 493, 1214, 11], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 43, "seek": 24344, "start": 255.64, "end": 260.96, "text": " so we use the cluster for the best that we can.", "tokens": [370, 321, 764, 264, 13630, 337, 264, 1151, 300, 321, 393, 13], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 44, "seek": 24344, "start": 260.96, "end": 264.28, "text": " So, actually, if we try to look at what we have,", "tokens": [407, 11, 767, 11, 498, 321, 853, 281, 574, 412, 437, 321, 362, 11], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 45, "seek": 24344, "start": 264.28, "end": 266.8, "text": " we want something flexible with fixed volume.", "tokens": [321, 528, 746, 11358, 365, 6806, 5523, 13], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 46, "seek": 24344, "start": 266.8, "end": 268.48, "text": " A balloon is what I find.", "tokens": [316, 16994, 307, 437, 286, 915, 13], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 47, "seek": 24344, "start": 268.48, "end": 272.4, "text": " We want something, the performance that we want is the volume,", "tokens": [492, 528, 746, 11, 264, 3389, 300, 321, 528, 307, 264, 5523, 11], "temperature": 0.0, "avg_logprob": -0.1471813402677837, "compression_ratio": 1.6896551724137931, "no_speech_prob": 0.0002036682708421722}, {"id": 48, "seek": 27240, "start": 272.4, "end": 277.12, "text": " but it should be flexible because we can't control all the workloads.", "tokens": [457, 309, 820, 312, 11358, 570, 321, 393, 380, 1969, 439, 264, 32452, 13], "temperature": 0.0, "avg_logprob": -0.15826199718357362, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.0002403507533017546}, {"id": 49, "seek": 27240, "start": 277.12, "end": 284.84, "text": " So, if we take, for example, we have on the nodes a backup program", "tokens": [407, 11, 498, 321, 747, 11, 337, 1365, 11, 321, 362, 322, 264, 13891, 257, 14807, 1461], "temperature": 0.0, "avg_logprob": -0.15826199718357362, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.0002403507533017546}, {"id": 50, "seek": 27240, "start": 284.84, "end": 287.67999999999995, "text": " which runs in nights, but not at the same time.", "tokens": [597, 6676, 294, 13249, 11, 457, 406, 412, 264, 912, 565, 13], "temperature": 0.0, "avg_logprob": -0.15826199718357362, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.0002403507533017546}, {"id": 51, "seek": 27240, "start": 287.67999999999995, "end": 289.47999999999996, "text": " It gradually goes over all the nodes.", "tokens": [467, 13145, 1709, 670, 439, 264, 13891, 13], "temperature": 0.0, "avg_logprob": -0.15826199718357362, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.0002403507533017546}, {"id": 52, "seek": 27240, "start": 289.47999999999996, "end": 296.08, "text": " So, each one of the nodes gets some kind of peak either in IOs", "tokens": [407, 11, 1184, 472, 295, 264, 13891, 2170, 512, 733, 295, 10651, 2139, 294, 286, 31376], "temperature": 0.0, "avg_logprob": -0.15826199718357362, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.0002403507533017546}, {"id": 53, "seek": 27240, "start": 296.08, "end": 302.08, "text": " or in network traffic, and it peaks and it's more full than others.", "tokens": [420, 294, 3209, 6419, 11, 293, 309, 26897, 293, 309, 311, 544, 1577, 813, 2357, 13], "temperature": 0.0, "avg_logprob": -0.15826199718357362, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.0002403507533017546}, {"id": 54, "seek": 30208, "start": 302.08, "end": 309.0, "text": " And then the others, the other one, and it goes over all the nodes.", "tokens": [400, 550, 264, 2357, 11, 264, 661, 472, 11, 293, 309, 1709, 670, 439, 264, 13891, 13], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 55, "seek": 30208, "start": 309.0, "end": 311.12, "text": " We can obviously mitigate this.", "tokens": [492, 393, 2745, 27336, 341, 13], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 56, "seek": 30208, "start": 311.12, "end": 317.03999999999996, "text": " We can say, OK, we allocate some capacity for this backup program", "tokens": [492, 393, 584, 11, 2264, 11, 321, 35713, 512, 6042, 337, 341, 14807, 1461], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 57, "seek": 30208, "start": 317.03999999999996, "end": 321.24, "text": " so we know that other workloads could run on this node.", "tokens": [370, 321, 458, 300, 661, 32452, 727, 1190, 322, 341, 9984, 13], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 58, "seek": 30208, "start": 321.24, "end": 324.88, "text": " But if these backup programs work for an hour every day,", "tokens": [583, 498, 613, 14807, 4268, 589, 337, 364, 1773, 633, 786, 11], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 59, "seek": 30208, "start": 324.88, "end": 330.03999999999996, "text": " then we allocate some capacity for one hour and the other 23 hours,", "tokens": [550, 321, 35713, 512, 6042, 337, 472, 1773, 293, 264, 661, 6673, 2496, 11], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 60, "seek": 30208, "start": 330.03999999999996, "end": 331.79999999999995, "text": " it is not used.", "tokens": [309, 307, 406, 1143, 13], "temperature": 0.0, "avg_logprob": -0.14181249340375265, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.0015763596165925264}, {"id": 61, "seek": 33180, "start": 331.8, "end": 333.04, "text": " Probably not used.", "tokens": [9210, 406, 1143, 13], "temperature": 0.0, "avg_logprob": -0.2112498998641968, "compression_ratio": 1.6864864864864866, "no_speech_prob": 0.0008611945668235421}, {"id": 62, "seek": 33180, "start": 333.04, "end": 337.56, "text": " It's much better if we could incorporate this change,", "tokens": [467, 311, 709, 1101, 498, 321, 727, 16091, 341, 1319, 11], "temperature": 0.0, "avg_logprob": -0.2112498998641968, "compression_ratio": 1.6864864864864866, "no_speech_prob": 0.0008611945668235421}, {"id": 63, "seek": 33180, "start": 337.56, "end": 345.36, "text": " these backup runs over the cluster and move the nodes of the nodes", "tokens": [613, 14807, 6676, 670, 264, 13630, 293, 1286, 264, 13891, 295, 264, 13891], "temperature": 0.0, "avg_logprob": -0.2112498998641968, "compression_ratio": 1.6864864864864866, "no_speech_prob": 0.0008611945668235421}, {"id": 64, "seek": 33180, "start": 345.36, "end": 349.56, "text": " with the backup to other nodes for some time for an hour.", "tokens": [365, 264, 14807, 281, 661, 13891, 337, 512, 565, 337, 364, 1773, 13], "temperature": 0.0, "avg_logprob": -0.2112498998641968, "compression_ratio": 1.6864864864864866, "no_speech_prob": 0.0008611945668235421}, {"id": 65, "seek": 33180, "start": 349.56, "end": 352.2, "text": " Then the backup finishes go to another node,", "tokens": [1396, 264, 14807, 23615, 352, 281, 1071, 9984, 11], "temperature": 0.0, "avg_logprob": -0.2112498998641968, "compression_ratio": 1.6864864864864866, "no_speech_prob": 0.0008611945668235421}, {"id": 66, "seek": 33180, "start": 352.2, "end": 357.44, "text": " then we move the nodes from back to the original node and we make it.", "tokens": [550, 321, 1286, 264, 13891, 490, 646, 281, 264, 3380, 9984, 293, 321, 652, 309, 13], "temperature": 0.0, "avg_logprob": -0.2112498998641968, "compression_ratio": 1.6864864864864866, "no_speech_prob": 0.0008611945668235421}, {"id": 67, "seek": 35744, "start": 357.44, "end": 362.04, "text": " It's way more effective.", "tokens": [467, 311, 636, 544, 4942, 13], "temperature": 0.0, "avg_logprob": -0.19922973536237887, "compression_ratio": 1.652694610778443, "no_speech_prob": 0.0006690367590636015}, {"id": 68, "seek": 35744, "start": 362.04, "end": 369.12, "text": " So, in some sense, we do some kind of over provisioning on the nodes", "tokens": [407, 11, 294, 512, 2020, 11, 321, 360, 512, 733, 295, 670, 17225, 278, 322, 264, 13891], "temperature": 0.0, "avg_logprob": -0.19922973536237887, "compression_ratio": 1.652694610778443, "no_speech_prob": 0.0006690367590636015}, {"id": 69, "seek": 35744, "start": 369.12, "end": 374.2, "text": " when we know that most of the time we are not over provisioning", "tokens": [562, 321, 458, 300, 881, 295, 264, 565, 321, 366, 406, 670, 17225, 278], "temperature": 0.0, "avg_logprob": -0.19922973536237887, "compression_ratio": 1.652694610778443, "no_speech_prob": 0.0006690367590636015}, {"id": 70, "seek": 35744, "start": 374.2, "end": 376.52, "text": " and when we are over provisioning, we could mitigate this.", "tokens": [293, 562, 321, 366, 670, 17225, 278, 11, 321, 727, 27336, 341, 13], "temperature": 0.0, "avg_logprob": -0.19922973536237887, "compression_ratio": 1.652694610778443, "no_speech_prob": 0.0006690367590636015}, {"id": 71, "seek": 35744, "start": 376.52, "end": 380.36, "text": " That's the idea.", "tokens": [663, 311, 264, 1558, 13], "temperature": 0.0, "avg_logprob": -0.19922973536237887, "compression_ratio": 1.652694610778443, "no_speech_prob": 0.0006690367590636015}, {"id": 72, "seek": 35744, "start": 380.36, "end": 383.24, "text": " And the other use case that we could have,", "tokens": [400, 264, 661, 764, 1389, 300, 321, 727, 362, 11], "temperature": 0.0, "avg_logprob": -0.19922973536237887, "compression_ratio": 1.652694610778443, "no_speech_prob": 0.0006690367590636015}, {"id": 73, "seek": 38324, "start": 383.24, "end": 388.52, "text": " that we could get a node coming to full capacity when we didn't plan it,", "tokens": [300, 321, 727, 483, 257, 9984, 1348, 281, 1577, 6042, 562, 321, 994, 380, 1393, 309, 11], "temperature": 0.0, "avg_logprob": -0.23584980867346939, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.0008976817480288446}, {"id": 74, "seek": 38324, "start": 388.52, "end": 392.72, "text": " it could be all kinds of failure, NIC problems,", "tokens": [309, 727, 312, 439, 3685, 295, 7763, 11, 426, 2532, 2740, 11], "temperature": 0.0, "avg_logprob": -0.23584980867346939, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.0008976817480288446}, {"id": 75, "seek": 38324, "start": 392.72, "end": 397.16, "text": " all the top of the rack switch problems, other hardware,", "tokens": [439, 264, 1192, 295, 264, 14788, 3679, 2740, 11, 661, 8837, 11], "temperature": 0.0, "avg_logprob": -0.23584980867346939, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.0008976817480288446}, {"id": 76, "seek": 38324, "start": 397.16, "end": 400.56, "text": " or if we talk about SEPH, disk failure,", "tokens": [420, 498, 321, 751, 466, 318, 8929, 39, 11, 12355, 7763, 11], "temperature": 0.0, "avg_logprob": -0.23584980867346939, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.0008976817480288446}, {"id": 77, "seek": 38324, "start": 400.56, "end": 408.24, "text": " all kinds of other stuff could bring to a situation that may be bad", "tokens": [439, 3685, 295, 661, 1507, 727, 1565, 281, 257, 2590, 300, 815, 312, 1578], "temperature": 0.0, "avg_logprob": -0.23584980867346939, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.0008976817480288446}, {"id": 78, "seek": 38324, "start": 408.24, "end": 412.8, "text": " but not critical enough to take node down and do full rebuild and all this stuff.", "tokens": [457, 406, 4924, 1547, 281, 747, 9984, 760, 293, 360, 1577, 16877, 293, 439, 341, 1507, 13], "temperature": 0.0, "avg_logprob": -0.23584980867346939, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.0008976817480288446}, {"id": 79, "seek": 41280, "start": 412.8, "end": 418.52000000000004, "text": " So, that's the idea is to have something which is flexible and we could play with it.", "tokens": [407, 11, 300, 311, 264, 1558, 307, 281, 362, 746, 597, 307, 11358, 293, 321, 727, 862, 365, 309, 13], "temperature": 0.0, "avg_logprob": -0.16466633081436158, "compression_ratio": 1.541871921182266, "no_speech_prob": 0.00022226771397981793}, {"id": 80, "seek": 41280, "start": 418.52000000000004, "end": 423.16, "text": " The problem is that our balloon is built of LEGO bricks", "tokens": [440, 1154, 307, 300, 527, 16994, 307, 3094, 295, 36072, 25497], "temperature": 0.0, "avg_logprob": -0.16466633081436158, "compression_ratio": 1.541871921182266, "no_speech_prob": 0.00022226771397981793}, {"id": 81, "seek": 41280, "start": 423.16, "end": 426.72, "text": " and it's not as flexible as we think.", "tokens": [293, 309, 311, 406, 382, 11358, 382, 321, 519, 13], "temperature": 0.0, "avg_logprob": -0.16466633081436158, "compression_ratio": 1.541871921182266, "no_speech_prob": 0.00022226771397981793}, {"id": 82, "seek": 41280, "start": 426.72, "end": 433.72, "text": " So, I want to show the amount of flexibility that we have,", "tokens": [407, 11, 286, 528, 281, 855, 264, 2372, 295, 12635, 300, 321, 362, 11], "temperature": 0.0, "avg_logprob": -0.16466633081436158, "compression_ratio": 1.541871921182266, "no_speech_prob": 0.00022226771397981793}, {"id": 83, "seek": 41280, "start": 433.72, "end": 438.72, "text": " that we could play with when we talk about software defined storage system", "tokens": [300, 321, 727, 862, 365, 562, 321, 751, 466, 4722, 7642, 6725, 1185], "temperature": 0.0, "avg_logprob": -0.16466633081436158, "compression_ratio": 1.541871921182266, "no_speech_prob": 0.00022226771397981793}, {"id": 84, "seek": 43872, "start": 438.72, "end": 445.12, "text": " and which are more challenging than other workloads because it's stateful,", "tokens": [293, 597, 366, 544, 7595, 813, 661, 32452, 570, 309, 311, 1785, 906, 11], "temperature": 0.0, "avg_logprob": -0.19178332291640243, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.001053422805853188}, {"id": 85, "seek": 43872, "start": 445.12, "end": 451.64000000000004, "text": " stateless workloads are easier to manage flexibly.", "tokens": [2219, 4272, 32452, 366, 3571, 281, 3067, 5896, 3545, 13], "temperature": 0.0, "avg_logprob": -0.19178332291640243, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.001053422805853188}, {"id": 86, "seek": 43872, "start": 451.64000000000004, "end": 454.52000000000004, "text": " So, we want to go from this, this was the first,", "tokens": [407, 11, 321, 528, 281, 352, 490, 341, 11, 341, 390, 264, 700, 11], "temperature": 0.0, "avg_logprob": -0.19178332291640243, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.001053422805853188}, {"id": 87, "seek": 43872, "start": 454.52000000000004, "end": 459.44000000000005, "text": " this is the copy of the first diagram that I showed", "tokens": [341, 307, 264, 5055, 295, 264, 700, 10686, 300, 286, 4712], "temperature": 0.0, "avg_logprob": -0.19178332291640243, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.001053422805853188}, {"id": 88, "seek": 43872, "start": 459.44000000000005, "end": 465.32000000000005, "text": " and this is where we want to be and I change only the orange workload.", "tokens": [293, 341, 307, 689, 321, 528, 281, 312, 293, 286, 1319, 787, 264, 7671, 20139, 13], "temperature": 0.0, "avg_logprob": -0.19178332291640243, "compression_ratio": 1.6685393258426966, "no_speech_prob": 0.001053422805853188}, {"id": 89, "seek": 46532, "start": 465.32, "end": 470.71999999999997, "text": " It's the same numbers, exactly the same numbers, exactly the same area,", "tokens": [467, 311, 264, 912, 3547, 11, 2293, 264, 912, 3547, 11, 2293, 264, 912, 1859, 11], "temperature": 0.0, "avg_logprob": -0.17672806694394066, "compression_ratio": 1.6512820512820512, "no_speech_prob": 0.0005506657180376351}, {"id": 90, "seek": 46532, "start": 470.71999999999997, "end": 472.96, "text": " orange area but split differently.", "tokens": [7671, 1859, 457, 7472, 7614, 13], "temperature": 0.0, "avg_logprob": -0.17672806694394066, "compression_ratio": 1.6512820512820512, "no_speech_prob": 0.0005506657180376351}, {"id": 91, "seek": 46532, "start": 472.96, "end": 479.36, "text": " That's the approach that I want to take but, okay, it's a presentation.", "tokens": [663, 311, 264, 3109, 300, 286, 528, 281, 747, 457, 11, 1392, 11, 309, 311, 257, 5860, 13], "temperature": 0.0, "avg_logprob": -0.17672806694394066, "compression_ratio": 1.6512820512820512, "no_speech_prob": 0.0005506657180376351}, {"id": 92, "seek": 46532, "start": 479.36, "end": 483.68, "text": " I could do miracles in presentation, how I do it in real life", "tokens": [286, 727, 360, 24685, 294, 5860, 11, 577, 286, 360, 309, 294, 957, 993], "temperature": 0.0, "avg_logprob": -0.17672806694394066, "compression_ratio": 1.6512820512820512, "no_speech_prob": 0.0005506657180376351}, {"id": 93, "seek": 46532, "start": 483.68, "end": 493.08, "text": " and I want to show how we could play assuming SEPH is or software defined storage", "tokens": [293, 286, 528, 281, 855, 577, 321, 727, 862, 11926, 318, 8929, 39, 307, 420, 4722, 7642, 6725], "temperature": 0.0, "avg_logprob": -0.17672806694394066, "compression_ratio": 1.6512820512820512, "no_speech_prob": 0.0005506657180376351}, {"id": 94, "seek": 49308, "start": 493.08, "end": 497.68, "text": " is the orange one, how we could play with this to a limits.", "tokens": [307, 264, 7671, 472, 11, 577, 321, 727, 862, 365, 341, 281, 257, 10406, 13], "temperature": 0.0, "avg_logprob": -0.18361461730230422, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00019517821783665568}, {"id": 95, "seek": 49308, "start": 497.68, "end": 500.84, "text": " We can't do all the magic that we could do in presentation", "tokens": [492, 393, 380, 360, 439, 264, 5585, 300, 321, 727, 360, 294, 5860], "temperature": 0.0, "avg_logprob": -0.18361461730230422, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00019517821783665568}, {"id": 96, "seek": 49308, "start": 500.84, "end": 507.24, "text": " but we could do reasonable, under some condition, very good work,", "tokens": [457, 321, 727, 360, 10585, 11, 833, 512, 4188, 11, 588, 665, 589, 11], "temperature": 0.0, "avg_logprob": -0.18361461730230422, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00019517821783665568}, {"id": 97, "seek": 49308, "start": 507.24, "end": 515.84, "text": " under other condition, improve the situation not to a perfect solution.", "tokens": [833, 661, 4188, 11, 3470, 264, 2590, 406, 281, 257, 2176, 3827, 13], "temperature": 0.0, "avg_logprob": -0.18361461730230422, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00019517821783665568}, {"id": 98, "seek": 49308, "start": 515.84, "end": 520.4399999999999, "text": " So, it's all based on the idea of the SEPH read balancer", "tokens": [407, 11, 309, 311, 439, 2361, 322, 264, 1558, 295, 264, 318, 8929, 39, 1401, 3119, 28347], "temperature": 0.0, "avg_logprob": -0.18361461730230422, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00019517821783665568}, {"id": 99, "seek": 52044, "start": 520.44, "end": 526.6800000000001, "text": " and the idea today in SEPH, we have, not in SEPH, in every software defined storage,", "tokens": [293, 264, 1558, 965, 294, 318, 8929, 39, 11, 321, 362, 11, 406, 294, 318, 8929, 39, 11, 294, 633, 4722, 7642, 6725, 11], "temperature": 0.0, "avg_logprob": -0.20180405741152557, "compression_ratio": 1.5571428571428572, "no_speech_prob": 0.0004616588121280074}, {"id": 100, "seek": 52044, "start": 526.6800000000001, "end": 531.8000000000001, "text": " the main balancing requirement is that all the disks are full at the same percentage.", "tokens": [264, 2135, 22495, 11695, 307, 300, 439, 264, 41617, 366, 1577, 412, 264, 912, 9668, 13], "temperature": 0.0, "avg_logprob": -0.20180405741152557, "compression_ratio": 1.5571428571428572, "no_speech_prob": 0.0004616588121280074}, {"id": 101, "seek": 52044, "start": 531.8000000000001, "end": 534.8000000000001, "text": " The first disk which is full, the system is full.", "tokens": [440, 700, 12355, 597, 307, 1577, 11, 264, 1185, 307, 1577, 13], "temperature": 0.0, "avg_logprob": -0.20180405741152557, "compression_ratio": 1.5571428571428572, "no_speech_prob": 0.0004616588121280074}, {"id": 102, "seek": 52044, "start": 534.8000000000001, "end": 538.72, "text": " So, this is our basic assumption.", "tokens": [407, 11, 341, 307, 527, 3875, 15302, 13], "temperature": 0.0, "avg_logprob": -0.20180405741152557, "compression_ratio": 1.5571428571428572, "no_speech_prob": 0.0004616588121280074}, {"id": 103, "seek": 52044, "start": 538.72, "end": 547.8800000000001, "text": " Then, what we're doing today, we try to do is that if we have replica 3,", "tokens": [1396, 11, 437, 321, 434, 884, 965, 11, 321, 853, 281, 360, 307, 300, 498, 321, 362, 35456, 805, 11], "temperature": 0.0, "avg_logprob": -0.20180405741152557, "compression_ratio": 1.5571428571428572, "no_speech_prob": 0.0004616588121280074}, {"id": 104, "seek": 54788, "start": 547.88, "end": 553.84, "text": " then we have XPGs mapped to OSD, X divided by 3 would be primaries.", "tokens": [550, 321, 362, 1783, 47, 33715, 33318, 281, 12731, 35, 11, 1783, 6666, 538, 805, 576, 312, 2886, 4889, 13], "temperature": 0.0, "avg_logprob": -0.18617169753364896, "compression_ratio": 1.5879396984924623, "no_speech_prob": 0.00039829910383559763}, {"id": 105, "seek": 54788, "start": 553.84, "end": 561.52, "text": " So, the primaries are split evenly on the devices, not evenly split according to the number of the PGs.", "tokens": [407, 11, 264, 2886, 4889, 366, 7472, 17658, 322, 264, 5759, 11, 406, 17658, 7472, 4650, 281, 264, 1230, 295, 264, 430, 33715, 13], "temperature": 0.0, "avg_logprob": -0.18617169753364896, "compression_ratio": 1.5879396984924623, "no_speech_prob": 0.00039829910383559763}, {"id": 106, "seek": 54788, "start": 561.52, "end": 567.72, "text": " So, if we have a device with more PGs, it has more primaries.", "tokens": [407, 11, 498, 321, 362, 257, 4302, 365, 544, 430, 33715, 11, 309, 575, 544, 2886, 4889, 13], "temperature": 0.0, "avg_logprob": -0.18617169753364896, "compression_ratio": 1.5879396984924623, "no_speech_prob": 0.00039829910383559763}, {"id": 107, "seek": 54788, "start": 567.72, "end": 572.92, "text": " But, we don't have anything that does it, actually what is happening today in SEPH", "tokens": [583, 11, 321, 500, 380, 362, 1340, 300, 775, 309, 11, 767, 437, 307, 2737, 965, 294, 318, 8929, 39], "temperature": 0.0, "avg_logprob": -0.18617169753364896, "compression_ratio": 1.5879396984924623, "no_speech_prob": 0.00039829910383559763}, {"id": 108, "seek": 57292, "start": 572.92, "end": 578.28, "text": " is that we rely on the statistics of crash.", "tokens": [307, 300, 321, 10687, 322, 264, 12523, 295, 8252, 13], "temperature": 0.0, "avg_logprob": -0.17332681768080768, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.0006716330535709858}, {"id": 109, "seek": 57292, "start": 578.28, "end": 583.1999999999999, "text": " It works well for large clusters, it doesn't work well for small cluster.", "tokens": [467, 1985, 731, 337, 2416, 23313, 11, 309, 1177, 380, 589, 731, 337, 1359, 13630, 13], "temperature": 0.0, "avg_logprob": -0.17332681768080768, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.0006716330535709858}, {"id": 110, "seek": 57292, "start": 583.1999999999999, "end": 590.5999999999999, "text": " So, the SEPH read balancer comes to fix this and it's what we currently have,", "tokens": [407, 11, 264, 318, 8929, 39, 1401, 3119, 28347, 1487, 281, 3191, 341, 293, 309, 311, 437, 321, 4362, 362, 11], "temperature": 0.0, "avg_logprob": -0.17332681768080768, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.0006716330535709858}, {"id": 111, "seek": 57292, "start": 590.5999999999999, "end": 596.3199999999999, "text": " more in the next bullet, is for the small clusters where the statistics doesn't play well.", "tokens": [544, 294, 264, 958, 11632, 11, 307, 337, 264, 1359, 23313, 689, 264, 12523, 1177, 380, 862, 731, 13], "temperature": 0.0, "avg_logprob": -0.17332681768080768, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.0006716330535709858}, {"id": 112, "seek": 57292, "start": 596.3199999999999, "end": 601.76, "text": " So, what we actually did,", "tokens": [407, 11, 437, 321, 767, 630, 11], "temperature": 0.0, "avg_logprob": -0.17332681768080768, "compression_ratio": 1.6507936507936507, "no_speech_prob": 0.0006716330535709858}, {"id": 113, "seek": 60176, "start": 601.76, "end": 609.0, "text": " we added three different things together, create a read balancer,", "tokens": [321, 3869, 1045, 819, 721, 1214, 11, 1884, 257, 1401, 3119, 28347, 11], "temperature": 0.0, "avg_logprob": -0.19620064461585318, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.0002223188494099304}, {"id": 114, "seek": 60176, "start": 609.0, "end": 613.0, "text": " which could actually split the reads evenly across us.", "tokens": [597, 727, 767, 7472, 264, 15700, 17658, 2108, 505, 13], "temperature": 0.0, "avg_logprob": -0.19620064461585318, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.0002223188494099304}, {"id": 115, "seek": 60176, "start": 613.0, "end": 618.8, "text": " This is actually what it does, it splits the primaries as I explained for replica X.", "tokens": [639, 307, 767, 437, 309, 775, 11, 309, 37741, 264, 2886, 4889, 382, 286, 8825, 337, 35456, 1783, 13], "temperature": 0.0, "avg_logprob": -0.19620064461585318, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.0002223188494099304}, {"id": 116, "seek": 60176, "start": 618.8, "end": 625.08, "text": " One divided by replica X are primaries per OSDs for the PGs.", "tokens": [1485, 6666, 538, 35456, 1783, 366, 2886, 4889, 680, 12731, 35, 82, 337, 264, 430, 33715, 13], "temperature": 0.0, "avg_logprob": -0.19620064461585318, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.0002223188494099304}, {"id": 117, "seek": 60176, "start": 625.08, "end": 627.28, "text": " So, it just changes the primaries.", "tokens": [407, 11, 309, 445, 2962, 264, 2886, 4889, 13], "temperature": 0.0, "avg_logprob": -0.19620064461585318, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.0002223188494099304}, {"id": 118, "seek": 60176, "start": 627.28, "end": 631.2, "text": " So, first of all, we created, it would be part of the RIF version.", "tokens": [407, 11, 700, 295, 439, 11, 321, 2942, 11, 309, 576, 312, 644, 295, 264, 497, 12775, 3037, 13], "temperature": 0.0, "avg_logprob": -0.19620064461585318, "compression_ratio": 1.6283185840707965, "no_speech_prob": 0.0002223188494099304}, {"id": 119, "seek": 63120, "start": 631.2, "end": 633.5200000000001, "text": " So, first of all, we created some kind of score.", "tokens": [407, 11, 700, 295, 439, 11, 321, 2942, 512, 733, 295, 6175, 13], "temperature": 0.0, "avg_logprob": -0.1821307707368658, "compression_ratio": 1.615, "no_speech_prob": 0.00023446005070582032}, {"id": 120, "seek": 63120, "start": 633.5200000000001, "end": 638.8000000000001, "text": " The score represents how well the read is balanced versus the optimum.", "tokens": [440, 6175, 8855, 577, 731, 264, 1401, 307, 13902, 5717, 264, 39326, 13], "temperature": 0.0, "avg_logprob": -0.1821307707368658, "compression_ratio": 1.615, "no_speech_prob": 0.00023446005070582032}, {"id": 121, "seek": 63120, "start": 638.8000000000001, "end": 641.2800000000001, "text": " Optimum is one.", "tokens": [35013, 449, 307, 472, 13], "temperature": 0.0, "avg_logprob": -0.1821307707368658, "compression_ratio": 1.615, "no_speech_prob": 0.00023446005070582032}, {"id": 122, "seek": 63120, "start": 641.2800000000001, "end": 646.0400000000001, "text": " If we have a score of two, meaning that under full load of reads,", "tokens": [759, 321, 362, 257, 6175, 295, 732, 11, 3620, 300, 833, 1577, 3677, 295, 15700, 11], "temperature": 0.0, "avg_logprob": -0.1821307707368658, "compression_ratio": 1.615, "no_speech_prob": 0.00023446005070582032}, {"id": 123, "seek": 63120, "start": 646.0400000000001, "end": 650.76, "text": " the system would perform half of a good system.", "tokens": [264, 1185, 576, 2042, 1922, 295, 257, 665, 1185, 13], "temperature": 0.0, "avg_logprob": -0.1821307707368658, "compression_ratio": 1.615, "no_speech_prob": 0.00023446005070582032}, {"id": 124, "seek": 63120, "start": 650.76, "end": 656.6, "text": " If it's three, for example, we have replica three and the score is three.", "tokens": [759, 309, 311, 1045, 11, 337, 1365, 11, 321, 362, 35456, 1045, 293, 264, 6175, 307, 1045, 13], "temperature": 0.0, "avg_logprob": -0.1821307707368658, "compression_ratio": 1.615, "no_speech_prob": 0.00023446005070582032}, {"id": 125, "seek": 65660, "start": 656.6, "end": 661.48, "text": " And we have three disks and score is three, it means all the reads are for a single disk.", "tokens": [400, 321, 362, 1045, 41617, 293, 6175, 307, 1045, 11, 309, 1355, 439, 264, 15700, 366, 337, 257, 2167, 12355, 13], "temperature": 0.0, "avg_logprob": -0.2079623914232441, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.001029855222441256}, {"id": 126, "seek": 65660, "start": 661.48, "end": 667.4, "text": " So, it's obviously third of the optimal when the reads split evenly among three disks.", "tokens": [407, 11, 309, 311, 2745, 2636, 295, 264, 16252, 562, 264, 15700, 7472, 17658, 3654, 1045, 41617, 13], "temperature": 0.0, "avg_logprob": -0.2079623914232441, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.001029855222441256}, {"id": 127, "seek": 65660, "start": 667.4, "end": 670.9200000000001, "text": " So, that's what I have.", "tokens": [407, 11, 300, 311, 437, 286, 362, 13], "temperature": 0.0, "avg_logprob": -0.2079623914232441, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.001029855222441256}, {"id": 128, "seek": 65660, "start": 670.9200000000001, "end": 679.8000000000001, "text": " Score works really well when the read affinity of the devices is high and it's still monotonous,", "tokens": [47901, 1985, 534, 731, 562, 264, 1401, 39703, 295, 264, 5759, 307, 1090, 293, 309, 311, 920, 1108, 27794, 563, 11], "temperature": 0.0, "avg_logprob": -0.2079623914232441, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.001029855222441256}, {"id": 129, "seek": 65660, "start": 679.8000000000001, "end": 686.5600000000001, "text": " but it's more difficult to explain the numbers when you have a lot of devices with small OSDs.", "tokens": [457, 309, 311, 544, 2252, 281, 2903, 264, 3547, 562, 291, 362, 257, 688, 295, 5759, 365, 1359, 12731, 35, 82, 13], "temperature": 0.0, "avg_logprob": -0.2079623914232441, "compression_ratio": 1.696969696969697, "no_speech_prob": 0.001029855222441256}, {"id": 130, "seek": 68656, "start": 686.56, "end": 691.56, "text": " With small read affinity numbers, and I could explain later why it is,", "tokens": [2022, 1359, 1401, 39703, 3547, 11, 293, 286, 727, 2903, 1780, 983, 309, 307, 11], "temperature": 0.0, "avg_logprob": -0.23557059933440855, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.00021150770771782845}, {"id": 131, "seek": 68656, "start": 691.56, "end": 696.04, "text": " it's not a good way to configure the system.", "tokens": [309, 311, 406, 257, 665, 636, 281, 22162, 264, 1185, 13], "temperature": 0.0, "avg_logprob": -0.23557059933440855, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.00021150770771782845}, {"id": 132, "seek": 68656, "start": 696.04, "end": 699.7199999999999, "text": " It creates all kinds of illegal configuration.", "tokens": [467, 7829, 439, 3685, 295, 11905, 11694, 13], "temperature": 0.0, "avg_logprob": -0.23557059933440855, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.00021150770771782845}, {"id": 133, "seek": 68656, "start": 699.7199999999999, "end": 707.4799999999999, "text": " You have to do what the user asks you not to do, but that's for side code.", "tokens": [509, 362, 281, 360, 437, 264, 4195, 8962, 291, 406, 281, 360, 11, 457, 300, 311, 337, 1252, 3089, 13], "temperature": 0.0, "avg_logprob": -0.23557059933440855, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.00021150770771782845}, {"id": 134, "seek": 68656, "start": 707.4799999999999, "end": 715.4, "text": " Then we have two new commands, PG-UPMAP commands, as we have PG-UPMAP primary and RMPG-UPMAP primary,", "tokens": [1396, 321, 362, 732, 777, 16901, 11, 40975, 12, 22917, 44, 4715, 16901, 11, 382, 321, 362, 40975, 12, 22917, 44, 4715, 6194, 293, 497, 12224, 38, 12, 22917, 44, 4715, 6194, 11], "temperature": 0.0, "avg_logprob": -0.23557059933440855, "compression_ratio": 1.5622119815668203, "no_speech_prob": 0.00021150770771782845}, {"id": 135, "seek": 71540, "start": 715.4, "end": 721.56, "text": " which actually say, okay, I get an OSD PG, the PG has X OSDs there,", "tokens": [597, 767, 584, 11, 1392, 11, 286, 483, 364, 12731, 35, 40975, 11, 264, 40975, 575, 1783, 12731, 35, 82, 456, 11], "temperature": 0.0, "avg_logprob": -0.1504377088239116, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00014921239926479757}, {"id": 136, "seek": 71540, "start": 721.56, "end": 724.1999999999999, "text": " make one of them the primary, I tell them which one.", "tokens": [652, 472, 295, 552, 264, 6194, 11, 286, 980, 552, 597, 472, 13], "temperature": 0.0, "avg_logprob": -0.1504377088239116, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00014921239926479757}, {"id": 137, "seek": 71540, "start": 724.1999999999999, "end": 728.4399999999999, "text": " So, I could actually change the primary within a PG.", "tokens": [407, 11, 286, 727, 767, 1319, 264, 6194, 1951, 257, 40975, 13], "temperature": 0.0, "avg_logprob": -0.1504377088239116, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00014921239926479757}, {"id": 138, "seek": 71540, "start": 728.4399999999999, "end": 735.36, "text": " And it's metadata only, we don't move data, you must give an OSD, which is part of the PG.", "tokens": [400, 309, 311, 26603, 787, 11, 321, 500, 380, 1286, 1412, 11, 291, 1633, 976, 364, 12731, 35, 11, 597, 307, 644, 295, 264, 40975, 13], "temperature": 0.0, "avg_logprob": -0.1504377088239116, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00014921239926479757}, {"id": 139, "seek": 71540, "start": 735.36, "end": 737.88, "text": " If you give OSD, which is not part of the PG, you get an error.", "tokens": [759, 291, 976, 12731, 35, 11, 597, 307, 406, 644, 295, 264, 40975, 11, 291, 483, 364, 6713, 13], "temperature": 0.0, "avg_logprob": -0.1504377088239116, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00014921239926479757}, {"id": 140, "seek": 71540, "start": 737.88, "end": 742.04, "text": " So, we are not trying to do anything, it's very cheap, very fast.", "tokens": [407, 11, 321, 366, 406, 1382, 281, 360, 1340, 11, 309, 311, 588, 7084, 11, 588, 2370, 13], "temperature": 0.0, "avg_logprob": -0.1504377088239116, "compression_ratio": 1.7280701754385965, "no_speech_prob": 0.00014921239926479757}, {"id": 141, "seek": 74204, "start": 742.04, "end": 749.28, "text": " It just changes the order of the OSDs within the PG, that's everything that it does.", "tokens": [467, 445, 2962, 264, 1668, 295, 264, 12731, 35, 82, 1951, 264, 40975, 11, 300, 311, 1203, 300, 309, 775, 13], "temperature": 0.0, "avg_logprob": -0.1471837361653646, "compression_ratio": 1.5394736842105263, "no_speech_prob": 0.00011931973858736455}, {"id": 142, "seek": 74204, "start": 749.28, "end": 753.56, "text": " And since it's first version, we want to make it opt-in option.", "tokens": [400, 1670, 309, 311, 700, 3037, 11, 321, 528, 281, 652, 309, 2427, 12, 259, 3614, 13], "temperature": 0.0, "avg_logprob": -0.1471837361653646, "compression_ratio": 1.5394736842105263, "no_speech_prob": 0.00011931973858736455}, {"id": 143, "seek": 74204, "start": 753.56, "end": 760.8399999999999, "text": " So, we have a new command to the OSD MAP tool, which actually calculates everything and spits", "tokens": [407, 11, 321, 362, 257, 777, 5622, 281, 264, 12731, 35, 376, 4715, 2290, 11, 597, 767, 4322, 1024, 1203, 293, 637, 1208], "temperature": 0.0, "avg_logprob": -0.1471837361653646, "compression_ratio": 1.5394736842105263, "no_speech_prob": 0.00011931973858736455}, {"id": 144, "seek": 74204, "start": 760.8399999999999, "end": 766.9599999999999, "text": " a script file that you could run in order to get to the perfect distribution.", "tokens": [257, 5755, 3991, 300, 291, 727, 1190, 294, 1668, 281, 483, 281, 264, 2176, 7316, 13], "temperature": 0.0, "avg_logprob": -0.1471837361653646, "compression_ratio": 1.5394736842105263, "no_speech_prob": 0.00011931973858736455}, {"id": 145, "seek": 74204, "start": 766.9599999999999, "end": 771.0799999999999, "text": " That's what we currently have.", "tokens": [663, 311, 437, 321, 4362, 362, 13], "temperature": 0.0, "avg_logprob": -0.1471837361653646, "compression_ratio": 1.5394736842105263, "no_speech_prob": 0.00011931973858736455}, {"id": 146, "seek": 77108, "start": 771.08, "end": 776.0400000000001, "text": " So, this is the example of when you run this, you could see smaller clusters,", "tokens": [407, 11, 341, 307, 264, 1365, 295, 562, 291, 1190, 341, 11, 291, 727, 536, 4356, 23313, 11], "temperature": 0.0, "avg_logprob": -0.1703528851534413, "compression_ratio": 1.6451612903225807, "no_speech_prob": 0.00014002935495227575}, {"id": 147, "seek": 77108, "start": 776.0400000000001, "end": 780.6800000000001, "text": " small cluster tend to be less balanced because statistics doesn't play well.", "tokens": [1359, 13630, 3928, 281, 312, 1570, 13902, 570, 12523, 1177, 380, 862, 731, 13], "temperature": 0.0, "avg_logprob": -0.1703528851534413, "compression_ratio": 1.6451612903225807, "no_speech_prob": 0.00014002935495227575}, {"id": 148, "seek": 77108, "start": 780.6800000000001, "end": 787.2800000000001, "text": " So, we have number of primaries for three OSDs, we have 11, 6, 15, obviously, it's not balanced.", "tokens": [407, 11, 321, 362, 1230, 295, 2886, 4889, 337, 1045, 12731, 35, 82, 11, 321, 362, 2975, 11, 1386, 11, 2119, 11, 2745, 11, 309, 311, 406, 13902, 13], "temperature": 0.0, "avg_logprob": -0.1703528851534413, "compression_ratio": 1.6451612903225807, "no_speech_prob": 0.00014002935495227575}, {"id": 149, "seek": 77108, "start": 787.2800000000001, "end": 793.84, "text": " And after you run it, you get 10, 11, 11, which is obviously the best that you could get.", "tokens": [400, 934, 291, 1190, 309, 11, 291, 483, 1266, 11, 2975, 11, 2975, 11, 597, 307, 2745, 264, 1151, 300, 291, 727, 483, 13], "temperature": 0.0, "avg_logprob": -0.1703528851534413, "compression_ratio": 1.6451612903225807, "no_speech_prob": 0.00014002935495227575}, {"id": 150, "seek": 77108, "start": 793.84, "end": 800.76, "text": " And the number is not one, because the average is 10 and 2 thirds.", "tokens": [400, 264, 1230, 307, 406, 472, 11, 570, 264, 4274, 307, 1266, 293, 568, 34552, 13], "temperature": 0.0, "avg_logprob": -0.1703528851534413, "compression_ratio": 1.6451612903225807, "no_speech_prob": 0.00014002935495227575}, {"id": 151, "seek": 80076, "start": 800.76, "end": 808.72, "text": " So, if you could have 10 and 2 thirds, you get a score of one, but it's 1.03 really good.", "tokens": [407, 11, 498, 291, 727, 362, 1266, 293, 568, 34552, 11, 291, 483, 257, 6175, 295, 472, 11, 457, 309, 311, 502, 13, 11592, 534, 665, 13], "temperature": 0.0, "avg_logprob": -0.14486610262017502, "compression_ratio": 1.4825581395348837, "no_speech_prob": 0.00020085062715224922}, {"id": 152, "seek": 80076, "start": 808.72, "end": 815.28, "text": " And here, obviously, it's 1.4 because it's 15 divided by 10 and 2 thirds.", "tokens": [400, 510, 11, 2745, 11, 309, 311, 502, 13, 19, 570, 309, 311, 2119, 6666, 538, 1266, 293, 568, 34552, 13], "temperature": 0.0, "avg_logprob": -0.14486610262017502, "compression_ratio": 1.4825581395348837, "no_speech_prob": 0.00020085062715224922}, {"id": 153, "seek": 80076, "start": 815.28, "end": 825.64, "text": " This is the out file that you could actually run as a script in order to apply the changes.", "tokens": [639, 307, 264, 484, 3991, 300, 291, 727, 767, 1190, 382, 257, 5755, 294, 1668, 281, 3079, 264, 2962, 13], "temperature": 0.0, "avg_logprob": -0.14486610262017502, "compression_ratio": 1.4825581395348837, "no_speech_prob": 0.00020085062715224922}, {"id": 154, "seek": 82564, "start": 825.64, "end": 833.4, "text": " If you look really carefully, you see that we have six changes, but actually we could only have five changes,", "tokens": [759, 291, 574, 534, 7500, 11, 291, 536, 300, 321, 362, 2309, 2962, 11, 457, 767, 321, 727, 787, 362, 1732, 2962, 11], "temperature": 0.0, "avg_logprob": -0.16386071118441495, "compression_ratio": 1.6195121951219513, "no_speech_prob": 0.00036237583844922483}, {"id": 155, "seek": 82564, "start": 833.4, "end": 837.12, "text": " even maybe four, we could, we should just make this 10.", "tokens": [754, 1310, 1451, 11, 321, 727, 11, 321, 820, 445, 652, 341, 1266, 13], "temperature": 0.0, "avg_logprob": -0.16386071118441495, "compression_ratio": 1.6195121951219513, "no_speech_prob": 0.00036237583844922483}, {"id": 156, "seek": 82564, "start": 837.12, "end": 844.56, "text": " So, we have 11, 10, 11, that's because of its greedy algorithm.", "tokens": [407, 11, 321, 362, 2975, 11, 1266, 11, 2975, 11, 300, 311, 570, 295, 1080, 28228, 9284, 13], "temperature": 0.0, "avg_logprob": -0.16386071118441495, "compression_ratio": 1.6195121951219513, "no_speech_prob": 0.00036237583844922483}, {"id": 157, "seek": 82564, "start": 844.56, "end": 852.8, "text": " Since these commands are really, really very, don't have overhead run really fast, it's not a problem.", "tokens": [4162, 613, 16901, 366, 534, 11, 534, 588, 11, 500, 380, 362, 19922, 1190, 534, 2370, 11, 309, 311, 406, 257, 1154, 13], "temperature": 0.0, "avg_logprob": -0.16386071118441495, "compression_ratio": 1.6195121951219513, "no_speech_prob": 0.00036237583844922483}, {"id": 158, "seek": 85280, "start": 852.8, "end": 859.24, "text": " If we would have need to move data, this would be a totally wrong one because we have two additional data movements.", "tokens": [759, 321, 576, 362, 643, 281, 1286, 1412, 11, 341, 576, 312, 257, 3879, 2085, 472, 570, 321, 362, 732, 4497, 1412, 9981, 13], "temperature": 0.0, "avg_logprob": -0.15553793122496787, "compression_ratio": 1.5794871794871794, "no_speech_prob": 0.0004785995988640934}, {"id": 159, "seek": 85280, "start": 859.24, "end": 870.0799999999999, "text": " We don't need it, it's really simple, so we didn't try to optimize on the number of changes just to make it come.", "tokens": [492, 500, 380, 643, 309, 11, 309, 311, 534, 2199, 11, 370, 321, 994, 380, 853, 281, 19719, 322, 264, 1230, 295, 2962, 445, 281, 652, 309, 808, 13], "temperature": 0.0, "avg_logprob": -0.15553793122496787, "compression_ratio": 1.5794871794871794, "no_speech_prob": 0.0004785995988640934}, {"id": 160, "seek": 85280, "start": 870.0799999999999, "end": 874.0799999999999, "text": " So, what is the implementation?", "tokens": [407, 11, 437, 307, 264, 11420, 30], "temperature": 0.0, "avg_logprob": -0.15553793122496787, "compression_ratio": 1.5794871794871794, "no_speech_prob": 0.0004785995988640934}, {"id": 161, "seek": 85280, "start": 874.0799999999999, "end": 877.4, "text": " The implementation is, we have two functions.", "tokens": [440, 11420, 307, 11, 321, 362, 732, 6828, 13], "temperature": 0.0, "avg_logprob": -0.15553793122496787, "compression_ratio": 1.5794871794871794, "no_speech_prob": 0.0004785995988640934}, {"id": 162, "seek": 87740, "start": 877.4, "end": 884.4399999999999, "text": " One of them is, we have one, it's an example, calc desired primary distribution.", "tokens": [1485, 295, 552, 307, 11, 321, 362, 472, 11, 309, 311, 364, 1365, 11, 2104, 66, 14721, 6194, 7316, 13], "temperature": 0.0, "avg_logprob": -0.1453793806188247, "compression_ratio": 1.5786802030456852, "no_speech_prob": 0.0001671455829637125}, {"id": 163, "seek": 87740, "start": 884.4399999999999, "end": 891.1999999999999, "text": " That's where we go over the configuration and decide what's the final distribution of primary that we want.", "tokens": [663, 311, 689, 321, 352, 670, 264, 11694, 293, 4536, 437, 311, 264, 2572, 7316, 295, 6194, 300, 321, 528, 13], "temperature": 0.0, "avg_logprob": -0.1453793806188247, "compression_ratio": 1.5786802030456852, "no_speech_prob": 0.0001671455829637125}, {"id": 164, "seek": 87740, "start": 891.1999999999999, "end": 896.56, "text": " For OSD, how many primaries we want to be on this OSD?", "tokens": [1171, 12731, 35, 11, 577, 867, 2886, 4889, 321, 528, 281, 312, 322, 341, 12731, 35, 30], "temperature": 0.0, "avg_logprob": -0.1453793806188247, "compression_ratio": 1.5786802030456852, "no_speech_prob": 0.0001671455829637125}, {"id": 165, "seek": 87740, "start": 896.56, "end": 901.04, "text": " It's really, it's some kind of policy function, it's really simple.", "tokens": [467, 311, 534, 11, 309, 311, 512, 733, 295, 3897, 2445, 11, 309, 311, 534, 2199, 13], "temperature": 0.0, "avg_logprob": -0.1453793806188247, "compression_ratio": 1.5786802030456852, "no_speech_prob": 0.0001671455829637125}, {"id": 166, "seek": 90104, "start": 901.04, "end": 908.7199999999999, "text": " Today, it's, it does one divided by replica count, as I said, and it's about 40 lines of code, something really simple.", "tokens": [2692, 11, 309, 311, 11, 309, 775, 472, 6666, 538, 35456, 1207, 11, 382, 286, 848, 11, 293, 309, 311, 466, 3356, 3876, 295, 3089, 11, 746, 534, 2199, 13], "temperature": 0.0, "avg_logprob": -0.1433119015260176, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.773245771299116e-05}, {"id": 167, "seek": 90104, "start": 908.7199999999999, "end": 917.9599999999999, "text": " So, adding more policies just for, to understand if you want to add more policies and I'll talk about more policies immediately.", "tokens": [407, 11, 5127, 544, 7657, 445, 337, 11, 281, 1223, 498, 291, 528, 281, 909, 544, 7657, 293, 286, 603, 751, 466, 544, 7657, 4258, 13], "temperature": 0.0, "avg_logprob": -0.1433119015260176, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.773245771299116e-05}, {"id": 168, "seek": 90104, "start": 917.9599999999999, "end": 925.1999999999999, "text": " If you want to add more policies, then we're talking about tens of lines of code, nothing more than this.", "tokens": [759, 291, 528, 281, 909, 544, 7657, 11, 550, 321, 434, 1417, 466, 10688, 295, 3876, 295, 3089, 11, 1825, 544, 813, 341, 13], "temperature": 0.0, "avg_logprob": -0.1433119015260176, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.773245771299116e-05}, {"id": 169, "seek": 92520, "start": 925.2, "end": 932.5200000000001, "text": " Then we have the functions that actually takes the configuration and goes over all the PG's, it's all run by pool.", "tokens": [1396, 321, 362, 264, 6828, 300, 767, 2516, 264, 11694, 293, 1709, 670, 439, 264, 40975, 311, 11, 309, 311, 439, 1190, 538, 7005, 13], "temperature": 0.0, "avg_logprob": -0.11299154835362588, "compression_ratio": 1.740909090909091, "no_speech_prob": 0.0001545578270452097}, {"id": 170, "seek": 92520, "start": 932.5200000000001, "end": 940.0, "text": " I didn't say this before, it's all run by pool because pool represents a workload and it's important to balance pair workload.", "tokens": [286, 994, 380, 584, 341, 949, 11, 309, 311, 439, 1190, 538, 7005, 570, 7005, 8855, 257, 20139, 293, 309, 311, 1021, 281, 4772, 6119, 20139, 13], "temperature": 0.0, "avg_logprob": -0.11299154835362588, "compression_ratio": 1.740909090909091, "no_speech_prob": 0.0001545578270452097}, {"id": 171, "seek": 92520, "start": 940.0, "end": 950.44, "text": " It goes over all the PG's on the pool and does its work and switches what it has to switch in order to get into the, what we calculated here.", "tokens": [467, 1709, 670, 439, 264, 40975, 311, 322, 264, 7005, 293, 775, 1080, 589, 293, 19458, 437, 309, 575, 281, 3679, 294, 1668, 281, 483, 666, 264, 11, 437, 321, 15598, 510, 13], "temperature": 0.0, "avg_logprob": -0.11299154835362588, "compression_ratio": 1.740909090909091, "no_speech_prob": 0.0001545578270452097}, {"id": 172, "seek": 95044, "start": 950.44, "end": 959.4000000000001, "text": " So basically, this is function, this is infrastructure function that could be used, we could add more and I'll talk about more policies.", "tokens": [407, 1936, 11, 341, 307, 2445, 11, 341, 307, 6896, 2445, 300, 727, 312, 1143, 11, 321, 727, 909, 544, 293, 286, 603, 751, 466, 544, 7657, 13], "temperature": 0.0, "avg_logprob": -0.1264826774597168, "compression_ratio": 1.73, "no_speech_prob": 0.0003414328093640506}, {"id": 173, "seek": 95044, "start": 959.4000000000001, "end": 967.48, "text": " We could add more policies and adding the policy is really something simple and the command is fast.", "tokens": [492, 727, 909, 544, 7657, 293, 5127, 264, 3897, 307, 534, 746, 2199, 293, 264, 5622, 307, 2370, 13], "temperature": 0.0, "avg_logprob": -0.1264826774597168, "compression_ratio": 1.73, "no_speech_prob": 0.0003414328093640506}, {"id": 174, "seek": 95044, "start": 967.48, "end": 976.36, "text": " That's, I keep on saying this because I want to talk about dynamic, that's what is behind the dynamic thing.", "tokens": [663, 311, 11, 286, 1066, 322, 1566, 341, 570, 286, 528, 281, 751, 466, 8546, 11, 300, 311, 437, 307, 2261, 264, 8546, 551, 13], "temperature": 0.0, "avg_logprob": -0.1264826774597168, "compression_ratio": 1.73, "no_speech_prob": 0.0003414328093640506}, {"id": 175, "seek": 97636, "start": 976.36, "end": 984.48, "text": " It's a cheap operation that we could run periodically and change things when we want to do it.", "tokens": [467, 311, 257, 7084, 6916, 300, 321, 727, 1190, 38916, 293, 1319, 721, 562, 321, 528, 281, 360, 309, 13], "temperature": 0.0, "avg_logprob": -0.1465919536093007, "compression_ratio": 1.3863636363636365, "no_speech_prob": 0.00032936406205408275}, {"id": 176, "seek": 97636, "start": 984.48, "end": 995.84, "text": " It's not involved in any, any high overhead or anything, it's just a metadata operation.", "tokens": [467, 311, 406, 3288, 294, 604, 11, 604, 1090, 19922, 420, 1340, 11, 309, 311, 445, 257, 26603, 6916, 13], "temperature": 0.0, "avg_logprob": -0.1465919536093007, "compression_ratio": 1.3863636363636365, "no_speech_prob": 0.00032936406205408275}, {"id": 177, "seek": 99584, "start": 995.84, "end": 1010.88, "text": " So we had the very simple read balancer, use case is small clusters, small clusters, it's very important use case for redhead,", "tokens": [407, 321, 632, 264, 588, 2199, 1401, 3119, 28347, 11, 764, 1389, 307, 1359, 23313, 11, 1359, 23313, 11, 309, 311, 588, 1021, 764, 1389, 337, 2182, 1934, 11], "temperature": 0.0, "avg_logprob": -0.2777594006250775, "compression_ratio": 1.396103896103896, "no_speech_prob": 0.0013642814010381699}, {"id": 178, "seek": 99584, "start": 1010.88, "end": 1022.72, "text": " now IBM, it's for ODF or for CEPH in OpenShift, but there is much more than we could do.", "tokens": [586, 23487, 11, 309, 311, 337, 48447, 37, 420, 337, 383, 8929, 39, 294, 7238, 7774, 2008, 11, 457, 456, 307, 709, 544, 813, 321, 727, 360, 13], "temperature": 0.0, "avg_logprob": -0.2777594006250775, "compression_ratio": 1.396103896103896, "no_speech_prob": 0.0013642814010381699}, {"id": 179, "seek": 102272, "start": 1022.72, "end": 1029.96, "text": " So now let's talk about the next, well, we have two use cases.", "tokens": [407, 586, 718, 311, 751, 466, 264, 958, 11, 731, 11, 321, 362, 732, 764, 3331, 13], "temperature": 0.0, "avg_logprob": -0.21183667864118302, "compression_ratio": 1.4630872483221478, "no_speech_prob": 0.0001148306910181418}, {"id": 180, "seek": 102272, "start": 1029.96, "end": 1037.88, "text": " So what we could do more?", "tokens": [407, 437, 321, 727, 360, 544, 30], "temperature": 0.0, "avg_logprob": -0.21183667864118302, "compression_ratio": 1.4630872483221478, "no_speech_prob": 0.0001148306910181418}, {"id": 181, "seek": 102272, "start": 1037.88, "end": 1047.92, "text": " We have a mechanism, we could change the things, but it's a pretty strong mechanism and we want to use, to use it for further on.", "tokens": [492, 362, 257, 7513, 11, 321, 727, 1319, 264, 721, 11, 457, 309, 311, 257, 1238, 2068, 7513, 293, 321, 528, 281, 764, 11, 281, 764, 309, 337, 3052, 322, 13], "temperature": 0.0, "avg_logprob": -0.21183667864118302, "compression_ratio": 1.4630872483221478, "no_speech_prob": 0.0001148306910181418}, {"id": 182, "seek": 104792, "start": 1047.92, "end": 1057.8400000000001, "text": " So one thing and this is one thing, this is a use case for larger cluster, load, load balance better on heterogeneous system.", "tokens": [407, 472, 551, 293, 341, 307, 472, 551, 11, 341, 307, 257, 764, 1389, 337, 4833, 13630, 11, 3677, 11, 3677, 4772, 1101, 322, 20789, 31112, 1185, 13], "temperature": 0.0, "avg_logprob": -0.11071263002545646, "compression_ratio": 1.722488038277512, "no_speech_prob": 8.958599210018292e-05}, {"id": 183, "seek": 104792, "start": 1057.8400000000001, "end": 1069.92, "text": " So you have a large CEPH cluster, you started to work five years ago, you have one terabyte devices, time comes, you need more capacity", "tokens": [407, 291, 362, 257, 2416, 383, 8929, 39, 13630, 11, 291, 1409, 281, 589, 1732, 924, 2057, 11, 291, 362, 472, 1796, 34529, 5759, 11, 565, 1487, 11, 291, 643, 544, 6042], "temperature": 0.0, "avg_logprob": -0.11071263002545646, "compression_ratio": 1.722488038277512, "no_speech_prob": 8.958599210018292e-05}, {"id": 184, "seek": 104792, "start": 1069.92, "end": 1075.5600000000002, "text": " and it doesn't make sense to buy one terabyte devices anymore and you bought two terabyte devices.", "tokens": [293, 309, 1177, 380, 652, 2020, 281, 2256, 472, 1796, 34529, 5759, 3602, 293, 291, 4243, 732, 1796, 34529, 5759, 13], "temperature": 0.0, "avg_logprob": -0.11071263002545646, "compression_ratio": 1.722488038277512, "no_speech_prob": 8.958599210018292e-05}, {"id": 185, "seek": 107556, "start": 1075.56, "end": 1088.84, "text": " Now normally it means that you get twice the workload on the two terabyte devices because you need that the devices would be split, even filled evenly.", "tokens": [823, 5646, 309, 1355, 300, 291, 483, 6091, 264, 20139, 322, 264, 732, 1796, 34529, 5759, 570, 291, 643, 300, 264, 5759, 576, 312, 7472, 11, 754, 6412, 17658, 13], "temperature": 0.0, "avg_logprob": -0.1318928122520447, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.0007577154319733381}, {"id": 186, "seek": 107556, "start": 1088.84, "end": 1097.76, "text": " You could create policies that says that you change gradually and when the smaller devices are not full, you have the same capacity.", "tokens": [509, 727, 1884, 7657, 300, 1619, 300, 291, 1319, 13145, 293, 562, 264, 4356, 5759, 366, 406, 1577, 11, 291, 362, 264, 912, 6042, 13], "temperature": 0.0, "avg_logprob": -0.1318928122520447, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.0007577154319733381}, {"id": 187, "seek": 107556, "start": 1097.76, "end": 1102.12, "text": " It doesn't work because every change is movement of data, it's very expensive.", "tokens": [467, 1177, 380, 589, 570, 633, 1319, 307, 3963, 295, 1412, 11, 309, 311, 588, 5124, 13], "temperature": 0.0, "avg_logprob": -0.1318928122520447, "compression_ratio": 1.6575342465753424, "no_speech_prob": 0.0007577154319733381}, {"id": 188, "seek": 110212, "start": 1102.12, "end": 1111.52, "text": " So you could in theory create really, really nice policies in practice, the price you pay in order to keep it is too much.", "tokens": [407, 291, 727, 294, 5261, 1884, 534, 11, 534, 1481, 7657, 294, 3124, 11, 264, 3218, 291, 1689, 294, 1668, 281, 1066, 309, 307, 886, 709, 13], "temperature": 0.0, "avg_logprob": -0.15130394155328925, "compression_ratio": 1.8431372549019607, "no_speech_prob": 0.0017999863484874368}, {"id": 189, "seek": 110212, "start": 1111.52, "end": 1126.36, "text": " Eventually you have device which is twice as large, it gets twice the capacity or you define it as a smaller device, then you lose capacity or it gets twice the load.", "tokens": [17586, 291, 362, 4302, 597, 307, 6091, 382, 2416, 11, 309, 2170, 6091, 264, 6042, 420, 291, 6964, 309, 382, 257, 4356, 4302, 11, 550, 291, 3624, 6042, 420, 309, 2170, 6091, 264, 3677, 13], "temperature": 0.0, "avg_logprob": -0.15130394155328925, "compression_ratio": 1.8431372549019607, "no_speech_prob": 0.0017999863484874368}, {"id": 190, "seek": 110212, "start": 1126.36, "end": 1131.32, "text": " If it gets twice the load, the smaller devices are working on half the potential load.", "tokens": [759, 309, 2170, 6091, 264, 3677, 11, 264, 4356, 5759, 366, 1364, 322, 1922, 264, 3995, 3677, 13], "temperature": 0.0, "avg_logprob": -0.15130394155328925, "compression_ratio": 1.8431372549019607, "no_speech_prob": 0.0017999863484874368}, {"id": 191, "seek": 113132, "start": 1131.32, "end": 1136.72, "text": " So just for the numbers, I have a little exercise.", "tokens": [407, 445, 337, 264, 3547, 11, 286, 362, 257, 707, 5380, 13], "temperature": 0.0, "avg_logprob": -0.15597366464549098, "compression_ratio": 1.6875, "no_speech_prob": 0.0005231956019997597}, {"id": 192, "seek": 113132, "start": 1136.72, "end": 1141.32, "text": " So we have devices of same technology, same bandwidth, same IOPS.", "tokens": [407, 321, 362, 5759, 295, 912, 2899, 11, 912, 23647, 11, 912, 39839, 6273, 13], "temperature": 0.0, "avg_logprob": -0.15597366464549098, "compression_ratio": 1.6875, "no_speech_prob": 0.0005231956019997597}, {"id": 193, "seek": 113132, "start": 1141.32, "end": 1146.84, "text": " We have one OSD of two terabytes and four OSDs of one terabyte.", "tokens": [492, 362, 472, 12731, 35, 295, 732, 1796, 24538, 293, 1451, 12731, 35, 82, 295, 472, 1796, 34529, 13], "temperature": 0.0, "avg_logprob": -0.15597366464549098, "compression_ratio": 1.6875, "no_speech_prob": 0.0005231956019997597}, {"id": 194, "seek": 113132, "start": 1146.84, "end": 1154.6, "text": " So it's like three OSDs of two terabytes if you think about capacity, so one of two terabytes, four of one terabyte.", "tokens": [407, 309, 311, 411, 1045, 12731, 35, 82, 295, 732, 1796, 24538, 498, 291, 519, 466, 6042, 11, 370, 472, 295, 732, 1796, 24538, 11, 1451, 295, 472, 1796, 34529, 13], "temperature": 0.0, "avg_logprob": -0.15597366464549098, "compression_ratio": 1.6875, "no_speech_prob": 0.0005231956019997597}, {"id": 195, "seek": 115460, "start": 1154.6, "end": 1163.76, "text": " So we have for each a PG, one copy on the large device and two copies on the small devices, a split.", "tokens": [407, 321, 362, 337, 1184, 257, 40975, 11, 472, 5055, 322, 264, 2416, 4302, 293, 732, 14341, 322, 264, 1359, 5759, 11, 257, 7472, 13], "temperature": 0.0, "avg_logprob": -0.15739636481562747, "compression_ratio": 1.4895833333333333, "no_speech_prob": 0.000553324818611145}, {"id": 196, "seek": 115460, "start": 1163.76, "end": 1172.1599999999999, "text": " So that's the assumption to just show a bit of play with the numbers.", "tokens": [407, 300, 311, 264, 15302, 281, 445, 855, 257, 857, 295, 862, 365, 264, 3547, 13], "temperature": 0.0, "avg_logprob": -0.15739636481562747, "compression_ratio": 1.4895833333333333, "no_speech_prob": 0.000553324818611145}, {"id": 197, "seek": 115460, "start": 1172.1599999999999, "end": 1176.9599999999998, "text": " And for the convenience, let's assume that we have 100 IOPS, it's just easy.", "tokens": [400, 337, 264, 19283, 11, 718, 311, 6552, 300, 321, 362, 2319, 39839, 6273, 11, 309, 311, 445, 1858, 13], "temperature": 0.0, "avg_logprob": -0.15739636481562747, "compression_ratio": 1.4895833333333333, "no_speech_prob": 0.000553324818611145}, {"id": 198, "seek": 115460, "start": 1176.9599999999998, "end": 1181.9199999999998, "text": " People like to think in round numbers.", "tokens": [3432, 411, 281, 519, 294, 3098, 3547, 13], "temperature": 0.0, "avg_logprob": -0.15739636481562747, "compression_ratio": 1.4895833333333333, "no_speech_prob": 0.000553324818611145}, {"id": 199, "seek": 118192, "start": 1181.92, "end": 1186.48, "text": " So under full load, what happens?", "tokens": [407, 833, 1577, 3677, 11, 437, 2314, 30], "temperature": 0.0, "avg_logprob": -0.12883590397081876, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.00011432860628701746}, {"id": 200, "seek": 118192, "start": 1186.48, "end": 1190.96, "text": " This device goes to 100 IOPS because that's what it could provide.", "tokens": [639, 4302, 1709, 281, 2319, 39839, 6273, 570, 300, 311, 437, 309, 727, 2893, 13], "temperature": 0.0, "avg_logprob": -0.12883590397081876, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.00011432860628701746}, {"id": 201, "seek": 118192, "start": 1190.96, "end": 1196.0800000000002, "text": " And these devices get half the load and they would provide each 150 IOPS.", "tokens": [400, 613, 5759, 483, 1922, 264, 3677, 293, 436, 576, 2893, 1184, 8451, 39839, 6273, 13], "temperature": 0.0, "avg_logprob": -0.12883590397081876, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.00011432860628701746}, {"id": 202, "seek": 118192, "start": 1196.0800000000002, "end": 1200.3200000000002, "text": " So total we have 300 IOPS.", "tokens": [407, 3217, 321, 362, 6641, 39839, 6273, 13], "temperature": 0.0, "avg_logprob": -0.12883590397081876, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.00011432860628701746}, {"id": 203, "seek": 120032, "start": 1200.32, "end": 1217.32, "text": " And there is nothing we could actually do about it because the requirements to have the capacity split twice here than here is so strong that we can't change it, can't play with it.", "tokens": [400, 456, 307, 1825, 321, 727, 767, 360, 466, 309, 570, 264, 7728, 281, 362, 264, 6042, 7472, 6091, 510, 813, 510, 307, 370, 2068, 300, 321, 393, 380, 1319, 309, 11, 393, 380, 862, 365, 309, 13], "temperature": 0.0, "avg_logprob": -0.09307340365737232, "compression_ratio": 1.4887640449438202, "no_speech_prob": 0.00012828162289224565}, {"id": 204, "seek": 120032, "start": 1217.32, "end": 1219.1599999999999, "text": " That's the rules of the game.", "tokens": [663, 311, 264, 4474, 295, 264, 1216, 13], "temperature": 0.0, "avg_logprob": -0.09307340365737232, "compression_ratio": 1.4887640449438202, "no_speech_prob": 0.00012828162289224565}, {"id": 205, "seek": 120032, "start": 1219.1599999999999, "end": 1223.08, "text": " Once we did it, we are bound in such a configuration.", "tokens": [3443, 321, 630, 309, 11, 321, 366, 5472, 294, 1270, 257, 11694, 13], "temperature": 0.0, "avg_logprob": -0.09307340365737232, "compression_ratio": 1.4887640449438202, "no_speech_prob": 0.00012828162289224565}, {"id": 206, "seek": 122308, "start": 1223.08, "end": 1234.24, "text": " Actually, we had a working cluster and we added one larger disk and all the cluster performs way, way worse than it used to be.", "tokens": [5135, 11, 321, 632, 257, 1364, 13630, 293, 321, 3869, 472, 4833, 12355, 293, 439, 264, 13630, 26213, 636, 11, 636, 5324, 813, 309, 1143, 281, 312, 13], "temperature": 0.0, "avg_logprob": -0.12982288103425102, "compression_ratio": 1.736318407960199, "no_speech_prob": 0.00011975284724030644}, {"id": 207, "seek": 122308, "start": 1234.24, "end": 1242.76, "text": " So it's not really something that we could do with it and accept, replace all the disks with larger disks or something like this.", "tokens": [407, 309, 311, 406, 534, 746, 300, 321, 727, 360, 365, 309, 293, 3241, 11, 7406, 439, 264, 41617, 365, 4833, 41617, 420, 746, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.12982288103425102, "compression_ratio": 1.736318407960199, "no_speech_prob": 0.00011975284724030644}, {"id": 208, "seek": 122308, "start": 1242.76, "end": 1246.24, "text": " But if you want to do gradual, we can do with it.", "tokens": [583, 498, 291, 528, 281, 360, 32890, 11, 321, 393, 360, 365, 309, 13], "temperature": 0.0, "avg_logprob": -0.12982288103425102, "compression_ratio": 1.736318407960199, "no_speech_prob": 0.00011975284724030644}, {"id": 209, "seek": 122308, "start": 1246.24, "end": 1251.48, "text": " Now, there is something that we could do.", "tokens": [823, 11, 456, 307, 746, 300, 321, 727, 360, 13], "temperature": 0.0, "avg_logprob": -0.12982288103425102, "compression_ratio": 1.736318407960199, "no_speech_prob": 0.00011975284724030644}, {"id": 210, "seek": 125148, "start": 1251.48, "end": 1258.64, "text": " Let's assume that we have, for now, the read-only, just read-only load.", "tokens": [961, 311, 6552, 300, 321, 362, 11, 337, 586, 11, 264, 1401, 12, 25202, 11, 445, 1401, 12, 25202, 3677, 13], "temperature": 0.0, "avg_logprob": -0.14217124588188085, "compression_ratio": 1.5736842105263158, "no_speech_prob": 0.00030291787697933614}, {"id": 211, "seek": 125148, "start": 1258.64, "end": 1262.24, "text": " The capacity is still the same, 30 PG is 15, 15, 15.", "tokens": [440, 6042, 307, 920, 264, 912, 11, 2217, 40975, 307, 2119, 11, 2119, 11, 2119, 13], "temperature": 0.0, "avg_logprob": -0.14217124588188085, "compression_ratio": 1.5736842105263158, "no_speech_prob": 0.00030291787697933614}, {"id": 212, "seek": 125148, "start": 1262.24, "end": 1268.08, "text": " But the 10 primaries here, I moved them and moved them here and split them here.", "tokens": [583, 264, 1266, 2886, 4889, 510, 11, 286, 4259, 552, 293, 4259, 552, 510, 293, 7472, 552, 510, 13], "temperature": 0.0, "avg_logprob": -0.14217124588188085, "compression_ratio": 1.5736842105263158, "no_speech_prob": 0.00030291787697933614}, {"id": 213, "seek": 125148, "start": 1268.08, "end": 1276.96, "text": " So we have here, when you have only reads, all the devices are fully working under full load.", "tokens": [407, 321, 362, 510, 11, 562, 291, 362, 787, 15700, 11, 439, 264, 5759, 366, 4498, 1364, 833, 1577, 3677, 13], "temperature": 0.0, "avg_logprob": -0.14217124588188085, "compression_ratio": 1.5736842105263158, "no_speech_prob": 0.00030291787697933614}, {"id": 214, "seek": 127696, "start": 1276.96, "end": 1289.6000000000001, "text": " So we moved from 300 IOPS to 500 IOPS, but just very minor change of changing primaries and splitting them differently across the cluster.", "tokens": [407, 321, 4259, 490, 6641, 39839, 6273, 281, 5923, 39839, 6273, 11, 457, 445, 588, 6696, 1319, 295, 4473, 2886, 4889, 293, 30348, 552, 7614, 2108, 264, 13630, 13], "temperature": 0.0, "avg_logprob": -0.1126126277295849, "compression_ratio": 1.5377358490566038, "no_speech_prob": 0.0002362091327086091}, {"id": 215, "seek": 127696, "start": 1289.6000000000001, "end": 1293.04, "text": " Now, this is the best that we could get.", "tokens": [823, 11, 341, 307, 264, 1151, 300, 321, 727, 483, 13], "temperature": 0.0, "avg_logprob": -0.1126126277295849, "compression_ratio": 1.5377358490566038, "no_speech_prob": 0.0002362091327086091}, {"id": 216, "seek": 127696, "start": 1293.04, "end": 1303.16, "text": " If we have read-write, obviously, if we have write-only workload, we can't improve using this technique because this technique changes only reads.", "tokens": [759, 321, 362, 1401, 12, 21561, 11, 2745, 11, 498, 321, 362, 2464, 12, 25202, 20139, 11, 321, 393, 380, 3470, 1228, 341, 6532, 570, 341, 6532, 2962, 787, 15700, 13], "temperature": 0.0, "avg_logprob": -0.1126126277295849, "compression_ratio": 1.5377358490566038, "no_speech_prob": 0.0002362091327086091}, {"id": 217, "seek": 130316, "start": 1303.16, "end": 1316.0800000000002, "text": " So if we have write-only, we can't change, and if we have some writes, we can't get as good as this one because eventually this will get all the time, twice writes than the others.", "tokens": [407, 498, 321, 362, 2464, 12, 25202, 11, 321, 393, 380, 1319, 11, 293, 498, 321, 362, 512, 13657, 11, 321, 393, 380, 483, 382, 665, 382, 341, 472, 570, 4728, 341, 486, 483, 439, 264, 565, 11, 6091, 13657, 813, 264, 2357, 13], "temperature": 0.0, "avg_logprob": -0.138199462890625, "compression_ratio": 1.7476190476190476, "no_speech_prob": 0.0004371341201476753}, {"id": 218, "seek": 130316, "start": 1316.0800000000002, "end": 1318.68, "text": " So there is limitation to what we could do.", "tokens": [407, 456, 307, 27432, 281, 437, 321, 727, 360, 13], "temperature": 0.0, "avg_logprob": -0.138199462890625, "compression_ratio": 1.7476190476190476, "no_speech_prob": 0.0004371341201476753}, {"id": 219, "seek": 130316, "start": 1318.68, "end": 1324.0, "text": " So the best potential is for read-only, but we could do also with mixed read-writes.", "tokens": [407, 264, 1151, 3995, 307, 337, 1401, 12, 25202, 11, 457, 321, 727, 360, 611, 365, 7467, 1401, 12, 86, 30931, 13], "temperature": 0.0, "avg_logprob": -0.138199462890625, "compression_ratio": 1.7476190476190476, "no_speech_prob": 0.0004371341201476753}, {"id": 220, "seek": 130316, "start": 1324.0, "end": 1329.16, "text": " We could get a lot of improvement under full load, a lot.", "tokens": [492, 727, 483, 257, 688, 295, 10444, 833, 1577, 3677, 11, 257, 688, 13], "temperature": 0.0, "avg_logprob": -0.138199462890625, "compression_ratio": 1.7476190476190476, "no_speech_prob": 0.0004371341201476753}, {"id": 221, "seek": 132916, "start": 1329.16, "end": 1335.6000000000001, "text": " So that's the idea, and this is already planned for the next version.", "tokens": [407, 300, 311, 264, 1558, 11, 293, 341, 307, 1217, 8589, 337, 264, 958, 3037, 13], "temperature": 0.0, "avg_logprob": -0.1696353995281717, "compression_ratio": 1.5898876404494382, "no_speech_prob": 0.00042867715819738805}, {"id": 222, "seek": 132916, "start": 1335.6000000000001, "end": 1346.3200000000002, "text": " On purpose, we didn't put it on the first version because we want adoption of the feature, but this is, we plan to add two steps for the next version.", "tokens": [1282, 4334, 11, 321, 994, 380, 829, 309, 322, 264, 700, 3037, 570, 321, 528, 19215, 295, 264, 4111, 11, 457, 341, 307, 11, 321, 1393, 281, 909, 732, 4439, 337, 264, 958, 3037, 13], "temperature": 0.0, "avg_logprob": -0.1696353995281717, "compression_ratio": 1.5898876404494382, "no_speech_prob": 0.00042867715819738805}, {"id": 223, "seek": 132916, "start": 1346.3200000000002, "end": 1356.3200000000002, "text": " This is actually better supporting different sizes of devices.", "tokens": [639, 307, 767, 1101, 7231, 819, 11602, 295, 5759, 13], "temperature": 0.0, "avg_logprob": -0.1696353995281717, "compression_ratio": 1.5898876404494382, "no_speech_prob": 0.00042867715819738805}, {"id": 224, "seek": 135632, "start": 1356.32, "end": 1369.08, "text": " So, can we improve on other loads which are not read-only?", "tokens": [407, 11, 393, 321, 3470, 322, 661, 12668, 597, 366, 406, 1401, 12, 25202, 30], "temperature": 0.0, "avg_logprob": -0.22879613679030847, "compression_ratio": 1.472972972972973, "no_speech_prob": 0.0018861040007323027}, {"id": 225, "seek": 135632, "start": 1369.08, "end": 1386.1599999999999, "text": " And I already said this, we can do this, but in order to do this, in order to do good job, we need to understand per pool some characteristics of the workload.", "tokens": [400, 286, 1217, 848, 341, 11, 321, 393, 360, 341, 11, 457, 294, 1668, 281, 360, 341, 11, 294, 1668, 281, 360, 665, 1691, 11, 321, 643, 281, 1223, 680, 7005, 512, 10891, 295, 264, 20139, 13], "temperature": 0.0, "avg_logprob": -0.22879613679030847, "compression_ratio": 1.472972972972973, "no_speech_prob": 0.0018861040007323027}, {"id": 226, "seek": 138616, "start": 1386.16, "end": 1388.48, "text": " And basically the read-write ratio.", "tokens": [400, 1936, 264, 1401, 12, 21561, 8509, 13], "temperature": 0.0, "avg_logprob": -0.15148517608642578, "compression_ratio": 1.4768211920529801, "no_speech_prob": 0.0002039194805547595}, {"id": 227, "seek": 138616, "start": 1388.48, "end": 1411.48, "text": " If we get read-write ratio which is reasonably close to what we actually have, then we could do good improvement in the performance when we have different size devices and mixed workload.", "tokens": [759, 321, 483, 1401, 12, 21561, 8509, 597, 307, 23551, 1998, 281, 437, 321, 767, 362, 11, 550, 321, 727, 360, 665, 10444, 294, 264, 3389, 562, 321, 362, 819, 2744, 5759, 293, 7467, 20139, 13], "temperature": 0.0, "avg_logprob": -0.15148517608642578, "compression_ratio": 1.4768211920529801, "no_speech_prob": 0.0002039194805547595}, {"id": 228, "seek": 141148, "start": 1411.48, "end": 1420.16, "text": " Well, I said it, there are limitations what we could do, so I said one thing, we can't improve on write-only using this technique.", "tokens": [1042, 11, 286, 848, 309, 11, 456, 366, 15705, 437, 321, 727, 360, 11, 370, 286, 848, 472, 551, 11, 321, 393, 380, 3470, 322, 2464, 12, 25202, 1228, 341, 6532, 13], "temperature": 0.0, "avg_logprob": -0.16768848503028955, "compression_ratio": 1.7552083333333333, "no_speech_prob": 0.0012789717875421047}, {"id": 229, "seek": 141148, "start": 1420.16, "end": 1432.2, "text": " I've seen this, so it's real thing, but if you use replica three and we, instead of having one terabyte and two terabyte devices, we have one terabyte and five terabyte devices.", "tokens": [286, 600, 1612, 341, 11, 370, 309, 311, 957, 551, 11, 457, 498, 291, 764, 35456, 1045, 293, 321, 11, 2602, 295, 1419, 472, 1796, 34529, 293, 732, 1796, 34529, 5759, 11, 321, 362, 472, 1796, 34529, 293, 1732, 1796, 34529, 5759, 13], "temperature": 0.0, "avg_logprob": -0.16768848503028955, "compression_ratio": 1.7552083333333333, "no_speech_prob": 0.0012789717875421047}, {"id": 230, "seek": 141148, "start": 1432.2, "end": 1434.72, "text": " I've seen this in real life.", "tokens": [286, 600, 1612, 341, 294, 957, 993, 13], "temperature": 0.0, "avg_logprob": -0.16768848503028955, "compression_ratio": 1.7552083333333333, "no_speech_prob": 0.0012789717875421047}, {"id": 231, "seek": 143472, "start": 1434.72, "end": 1446.32, "text": " We can't improve, we can't, well, we can improve, but we can get to optimal performance when we have five terabyte devices and one terabyte devices on the same pool, the numbers are too low.", "tokens": [492, 393, 380, 3470, 11, 321, 393, 380, 11, 731, 11, 321, 393, 3470, 11, 457, 321, 393, 483, 281, 16252, 3389, 562, 321, 362, 1732, 1796, 34529, 5759, 293, 472, 1796, 34529, 5759, 322, 264, 912, 7005, 11, 264, 3547, 366, 886, 2295, 13], "temperature": 0.0, "avg_logprob": -0.13316022518069245, "compression_ratio": 1.8, "no_speech_prob": 0.0004054371383972466}, {"id": 232, "seek": 143472, "start": 1446.32, "end": 1462.8, "text": " We could reduce it to the minimum, moving all reads out of the five terabyte devices, but eventually when you have enough writes, the system would not perform optimally.", "tokens": [492, 727, 5407, 309, 281, 264, 7285, 11, 2684, 439, 15700, 484, 295, 264, 1732, 1796, 34529, 5759, 11, 457, 4728, 562, 291, 362, 1547, 13657, 11, 264, 1185, 576, 406, 2042, 5028, 379, 13], "temperature": 0.0, "avg_logprob": -0.13316022518069245, "compression_ratio": 1.8, "no_speech_prob": 0.0004054371383972466}, {"id": 233, "seek": 146280, "start": 1462.8, "end": 1464.76, "text": " So, we covered this.", "tokens": [407, 11, 321, 5343, 341, 13], "temperature": 0.0, "avg_logprob": -0.18570256233215332, "compression_ratio": 1.375, "no_speech_prob": 0.00026674129185266793}, {"id": 234, "seek": 146280, "start": 1464.76, "end": 1483.84, "text": " So, another case which was, another case which is, well, it's a no-no, big no-no, don't put SSDs and HDDs on the same pool, everyone knows this.", "tokens": [407, 11, 1071, 1389, 597, 390, 11, 1071, 1389, 597, 307, 11, 731, 11, 309, 311, 257, 572, 12, 1771, 11, 955, 572, 12, 1771, 11, 500, 380, 829, 30262, 82, 293, 12149, 35, 82, 322, 264, 912, 7005, 11, 1518, 3255, 341, 13], "temperature": 0.0, "avg_logprob": -0.18570256233215332, "compression_ratio": 1.375, "no_speech_prob": 0.00026674129185266793}, {"id": 235, "seek": 148384, "start": 1483.84, "end": 1509.08, "text": " Well, if you could, if you can make sure that you have enough SSDs that, sorry, that every PG is mapped to at least one SSD and then to HDDs, preferably replica three, one SSD, two HDDs, you could actually get the effect of read flash cache without cache misses.", "tokens": [1042, 11, 498, 291, 727, 11, 498, 291, 393, 652, 988, 300, 291, 362, 1547, 30262, 82, 300, 11, 2597, 11, 300, 633, 40975, 307, 33318, 281, 412, 1935, 472, 30262, 293, 550, 281, 12149, 35, 82, 11, 45916, 35456, 1045, 11, 472, 30262, 11, 732, 12149, 35, 82, 11, 291, 727, 767, 483, 264, 1802, 295, 1401, 7319, 19459, 1553, 19459, 29394, 13], "temperature": 0.0, "avg_logprob": -0.09701105426339542, "compression_ratio": 1.5321637426900585, "no_speech_prob": 9.600381599739194e-05}, {"id": 236, "seek": 150908, "start": 1509.08, "end": 1520.12, "text": " You always read from the SSDs and you only write to the HDDs. You could improve on the performance of your system and get really fast read latencies.", "tokens": [509, 1009, 1401, 490, 264, 30262, 82, 293, 291, 787, 2464, 281, 264, 12149, 35, 82, 13, 509, 727, 3470, 322, 264, 3389, 295, 428, 1185, 293, 483, 534, 2370, 1401, 4465, 6464, 13], "temperature": 0.0, "avg_logprob": -0.07113961169594213, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.0002688092354219407}, {"id": 237, "seek": 150908, "start": 1520.12, "end": 1532.08, "text": " So, I'm breaking this no-no, but it is important, don't mix the technologies if you can't make sure that all the reads are from the faster device.", "tokens": [407, 11, 286, 478, 7697, 341, 572, 12, 1771, 11, 457, 309, 307, 1021, 11, 500, 380, 2890, 264, 7943, 498, 291, 393, 380, 652, 988, 300, 439, 264, 15700, 366, 490, 264, 4663, 4302, 13], "temperature": 0.0, "avg_logprob": -0.07113961169594213, "compression_ratio": 1.4874371859296482, "no_speech_prob": 0.0002688092354219407}, {"id": 238, "seek": 153208, "start": 1532.08, "end": 1545.32, "text": " If you could make, so if you take replica three and you put one-third of your PG's, of your SSDs are SSD capacity, one-third of the capacity is on SSDs, two-third on HDDs.", "tokens": [759, 291, 727, 652, 11, 370, 498, 291, 747, 35456, 1045, 293, 291, 829, 472, 12, 25095, 295, 428, 40975, 311, 11, 295, 428, 30262, 82, 366, 30262, 6042, 11, 472, 12, 25095, 295, 264, 6042, 307, 322, 30262, 82, 11, 732, 12, 25095, 322, 12149, 35, 82, 13], "temperature": 0.0, "avg_logprob": -0.16102340174656288, "compression_ratio": 1.6621004566210045, "no_speech_prob": 0.0003545176878105849}, {"id": 239, "seek": 153208, "start": 1545.32, "end": 1558.6799999999998, "text": " And you could also make sure, whatever techniques you use, it's really easy. You need to change a bit of crush rules, but all the copies, you have one copy on SSD and the other copies on HDDs.", "tokens": [400, 291, 727, 611, 652, 988, 11, 2035, 7512, 291, 764, 11, 309, 311, 534, 1858, 13, 509, 643, 281, 1319, 257, 857, 295, 10321, 4474, 11, 457, 439, 264, 14341, 11, 291, 362, 472, 5055, 322, 30262, 293, 264, 661, 14341, 322, 12149, 35, 82, 13], "temperature": 0.0, "avg_logprob": -0.16102340174656288, "compression_ratio": 1.6621004566210045, "no_speech_prob": 0.0003545176878105849}, {"id": 240, "seek": 155868, "start": 1558.68, "end": 1567.88, "text": " You could actually improve your performance dramatically because the bottleneck of HDD would be only for writes and all the reads would get the SSD or NVMe or whatever performance.", "tokens": [509, 727, 767, 3470, 428, 3389, 17548, 570, 264, 44641, 547, 295, 12149, 35, 576, 312, 787, 337, 13657, 293, 439, 264, 15700, 576, 483, 264, 30262, 420, 46512, 12671, 420, 2035, 3389, 13], "temperature": 0.0, "avg_logprob": -0.1134173075358073, "compression_ratio": 1.631578947368421, "no_speech_prob": 0.0004101853119209409}, {"id": 241, "seek": 155868, "start": 1567.88, "end": 1579.76, "text": " So, I'm breaking one of the big no-no's here, but if you can't make sure that all the reads are from the fast devices, then you waste, it wouldn't work.", "tokens": [407, 11, 286, 478, 7697, 472, 295, 264, 955, 572, 12, 1771, 311, 510, 11, 457, 498, 291, 393, 380, 652, 988, 300, 439, 264, 15700, 366, 490, 264, 2370, 5759, 11, 550, 291, 5964, 11, 309, 2759, 380, 589, 13], "temperature": 0.0, "avg_logprob": -0.1134173075358073, "compression_ratio": 1.631578947368421, "no_speech_prob": 0.0004101853119209409}, {"id": 242, "seek": 155868, "start": 1579.76, "end": 1585.88, "text": " Eventually, under full load, you'll get the known weakest link in the chain and it would be blocked.", "tokens": [17586, 11, 833, 1577, 3677, 11, 291, 603, 483, 264, 2570, 44001, 2113, 294, 264, 5021, 293, 309, 576, 312, 15470, 13], "temperature": 0.0, "avg_logprob": -0.1134173075358073, "compression_ratio": 1.631578947368421, "no_speech_prob": 0.0004101853119209409}, {"id": 243, "seek": 158588, "start": 1585.88, "end": 1607.48, "text": " But if you can do it, so this is a way to modernize the devices gradually and not moving all the HDD to SSDs once, one-third in case of replica three could be the first step and you could do it gradually and you don't know to do anything.", "tokens": [583, 498, 291, 393, 360, 309, 11, 370, 341, 307, 257, 636, 281, 4363, 1125, 264, 5759, 13145, 293, 406, 2684, 439, 264, 12149, 35, 281, 30262, 82, 1564, 11, 472, 12, 25095, 294, 1389, 295, 35456, 1045, 727, 312, 264, 700, 1823, 293, 291, 727, 360, 309, 13145, 293, 291, 500, 380, 458, 281, 360, 1340, 13], "temperature": 0.0, "avg_logprob": -0.12971498120215633, "compression_ratio": 1.4691358024691359, "no_speech_prob": 0.00026183880981989205}, {"id": 244, "seek": 160748, "start": 1607.48, "end": 1619.8, "text": " So, that's another thing that could be with existing, by the way, for this, because it's different technique, you don't need what we did in the read balancer.", "tokens": [407, 11, 300, 311, 1071, 551, 300, 727, 312, 365, 6741, 11, 538, 264, 636, 11, 337, 341, 11, 570, 309, 311, 819, 6532, 11, 291, 500, 380, 643, 437, 321, 630, 294, 264, 1401, 3119, 28347, 13], "temperature": 0.0, "avg_logprob": -0.13850970017282585, "compression_ratio": 1.544502617801047, "no_speech_prob": 0.00010454987932462245}, {"id": 245, "seek": 160748, "start": 1619.8, "end": 1627.2, "text": " It's enough to have good crush rules. This could be managed by crush rules differently.", "tokens": [467, 311, 1547, 281, 362, 665, 10321, 4474, 13, 639, 727, 312, 6453, 538, 10321, 4474, 7614, 13], "temperature": 0.0, "avg_logprob": -0.13850970017282585, "compression_ratio": 1.544502617801047, "no_speech_prob": 0.00010454987932462245}, {"id": 246, "seek": 160748, "start": 1627.2, "end": 1636.8, "text": " Okay, now we come to the dynamic aspect of this.", "tokens": [1033, 11, 586, 321, 808, 281, 264, 8546, 4171, 295, 341, 13], "temperature": 0.0, "avg_logprob": -0.13850970017282585, "compression_ratio": 1.544502617801047, "no_speech_prob": 0.00010454987932462245}, {"id": 247, "seek": 163680, "start": 1636.8, "end": 1648.0, "text": " So, the thing is that we have cluster, we build cluster, we know we have the numbers, how the cluster performs, what are the network bandwidths, how devices perform.", "tokens": [407, 11, 264, 551, 307, 300, 321, 362, 13630, 11, 321, 1322, 13630, 11, 321, 458, 321, 362, 264, 3547, 11, 577, 264, 13630, 26213, 11, 437, 366, 264, 3209, 23647, 82, 11, 577, 5759, 2042, 13], "temperature": 0.0, "avg_logprob": -0.15071202613211968, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.00015615398297086358}, {"id": 248, "seek": 163680, "start": 1648.0, "end": 1650.6399999999999, "text": " It all works well until it doesn't.", "tokens": [467, 439, 1985, 731, 1826, 309, 1177, 380, 13], "temperature": 0.0, "avg_logprob": -0.15071202613211968, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.00015615398297086358}, {"id": 249, "seek": 163680, "start": 1650.6399999999999, "end": 1661.2, "text": " So, we may have problems, hardware problems, and we may have noisy neighbors where we work.", "tokens": [407, 11, 321, 815, 362, 2740, 11, 8837, 2740, 11, 293, 321, 815, 362, 24518, 12512, 689, 321, 589, 13], "temperature": 0.0, "avg_logprob": -0.15071202613211968, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.00015615398297086358}, {"id": 250, "seek": 166120, "start": 1661.2, "end": 1667.0, "text": " As I said, full isolation of neighbors has a cost.", "tokens": [1018, 286, 848, 11, 1577, 16001, 295, 12512, 575, 257, 2063, 13], "temperature": 0.0, "avg_logprob": -0.14354230316591934, "compression_ratio": 1.558011049723757, "no_speech_prob": 0.00034783530281856656}, {"id": 251, "seek": 166120, "start": 1667.0, "end": 1679.24, "text": " If you prevent over provisioning in all costs, well, it has a cost, depending on your workloads, you allocate a lot for temporary workloads.", "tokens": [759, 291, 4871, 670, 17225, 278, 294, 439, 5497, 11, 731, 11, 309, 575, 257, 2063, 11, 5413, 322, 428, 32452, 11, 291, 35713, 257, 688, 337, 13413, 32452, 13], "temperature": 0.0, "avg_logprob": -0.14354230316591934, "compression_ratio": 1.558011049723757, "no_speech_prob": 0.00034783530281856656}, {"id": 252, "seek": 166120, "start": 1679.24, "end": 1685.88, "text": " So, in some cases, doing over provisioning of nodes makes sense if you know how to behave.", "tokens": [407, 11, 294, 512, 3331, 11, 884, 670, 17225, 278, 295, 13891, 1669, 2020, 498, 291, 458, 577, 281, 15158, 13], "temperature": 0.0, "avg_logprob": -0.14354230316591934, "compression_ratio": 1.558011049723757, "no_speech_prob": 0.00034783530281856656}, {"id": 253, "seek": 168588, "start": 1685.88, "end": 1706.1200000000001, "text": " And this is especially in hyperconverged. So, we know that hyperconverged deployment, noisy neighbors, it could be in Kubernetes, we tend to limit, we know how to limit, we use, we tend to limit these CPUs and memories and not network.", "tokens": [400, 341, 307, 2318, 294, 9848, 1671, 331, 3004, 13, 407, 11, 321, 458, 300, 9848, 1671, 331, 3004, 19317, 11, 24518, 12512, 11, 309, 727, 312, 294, 23145, 11, 321, 3928, 281, 4948, 11, 321, 458, 577, 281, 4948, 11, 321, 764, 11, 321, 3928, 281, 4948, 613, 13199, 82, 293, 8495, 293, 406, 3209, 13], "temperature": 0.0, "avg_logprob": -0.2715930938720703, "compression_ratio": 1.5460526315789473, "no_speech_prob": 0.0011626594932749867}, {"id": 254, "seek": 170612, "start": 1706.12, "end": 1719.8799999999999, "text": " Obviously, for sort of defense systems, the network is really important. So, noisy neighbor on the network could cause huge performance problems.", "tokens": [7580, 11, 337, 1333, 295, 7654, 3652, 11, 264, 3209, 307, 534, 1021, 13, 407, 11, 24518, 5987, 322, 264, 3209, 727, 3082, 2603, 3389, 2740, 13], "temperature": 0.0, "avg_logprob": -0.2680404792397709, "compression_ratio": 1.4853801169590644, "no_speech_prob": 0.0005361214862205088}, {"id": 255, "seek": 170612, "start": 1719.8799999999999, "end": 1729.76, "text": " So, the process, and this is the process is, I want to explain, because it's more than just technical thing.", "tokens": [407, 11, 264, 1399, 11, 293, 341, 307, 264, 1399, 307, 11, 286, 528, 281, 2903, 11, 570, 309, 311, 544, 813, 445, 6191, 551, 13], "temperature": 0.0, "avg_logprob": -0.2680404792397709, "compression_ratio": 1.4853801169590644, "no_speech_prob": 0.0005361214862205088}, {"id": 256, "seek": 172976, "start": 1729.76, "end": 1740.76, "text": " We want to monitor the IO performance from OSD level and up. We want to identify what happens. It could be on OSD level, it could be on node level, it could be on rack level.", "tokens": [492, 528, 281, 6002, 264, 39839, 3389, 490, 12731, 35, 1496, 293, 493, 13, 492, 528, 281, 5876, 437, 2314, 13, 467, 727, 312, 322, 12731, 35, 1496, 11, 309, 727, 312, 322, 9984, 1496, 11, 309, 727, 312, 322, 14788, 1496, 13], "temperature": 0.0, "avg_logprob": -0.11349741617838542, "compression_ratio": 1.7393617021276595, "no_speech_prob": 0.0005923221469856799}, {"id": 257, "seek": 172976, "start": 1740.76, "end": 1748.8799999999999, "text": " We need to understand what happens. Then we could tune up the system. We could reduce the load. If the problem is temporary, we don't want to move data.", "tokens": [492, 643, 281, 1223, 437, 2314, 13, 1396, 321, 727, 10864, 493, 264, 1185, 13, 492, 727, 5407, 264, 3677, 13, 759, 264, 1154, 307, 13413, 11, 321, 500, 380, 528, 281, 1286, 1412, 13], "temperature": 0.0, "avg_logprob": -0.11349741617838542, "compression_ratio": 1.7393617021276595, "no_speech_prob": 0.0005923221469856799}, {"id": 258, "seek": 174888, "start": 1748.88, "end": 1769.7600000000002, "text": " Even if the problem is that we have a faulty nick, and we know that it would take 24 hours to fix it, it may not be worth the effort of, for a node, to move all the data from this node to another node, to other nodes, to the rest of the cluster and then move it back.", "tokens": [2754, 498, 264, 1154, 307, 300, 321, 362, 257, 2050, 5773, 15416, 11, 293, 321, 458, 300, 309, 576, 747, 4022, 2496, 281, 3191, 309, 11, 309, 815, 406, 312, 3163, 264, 4630, 295, 11, 337, 257, 9984, 11, 281, 1286, 439, 264, 1412, 490, 341, 9984, 281, 1071, 9984, 11, 281, 661, 13891, 11, 281, 264, 1472, 295, 264, 13630, 293, 550, 1286, 309, 646, 13], "temperature": 0.0, "avg_logprob": -0.12937391307991994, "compression_ratio": 1.598802395209581, "no_speech_prob": 0.00044531296589411795}, {"id": 259, "seek": 176976, "start": 1769.76, "end": 1780.8, "text": " If we could make sure that we have a faulty nick and until it is fixed, we don't read from this node at all. We just write to it. Maybe we could live with it.", "tokens": [759, 321, 727, 652, 988, 300, 321, 362, 257, 2050, 5773, 15416, 293, 1826, 309, 307, 6806, 11, 321, 500, 380, 1401, 490, 341, 9984, 412, 439, 13, 492, 445, 2464, 281, 309, 13, 2704, 321, 727, 1621, 365, 309, 13], "temperature": 0.0, "avg_logprob": -0.13484587876693063, "compression_ratio": 1.5656108597285068, "no_speech_prob": 0.0003216238401364535}, {"id": 260, "seek": 176976, "start": 1780.8, "end": 1793.44, "text": " So, the idea is that we don't want, the obvious solution is mark OSD is out and move the data and everything fix itself, but it costly, especially if you have a lot of data over the node.", "tokens": [407, 11, 264, 1558, 307, 300, 321, 500, 380, 528, 11, 264, 6322, 3827, 307, 1491, 12731, 35, 307, 484, 293, 1286, 264, 1412, 293, 1203, 3191, 2564, 11, 457, 309, 28328, 11, 2318, 498, 291, 362, 257, 688, 295, 1412, 670, 264, 9984, 13], "temperature": 0.0, "avg_logprob": -0.13484587876693063, "compression_ratio": 1.5656108597285068, "no_speech_prob": 0.0003216238401364535}, {"id": 261, "seek": 179344, "start": 1793.44, "end": 1807.72, "text": " So, this is a way to reduce the load temporarily until it is fixed. And then, once you did all your magic, fixed everything, you could go back to the normal.", "tokens": [407, 11, 341, 307, 257, 636, 281, 5407, 264, 3677, 23750, 1826, 309, 307, 6806, 13, 400, 550, 11, 1564, 291, 630, 439, 428, 5585, 11, 6806, 1203, 11, 291, 727, 352, 646, 281, 264, 2710, 13], "temperature": 0.0, "avg_logprob": -0.16282879433980801, "compression_ratio": 1.3083333333333333, "no_speech_prob": 0.00013168560690246522}, {"id": 262, "seek": 180772, "start": 1807.72, "end": 1837.0, "text": " So, and by the way, this is something that is not related to software-defined storage, but it's much easier, all this much easier to do for a stateless application. If we have a web server that gives us the stock exchange quotes, and it doesn't function, one of the servers doesn't function, we change the proxy and we send the request to other servers.", "tokens": [407, 11, 293, 538, 264, 636, 11, 341, 307, 746, 300, 307, 406, 4077, 281, 4722, 12, 37716, 6725, 11, 457, 309, 311, 709, 3571, 11, 439, 341, 709, 3571, 281, 360, 337, 257, 2219, 4272, 3861, 13, 759, 321, 362, 257, 3670, 7154, 300, 2709, 505, 264, 4127, 7742, 19963, 11, 293, 309, 1177, 380, 2445, 11, 472, 295, 264, 15909, 1177, 380, 2445, 11, 321, 1319, 264, 29690, 293, 321, 2845, 264, 5308, 281, 661, 15909, 13], "temperature": 0.0, "avg_logprob": -0.20244940792221622, "compression_ratio": 1.6495327102803738, "no_speech_prob": 0.0003730617754627019}, {"id": 263, "seek": 183700, "start": 1837.0, "end": 1854.04, "text": " It's way more difficult to do with stateful application when you can't exchange every server with every other server and you need, there are more limitations and obviously we talk about storage. It's the most stateful thing that you could think of.", "tokens": [467, 311, 636, 544, 2252, 281, 360, 365, 1785, 906, 3861, 562, 291, 393, 380, 7742, 633, 7154, 365, 633, 661, 7154, 293, 291, 643, 11, 456, 366, 544, 15705, 293, 2745, 321, 751, 466, 6725, 13, 467, 311, 264, 881, 1785, 906, 551, 300, 291, 727, 519, 295, 13], "temperature": 0.0, "avg_logprob": -0.17078837641963251, "compression_ratio": 1.521472392638037, "no_speech_prob": 0.00027855159714818}, {"id": 264, "seek": 185404, "start": 1854.04, "end": 1873.72, "text": " So, option one, it's something we thought about even for the rebalances we did. This is what is a very good solution for the stateless part, it's called the power of two.", "tokens": [407, 11, 3614, 472, 11, 309, 311, 746, 321, 1194, 466, 754, 337, 264, 319, 2645, 2676, 321, 630, 13, 639, 307, 437, 307, 257, 588, 665, 3827, 337, 264, 2219, 4272, 644, 11, 309, 311, 1219, 264, 1347, 295, 732, 13], "temperature": 0.0, "avg_logprob": -0.1515081760495208, "compression_ratio": 1.6398104265402844, "no_speech_prob": 0.00014134918455965817}, {"id": 265, "seek": 185404, "start": 1873.72, "end": 1883.92, "text": " Before you send the request, you randomly select two candidates to get the request, you find out who is more loaded and you send to the one that is less loaded. It does magic.", "tokens": [4546, 291, 2845, 264, 5308, 11, 291, 16979, 3048, 732, 11255, 281, 483, 264, 5308, 11, 291, 915, 484, 567, 307, 544, 13210, 293, 291, 2845, 281, 264, 472, 300, 307, 1570, 13210, 13, 467, 775, 5585, 13], "temperature": 0.0, "avg_logprob": -0.1515081760495208, "compression_ratio": 1.6398104265402844, "no_speech_prob": 0.00014134918455965817}, {"id": 266, "seek": 188392, "start": 1883.92, "end": 1902.52, "text": " That's really, really good way to move the load from the loaded servers to the unloaded servers and it works. Unfortunately, in order to fix, to do such thing in SEF, you need to go into the data path. Everything that I explained up until now is totally outside of the data path.", "tokens": [663, 311, 534, 11, 534, 665, 636, 281, 1286, 264, 3677, 490, 264, 13210, 15909, 281, 264, 32165, 292, 15909, 293, 309, 1985, 13, 8590, 11, 294, 1668, 281, 3191, 11, 281, 360, 1270, 551, 294, 10269, 37, 11, 291, 643, 281, 352, 666, 264, 1412, 3100, 13, 5471, 300, 286, 8825, 493, 1826, 586, 307, 3879, 2380, 295, 264, 1412, 3100, 13], "temperature": 0.0, "avg_logprob": -0.16546055807996152, "compression_ratio": 1.603448275862069, "no_speech_prob": 0.0004957917844876647}, {"id": 267, "seek": 190252, "start": 1902.52, "end": 1924.72, "text": " You have to add things to the data path and to change the clients and we thought about this also in order to do the read balancing, it would be very simple. Every PG, since we have read from non-replicant in SEF now, we could say for every PG, don't send the request to the primary, send it randomly to any of the PG's and automatically you'll get the balance spread.", "tokens": [509, 362, 281, 909, 721, 281, 264, 1412, 3100, 293, 281, 1319, 264, 6982, 293, 321, 1194, 466, 341, 611, 294, 1668, 281, 360, 264, 1401, 22495, 11, 309, 576, 312, 588, 2199, 13, 2048, 40975, 11, 1670, 321, 362, 1401, 490, 2107, 12, 265, 4770, 394, 294, 10269, 37, 586, 11, 321, 727, 584, 337, 633, 40975, 11, 500, 380, 2845, 264, 5308, 281, 264, 6194, 11, 2845, 309, 16979, 281, 604, 295, 264, 40975, 311, 293, 6772, 291, 603, 483, 264, 4772, 3974, 13], "temperature": 0.0, "avg_logprob": -0.15777576234605578, "compression_ratio": 1.6167400881057268, "no_speech_prob": 0.00036469733458943665}, {"id": 268, "seek": 192472, "start": 1924.72, "end": 1940.72, "text": " Sorry, for HPG to any of the OSD's, don't send to the primary OSD, just send to whatever you have there. We decided not to do it, it's risky and we don't like to play with the data path. I don't like to play with the data path personally, but it was a mutual decision, not only me.", "tokens": [4919, 11, 337, 12557, 38, 281, 604, 295, 264, 12731, 35, 311, 11, 500, 380, 2845, 281, 264, 6194, 12731, 35, 11, 445, 2845, 281, 2035, 291, 362, 456, 13, 492, 3047, 406, 281, 360, 309, 11, 309, 311, 21137, 293, 321, 500, 380, 411, 281, 862, 365, 264, 1412, 3100, 13, 286, 500, 380, 411, 281, 862, 365, 264, 1412, 3100, 5665, 11, 457, 309, 390, 257, 16917, 3537, 11, 406, 787, 385, 13], "temperature": 0.0, "avg_logprob": -0.17195302021654346, "compression_ratio": 1.6057142857142856, "no_speech_prob": 0.0003312888147775084}, {"id": 269, "seek": 194072, "start": 1940.72, "end": 1960.72, "text": " So that's option two, monitor centrally, monitor centrally, obviously, create the policy. This is something that you need to get the function of the policy that knows what to do when you find these discrepancies.", "tokens": [407, 300, 311, 3614, 732, 11, 6002, 32199, 379, 11, 6002, 32199, 379, 11, 2745, 11, 1884, 264, 3897, 13, 639, 307, 746, 300, 291, 643, 281, 483, 264, 2445, 295, 264, 3897, 300, 3255, 437, 281, 360, 562, 291, 915, 613, 2983, 19919, 32286, 13], "temperature": 0.0, "avg_logprob": -0.14918050765991211, "compression_ratio": 1.536231884057971, "no_speech_prob": 0.00027422033599577844}, {"id": 270, "seek": 196072, "start": 1960.72, "end": 1974.72, "text": " You need to understand what you're doing, what you want to achieve, how much time you want to play with this before you decide to move data or maybe you need the human involvement which will tell me, okay, I'm going to fix this, don't do anything.", "tokens": [509, 643, 281, 1223, 437, 291, 434, 884, 11, 437, 291, 528, 281, 4584, 11, 577, 709, 565, 291, 528, 281, 862, 365, 341, 949, 291, 4536, 281, 1286, 1412, 420, 1310, 291, 643, 264, 1952, 17447, 597, 486, 980, 385, 11, 1392, 11, 286, 478, 516, 281, 3191, 341, 11, 500, 380, 360, 1340, 13], "temperature": 0.0, "avg_logprob": -0.10180461269685592, "compression_ratio": 1.6574074074074074, "no_speech_prob": 0.0005227659712545574}, {"id": 271, "seek": 196072, "start": 1974.72, "end": 1986.72, "text": " It's a policy you need to do both in the terms of workflow and then program what you need to program for this.", "tokens": [467, 311, 257, 3897, 291, 643, 281, 360, 1293, 294, 264, 2115, 295, 20993, 293, 550, 1461, 437, 291, 643, 281, 1461, 337, 341, 13], "temperature": 0.0, "avg_logprob": -0.10180461269685592, "compression_ratio": 1.6574074074074074, "no_speech_prob": 0.0005227659712545574}, {"id": 272, "seek": 198672, "start": 1986.72, "end": 2004.72, "text": " The policy function is small, we talked about this, it's nothing. And when the performance changes, first you need to notify operator because we suspect that a lot of the problems could be hardware problems that should be fixed and we need to tell something that we see something bad.", "tokens": [440, 3897, 2445, 307, 1359, 11, 321, 2825, 466, 341, 11, 309, 311, 1825, 13, 400, 562, 264, 3389, 2962, 11, 700, 291, 643, 281, 36560, 12973, 570, 321, 9091, 300, 257, 688, 295, 264, 2740, 727, 312, 8837, 2740, 300, 820, 312, 6806, 293, 321, 643, 281, 980, 746, 300, 321, 536, 746, 1578, 13], "temperature": 0.0, "avg_logprob": -0.13298602104187013, "compression_ratio": 1.5777777777777777, "no_speech_prob": 0.00011605159670580178}, {"id": 273, "seek": 200472, "start": 2004.72, "end": 2016.72, "text": " And then change primary settings so we remove the load from the less performant OSDs or components to other places.", "tokens": [400, 550, 1319, 6194, 6257, 370, 321, 4159, 264, 3677, 490, 264, 1570, 2042, 394, 12731, 35, 82, 420, 6677, 281, 661, 3190, 13], "temperature": 0.0, "avg_logprob": -0.13905035597937448, "compression_ratio": 1.1855670103092784, "no_speech_prob": 9.591348498361185e-05}, {"id": 274, "seek": 201672, "start": 2016.72, "end": 2044.72, "text": " And before monitoring the system and when it's back to normal, we could remove everything and go back to full things. So here is the conclusion, again, it's data path outside of the data path, syncing the metadata, the performance to the clients, which is also something that we didn't want to do,", "tokens": [400, 949, 11028, 264, 1185, 293, 562, 309, 311, 646, 281, 2710, 11, 321, 727, 4159, 1203, 293, 352, 646, 281, 1577, 721, 13, 407, 510, 307, 264, 10063, 11, 797, 11, 309, 311, 1412, 3100, 2380, 295, 264, 1412, 3100, 11, 5451, 2175, 264, 26603, 11, 264, 3389, 281, 264, 6982, 11, 597, 307, 611, 746, 300, 321, 994, 380, 528, 281, 360, 11], "temperature": 0.0, "avg_logprob": -0.1750229821688887, "compression_ratio": 1.5797872340425532, "no_speech_prob": 0.00018637054017744958}, {"id": 275, "seek": 204472, "start": 2044.72, "end": 2059.7200000000003, "text": " versus the external metadata configuration that we do on the server side, whatever, because we trigger the policy from server side and no change.", "tokens": [5717, 264, 8320, 26603, 11694, 300, 321, 360, 322, 264, 7154, 1252, 11, 2035, 11, 570, 321, 7875, 264, 3897, 490, 7154, 1252, 293, 572, 1319, 13], "temperature": 0.0, "avg_logprob": -0.1703894369063839, "compression_ratio": 1.355140186915888, "no_speech_prob": 0.00017399608623236418}, {"id": 276, "seek": 205972, "start": 2059.72, "end": 2076.72, "text": " So that's the idea for, again, this is for how to implement this in the future, but the idea we could, if we measure, if we know what's going on, we could improve to send it some point aside whether this improvement is good enough for us until we fix,", "tokens": [407, 300, 311, 264, 1558, 337, 11, 797, 11, 341, 307, 337, 577, 281, 4445, 341, 294, 264, 2027, 11, 457, 264, 1558, 321, 727, 11, 498, 321, 3481, 11, 498, 321, 458, 437, 311, 516, 322, 11, 321, 727, 3470, 281, 2845, 309, 512, 935, 7359, 1968, 341, 10444, 307, 665, 1547, 337, 505, 1826, 321, 3191, 11], "temperature": 0.0, "avg_logprob": -0.15035363038380942, "compression_ratio": 1.7557603686635945, "no_speech_prob": 0.00019132571469526738}, {"id": 277, "seek": 205972, "start": 2076.72, "end": 2085.72, "text": " or in some cases we decide to move data and don't say don't move data, but don't move it as the default option for every problem.", "tokens": [420, 294, 512, 3331, 321, 4536, 281, 1286, 1412, 293, 500, 380, 584, 500, 380, 1286, 1412, 11, 457, 500, 380, 1286, 309, 382, 264, 7576, 3614, 337, 633, 1154, 13], "temperature": 0.0, "avg_logprob": -0.15035363038380942, "compression_ratio": 1.7557603686635945, "no_speech_prob": 0.00019132571469526738}, {"id": 278, "seek": 208572, "start": 2085.72, "end": 2094.72, "text": " Acknowledgements, Orit, which worked with me a lot on the ideas that I put here, and she's now in IBM.", "tokens": [316, 7678, 3042, 1117, 11, 1610, 270, 11, 597, 2732, 365, 385, 257, 688, 322, 264, 3487, 300, 286, 829, 510, 11, 293, 750, 311, 586, 294, 23487, 13], "temperature": 0.0, "avg_logprob": -0.1396331787109375, "compression_ratio": 1.496969696969697, "no_speech_prob": 0.0007003646460361779}, {"id": 279, "seek": 208572, "start": 2094.72, "end": 2107.72, "text": " And Laura, which did a lot of the coding with me on this, and actually since my coding skills were a bit rusty, I couldn't do a lot without her.", "tokens": [400, 13220, 11, 597, 630, 257, 688, 295, 264, 17720, 365, 385, 322, 341, 11, 293, 767, 1670, 452, 17720, 3942, 645, 257, 857, 45394, 11, 286, 2809, 380, 360, 257, 688, 1553, 720, 13], "temperature": 0.0, "avg_logprob": -0.1396331787109375, "compression_ratio": 1.496969696969697, "no_speech_prob": 0.0007003646460361779}, {"id": 280, "seek": 210772, "start": 2107.72, "end": 2116.72, "text": " So thanks to Orit and Laura that helped in this project, and I'm done. Questions?", "tokens": [407, 3231, 281, 1610, 270, 293, 13220, 300, 4254, 294, 341, 1716, 11, 293, 286, 478, 1096, 13, 27738, 30], "temperature": 0.0, "avg_logprob": -0.1297274430592855, "compression_ratio": 0.9878048780487805, "no_speech_prob": 0.0029368908144533634}, {"id": 281, "seek": 211672, "start": 2116.72, "end": 2143.72, "text": " Yes, please. Can you use the new OSD map rule that is like released for brief, as I said, like master? Can you use that to generate a list of distribution of the primaries that will be optimal on all the clusters,", "tokens": [1079, 11, 1767, 13, 1664, 291, 764, 264, 777, 12731, 35, 4471, 4978, 300, 307, 411, 4736, 337, 5353, 11, 382, 286, 848, 11, 411, 4505, 30, 1664, 291, 764, 300, 281, 8460, 257, 1329, 295, 7316, 295, 264, 2886, 4889, 300, 486, 312, 16252, 322, 439, 264, 23313, 11], "temperature": 0.0, "avg_logprob": -0.27830664316813153, "compression_ratio": 1.4391891891891893, "no_speech_prob": 0.0011230668751522899}, {"id": 282, "seek": 214372, "start": 2143.72, "end": 2156.72, "text": " and use the temporary map feature that is already existing in all our releases to actually apply that policy that this would be optimal.", "tokens": [293, 764, 264, 13413, 4471, 4111, 300, 307, 1217, 6741, 294, 439, 527, 16952, 281, 767, 3079, 300, 3897, 300, 341, 576, 312, 16252, 13], "temperature": 0.0, "avg_logprob": -0.3515932559967041, "compression_ratio": 1.3493150684931507, "no_speech_prob": 0.000258755317190662}, {"id": 283, "seek": 214372, "start": 2156.72, "end": 2157.72, "text": " Okay.", "tokens": [1033, 13], "temperature": 0.0, "avg_logprob": -0.3515932559967041, "compression_ratio": 1.3493150684931507, "no_speech_prob": 0.000258755317190662}, {"id": 284, "seek": 214372, "start": 2157.72, "end": 2159.72, "text": " Basically, I'd like to back forward, but then without.", "tokens": [8537, 11, 286, 1116, 411, 281, 646, 2128, 11, 457, 550, 1553, 13], "temperature": 0.0, "avg_logprob": -0.3515932559967041, "compression_ratio": 1.3493150684931507, "no_speech_prob": 0.000258755317190662}, {"id": 285, "seek": 215972, "start": 2159.72, "end": 2174.72, "text": " The question was, if you could use the OSD map tool on older classes, and then instead of using the new PG op map use a temporary permit permit temp in order to do it.", "tokens": [440, 1168, 390, 11, 498, 291, 727, 764, 264, 12731, 35, 4471, 2290, 322, 4906, 5359, 11, 293, 550, 2602, 295, 1228, 264, 777, 40975, 999, 4471, 764, 257, 13413, 13423, 13423, 18274, 294, 1668, 281, 360, 309, 13], "temperature": 0.0, "avg_logprob": -0.23770248058230378, "compression_ratio": 1.3253968253968254, "no_speech_prob": 0.000536619161721319}, {"id": 286, "seek": 217472, "start": 2174.72, "end": 2192.72, "text": " I think it should, the OSD, you should have a new set cluster with all the new tools because there are some other changes, but you run OSD map tools on a file that generated from the OSD map tools work on configuration file that you take.", "tokens": [286, 519, 309, 820, 11, 264, 12731, 35, 11, 291, 820, 362, 257, 777, 992, 13630, 365, 439, 264, 777, 3873, 570, 456, 366, 512, 661, 2962, 11, 457, 291, 1190, 12731, 35, 4471, 3873, 322, 257, 3991, 300, 10833, 490, 264, 12731, 35, 4471, 3873, 589, 322, 11694, 3991, 300, 291, 747, 13], "temperature": 0.0, "avg_logprob": -0.19809629177225047, "compression_ratio": 1.5256410256410255, "no_speech_prob": 0.00011835813347715884}, {"id": 287, "seek": 219272, "start": 2192.72, "end": 2204.72, "text": " So you could create a configuration file out of an old cluster and run it with the new OSD map tool. And then so I think actually the primary temp is how we tested this.", "tokens": [407, 291, 727, 1884, 257, 11694, 3991, 484, 295, 364, 1331, 13630, 293, 1190, 309, 365, 264, 777, 12731, 35, 4471, 2290, 13, 400, 550, 370, 286, 519, 767, 264, 6194, 18274, 307, 577, 321, 8246, 341, 13], "temperature": 0.0, "avg_logprob": -0.10698998542059035, "compression_ratio": 1.3, "no_speech_prob": 0.00028187487623654306}, {"id": 288, "seek": 220472, "start": 2204.72, "end": 2225.72, "text": " What is missing is that the new OSD map tool relates on the score. And actually I'm not sure, it not depends on the score, but it uses a score internally. So it should run on a new environment, but I think it should be able to work.", "tokens": [708, 307, 5361, 307, 300, 264, 777, 12731, 35, 4471, 2290, 16155, 322, 264, 6175, 13, 400, 767, 286, 478, 406, 988, 11, 309, 406, 5946, 322, 264, 6175, 11, 457, 309, 4960, 257, 6175, 19501, 13, 407, 309, 820, 1190, 322, 257, 777, 2823, 11, 457, 286, 519, 309, 820, 312, 1075, 281, 589, 13], "temperature": 0.0, "avg_logprob": -0.13950762748718262, "compression_ratio": 1.4871794871794872, "no_speech_prob": 0.0003616976900957525}, {"id": 289, "seek": 222572, "start": 2225.72, "end": 2239.72, "text": " I have my information here, or I'll give you my email and send me, I'll verify this. It should work. I'm not 100% sure, but it should work.", "tokens": [286, 362, 452, 1589, 510, 11, 420, 286, 603, 976, 291, 452, 3796, 293, 2845, 385, 11, 286, 603, 16888, 341, 13, 467, 820, 589, 13, 286, 478, 406, 2319, 4, 988, 11, 457, 309, 820, 589, 13], "temperature": 0.0, "avg_logprob": -0.16381132035028367, "compression_ratio": 1.2522522522522523, "no_speech_prob": 0.0007507795817218721}, {"id": 290, "seek": 223972, "start": 2239.72, "end": 2256.72, "text": " If it doesn't work, it is a problem. You said that you defined that it's especially good for smaller clusters. How big would you define smaller clusters?", "tokens": [759, 309, 1177, 380, 589, 11, 309, 307, 257, 1154, 13, 509, 848, 300, 291, 7642, 300, 309, 311, 2318, 665, 337, 4356, 23313, 13, 1012, 955, 576, 291, 6964, 4356, 23313, 30], "temperature": 0.0, "avg_logprob": -0.20984073587366053, "compression_ratio": 1.3421052631578947, "no_speech_prob": 0.0026046717539429665}, {"id": 291, "seek": 225672, "start": 2256.72, "end": 2273.72, "text": " See, the question was, what is small cluster and big cluster? The thing is, the way CRUSH works, it uses statistics to do the split to primaries.", "tokens": [3008, 11, 264, 1168, 390, 11, 437, 307, 1359, 13630, 293, 955, 13630, 30, 440, 551, 307, 11, 264, 636, 14123, 3447, 39, 1985, 11, 309, 4960, 12523, 281, 360, 264, 7472, 281, 2886, 4889, 13], "temperature": 0.0, "avg_logprob": -0.1837027907371521, "compression_ratio": 1.228813559322034, "no_speech_prob": 0.00022013403940945864}, {"id": 292, "seek": 227372, "start": 2273.72, "end": 2286.72, "text": " If you have a cluster in which primaries are not balanced, probably it falls into the smaller side. But if you look at hundreds of OSD, even it's a number of PG's, not number of OSD's.", "tokens": [759, 291, 362, 257, 13630, 294, 597, 2886, 4889, 366, 406, 13902, 11, 1391, 309, 8804, 666, 264, 4356, 1252, 13, 583, 498, 291, 574, 412, 6779, 295, 12731, 35, 11, 754, 309, 311, 257, 1230, 295, 40975, 311, 11, 406, 1230, 295, 12731, 35, 311, 13], "temperature": 0.0, "avg_logprob": -0.1845078000835344, "compression_ratio": 1.3142857142857143, "no_speech_prob": 0.00033372349571436644}, {"id": 293, "seek": 228672, "start": 2286.72, "end": 2301.72, "text": " In the past, I did an experiment and I saw that you saw the score here, 1.4. Every time that you double the number of the PG's, roughly the difference from 1 goes by half.", "tokens": [682, 264, 1791, 11, 286, 630, 364, 5120, 293, 286, 1866, 300, 291, 1866, 264, 6175, 510, 11, 502, 13, 19, 13, 2048, 565, 300, 291, 3834, 264, 1230, 295, 264, 40975, 311, 11, 9810, 264, 2649, 490, 502, 1709, 538, 1922, 13], "temperature": 0.0, "avg_logprob": -0.12763416006210002, "compression_ratio": 1.3053435114503817, "no_speech_prob": 0.0006778050446882844}, {"id": 294, "seek": 230172, "start": 2301.72, "end": 2317.72, "text": " So we put 1.4 for 32 PG's, probably around 1.2 for 64. So it's large clusters with pools with large number of PG's, usually somehow balance themselves.", "tokens": [407, 321, 829, 502, 13, 19, 337, 8858, 40975, 311, 11, 1391, 926, 502, 13, 17, 337, 12145, 13, 407, 309, 311, 2416, 23313, 365, 28688, 365, 2416, 1230, 295, 40975, 311, 11, 2673, 6063, 4772, 2969, 13], "temperature": 0.0, "avg_logprob": -0.19961254506171505, "compression_ratio": 1.5401069518716577, "no_speech_prob": 0.00018546303908806294}, {"id": 295, "seek": 230172, "start": 2317.72, "end": 2324.72, "text": " But it's a matter of, you need to look, if you have unbalanced pools, it's unbalanced pools. It doesn't matter which cluster you are in.", "tokens": [583, 309, 311, 257, 1871, 295, 11, 291, 643, 281, 574, 11, 498, 291, 362, 517, 40251, 28688, 11, 309, 311, 517, 40251, 28688, 13, 467, 1177, 380, 1871, 597, 13630, 291, 366, 294, 13], "temperature": 0.0, "avg_logprob": -0.19961254506171505, "compression_ratio": 1.5401069518716577, "no_speech_prob": 0.00018546303908806294}, {"id": 296, "seek": 232472, "start": 2324.72, "end": 2338.72, "text": " But that's why we do it. But most benefit for the larger pools, the pools with the data, is when you have smaller clusters, it's not worth putting 512 PG's per pool and you work with smaller numbers.", "tokens": [583, 300, 311, 983, 321, 360, 309, 13, 583, 881, 5121, 337, 264, 4833, 28688, 11, 264, 28688, 365, 264, 1412, 11, 307, 562, 291, 362, 4356, 23313, 11, 309, 311, 406, 3163, 3372, 1025, 4762, 40975, 311, 680, 7005, 293, 291, 589, 365, 4356, 3547, 13], "temperature": 0.0, "avg_logprob": -0.12152076721191406, "compression_ratio": 1.5, "no_speech_prob": 0.000561256892979145}, {"id": 297, "seek": 232472, "start": 2338.72, "end": 2346.72, "text": " If you have 510K or 2K PG's per cluster, probably your score would be pretty good.", "tokens": [759, 291, 362, 1025, 3279, 42, 420, 568, 42, 40975, 311, 680, 13630, 11, 1391, 428, 6175, 576, 312, 1238, 665, 13], "temperature": 0.0, "avg_logprob": -0.12152076721191406, "compression_ratio": 1.5, "no_speech_prob": 0.000561256892979145}, {"id": 298, "seek": 234672, "start": 2346.72, "end": 2354.72, "text": " Would it also be useful for erasure coded pools?", "tokens": [6068, 309, 611, 312, 4420, 337, 1189, 2508, 34874, 28688, 30], "temperature": 0.0, "avg_logprob": -0.2256932165108475, "compression_ratio": 1.446969696969697, "no_speech_prob": 0.0007369822124019265}, {"id": 299, "seek": 234672, "start": 2354.72, "end": 2365.72, "text": " The question whether it's good for erasure coded pools, probably not. Well, way, way, way less sufficient. I tried to do the theory behind it.", "tokens": [440, 1168, 1968, 309, 311, 665, 337, 1189, 2508, 34874, 28688, 11, 1391, 406, 13, 1042, 11, 636, 11, 636, 11, 636, 1570, 11563, 13, 286, 3031, 281, 360, 264, 5261, 2261, 309, 13], "temperature": 0.0, "avg_logprob": -0.2256932165108475, "compression_ratio": 1.446969696969697, "no_speech_prob": 0.0007369822124019265}, {"id": 300, "seek": 236572, "start": 2365.72, "end": 2376.72, "text": " Then maybe really, really little, I don't know. So currently we check in the code, it doesn't work for erasure coded at all because we think it doesn't worth the hassle.", "tokens": [1396, 1310, 534, 11, 534, 707, 11, 286, 500, 380, 458, 13, 407, 4362, 321, 1520, 294, 264, 3089, 11, 309, 1177, 380, 589, 337, 1189, 2508, 34874, 412, 439, 570, 321, 519, 309, 1177, 380, 3163, 264, 39526, 13], "temperature": 0.0, "avg_logprob": -0.14294434729076566, "compression_ratio": 1.5522388059701493, "no_speech_prob": 0.00047254565288312733}, {"id": 301, "seek": 236572, "start": 2376.72, "end": 2385.72, "text": " So it's tested and it works only on replicables.", "tokens": [407, 309, 311, 8246, 293, 309, 1985, 787, 322, 3248, 299, 2965, 13], "temperature": 0.0, "avg_logprob": -0.14294434729076566, "compression_ratio": 1.5522388059701493, "no_speech_prob": 0.00047254565288312733}, {"id": 302, "seek": 238572, "start": 2385.72, "end": 2397.72, "text": " Okay, my time is up. Thank you very much. It was pleasure being face to face here. Thank you.", "tokens": [50364, 1033, 11, 452, 565, 307, 493, 13, 1044, 291, 588, 709, 13, 467, 390, 6834, 885, 1851, 281, 1851, 510, 13, 1044, 291, 13, 50964], "temperature": 0.0, "avg_logprob": -0.1569429150334111, "compression_ratio": 1.1071428571428572, "no_speech_prob": 0.0029870395082980394}], "language": "en"}