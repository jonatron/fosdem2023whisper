{"text": " Okay, now we have Charles Brozegard and he's going to speak to us of binary pattern matching in Elixir and Erlang, one of the cool features of Erlang and Elixir. So if you speak binary to me, give it up for Charles. Thank you, don't worry, I'm not going to speak binary, but yes, this is a talk about speaking binary to other devices. And this is me and you can find me around the web at ARTRARBR, yes. I work as a software developer in Denmark in a company called Indelab and part of my job is to work on innovations in the Internet of Things realm. So things like smart buildings, smart cities, and smart factories. In practice, this involves building gateways that link many different kinds of stupid things together and then when we have a network of things, they can exchange information and we can embed the smartest into the system. And by many different stupid things, I mean things like remote terminal units which are used in the grid, electric grid and all the utilities, PLCs which are used heavily in factories for automation, solar inverters, heat pumps, thermostats, all kinds of smart home equipment. And at the lowest level, we have simple sensors and actuators. And the thing that all these things have in common is that I had to speak binary to them. They don't speak JSON, they don't know XML, they don't know protocol even. They had their own custom binary dialects depending on the protocol that they are using. And later in this talk I show an example of a simple binary dialect so that we all know what it is. When I'm building an integration for a system like this, I always reach for Elixir first. This is because Elixir has some special affordances that makes it extremely good at this kind of work. This is also the case for Erlang and LFE and Beam and Gleam and the other languages on the Erlang virtual machine, but Elixir happens to be my happy space. Some of the Beam's known strong points in this area are fault tolerance, state machines and concurrency. And then there's business acts and that's what I'll be talking about today. This is a beginner level talk. I don't assume you know anything about Elixir or the previously mentioned systems, but my hope is that if you should find yourself in a situation where you need to speak binary to something, this talk will help you get started. So binaries. Computers today work by manipulating electric signals and a signal can be either a logic high or a logic low. Because a signal is known as a bit and a sequence of 8 bits is a byte. And this is also how computers communicate. No matter if it's Ethernet or Wi-Fi or whatever, it's about transferring a logic signal of high and low bits. There are different ways we can write down the binary signals. The first notation that I highlighted here is in binary where we just take every bit in the sequence and we write it down as a 0 or a 1. And then it prefix it with a 0B so that it's easier to tell from other numbers. And in this case, the sequence of 8 bits, which is a byte, can also be turned into a decimal number because in a byte we can have 256 different combinations. So it's a number from 0 to 255. And in decimal notation, this sequence of bits is 75. There's also Hex notation, where we use the characters 0 to 9 and 8 to F. This means we can describe the constant of a byte with just two characters. So this is very convenient when we are dealing with binary numbers. Just a common example of where we write the bytes as decimals. We do that with IPv4 addresses because an IPv4 address is just four bytes. But then for human consumption, we write it as a binary number, or sorry, a decimal number. And MAC addresses use Hex notation instead of the binary notation. While all the operations in our computers are processing bits and bytes, we rarely think about them when we are programming. We think in terms of integers, floats, strings, lists, maps, and all the structures. But binary data is just a flat stream of bits. There's nothing inherent in it to tell one field from the other, or any kind of structure. It's all down to how we interpret those bits. This means that when we need to speak binary to something from our programs, we need to write a translation layer that can take whatever list of maps we have in our program and turn it into a binary sequence. I prefer calling this translation layer a codec because it's short to write. And you can say that a codec encodes our data structures in bytes for sending. And then when we receive data, the codec decodes that data into our high-level data structures. And sometimes we're lucky we can find a library that will do that for us, but sometimes we need to do it ourselves. And that's where bit syntax comes in handy. So let's take a look at that. Let's say I need to send a sequence of free bytes to some other system. They need to have values 10, 20, and 30. To do that, I use distance x, so I use double ankle brackets to start the binary sequence. And then I write the bytes that I need in sequence and separate it by a comma. So that's pretty simple. Yes. And when I need to receive that data, like if I'm receiving the same sequence of bytes, I need to decode that into free variables, a, b, and c. Then I use this syntax, again, double brackets. Then I put the variables instead of the numbers that I want to extract. So it's pretty simple. But of course, we are not really done yet. It's very few domains where we only work with integers in the sequence of 0 to 255. We need larger numbers. We need negative numbers. We need floats and strings. But many languages will just give you a byte stream, and then you need to sort of do a lot of strange computations to turn that into lists and strings. But in Elixir and on the Beam, we have the bits and sacks, and we can do more. Specifically with bits and sacks, we have the option or the ability to specify modifiers. And the modifiers can specify the type, the sign, the size, unit, and indianess of the sequence of bits we want to extract from the binary. So here you see that the type is integer. It is unsigned, so it's positive numbers only. It has a size of eight units, and one unit is said to be one bit long. And it's big indian, which I will talk about later. So these are all equivalent 10, 20, 30, they are encoded the same way. It's just different syntaxes. So you can see if you don't specify any modifiers, these are the defaults that I used instead. And the second line I used, I omitted size, I just wrote eight. That's something you can do when you know it has a constant at compile time. If the size is variable, you will need to use the full size modifier. And the modifiers can be combined in any order, so you can do whatever you like. And when we decode it, we use exactly the same syntax. We can say the same things, like grab the first byte, tell it to compile it that it's an integer, and then it will extract it like this. And instead of just going through all the different modifiers and the combinations, I move on to showcasing some examples. But before we do that, I want to mention where the bits and text came from. Bits and text comes from a place of pain. These two guys, Clairs, Wichstr\u00f6m, and Tony Rockwell, were working at the computer science laboratory at AXN on implementing networking protocols for Erlang, and it was painful. And so they sat down, since they were so close to the makers of the language, they could invent a new syntax for use in Erlang. And this paper, which is published in 1998, describes the first version of the syntax as it was implemented in an experimental version of Erlang. I think a few months later, it was released with slightly different syntax, but with all the same concepts. And that paper also explains what Indianness is, and it's actually just a fun word for byte order, because if you have a 16-bit integer that you need to send to some other system, that's two bytes, right? And you have to figure out, the one byte is A2, and the other byte is C1. And you have to figure out which byte do you send first. Some systems will send the most significant byte first, so that's A2. But other systems will send the least significant byte first, that's C1. And so this obviously has consequences, because you need to know the byte order that the system you're talking to, what it expects, otherwise it just gets confused. And yes, the byte ordering is said to be big Indian when you start with the most significant byte, and it's said to be little Indian if you start with the least significant byte. And this is kind of a thing, I've been working with this for years, but I didn't really know what Indian means, because it's a sort of weird name, right? But the paper by Claes and Tony hinted me in the direction of finding that by pointing me to this Internet experiment note from 1980, which is, I think, the first sort of place where Indian and byte order was used together on holy wars of the plea for peace. And that sort of shows that this is an important topic, sort of like Vim vs. T-Max, I guess. And it's actually just, Indian is just a pop culture reference to a book called Gulliver's Travels, where a seagull travels out into the world and meets the people of Lilliput and Plefusco, I think, and they are in conflict, because the emperor of Lilliput has commanded that X must be broken at the little end when you eat them for breakfast or whatever. So that's obviously absurd, and so they wage a war. So big Indian means we send the big end of the number first, and the little end means we send the little end of the number. So examples of bits and texts. For the purpose of this talk, I have invented the T-Box, which is a very simple device. It has a name, and it can measure the temperature, and it can tell you if there's an error in the time stamp or the measurement. It has a binary dialect or protocol, which I also invented, and this sort of mirrors what you will find in a real protocol description for some kind of device. A client can connect to a T-Box and can send requests to the T-Box, and the T-Box will respond with a reply. Every message that is sent includes a header, which is one byte long, and replies from the T-Box will also contain a value. The header starts with four bits of magic, which is a constant value that is always there and is used to sort of make sure this is the beginning of a message. Then there's a direction bit, which tells whether this message is a request or a reply, and there's the attribute, three bits, which are used to tell if this is a name or temperature message. There are extra, we only use one bit in the attribute, but that's just because they expect to expand the protocol someday. This is an example of a sequence request-reply. First we send the request with the header, with the magic bits first, then it's a zero because the direction is a request, and then we're requesting one, which means we're requesting the temperature, and then the reply has almost the same header at the beginning, it's just one in place of the direction, and then the bytes with the value after that. If you're requesting the name of the T-Box, then it will respond with 12 bytes, and it's always 12 bytes. If the name is shorter than 12 bytes, then the rest of the bytes are just null bytes, and that looks like this. If the name of the box is fustum, then you have six bytes of actual characters, and then null bytes for the rest. The temperature is a little more complicated. It has three fields. There's the time, which is a 32-bit integer, counting the number of seconds since 1st of January, 1970. Then there's the temperature, which is a 16-bit float, and then there's the quality byte, which tells you whether there's an error in some of the measurements. It's the two last bits in the Q-byte that are used. The second to last bit tells you there's an error in the clock, and the last bit tells you there's an error in the temperature measurement. It's important to note that the numbers are little in the end. This is what a temperature value looks like. First, it has a timestamp, which is a couple days ago. Then the temperature, which is 32 degrees about that, and then both of the error bits are high, so you should not trust the sample. This syntax, we want to send a request to the T-box to get the name. I use the double anchor brackets again. It's all integers, and it's all unsigned, so the only thing I have to specify is the size. Here I specify the magic is four bits, then I have my direction, one bit, and the attribute which is zero for getting the name. This shows how we can use the bits and tags to encode, easily encode things which are smaller than bytes. The reply that comes back looks like this. When we receive the goodbye, we do like this. First I want to assert that the message I get back is what I expect. In place of the header, I assert that the values are what I expect. I assert that I get the magic bits first, that the direction bit is high so that I know it's a reply, and that the attribute is zero so that I know it's the name. This is all true. I know that the rest of the message is 12 bytes long, and I want to assign that to the variable name. Here you can see I will use the bytes modifier. This changes the type, and it changes the size, or it changes the unit property. Before with integers, I would specify, like in the header you can see it's two colon colon four for the magic. That means four bits, but when I specify bytes, that the type of name is bytes, then I also say that the 12 means 12 bytes long and not 12 bits long. That's just to say that the bytes is a type and has different defaults than integers. When I get the Tbox temperature, I request it like this, pretty much the same as before, just with a one for the attribute, and for the reply, I again assert on the header that I get back what I expect. Then I have the timestamp, which was the 32-bit integer, but little indian, so let's put that in there, and the temperature, which is a float, 16 bits, also little indian. Then I discard six bits from the cube byte because they were not used, and then I just plug the second to last and the last bit out as clock error and temperature error. That's the basics of bits and tacks. There's so much more to cover with writing whole applications or libraries to do this kind of stuff, like what do we do when you don't receive the entire message at once, you have to frame messages when you're streaming them or receiving them as a stream. There's generators, there's a special, well, it looks like just a normal forward generator, but it actually has some special optimizations for working with binaries when you need to generate a binary. We could talk about performance tuning, but as I said, I've been working with this for years and I've never had to really do any performance tuning. It's pretty performant as is. That's also one of the points in the paper by Claes and Tony is that this is performant. Yeah, there are many other tools for working with binaries that help us when we're looking at this data and not understanding why it's not doing what we expect. Wireshark is definitely one of them. I recommend checking that out. I also recommend if you want to explore more depth, that you check out Protohackers, which is a sort of advent of code challenge thing about their networking protocols, and Andrea Lopardi from the Elixir core team has a live stream on YouTube or has streams on YouTube where he sort of goes through the problems one by one, so that's very good for learning that. Andrea has also started writing a book about this kind of stuff. So that's it. Thank you. Thank you for your thoughts, Rolf. Do you have any questions? Hi. Thanks. So I've done, I've implemented a few binary protocols like network protocols like HTTP 2 or other stuff like that. I'd love to know how you, if you have done any streaming of data and passing of messages coming from streaming data and generators also would be interesting just to know how you approached it because I know I did something but I don't know how we did it. I think I've implemented a few protocols that use, for example, TCP as the underlying transport and then that's like a stream. And then there are a few patterns for how you want to handle that. I think Frank Honloth and the nerve team wrote a sort of framing behavior, which way you have a couple of callbacks that you need to implement in order to handle a stream so that they give you bytes and then you return back messages when you see a full message. It's actually a very good sort of guideline for how to do that. Another approach is taken by Andrea Leopardi in his library for Redis where it's like you call, when you call the decoding function and it returns a result, the result will be whatever messages was in that binary you gave it and then a continuation function which you call next time with more bytes so that it continues to return new messages, yeah. Any question? If I would buy a T-box from you, do I still get support in about 16 years from now? Maybe five minutes. I actually have a question for you if there are no other questions. Do you have a library you suggest to see? Because I implemented a library to decode the QOEI which is the quite okay image format which is a new image format just to get my irons dirty with binary pattern matching in Elixir but it gets very unwieldy very fast. So I saw like in JSON they have some macros that generate binary pattern matching. Do you have any libraries you recommend to check out? I think the Redis library is pretty nice. I also have a KNX library which is like a smart home protocol which I don't know if I would recommend but when I wrote it I thought it was made sense, yeah. Thank you. Any other questions? The last one I guess. Maybe a word about exceptions when patterns don't match. Yeah. You didn't talk about that if I'm correct. That's true. I mean sometimes we say we should just let it crash in this community. That's not always the case. Sometimes the protocol will say that if you're unable to decode a message you must ignore it and just continue going. In that case what I usually do is I define functions where I match on the data I received and then I always need to have a fallback clause in case it didn't match anything and then just lock an error and continue. But I mean probably the proper thing to do in Erlang is to try to just die. There's also you could when you receive a message you could have a special process that is only for decoding so you start a task, decode a message and get the data structure back but I think it depends on the use case how you want to handle bad data. Okay, thank you very much.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 15.88, "text": " Okay, now we have Charles Brozegard and he's going to speak to us of binary pattern matching", "tokens": [1033, 11, 586, 321, 362, 10523, 5425, 89, 1146, 515, 293, 415, 311, 516, 281, 1710, 281, 505, 295, 17434, 5102, 14324], "temperature": 0.0, "avg_logprob": -0.35179114708533654, "compression_ratio": 1.4333333333333333, "no_speech_prob": 0.3553430140018463}, {"id": 1, "seek": 0, "start": 15.88, "end": 20.2, "text": " in Elixir and Erlang, one of the cool features of Erlang and Elixir.", "tokens": [294, 2699, 970, 347, 293, 3300, 25241, 11, 472, 295, 264, 1627, 4122, 295, 3300, 25241, 293, 2699, 970, 347, 13], "temperature": 0.0, "avg_logprob": -0.35179114708533654, "compression_ratio": 1.4333333333333333, "no_speech_prob": 0.3553430140018463}, {"id": 2, "seek": 0, "start": 20.2, "end": 26.04, "text": " So if you speak binary to me, give it up for Charles.", "tokens": [407, 498, 291, 1710, 17434, 281, 385, 11, 976, 309, 493, 337, 10523, 13], "temperature": 0.0, "avg_logprob": -0.35179114708533654, "compression_ratio": 1.4333333333333333, "no_speech_prob": 0.3553430140018463}, {"id": 3, "seek": 2604, "start": 26.04, "end": 35.44, "text": " Thank you, don't worry, I'm not going to speak binary, but yes, this is a talk about speaking", "tokens": [1044, 291, 11, 500, 380, 3292, 11, 286, 478, 406, 516, 281, 1710, 17434, 11, 457, 2086, 11, 341, 307, 257, 751, 466, 4124], "temperature": 0.0, "avg_logprob": -0.23359829866433446, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.00026307054213248193}, {"id": 4, "seek": 2604, "start": 35.44, "end": 37.8, "text": " binary to other devices.", "tokens": [17434, 281, 661, 5759, 13], "temperature": 0.0, "avg_logprob": -0.23359829866433446, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.00026307054213248193}, {"id": 5, "seek": 2604, "start": 37.8, "end": 47.16, "text": " And this is me and you can find me around the web at ARTRARBR, yes.", "tokens": [400, 341, 307, 385, 293, 291, 393, 915, 385, 926, 264, 3670, 412, 8943, 25936, 1899, 11609, 11, 2086, 13], "temperature": 0.0, "avg_logprob": -0.23359829866433446, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.00026307054213248193}, {"id": 6, "seek": 2604, "start": 47.16, "end": 53.0, "text": " I work as a software developer in Denmark in a company called Indelab and part of my job", "tokens": [286, 589, 382, 257, 4722, 10754, 294, 28065, 294, 257, 2237, 1219, 2333, 338, 455, 293, 644, 295, 452, 1691], "temperature": 0.0, "avg_logprob": -0.23359829866433446, "compression_ratio": 1.4473684210526316, "no_speech_prob": 0.00026307054213248193}, {"id": 7, "seek": 5300, "start": 53.0, "end": 57.56, "text": " is to work on innovations in the Internet of Things realm.", "tokens": [307, 281, 589, 322, 24283, 294, 264, 7703, 295, 9514, 15355, 13], "temperature": 0.0, "avg_logprob": -0.1679364244143168, "compression_ratio": 1.7682926829268293, "no_speech_prob": 0.0006794418441131711}, {"id": 8, "seek": 5300, "start": 57.56, "end": 63.28, "text": " So things like smart buildings, smart cities, and smart factories.", "tokens": [407, 721, 411, 4069, 7446, 11, 4069, 6486, 11, 293, 4069, 24813, 13], "temperature": 0.0, "avg_logprob": -0.1679364244143168, "compression_ratio": 1.7682926829268293, "no_speech_prob": 0.0006794418441131711}, {"id": 9, "seek": 5300, "start": 63.28, "end": 68.44, "text": " In practice, this involves building gateways that link many different kinds of stupid things", "tokens": [682, 3124, 11, 341, 11626, 2390, 8539, 942, 300, 2113, 867, 819, 3685, 295, 6631, 721], "temperature": 0.0, "avg_logprob": -0.1679364244143168, "compression_ratio": 1.7682926829268293, "no_speech_prob": 0.0006794418441131711}, {"id": 10, "seek": 5300, "start": 68.44, "end": 74.16, "text": " together and then when we have a network of things, they can exchange information and", "tokens": [1214, 293, 550, 562, 321, 362, 257, 3209, 295, 721, 11, 436, 393, 7742, 1589, 293], "temperature": 0.0, "avg_logprob": -0.1679364244143168, "compression_ratio": 1.7682926829268293, "no_speech_prob": 0.0006794418441131711}, {"id": 11, "seek": 5300, "start": 74.16, "end": 77.64, "text": " we can embed the smartest into the system.", "tokens": [321, 393, 12240, 264, 41491, 666, 264, 1185, 13], "temperature": 0.0, "avg_logprob": -0.1679364244143168, "compression_ratio": 1.7682926829268293, "no_speech_prob": 0.0006794418441131711}, {"id": 12, "seek": 5300, "start": 77.64, "end": 81.52, "text": " And by many different stupid things, I mean things like remote terminal units which are", "tokens": [400, 538, 867, 819, 6631, 721, 11, 286, 914, 721, 411, 8607, 14709, 6815, 597, 366], "temperature": 0.0, "avg_logprob": -0.1679364244143168, "compression_ratio": 1.7682926829268293, "no_speech_prob": 0.0006794418441131711}, {"id": 13, "seek": 8152, "start": 81.52, "end": 88.24, "text": " used in the grid, electric grid and all the utilities, PLCs which are used heavily in factories", "tokens": [1143, 294, 264, 10748, 11, 5210, 10748, 293, 439, 264, 30482, 11, 6999, 33290, 597, 366, 1143, 10950, 294, 24813], "temperature": 0.0, "avg_logprob": -0.12780425127814798, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004977865610271692}, {"id": 14, "seek": 8152, "start": 88.24, "end": 96.36, "text": " for automation, solar inverters, heat pumps, thermostats, all kinds of smart home equipment.", "tokens": [337, 17769, 11, 7936, 28653, 1559, 11, 3738, 27648, 11, 8810, 555, 1720, 11, 439, 3685, 295, 4069, 1280, 5927, 13], "temperature": 0.0, "avg_logprob": -0.12780425127814798, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004977865610271692}, {"id": 15, "seek": 8152, "start": 96.36, "end": 101.84, "text": " And at the lowest level, we have simple sensors and actuators.", "tokens": [400, 412, 264, 12437, 1496, 11, 321, 362, 2199, 14840, 293, 34964, 3391, 13], "temperature": 0.0, "avg_logprob": -0.12780425127814798, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004977865610271692}, {"id": 16, "seek": 8152, "start": 101.84, "end": 107.64, "text": " And the thing that all these things have in common is that I had to speak binary to them.", "tokens": [400, 264, 551, 300, 439, 613, 721, 362, 294, 2689, 307, 300, 286, 632, 281, 1710, 17434, 281, 552, 13], "temperature": 0.0, "avg_logprob": -0.12780425127814798, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0004977865610271692}, {"id": 17, "seek": 10764, "start": 107.64, "end": 112.96000000000001, "text": " They don't speak JSON, they don't know XML, they don't know protocol even.", "tokens": [814, 500, 380, 1710, 31828, 11, 436, 500, 380, 458, 43484, 11, 436, 500, 380, 458, 10336, 754, 13], "temperature": 0.0, "avg_logprob": -0.1723963799683944, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.00018795151845552027}, {"id": 18, "seek": 10764, "start": 112.96000000000001, "end": 120.96000000000001, "text": " They had their own custom binary dialects depending on the protocol that they are using.", "tokens": [814, 632, 641, 1065, 2375, 17434, 24652, 82, 5413, 322, 264, 10336, 300, 436, 366, 1228, 13], "temperature": 0.0, "avg_logprob": -0.1723963799683944, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.00018795151845552027}, {"id": 19, "seek": 10764, "start": 120.96000000000001, "end": 126.04, "text": " And later in this talk I show an example of a simple binary dialect so that we all know", "tokens": [400, 1780, 294, 341, 751, 286, 855, 364, 1365, 295, 257, 2199, 17434, 24652, 370, 300, 321, 439, 458], "temperature": 0.0, "avg_logprob": -0.1723963799683944, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.00018795151845552027}, {"id": 20, "seek": 10764, "start": 126.04, "end": 129.12, "text": " what it is.", "tokens": [437, 309, 307, 13], "temperature": 0.0, "avg_logprob": -0.1723963799683944, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.00018795151845552027}, {"id": 21, "seek": 10764, "start": 129.12, "end": 133.96, "text": " When I'm building an integration for a system like this, I always reach for Elixir first.", "tokens": [1133, 286, 478, 2390, 364, 10980, 337, 257, 1185, 411, 341, 11, 286, 1009, 2524, 337, 2699, 970, 347, 700, 13], "temperature": 0.0, "avg_logprob": -0.1723963799683944, "compression_ratio": 1.59009009009009, "no_speech_prob": 0.00018795151845552027}, {"id": 22, "seek": 13396, "start": 133.96, "end": 138.16, "text": " This is because Elixir has some special affordances that makes it extremely good at this kind", "tokens": [639, 307, 570, 2699, 970, 347, 575, 512, 2121, 6157, 2676, 300, 1669, 309, 4664, 665, 412, 341, 733], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 23, "seek": 13396, "start": 138.16, "end": 140.72, "text": " of work.", "tokens": [295, 589, 13], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 24, "seek": 13396, "start": 140.72, "end": 147.16, "text": " This is also the case for Erlang and LFE and Beam and Gleam and the other languages on the", "tokens": [639, 307, 611, 264, 1389, 337, 3300, 25241, 293, 441, 28182, 293, 40916, 293, 460, 306, 335, 293, 264, 661, 8650, 322, 264], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 25, "seek": 13396, "start": 147.16, "end": 152.04000000000002, "text": " Erlang virtual machine, but Elixir happens to be my happy space.", "tokens": [3300, 25241, 6374, 3479, 11, 457, 2699, 970, 347, 2314, 281, 312, 452, 2055, 1901, 13], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 26, "seek": 13396, "start": 152.04000000000002, "end": 157.08, "text": " Some of the Beam's known strong points in this area are fault tolerance, state machines", "tokens": [2188, 295, 264, 40916, 311, 2570, 2068, 2793, 294, 341, 1859, 366, 7441, 23368, 11, 1785, 8379], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 27, "seek": 13396, "start": 157.08, "end": 159.44, "text": " and concurrency.", "tokens": [293, 23702, 10457, 13], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 28, "seek": 13396, "start": 159.44, "end": 163.92000000000002, "text": " And then there's business acts and that's what I'll be talking about today.", "tokens": [400, 550, 456, 311, 1606, 10672, 293, 300, 311, 437, 286, 603, 312, 1417, 466, 965, 13], "temperature": 0.0, "avg_logprob": -0.21329823369565218, "compression_ratio": 1.6319702602230484, "no_speech_prob": 0.00015717615315224975}, {"id": 29, "seek": 16392, "start": 163.92, "end": 165.35999999999999, "text": " This is a beginner level talk.", "tokens": [639, 307, 257, 22080, 1496, 751, 13], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 30, "seek": 16392, "start": 165.35999999999999, "end": 170.72, "text": " I don't assume you know anything about Elixir or the previously mentioned systems, but my", "tokens": [286, 500, 380, 6552, 291, 458, 1340, 466, 2699, 970, 347, 420, 264, 8046, 2835, 3652, 11, 457, 452], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 31, "seek": 16392, "start": 170.72, "end": 174.11999999999998, "text": " hope is that if you should find yourself in a situation where you need to speak binary", "tokens": [1454, 307, 300, 498, 291, 820, 915, 1803, 294, 257, 2590, 689, 291, 643, 281, 1710, 17434], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 32, "seek": 16392, "start": 174.11999999999998, "end": 179.23999999999998, "text": " to something, this talk will help you get started.", "tokens": [281, 746, 11, 341, 751, 486, 854, 291, 483, 1409, 13], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 33, "seek": 16392, "start": 179.23999999999998, "end": 182.6, "text": " So binaries.", "tokens": [407, 5171, 4889, 13], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 34, "seek": 16392, "start": 182.6, "end": 188.04, "text": " Computers today work by manipulating electric signals and a signal can be either a logic", "tokens": [37804, 433, 965, 589, 538, 40805, 5210, 12354, 293, 257, 6358, 393, 312, 2139, 257, 9952], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 35, "seek": 16392, "start": 188.04, "end": 190.35999999999999, "text": " high or a logic low.", "tokens": [1090, 420, 257, 9952, 2295, 13], "temperature": 0.0, "avg_logprob": -0.13884772857030234, "compression_ratio": 1.5362903225806452, "no_speech_prob": 0.00013673293869942427}, {"id": 36, "seek": 19036, "start": 190.36, "end": 195.60000000000002, "text": " Because a signal is known as a bit and a sequence of 8 bits is a byte.", "tokens": [1436, 257, 6358, 307, 2570, 382, 257, 857, 293, 257, 8310, 295, 1649, 9239, 307, 257, 40846, 13], "temperature": 0.0, "avg_logprob": -0.20593810391116452, "compression_ratio": 1.4642857142857142, "no_speech_prob": 4.822842311114073e-05}, {"id": 37, "seek": 19036, "start": 195.60000000000002, "end": 198.28, "text": " And this is also how computers communicate.", "tokens": [400, 341, 307, 611, 577, 10807, 7890, 13], "temperature": 0.0, "avg_logprob": -0.20593810391116452, "compression_ratio": 1.4642857142857142, "no_speech_prob": 4.822842311114073e-05}, {"id": 38, "seek": 19036, "start": 198.28, "end": 203.56, "text": " No matter if it's Ethernet or Wi-Fi or whatever, it's about transferring a logic signal of", "tokens": [883, 1871, 498, 309, 311, 38636, 7129, 420, 14035, 12, 13229, 420, 2035, 11, 309, 311, 466, 31437, 257, 9952, 6358, 295], "temperature": 0.0, "avg_logprob": -0.20593810391116452, "compression_ratio": 1.4642857142857142, "no_speech_prob": 4.822842311114073e-05}, {"id": 39, "seek": 19036, "start": 203.56, "end": 207.76000000000002, "text": " high and low bits.", "tokens": [1090, 293, 2295, 9239, 13], "temperature": 0.0, "avg_logprob": -0.20593810391116452, "compression_ratio": 1.4642857142857142, "no_speech_prob": 4.822842311114073e-05}, {"id": 40, "seek": 19036, "start": 207.76000000000002, "end": 214.16000000000003, "text": " There are different ways we can write down the binary signals.", "tokens": [821, 366, 819, 2098, 321, 393, 2464, 760, 264, 17434, 12354, 13], "temperature": 0.0, "avg_logprob": -0.20593810391116452, "compression_ratio": 1.4642857142857142, "no_speech_prob": 4.822842311114073e-05}, {"id": 41, "seek": 21416, "start": 214.16, "end": 220.56, "text": " The first notation that I highlighted here is in binary where we just take every bit", "tokens": [440, 700, 24657, 300, 286, 17173, 510, 307, 294, 17434, 689, 321, 445, 747, 633, 857], "temperature": 0.0, "avg_logprob": -0.16063181176243058, "compression_ratio": 1.52020202020202, "no_speech_prob": 5.861743920831941e-05}, {"id": 42, "seek": 21416, "start": 220.56, "end": 225.51999999999998, "text": " in the sequence and we write it down as a 0 or a 1.", "tokens": [294, 264, 8310, 293, 321, 2464, 309, 760, 382, 257, 1958, 420, 257, 502, 13], "temperature": 0.0, "avg_logprob": -0.16063181176243058, "compression_ratio": 1.52020202020202, "no_speech_prob": 5.861743920831941e-05}, {"id": 43, "seek": 21416, "start": 225.51999999999998, "end": 232.04, "text": " And then it prefix it with a 0B so that it's easier to tell from other numbers.", "tokens": [400, 550, 309, 46969, 309, 365, 257, 1958, 33, 370, 300, 309, 311, 3571, 281, 980, 490, 661, 3547, 13], "temperature": 0.0, "avg_logprob": -0.16063181176243058, "compression_ratio": 1.52020202020202, "no_speech_prob": 5.861743920831941e-05}, {"id": 44, "seek": 21416, "start": 232.04, "end": 239.72, "text": " And in this case, the sequence of 8 bits, which is a byte, can also be turned into a", "tokens": [400, 294, 341, 1389, 11, 264, 8310, 295, 1649, 9239, 11, 597, 307, 257, 40846, 11, 393, 611, 312, 3574, 666, 257], "temperature": 0.0, "avg_logprob": -0.16063181176243058, "compression_ratio": 1.52020202020202, "no_speech_prob": 5.861743920831941e-05}, {"id": 45, "seek": 23972, "start": 239.72, "end": 245.96, "text": " decimal number because in a byte we can have 256 different combinations.", "tokens": [26601, 1230, 570, 294, 257, 40846, 321, 393, 362, 38882, 819, 21267, 13], "temperature": 0.0, "avg_logprob": -0.17535125848018762, "compression_ratio": 1.406060606060606, "no_speech_prob": 0.0001507656998001039}, {"id": 46, "seek": 23972, "start": 245.96, "end": 249.52, "text": " So it's a number from 0 to 255.", "tokens": [407, 309, 311, 257, 1230, 490, 1958, 281, 3552, 20, 13], "temperature": 0.0, "avg_logprob": -0.17535125848018762, "compression_ratio": 1.406060606060606, "no_speech_prob": 0.0001507656998001039}, {"id": 47, "seek": 23972, "start": 249.52, "end": 256.96, "text": " And in decimal notation, this sequence of bits is 75.", "tokens": [400, 294, 26601, 24657, 11, 341, 8310, 295, 9239, 307, 9562, 13], "temperature": 0.0, "avg_logprob": -0.17535125848018762, "compression_ratio": 1.406060606060606, "no_speech_prob": 0.0001507656998001039}, {"id": 48, "seek": 23972, "start": 256.96, "end": 264.96, "text": " There's also Hex notation, where we use the characters 0 to 9 and 8 to F.", "tokens": [821, 311, 611, 634, 87, 24657, 11, 689, 321, 764, 264, 4342, 1958, 281, 1722, 293, 1649, 281, 479, 13], "temperature": 0.0, "avg_logprob": -0.17535125848018762, "compression_ratio": 1.406060606060606, "no_speech_prob": 0.0001507656998001039}, {"id": 49, "seek": 26496, "start": 264.96, "end": 271.12, "text": " This means we can describe the constant of a byte with just two characters.", "tokens": [639, 1355, 321, 393, 6786, 264, 5754, 295, 257, 40846, 365, 445, 732, 4342, 13], "temperature": 0.0, "avg_logprob": -0.12855941370913856, "compression_ratio": 1.6504424778761062, "no_speech_prob": 3.532228583935648e-05}, {"id": 50, "seek": 26496, "start": 271.12, "end": 277.76, "text": " So this is very convenient when we are dealing with binary numbers.", "tokens": [407, 341, 307, 588, 10851, 562, 321, 366, 6260, 365, 17434, 3547, 13], "temperature": 0.0, "avg_logprob": -0.12855941370913856, "compression_ratio": 1.6504424778761062, "no_speech_prob": 3.532228583935648e-05}, {"id": 51, "seek": 26496, "start": 277.76, "end": 281.47999999999996, "text": " Just a common example of where we write the bytes as decimals.", "tokens": [1449, 257, 2689, 1365, 295, 689, 321, 2464, 264, 36088, 382, 979, 332, 1124, 13], "temperature": 0.0, "avg_logprob": -0.12855941370913856, "compression_ratio": 1.6504424778761062, "no_speech_prob": 3.532228583935648e-05}, {"id": 52, "seek": 26496, "start": 281.47999999999996, "end": 287.08, "text": " We do that with IPv4 addresses because an IPv4 address is just four bytes.", "tokens": [492, 360, 300, 365, 8671, 85, 19, 16862, 570, 364, 8671, 85, 19, 2985, 307, 445, 1451, 36088, 13], "temperature": 0.0, "avg_logprob": -0.12855941370913856, "compression_ratio": 1.6504424778761062, "no_speech_prob": 3.532228583935648e-05}, {"id": 53, "seek": 26496, "start": 287.08, "end": 294.0, "text": " But then for human consumption, we write it as a binary number, or sorry, a decimal number.", "tokens": [583, 550, 337, 1952, 12126, 11, 321, 2464, 309, 382, 257, 17434, 1230, 11, 420, 2597, 11, 257, 26601, 1230, 13], "temperature": 0.0, "avg_logprob": -0.12855941370913856, "compression_ratio": 1.6504424778761062, "no_speech_prob": 3.532228583935648e-05}, {"id": 54, "seek": 29400, "start": 294.0, "end": 305.36, "text": " And MAC addresses use Hex notation instead of the binary notation.", "tokens": [400, 27716, 16862, 764, 634, 87, 24657, 2602, 295, 264, 17434, 24657, 13], "temperature": 0.0, "avg_logprob": -0.11841545682964903, "compression_ratio": 1.5, "no_speech_prob": 4.000911576440558e-05}, {"id": 55, "seek": 29400, "start": 305.36, "end": 311.44, "text": " While all the operations in our computers are processing bits and bytes, we rarely think", "tokens": [3987, 439, 264, 7705, 294, 527, 10807, 366, 9007, 9239, 293, 36088, 11, 321, 13752, 519], "temperature": 0.0, "avg_logprob": -0.11841545682964903, "compression_ratio": 1.5, "no_speech_prob": 4.000911576440558e-05}, {"id": 56, "seek": 29400, "start": 311.44, "end": 314.12, "text": " about them when we are programming.", "tokens": [466, 552, 562, 321, 366, 9410, 13], "temperature": 0.0, "avg_logprob": -0.11841545682964903, "compression_ratio": 1.5, "no_speech_prob": 4.000911576440558e-05}, {"id": 57, "seek": 29400, "start": 314.12, "end": 321.28, "text": " We think in terms of integers, floats, strings, lists, maps, and all the structures.", "tokens": [492, 519, 294, 2115, 295, 41674, 11, 37878, 11, 13985, 11, 14511, 11, 11317, 11, 293, 439, 264, 9227, 13], "temperature": 0.0, "avg_logprob": -0.11841545682964903, "compression_ratio": 1.5, "no_speech_prob": 4.000911576440558e-05}, {"id": 58, "seek": 32128, "start": 321.28, "end": 326.71999999999997, "text": " But binary data is just a flat stream of bits.", "tokens": [583, 17434, 1412, 307, 445, 257, 4962, 4309, 295, 9239, 13], "temperature": 0.0, "avg_logprob": -0.13197632895575628, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.903857426252216e-05}, {"id": 59, "seek": 32128, "start": 326.71999999999997, "end": 333.08, "text": " There's nothing inherent in it to tell one field from the other, or any kind of structure.", "tokens": [821, 311, 1825, 26387, 294, 309, 281, 980, 472, 2519, 490, 264, 661, 11, 420, 604, 733, 295, 3877, 13], "temperature": 0.0, "avg_logprob": -0.13197632895575628, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.903857426252216e-05}, {"id": 60, "seek": 32128, "start": 333.08, "end": 337.11999999999995, "text": " It's all down to how we interpret those bits.", "tokens": [467, 311, 439, 760, 281, 577, 321, 7302, 729, 9239, 13], "temperature": 0.0, "avg_logprob": -0.13197632895575628, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.903857426252216e-05}, {"id": 61, "seek": 32128, "start": 337.11999999999995, "end": 341.47999999999996, "text": " This means that when we need to speak binary to something from our programs, we need to", "tokens": [639, 1355, 300, 562, 321, 643, 281, 1710, 17434, 281, 746, 490, 527, 4268, 11, 321, 643, 281], "temperature": 0.0, "avg_logprob": -0.13197632895575628, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.903857426252216e-05}, {"id": 62, "seek": 32128, "start": 341.47999999999996, "end": 347.59999999999997, "text": " write a translation layer that can take whatever list of maps we have in our program and turn", "tokens": [2464, 257, 12853, 4583, 300, 393, 747, 2035, 1329, 295, 11317, 321, 362, 294, 527, 1461, 293, 1261], "temperature": 0.0, "avg_logprob": -0.13197632895575628, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.903857426252216e-05}, {"id": 63, "seek": 34760, "start": 347.6, "end": 352.84000000000003, "text": " it into a binary sequence.", "tokens": [309, 666, 257, 17434, 8310, 13], "temperature": 0.0, "avg_logprob": -0.1348329650031196, "compression_ratio": 1.5885714285714285, "no_speech_prob": 3.935670974897221e-05}, {"id": 64, "seek": 34760, "start": 352.84000000000003, "end": 358.16, "text": " I prefer calling this translation layer a codec because it's short to write.", "tokens": [286, 4382, 5141, 341, 12853, 4583, 257, 3089, 66, 570, 309, 311, 2099, 281, 2464, 13], "temperature": 0.0, "avg_logprob": -0.1348329650031196, "compression_ratio": 1.5885714285714285, "no_speech_prob": 3.935670974897221e-05}, {"id": 65, "seek": 34760, "start": 358.16, "end": 364.36, "text": " And you can say that a codec encodes our data structures in bytes for sending.", "tokens": [400, 291, 393, 584, 300, 257, 3089, 66, 2058, 4789, 527, 1412, 9227, 294, 36088, 337, 7750, 13], "temperature": 0.0, "avg_logprob": -0.1348329650031196, "compression_ratio": 1.5885714285714285, "no_speech_prob": 3.935670974897221e-05}, {"id": 66, "seek": 34760, "start": 364.36, "end": 374.44, "text": " And then when we receive data, the codec decodes that data into our high-level data structures.", "tokens": [400, 550, 562, 321, 4774, 1412, 11, 264, 3089, 66, 979, 4789, 300, 1412, 666, 527, 1090, 12, 12418, 1412, 9227, 13], "temperature": 0.0, "avg_logprob": -0.1348329650031196, "compression_ratio": 1.5885714285714285, "no_speech_prob": 3.935670974897221e-05}, {"id": 67, "seek": 37444, "start": 374.44, "end": 378.44, "text": " And sometimes we're lucky we can find a library that will do that for us, but sometimes we", "tokens": [400, 2171, 321, 434, 6356, 321, 393, 915, 257, 6405, 300, 486, 360, 300, 337, 505, 11, 457, 2171, 321], "temperature": 0.0, "avg_logprob": -0.15016605637290262, "compression_ratio": 1.51, "no_speech_prob": 2.1435947928694077e-05}, {"id": 68, "seek": 37444, "start": 378.44, "end": 380.36, "text": " need to do it ourselves.", "tokens": [643, 281, 360, 309, 4175, 13], "temperature": 0.0, "avg_logprob": -0.15016605637290262, "compression_ratio": 1.51, "no_speech_prob": 2.1435947928694077e-05}, {"id": 69, "seek": 37444, "start": 380.36, "end": 384.16, "text": " And that's where bit syntax comes in handy.", "tokens": [400, 300, 311, 689, 857, 28431, 1487, 294, 13239, 13], "temperature": 0.0, "avg_logprob": -0.15016605637290262, "compression_ratio": 1.51, "no_speech_prob": 2.1435947928694077e-05}, {"id": 70, "seek": 37444, "start": 384.16, "end": 389.08, "text": " So let's take a look at that.", "tokens": [407, 718, 311, 747, 257, 574, 412, 300, 13], "temperature": 0.0, "avg_logprob": -0.15016605637290262, "compression_ratio": 1.51, "no_speech_prob": 2.1435947928694077e-05}, {"id": 71, "seek": 37444, "start": 389.08, "end": 394.4, "text": " Let's say I need to send a sequence of free bytes to some other system.", "tokens": [961, 311, 584, 286, 643, 281, 2845, 257, 8310, 295, 1737, 36088, 281, 512, 661, 1185, 13], "temperature": 0.0, "avg_logprob": -0.15016605637290262, "compression_ratio": 1.51, "no_speech_prob": 2.1435947928694077e-05}, {"id": 72, "seek": 37444, "start": 394.4, "end": 398.92, "text": " They need to have values 10, 20, and 30.", "tokens": [814, 643, 281, 362, 4190, 1266, 11, 945, 11, 293, 2217, 13], "temperature": 0.0, "avg_logprob": -0.15016605637290262, "compression_ratio": 1.51, "no_speech_prob": 2.1435947928694077e-05}, {"id": 73, "seek": 39892, "start": 398.92, "end": 408.72, "text": " To do that, I use distance x, so I use double ankle brackets to start the binary sequence.", "tokens": [1407, 360, 300, 11, 286, 764, 4560, 2031, 11, 370, 286, 764, 3834, 21999, 26179, 281, 722, 264, 17434, 8310, 13], "temperature": 0.0, "avg_logprob": -0.19566817223271238, "compression_ratio": 1.5944444444444446, "no_speech_prob": 3.820273923338391e-05}, {"id": 74, "seek": 39892, "start": 408.72, "end": 414.44, "text": " And then I write the bytes that I need in sequence and separate it by a comma.", "tokens": [400, 550, 286, 2464, 264, 36088, 300, 286, 643, 294, 8310, 293, 4994, 309, 538, 257, 22117, 13], "temperature": 0.0, "avg_logprob": -0.19566817223271238, "compression_ratio": 1.5944444444444446, "no_speech_prob": 3.820273923338391e-05}, {"id": 75, "seek": 39892, "start": 414.44, "end": 417.72, "text": " So that's pretty simple.", "tokens": [407, 300, 311, 1238, 2199, 13], "temperature": 0.0, "avg_logprob": -0.19566817223271238, "compression_ratio": 1.5944444444444446, "no_speech_prob": 3.820273923338391e-05}, {"id": 76, "seek": 39892, "start": 417.72, "end": 418.96000000000004, "text": " Yes.", "tokens": [1079, 13], "temperature": 0.0, "avg_logprob": -0.19566817223271238, "compression_ratio": 1.5944444444444446, "no_speech_prob": 3.820273923338391e-05}, {"id": 77, "seek": 39892, "start": 418.96000000000004, "end": 425.48, "text": " And when I need to receive that data, like if I'm receiving the same sequence of bytes,", "tokens": [400, 562, 286, 643, 281, 4774, 300, 1412, 11, 411, 498, 286, 478, 10040, 264, 912, 8310, 295, 36088, 11], "temperature": 0.0, "avg_logprob": -0.19566817223271238, "compression_ratio": 1.5944444444444446, "no_speech_prob": 3.820273923338391e-05}, {"id": 78, "seek": 42548, "start": 425.48, "end": 431.48, "text": " I need to decode that into free variables, a, b, and c.", "tokens": [286, 643, 281, 979, 1429, 300, 666, 1737, 9102, 11, 257, 11, 272, 11, 293, 269, 13], "temperature": 0.0, "avg_logprob": -0.21181241671244302, "compression_ratio": 1.4518072289156627, "no_speech_prob": 7.592820475110784e-05}, {"id": 79, "seek": 42548, "start": 431.48, "end": 435.52000000000004, "text": " Then I use this syntax, again, double brackets.", "tokens": [1396, 286, 764, 341, 28431, 11, 797, 11, 3834, 26179, 13], "temperature": 0.0, "avg_logprob": -0.21181241671244302, "compression_ratio": 1.4518072289156627, "no_speech_prob": 7.592820475110784e-05}, {"id": 80, "seek": 42548, "start": 435.52000000000004, "end": 441.76, "text": " Then I put the variables instead of the numbers that I want to extract.", "tokens": [1396, 286, 829, 264, 9102, 2602, 295, 264, 3547, 300, 286, 528, 281, 8947, 13], "temperature": 0.0, "avg_logprob": -0.21181241671244302, "compression_ratio": 1.4518072289156627, "no_speech_prob": 7.592820475110784e-05}, {"id": 81, "seek": 42548, "start": 441.76, "end": 444.36, "text": " So it's pretty simple.", "tokens": [407, 309, 311, 1238, 2199, 13], "temperature": 0.0, "avg_logprob": -0.21181241671244302, "compression_ratio": 1.4518072289156627, "no_speech_prob": 7.592820475110784e-05}, {"id": 82, "seek": 42548, "start": 444.36, "end": 450.40000000000003, "text": " But of course, we are not really done yet.", "tokens": [583, 295, 1164, 11, 321, 366, 406, 534, 1096, 1939, 13], "temperature": 0.0, "avg_logprob": -0.21181241671244302, "compression_ratio": 1.4518072289156627, "no_speech_prob": 7.592820475110784e-05}, {"id": 83, "seek": 45040, "start": 450.4, "end": 457.08, "text": " It's very few domains where we only work with integers in the sequence of 0 to 255.", "tokens": [467, 311, 588, 1326, 25514, 689, 321, 787, 589, 365, 41674, 294, 264, 8310, 295, 1958, 281, 3552, 20, 13], "temperature": 0.0, "avg_logprob": -0.1610809234251459, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00013776315608993173}, {"id": 84, "seek": 45040, "start": 457.08, "end": 458.08, "text": " We need larger numbers.", "tokens": [492, 643, 4833, 3547, 13], "temperature": 0.0, "avg_logprob": -0.1610809234251459, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00013776315608993173}, {"id": 85, "seek": 45040, "start": 458.08, "end": 459.08, "text": " We need negative numbers.", "tokens": [492, 643, 3671, 3547, 13], "temperature": 0.0, "avg_logprob": -0.1610809234251459, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00013776315608993173}, {"id": 86, "seek": 45040, "start": 459.08, "end": 462.64, "text": " We need floats and strings.", "tokens": [492, 643, 37878, 293, 13985, 13], "temperature": 0.0, "avg_logprob": -0.1610809234251459, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00013776315608993173}, {"id": 87, "seek": 45040, "start": 462.64, "end": 468.79999999999995, "text": " But many languages will just give you a byte stream, and then you need to sort of do a", "tokens": [583, 867, 8650, 486, 445, 976, 291, 257, 40846, 4309, 11, 293, 550, 291, 643, 281, 1333, 295, 360, 257], "temperature": 0.0, "avg_logprob": -0.1610809234251459, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00013776315608993173}, {"id": 88, "seek": 45040, "start": 468.79999999999995, "end": 476.47999999999996, "text": " lot of strange computations to turn that into lists and strings.", "tokens": [688, 295, 5861, 2807, 763, 281, 1261, 300, 666, 14511, 293, 13985, 13], "temperature": 0.0, "avg_logprob": -0.1610809234251459, "compression_ratio": 1.5888324873096447, "no_speech_prob": 0.00013776315608993173}, {"id": 89, "seek": 47648, "start": 476.48, "end": 485.0, "text": " But in Elixir and on the Beam, we have the bits and sacks, and we can do more.", "tokens": [583, 294, 2699, 970, 347, 293, 322, 264, 40916, 11, 321, 362, 264, 9239, 293, 262, 7424, 11, 293, 321, 393, 360, 544, 13], "temperature": 0.0, "avg_logprob": -0.28799613746436864, "compression_ratio": 1.6346153846153846, "no_speech_prob": 0.00016265999875031412}, {"id": 90, "seek": 47648, "start": 485.0, "end": 492.16, "text": " Specifically with bits and sacks, we have the option or the ability to specify modifiers.", "tokens": [26058, 365, 9239, 293, 262, 7424, 11, 321, 362, 264, 3614, 420, 264, 3485, 281, 16500, 1072, 23463, 13], "temperature": 0.0, "avg_logprob": -0.28799613746436864, "compression_ratio": 1.6346153846153846, "no_speech_prob": 0.00016265999875031412}, {"id": 91, "seek": 47648, "start": 492.16, "end": 505.32, "text": " And the modifiers can specify the type, the sign, the size, unit, and indianess of the", "tokens": [400, 264, 1072, 23463, 393, 16500, 264, 2010, 11, 264, 1465, 11, 264, 2744, 11, 4985, 11, 293, 1016, 952, 442, 295, 264], "temperature": 0.0, "avg_logprob": -0.28799613746436864, "compression_ratio": 1.6346153846153846, "no_speech_prob": 0.00016265999875031412}, {"id": 92, "seek": 50532, "start": 505.32, "end": 510.64, "text": " sequence of bits we want to extract from the binary.", "tokens": [8310, 295, 9239, 321, 528, 281, 8947, 490, 264, 17434, 13], "temperature": 0.0, "avg_logprob": -0.15247588687472874, "compression_ratio": 1.509009009009009, "no_speech_prob": 0.0001351956743746996}, {"id": 93, "seek": 50532, "start": 510.64, "end": 514.56, "text": " So here you see that the type is integer.", "tokens": [407, 510, 291, 536, 300, 264, 2010, 307, 24922, 13], "temperature": 0.0, "avg_logprob": -0.15247588687472874, "compression_ratio": 1.509009009009009, "no_speech_prob": 0.0001351956743746996}, {"id": 94, "seek": 50532, "start": 514.56, "end": 517.72, "text": " It is unsigned, so it's positive numbers only.", "tokens": [467, 307, 2693, 16690, 11, 370, 309, 311, 3353, 3547, 787, 13], "temperature": 0.0, "avg_logprob": -0.15247588687472874, "compression_ratio": 1.509009009009009, "no_speech_prob": 0.0001351956743746996}, {"id": 95, "seek": 50532, "start": 517.72, "end": 523.76, "text": " It has a size of eight units, and one unit is said to be one bit long.", "tokens": [467, 575, 257, 2744, 295, 3180, 6815, 11, 293, 472, 4985, 307, 848, 281, 312, 472, 857, 938, 13], "temperature": 0.0, "avg_logprob": -0.15247588687472874, "compression_ratio": 1.509009009009009, "no_speech_prob": 0.0001351956743746996}, {"id": 96, "seek": 50532, "start": 523.76, "end": 527.28, "text": " And it's big indian, which I will talk about later.", "tokens": [400, 309, 311, 955, 1016, 952, 11, 597, 286, 486, 751, 466, 1780, 13], "temperature": 0.0, "avg_logprob": -0.15247588687472874, "compression_ratio": 1.509009009009009, "no_speech_prob": 0.0001351956743746996}, {"id": 97, "seek": 50532, "start": 527.28, "end": 533.24, "text": " So these are all equivalent 10, 20, 30, they are encoded the same way.", "tokens": [407, 613, 366, 439, 10344, 1266, 11, 945, 11, 2217, 11, 436, 366, 2058, 12340, 264, 912, 636, 13], "temperature": 0.0, "avg_logprob": -0.15247588687472874, "compression_ratio": 1.509009009009009, "no_speech_prob": 0.0001351956743746996}, {"id": 98, "seek": 53324, "start": 533.24, "end": 537.84, "text": " It's just different syntaxes.", "tokens": [467, 311, 445, 819, 28431, 279, 13], "temperature": 0.0, "avg_logprob": -0.16514658283542943, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.00010504088277230039}, {"id": 99, "seek": 53324, "start": 537.84, "end": 547.76, "text": " So you can see if you don't specify any modifiers, these are the defaults that I used instead.", "tokens": [407, 291, 393, 536, 498, 291, 500, 380, 16500, 604, 1072, 23463, 11, 613, 366, 264, 7576, 82, 300, 286, 1143, 2602, 13], "temperature": 0.0, "avg_logprob": -0.16514658283542943, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.00010504088277230039}, {"id": 100, "seek": 53324, "start": 547.76, "end": 553.44, "text": " And the second line I used, I omitted size, I just wrote eight.", "tokens": [400, 264, 1150, 1622, 286, 1143, 11, 286, 3406, 3944, 2744, 11, 286, 445, 4114, 3180, 13], "temperature": 0.0, "avg_logprob": -0.16514658283542943, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.00010504088277230039}, {"id": 101, "seek": 53324, "start": 553.44, "end": 557.52, "text": " That's something you can do when you know it has a constant at compile time.", "tokens": [663, 311, 746, 291, 393, 360, 562, 291, 458, 309, 575, 257, 5754, 412, 31413, 565, 13], "temperature": 0.0, "avg_logprob": -0.16514658283542943, "compression_ratio": 1.4722222222222223, "no_speech_prob": 0.00010504088277230039}, {"id": 102, "seek": 55752, "start": 557.52, "end": 564.0799999999999, "text": " If the size is variable, you will need to use the full size modifier.", "tokens": [759, 264, 2744, 307, 7006, 11, 291, 486, 643, 281, 764, 264, 1577, 2744, 38011, 13], "temperature": 0.0, "avg_logprob": -0.13522752802422705, "compression_ratio": 1.6285714285714286, "no_speech_prob": 4.81756214867346e-05}, {"id": 103, "seek": 55752, "start": 564.0799999999999, "end": 570.72, "text": " And the modifiers can be combined in any order, so you can do whatever you like.", "tokens": [400, 264, 1072, 23463, 393, 312, 9354, 294, 604, 1668, 11, 370, 291, 393, 360, 2035, 291, 411, 13], "temperature": 0.0, "avg_logprob": -0.13522752802422705, "compression_ratio": 1.6285714285714286, "no_speech_prob": 4.81756214867346e-05}, {"id": 104, "seek": 55752, "start": 570.72, "end": 574.12, "text": " And when we decode it, we use exactly the same syntax.", "tokens": [400, 562, 321, 979, 1429, 309, 11, 321, 764, 2293, 264, 912, 28431, 13], "temperature": 0.0, "avg_logprob": -0.13522752802422705, "compression_ratio": 1.6285714285714286, "no_speech_prob": 4.81756214867346e-05}, {"id": 105, "seek": 55752, "start": 574.12, "end": 579.0, "text": " We can say the same things, like grab the first byte, tell it to compile it that it's", "tokens": [492, 393, 584, 264, 912, 721, 11, 411, 4444, 264, 700, 40846, 11, 980, 309, 281, 31413, 309, 300, 309, 311], "temperature": 0.0, "avg_logprob": -0.13522752802422705, "compression_ratio": 1.6285714285714286, "no_speech_prob": 4.81756214867346e-05}, {"id": 106, "seek": 55752, "start": 579.0, "end": 586.1999999999999, "text": " an integer, and then it will extract it like this.", "tokens": [364, 24922, 11, 293, 550, 309, 486, 8947, 309, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.13522752802422705, "compression_ratio": 1.6285714285714286, "no_speech_prob": 4.81756214867346e-05}, {"id": 107, "seek": 58620, "start": 586.2, "end": 592.0, "text": " And instead of just going through all the different modifiers and the combinations, I move on", "tokens": [400, 2602, 295, 445, 516, 807, 439, 264, 819, 1072, 23463, 293, 264, 21267, 11, 286, 1286, 322], "temperature": 0.0, "avg_logprob": -0.22698608311739835, "compression_ratio": 1.4887892376681615, "no_speech_prob": 0.0001850429835030809}, {"id": 108, "seek": 58620, "start": 592.0, "end": 595.0400000000001, "text": " to showcasing some examples.", "tokens": [281, 29794, 3349, 512, 5110, 13], "temperature": 0.0, "avg_logprob": -0.22698608311739835, "compression_ratio": 1.4887892376681615, "no_speech_prob": 0.0001850429835030809}, {"id": 109, "seek": 58620, "start": 595.0400000000001, "end": 600.6, "text": " But before we do that, I want to mention where the bits and text came from.", "tokens": [583, 949, 321, 360, 300, 11, 286, 528, 281, 2152, 689, 264, 9239, 293, 2487, 1361, 490, 13], "temperature": 0.0, "avg_logprob": -0.22698608311739835, "compression_ratio": 1.4887892376681615, "no_speech_prob": 0.0001850429835030809}, {"id": 110, "seek": 58620, "start": 600.6, "end": 604.88, "text": " Bits and text comes from a place of pain.", "tokens": [363, 1208, 293, 2487, 1487, 490, 257, 1081, 295, 1822, 13], "temperature": 0.0, "avg_logprob": -0.22698608311739835, "compression_ratio": 1.4887892376681615, "no_speech_prob": 0.0001850429835030809}, {"id": 111, "seek": 58620, "start": 604.88, "end": 611.8000000000001, "text": " These two guys, Clairs, Wichstr\u00f6m, and Tony Rockwell, were working at the computer science", "tokens": [1981, 732, 1074, 11, 12947, 12983, 11, 343, 480, 9733, 32374, 11, 293, 10902, 6922, 6326, 11, 645, 1364, 412, 264, 3820, 3497], "temperature": 0.0, "avg_logprob": -0.22698608311739835, "compression_ratio": 1.4887892376681615, "no_speech_prob": 0.0001850429835030809}, {"id": 112, "seek": 61180, "start": 611.8, "end": 623.0, "text": " laboratory at AXN on implementing networking protocols for Erlang, and it was painful.", "tokens": [16523, 412, 316, 55, 45, 322, 18114, 17985, 20618, 337, 3300, 25241, 11, 293, 309, 390, 11697, 13], "temperature": 0.0, "avg_logprob": -0.15817633310953777, "compression_ratio": 1.5, "no_speech_prob": 0.000169913619174622}, {"id": 113, "seek": 61180, "start": 623.0, "end": 628.76, "text": " And so they sat down, since they were so close to the makers of the language, they could", "tokens": [400, 370, 436, 3227, 760, 11, 1670, 436, 645, 370, 1998, 281, 264, 19323, 295, 264, 2856, 11, 436, 727], "temperature": 0.0, "avg_logprob": -0.15817633310953777, "compression_ratio": 1.5, "no_speech_prob": 0.000169913619174622}, {"id": 114, "seek": 61180, "start": 628.76, "end": 633.4799999999999, "text": " invent a new syntax for use in Erlang.", "tokens": [7962, 257, 777, 28431, 337, 764, 294, 3300, 25241, 13], "temperature": 0.0, "avg_logprob": -0.15817633310953777, "compression_ratio": 1.5, "no_speech_prob": 0.000169913619174622}, {"id": 115, "seek": 61180, "start": 633.4799999999999, "end": 638.76, "text": " And this paper, which is published in 1998, describes the first version of the syntax", "tokens": [400, 341, 3035, 11, 597, 307, 6572, 294, 21404, 11, 15626, 264, 700, 3037, 295, 264, 28431], "temperature": 0.0, "avg_logprob": -0.15817633310953777, "compression_ratio": 1.5, "no_speech_prob": 0.000169913619174622}, {"id": 116, "seek": 63876, "start": 638.76, "end": 644.0, "text": " as it was implemented in an experimental version of Erlang.", "tokens": [382, 309, 390, 12270, 294, 364, 17069, 3037, 295, 3300, 25241, 13], "temperature": 0.0, "avg_logprob": -0.1498037864421976, "compression_ratio": 1.5021645021645023, "no_speech_prob": 0.00021089767687954009}, {"id": 117, "seek": 63876, "start": 644.0, "end": 649.88, "text": " I think a few months later, it was released with slightly different syntax, but with all", "tokens": [286, 519, 257, 1326, 2493, 1780, 11, 309, 390, 4736, 365, 4748, 819, 28431, 11, 457, 365, 439], "temperature": 0.0, "avg_logprob": -0.1498037864421976, "compression_ratio": 1.5021645021645023, "no_speech_prob": 0.00021089767687954009}, {"id": 118, "seek": 63876, "start": 649.88, "end": 655.04, "text": " the same concepts.", "tokens": [264, 912, 10392, 13], "temperature": 0.0, "avg_logprob": -0.1498037864421976, "compression_ratio": 1.5021645021645023, "no_speech_prob": 0.00021089767687954009}, {"id": 119, "seek": 63876, "start": 655.04, "end": 661.08, "text": " And that paper also explains what Indianness is, and it's actually just a fun word for", "tokens": [400, 300, 3035, 611, 13948, 437, 6427, 1287, 307, 11, 293, 309, 311, 767, 445, 257, 1019, 1349, 337], "temperature": 0.0, "avg_logprob": -0.1498037864421976, "compression_ratio": 1.5021645021645023, "no_speech_prob": 0.00021089767687954009}, {"id": 120, "seek": 63876, "start": 661.08, "end": 668.3199999999999, "text": " byte order, because if you have a 16-bit integer that you need to send to some other system,", "tokens": [40846, 1668, 11, 570, 498, 291, 362, 257, 3165, 12, 5260, 24922, 300, 291, 643, 281, 2845, 281, 512, 661, 1185, 11], "temperature": 0.0, "avg_logprob": -0.1498037864421976, "compression_ratio": 1.5021645021645023, "no_speech_prob": 0.00021089767687954009}, {"id": 121, "seek": 66832, "start": 668.32, "end": 670.24, "text": " that's two bytes, right?", "tokens": [300, 311, 732, 36088, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.14477296208226403, "compression_ratio": 1.8509316770186335, "no_speech_prob": 0.00020844399114139378}, {"id": 122, "seek": 66832, "start": 670.24, "end": 675.2, "text": " And you have to figure out, the one byte is A2, and the other byte is C1.", "tokens": [400, 291, 362, 281, 2573, 484, 11, 264, 472, 40846, 307, 316, 17, 11, 293, 264, 661, 40846, 307, 383, 16, 13], "temperature": 0.0, "avg_logprob": -0.14477296208226403, "compression_ratio": 1.8509316770186335, "no_speech_prob": 0.00020844399114139378}, {"id": 123, "seek": 66832, "start": 675.2, "end": 680.9200000000001, "text": " And you have to figure out which byte do you send first.", "tokens": [400, 291, 362, 281, 2573, 484, 597, 40846, 360, 291, 2845, 700, 13], "temperature": 0.0, "avg_logprob": -0.14477296208226403, "compression_ratio": 1.8509316770186335, "no_speech_prob": 0.00020844399114139378}, {"id": 124, "seek": 66832, "start": 680.9200000000001, "end": 687.9200000000001, "text": " Some systems will send the most significant byte first, so that's A2.", "tokens": [2188, 3652, 486, 2845, 264, 881, 4776, 40846, 700, 11, 370, 300, 311, 316, 17, 13], "temperature": 0.0, "avg_logprob": -0.14477296208226403, "compression_ratio": 1.8509316770186335, "no_speech_prob": 0.00020844399114139378}, {"id": 125, "seek": 66832, "start": 687.9200000000001, "end": 694.5600000000001, "text": " But other systems will send the least significant byte first, that's C1.", "tokens": [583, 661, 3652, 486, 2845, 264, 1935, 4776, 40846, 700, 11, 300, 311, 383, 16, 13], "temperature": 0.0, "avg_logprob": -0.14477296208226403, "compression_ratio": 1.8509316770186335, "no_speech_prob": 0.00020844399114139378}, {"id": 126, "seek": 69456, "start": 694.56, "end": 701.0799999999999, "text": " And so this obviously has consequences, because you need to know the byte order that the system", "tokens": [400, 370, 341, 2745, 575, 10098, 11, 570, 291, 643, 281, 458, 264, 40846, 1668, 300, 264, 1185], "temperature": 0.0, "avg_logprob": -0.15248600941783977, "compression_ratio": 1.7723577235772359, "no_speech_prob": 6.036729973857291e-05}, {"id": 127, "seek": 69456, "start": 701.0799999999999, "end": 706.52, "text": " you're talking to, what it expects, otherwise it just gets confused.", "tokens": [291, 434, 1417, 281, 11, 437, 309, 33280, 11, 5911, 309, 445, 2170, 9019, 13], "temperature": 0.0, "avg_logprob": -0.15248600941783977, "compression_ratio": 1.7723577235772359, "no_speech_prob": 6.036729973857291e-05}, {"id": 128, "seek": 69456, "start": 706.52, "end": 713.68, "text": " And yes, the byte ordering is said to be big Indian when you start with the most significant", "tokens": [400, 2086, 11, 264, 40846, 21739, 307, 848, 281, 312, 955, 6427, 562, 291, 722, 365, 264, 881, 4776], "temperature": 0.0, "avg_logprob": -0.15248600941783977, "compression_ratio": 1.7723577235772359, "no_speech_prob": 6.036729973857291e-05}, {"id": 129, "seek": 69456, "start": 713.68, "end": 718.4799999999999, "text": " byte, and it's said to be little Indian if you start with the least significant byte.", "tokens": [40846, 11, 293, 309, 311, 848, 281, 312, 707, 6427, 498, 291, 722, 365, 264, 1935, 4776, 40846, 13], "temperature": 0.0, "avg_logprob": -0.15248600941783977, "compression_ratio": 1.7723577235772359, "no_speech_prob": 6.036729973857291e-05}, {"id": 130, "seek": 69456, "start": 718.4799999999999, "end": 724.0, "text": " And this is kind of a thing, I've been working with this for years, but I didn't really know", "tokens": [400, 341, 307, 733, 295, 257, 551, 11, 286, 600, 668, 1364, 365, 341, 337, 924, 11, 457, 286, 994, 380, 534, 458], "temperature": 0.0, "avg_logprob": -0.15248600941783977, "compression_ratio": 1.7723577235772359, "no_speech_prob": 6.036729973857291e-05}, {"id": 131, "seek": 72400, "start": 724.0, "end": 729.0, "text": " what Indian means, because it's a sort of weird name, right?", "tokens": [437, 6427, 1355, 11, 570, 309, 311, 257, 1333, 295, 3657, 1315, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.1665451968157733, "compression_ratio": 1.4976525821596245, "no_speech_prob": 0.0003038659051526338}, {"id": 132, "seek": 72400, "start": 729.0, "end": 734.08, "text": " But the paper by Claes and Tony hinted me in the direction of finding that by pointing", "tokens": [583, 264, 3035, 538, 12947, 279, 293, 10902, 12075, 292, 385, 294, 264, 3513, 295, 5006, 300, 538, 12166], "temperature": 0.0, "avg_logprob": -0.1665451968157733, "compression_ratio": 1.4976525821596245, "no_speech_prob": 0.0003038659051526338}, {"id": 133, "seek": 72400, "start": 734.08, "end": 741.56, "text": " me to this Internet experiment note from 1980, which is, I think, the first sort of place", "tokens": [385, 281, 341, 7703, 5120, 3637, 490, 13626, 11, 597, 307, 11, 286, 519, 11, 264, 700, 1333, 295, 1081], "temperature": 0.0, "avg_logprob": -0.1665451968157733, "compression_ratio": 1.4976525821596245, "no_speech_prob": 0.0003038659051526338}, {"id": 134, "seek": 72400, "start": 741.56, "end": 749.12, "text": " where Indian and byte order was used together on holy wars of the plea for peace.", "tokens": [689, 6427, 293, 40846, 1668, 390, 1143, 1214, 322, 10622, 13718, 295, 264, 42152, 337, 4336, 13], "temperature": 0.0, "avg_logprob": -0.1665451968157733, "compression_ratio": 1.4976525821596245, "no_speech_prob": 0.0003038659051526338}, {"id": 135, "seek": 74912, "start": 749.12, "end": 759.28, "text": " And that sort of shows that this is an important topic, sort of like Vim vs. T-Max, I guess.", "tokens": [400, 300, 1333, 295, 3110, 300, 341, 307, 364, 1021, 4829, 11, 1333, 295, 411, 691, 332, 12041, 13, 314, 12, 36025, 11, 286, 2041, 13], "temperature": 0.0, "avg_logprob": -0.24362685463645242, "compression_ratio": 1.425531914893617, "no_speech_prob": 0.0003158123872708529}, {"id": 136, "seek": 74912, "start": 759.28, "end": 764.84, "text": " And it's actually just, Indian is just a pop culture reference to a book called Gulliver's", "tokens": [400, 309, 311, 767, 445, 11, 6427, 307, 445, 257, 1665, 3713, 6408, 281, 257, 1446, 1219, 460, 858, 1837, 311], "temperature": 0.0, "avg_logprob": -0.24362685463645242, "compression_ratio": 1.425531914893617, "no_speech_prob": 0.0003158123872708529}, {"id": 137, "seek": 74912, "start": 764.84, "end": 771.16, "text": " Travels, where a seagull travels out into the world and meets the people of Lilliput", "tokens": [20610, 82, 11, 689, 257, 369, 559, 858, 19863, 484, 666, 264, 1002, 293, 13961, 264, 561, 295, 441, 373, 647, 325], "temperature": 0.0, "avg_logprob": -0.24362685463645242, "compression_ratio": 1.425531914893617, "no_speech_prob": 0.0003158123872708529}, {"id": 138, "seek": 77116, "start": 771.16, "end": 779.36, "text": " and Plefusco, I think, and they are in conflict, because the emperor of Lilliput has commanded", "tokens": [293, 25658, 69, 301, 1291, 11, 286, 519, 11, 293, 436, 366, 294, 6596, 11, 570, 264, 20255, 295, 441, 373, 647, 325, 575, 34359], "temperature": 0.0, "avg_logprob": -0.21030173699061075, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.00018695487233344465}, {"id": 139, "seek": 77116, "start": 779.36, "end": 785.88, "text": " that X must be broken at the little end when you eat them for breakfast or whatever.", "tokens": [300, 1783, 1633, 312, 5463, 412, 264, 707, 917, 562, 291, 1862, 552, 337, 8201, 420, 2035, 13], "temperature": 0.0, "avg_logprob": -0.21030173699061075, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.00018695487233344465}, {"id": 140, "seek": 77116, "start": 785.88, "end": 790.56, "text": " So that's obviously absurd, and so they wage a war.", "tokens": [407, 300, 311, 2745, 19774, 11, 293, 370, 436, 15444, 257, 1516, 13], "temperature": 0.0, "avg_logprob": -0.21030173699061075, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.00018695487233344465}, {"id": 141, "seek": 77116, "start": 790.56, "end": 794.92, "text": " So big Indian means we send the big end of the number first, and the little end means", "tokens": [407, 955, 6427, 1355, 321, 2845, 264, 955, 917, 295, 264, 1230, 700, 11, 293, 264, 707, 917, 1355], "temperature": 0.0, "avg_logprob": -0.21030173699061075, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.00018695487233344465}, {"id": 142, "seek": 77116, "start": 794.92, "end": 800.0799999999999, "text": " we send the little end of the number.", "tokens": [321, 2845, 264, 707, 917, 295, 264, 1230, 13], "temperature": 0.0, "avg_logprob": -0.21030173699061075, "compression_ratio": 1.6904761904761905, "no_speech_prob": 0.00018695487233344465}, {"id": 143, "seek": 80008, "start": 800.08, "end": 804.32, "text": " So examples of bits and texts.", "tokens": [407, 5110, 295, 9239, 293, 15765, 13], "temperature": 0.0, "avg_logprob": -0.15436215347118593, "compression_ratio": 1.6274509803921569, "no_speech_prob": 0.00010996279161190614}, {"id": 144, "seek": 80008, "start": 804.32, "end": 809.5200000000001, "text": " For the purpose of this talk, I have invented the T-Box, which is a very simple device.", "tokens": [1171, 264, 4334, 295, 341, 751, 11, 286, 362, 14479, 264, 314, 12, 34980, 11, 597, 307, 257, 588, 2199, 4302, 13], "temperature": 0.0, "avg_logprob": -0.15436215347118593, "compression_ratio": 1.6274509803921569, "no_speech_prob": 0.00010996279161190614}, {"id": 145, "seek": 80008, "start": 809.5200000000001, "end": 814.6, "text": " It has a name, and it can measure the temperature, and it can tell you if there's an error in", "tokens": [467, 575, 257, 1315, 11, 293, 309, 393, 3481, 264, 4292, 11, 293, 309, 393, 980, 291, 498, 456, 311, 364, 6713, 294], "temperature": 0.0, "avg_logprob": -0.15436215347118593, "compression_ratio": 1.6274509803921569, "no_speech_prob": 0.00010996279161190614}, {"id": 146, "seek": 80008, "start": 814.6, "end": 817.5600000000001, "text": " the time stamp or the measurement.", "tokens": [264, 565, 9921, 420, 264, 13160, 13], "temperature": 0.0, "avg_logprob": -0.15436215347118593, "compression_ratio": 1.6274509803921569, "no_speech_prob": 0.00010996279161190614}, {"id": 147, "seek": 80008, "start": 817.5600000000001, "end": 824.1600000000001, "text": " It has a binary dialect or protocol, which I also invented, and this sort of mirrors", "tokens": [467, 575, 257, 17434, 24652, 420, 10336, 11, 597, 286, 611, 14479, 11, 293, 341, 1333, 295, 24238], "temperature": 0.0, "avg_logprob": -0.15436215347118593, "compression_ratio": 1.6274509803921569, "no_speech_prob": 0.00010996279161190614}, {"id": 148, "seek": 82416, "start": 824.16, "end": 831.56, "text": " what you will find in a real protocol description for some kind of device.", "tokens": [437, 291, 486, 915, 294, 257, 957, 10336, 3855, 337, 512, 733, 295, 4302, 13], "temperature": 0.0, "avg_logprob": -0.10113737442914178, "compression_ratio": 1.5505050505050506, "no_speech_prob": 6.682111416012049e-05}, {"id": 149, "seek": 82416, "start": 831.56, "end": 837.68, "text": " A client can connect to a T-Box and can send requests to the T-Box, and the T-Box will", "tokens": [316, 6423, 393, 1745, 281, 257, 314, 12, 34980, 293, 393, 2845, 12475, 281, 264, 314, 12, 34980, 11, 293, 264, 314, 12, 34980, 486], "temperature": 0.0, "avg_logprob": -0.10113737442914178, "compression_ratio": 1.5505050505050506, "no_speech_prob": 6.682111416012049e-05}, {"id": 150, "seek": 82416, "start": 837.68, "end": 840.64, "text": " respond with a reply.", "tokens": [4196, 365, 257, 16972, 13], "temperature": 0.0, "avg_logprob": -0.10113737442914178, "compression_ratio": 1.5505050505050506, "no_speech_prob": 6.682111416012049e-05}, {"id": 151, "seek": 82416, "start": 840.64, "end": 847.64, "text": " Every message that is sent includes a header, which is one byte long, and replies from the", "tokens": [2048, 3636, 300, 307, 2279, 5974, 257, 23117, 11, 597, 307, 472, 40846, 938, 11, 293, 42289, 490, 264], "temperature": 0.0, "avg_logprob": -0.10113737442914178, "compression_ratio": 1.5505050505050506, "no_speech_prob": 6.682111416012049e-05}, {"id": 152, "seek": 82416, "start": 847.64, "end": 853.12, "text": " T-Box will also contain a value.", "tokens": [314, 12, 34980, 486, 611, 5304, 257, 2158, 13], "temperature": 0.0, "avg_logprob": -0.10113737442914178, "compression_ratio": 1.5505050505050506, "no_speech_prob": 6.682111416012049e-05}, {"id": 153, "seek": 85312, "start": 853.12, "end": 859.88, "text": " The header starts with four bits of magic, which is a constant value that is always there", "tokens": [440, 23117, 3719, 365, 1451, 9239, 295, 5585, 11, 597, 307, 257, 5754, 2158, 300, 307, 1009, 456], "temperature": 0.0, "avg_logprob": -0.1876209865916859, "compression_ratio": 1.75, "no_speech_prob": 3.417146945139393e-05}, {"id": 154, "seek": 85312, "start": 859.88, "end": 865.4, "text": " and is used to sort of make sure this is the beginning of a message.", "tokens": [293, 307, 1143, 281, 1333, 295, 652, 988, 341, 307, 264, 2863, 295, 257, 3636, 13], "temperature": 0.0, "avg_logprob": -0.1876209865916859, "compression_ratio": 1.75, "no_speech_prob": 3.417146945139393e-05}, {"id": 155, "seek": 85312, "start": 865.4, "end": 870.84, "text": " Then there's a direction bit, which tells whether this message is a request or a reply,", "tokens": [1396, 456, 311, 257, 3513, 857, 11, 597, 5112, 1968, 341, 3636, 307, 257, 5308, 420, 257, 16972, 11], "temperature": 0.0, "avg_logprob": -0.1876209865916859, "compression_ratio": 1.75, "no_speech_prob": 3.417146945139393e-05}, {"id": 156, "seek": 85312, "start": 870.84, "end": 877.0, "text": " and there's the attribute, three bits, which are used to tell if this is a name or temperature", "tokens": [293, 456, 311, 264, 19667, 11, 1045, 9239, 11, 597, 366, 1143, 281, 980, 498, 341, 307, 257, 1315, 420, 4292], "temperature": 0.0, "avg_logprob": -0.1876209865916859, "compression_ratio": 1.75, "no_speech_prob": 3.417146945139393e-05}, {"id": 157, "seek": 85312, "start": 877.0, "end": 882.0, "text": " message.", "tokens": [3636, 13], "temperature": 0.0, "avg_logprob": -0.1876209865916859, "compression_ratio": 1.75, "no_speech_prob": 3.417146945139393e-05}, {"id": 158, "seek": 88200, "start": 882.0, "end": 886.52, "text": " There are extra, we only use one bit in the attribute, but that's just because they expect", "tokens": [821, 366, 2857, 11, 321, 787, 764, 472, 857, 294, 264, 19667, 11, 457, 300, 311, 445, 570, 436, 2066], "temperature": 0.0, "avg_logprob": -0.17804265825935964, "compression_ratio": 1.6971153846153846, "no_speech_prob": 4.001520574092865e-05}, {"id": 159, "seek": 88200, "start": 886.52, "end": 891.2, "text": " to expand the protocol someday.", "tokens": [281, 5268, 264, 10336, 19412, 13], "temperature": 0.0, "avg_logprob": -0.17804265825935964, "compression_ratio": 1.6971153846153846, "no_speech_prob": 4.001520574092865e-05}, {"id": 160, "seek": 88200, "start": 891.2, "end": 895.6, "text": " This is an example of a sequence request-reply.", "tokens": [639, 307, 364, 1365, 295, 257, 8310, 5308, 12, 265, 2724, 13], "temperature": 0.0, "avg_logprob": -0.17804265825935964, "compression_ratio": 1.6971153846153846, "no_speech_prob": 4.001520574092865e-05}, {"id": 161, "seek": 88200, "start": 895.6, "end": 902.76, "text": " First we send the request with the header, with the magic bits first, then it's a zero", "tokens": [2386, 321, 2845, 264, 5308, 365, 264, 23117, 11, 365, 264, 5585, 9239, 700, 11, 550, 309, 311, 257, 4018], "temperature": 0.0, "avg_logprob": -0.17804265825935964, "compression_ratio": 1.6971153846153846, "no_speech_prob": 4.001520574092865e-05}, {"id": 162, "seek": 88200, "start": 902.76, "end": 908.08, "text": " because the direction is a request, and then we're requesting one, which means we're requesting", "tokens": [570, 264, 3513, 307, 257, 5308, 11, 293, 550, 321, 434, 31937, 472, 11, 597, 1355, 321, 434, 31937], "temperature": 0.0, "avg_logprob": -0.17804265825935964, "compression_ratio": 1.6971153846153846, "no_speech_prob": 4.001520574092865e-05}, {"id": 163, "seek": 90808, "start": 908.08, "end": 914.0400000000001, "text": " the temperature, and then the reply has almost the same header at the beginning, it's just", "tokens": [264, 4292, 11, 293, 550, 264, 16972, 575, 1920, 264, 912, 23117, 412, 264, 2863, 11, 309, 311, 445], "temperature": 0.0, "avg_logprob": -0.11732417589997592, "compression_ratio": 1.56, "no_speech_prob": 7.323992031160742e-05}, {"id": 164, "seek": 90808, "start": 914.0400000000001, "end": 925.64, "text": " one in place of the direction, and then the bytes with the value after that.", "tokens": [472, 294, 1081, 295, 264, 3513, 11, 293, 550, 264, 36088, 365, 264, 2158, 934, 300, 13], "temperature": 0.0, "avg_logprob": -0.11732417589997592, "compression_ratio": 1.56, "no_speech_prob": 7.323992031160742e-05}, {"id": 165, "seek": 90808, "start": 925.64, "end": 933.4000000000001, "text": " If you're requesting the name of the T-Box, then it will respond with 12 bytes, and it's", "tokens": [759, 291, 434, 31937, 264, 1315, 295, 264, 314, 12, 34980, 11, 550, 309, 486, 4196, 365, 2272, 36088, 11, 293, 309, 311], "temperature": 0.0, "avg_logprob": -0.11732417589997592, "compression_ratio": 1.56, "no_speech_prob": 7.323992031160742e-05}, {"id": 166, "seek": 90808, "start": 933.4000000000001, "end": 935.8000000000001, "text": " always 12 bytes.", "tokens": [1009, 2272, 36088, 13], "temperature": 0.0, "avg_logprob": -0.11732417589997592, "compression_ratio": 1.56, "no_speech_prob": 7.323992031160742e-05}, {"id": 167, "seek": 93580, "start": 935.8, "end": 942.4799999999999, "text": " If the name is shorter than 12 bytes, then the rest of the bytes are just null bytes,", "tokens": [759, 264, 1315, 307, 11639, 813, 2272, 36088, 11, 550, 264, 1472, 295, 264, 36088, 366, 445, 18184, 36088, 11], "temperature": 0.0, "avg_logprob": -0.15585672119517385, "compression_ratio": 1.6685714285714286, "no_speech_prob": 4.310730582801625e-05}, {"id": 168, "seek": 93580, "start": 942.4799999999999, "end": 943.88, "text": " and that looks like this.", "tokens": [293, 300, 1542, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.15585672119517385, "compression_ratio": 1.6685714285714286, "no_speech_prob": 4.310730582801625e-05}, {"id": 169, "seek": 93580, "start": 943.88, "end": 952.68, "text": " If the name of the box is fustum, then you have six bytes of actual characters, and then", "tokens": [759, 264, 1315, 295, 264, 2424, 307, 283, 381, 449, 11, 550, 291, 362, 2309, 36088, 295, 3539, 4342, 11, 293, 550], "temperature": 0.0, "avg_logprob": -0.15585672119517385, "compression_ratio": 1.6685714285714286, "no_speech_prob": 4.310730582801625e-05}, {"id": 170, "seek": 93580, "start": 952.68, "end": 957.56, "text": " null bytes for the rest.", "tokens": [18184, 36088, 337, 264, 1472, 13], "temperature": 0.0, "avg_logprob": -0.15585672119517385, "compression_ratio": 1.6685714285714286, "no_speech_prob": 4.310730582801625e-05}, {"id": 171, "seek": 93580, "start": 957.56, "end": 960.3199999999999, "text": " The temperature is a little more complicated.", "tokens": [440, 4292, 307, 257, 707, 544, 6179, 13], "temperature": 0.0, "avg_logprob": -0.15585672119517385, "compression_ratio": 1.6685714285714286, "no_speech_prob": 4.310730582801625e-05}, {"id": 172, "seek": 93580, "start": 960.3199999999999, "end": 961.3199999999999, "text": " It has three fields.", "tokens": [467, 575, 1045, 7909, 13], "temperature": 0.0, "avg_logprob": -0.15585672119517385, "compression_ratio": 1.6685714285714286, "no_speech_prob": 4.310730582801625e-05}, {"id": 173, "seek": 96132, "start": 961.32, "end": 966.84, "text": " There's the time, which is a 32-bit integer, counting the number of seconds since 1st", "tokens": [821, 311, 264, 565, 11, 597, 307, 257, 8858, 12, 5260, 24922, 11, 13251, 264, 1230, 295, 3949, 1670, 502, 372], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 174, "seek": 96132, "start": 966.84, "end": 969.36, "text": " of January, 1970.", "tokens": [295, 7061, 11, 14577, 13], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 175, "seek": 96132, "start": 969.36, "end": 974.0400000000001, "text": " Then there's the temperature, which is a 16-bit float, and then there's the quality byte,", "tokens": [1396, 456, 311, 264, 4292, 11, 597, 307, 257, 3165, 12, 5260, 15706, 11, 293, 550, 456, 311, 264, 3125, 40846, 11], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 176, "seek": 96132, "start": 974.0400000000001, "end": 979.96, "text": " which tells you whether there's an error in some of the measurements.", "tokens": [597, 5112, 291, 1968, 456, 311, 364, 6713, 294, 512, 295, 264, 15383, 13], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 177, "seek": 96132, "start": 979.96, "end": 983.1600000000001, "text": " It's the two last bits in the Q-byte that are used.", "tokens": [467, 311, 264, 732, 1036, 9239, 294, 264, 1249, 12, 2322, 975, 300, 366, 1143, 13], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 178, "seek": 96132, "start": 983.1600000000001, "end": 987.12, "text": " The second to last bit tells you there's an error in the clock, and the last bit tells", "tokens": [440, 1150, 281, 1036, 857, 5112, 291, 456, 311, 364, 6713, 294, 264, 7830, 11, 293, 264, 1036, 857, 5112], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 179, "seek": 96132, "start": 987.12, "end": 990.36, "text": " you there's an error in the temperature measurement.", "tokens": [291, 456, 311, 364, 6713, 294, 264, 4292, 13160, 13], "temperature": 0.0, "avg_logprob": -0.18137467292047316, "compression_ratio": 1.9956140350877194, "no_speech_prob": 0.00015145425277296454}, {"id": 180, "seek": 99036, "start": 990.36, "end": 994.96, "text": " It's important to note that the numbers are little in the end.", "tokens": [467, 311, 1021, 281, 3637, 300, 264, 3547, 366, 707, 294, 264, 917, 13], "temperature": 0.0, "avg_logprob": -0.2347860215585443, "compression_ratio": 1.5555555555555556, "no_speech_prob": 9.88045139820315e-05}, {"id": 181, "seek": 99036, "start": 994.96, "end": 998.04, "text": " This is what a temperature value looks like.", "tokens": [639, 307, 437, 257, 4292, 2158, 1542, 411, 13], "temperature": 0.0, "avg_logprob": -0.2347860215585443, "compression_ratio": 1.5555555555555556, "no_speech_prob": 9.88045139820315e-05}, {"id": 182, "seek": 99036, "start": 998.04, "end": 1001.72, "text": " First, it has a timestamp, which is a couple days ago.", "tokens": [2386, 11, 309, 575, 257, 49108, 1215, 11, 597, 307, 257, 1916, 1708, 2057, 13], "temperature": 0.0, "avg_logprob": -0.2347860215585443, "compression_ratio": 1.5555555555555556, "no_speech_prob": 9.88045139820315e-05}, {"id": 183, "seek": 99036, "start": 1001.72, "end": 1007.4, "text": " Then the temperature, which is 32 degrees about that, and then both of the error bits", "tokens": [1396, 264, 4292, 11, 597, 307, 8858, 5310, 466, 300, 11, 293, 550, 1293, 295, 264, 6713, 9239], "temperature": 0.0, "avg_logprob": -0.2347860215585443, "compression_ratio": 1.5555555555555556, "no_speech_prob": 9.88045139820315e-05}, {"id": 184, "seek": 99036, "start": 1007.4, "end": 1013.48, "text": " are high, so you should not trust the sample.", "tokens": [366, 1090, 11, 370, 291, 820, 406, 3361, 264, 6889, 13], "temperature": 0.0, "avg_logprob": -0.2347860215585443, "compression_ratio": 1.5555555555555556, "no_speech_prob": 9.88045139820315e-05}, {"id": 185, "seek": 101348, "start": 1013.48, "end": 1020.84, "text": " This syntax, we want to send a request to the T-box to get the name.", "tokens": [639, 28431, 11, 321, 528, 281, 2845, 257, 5308, 281, 264, 314, 12, 4995, 281, 483, 264, 1315, 13], "temperature": 0.0, "avg_logprob": -0.25614330616403136, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.00013525977556128055}, {"id": 186, "seek": 101348, "start": 1020.84, "end": 1023.36, "text": " I use the double anchor brackets again.", "tokens": [286, 764, 264, 3834, 18487, 26179, 797, 13], "temperature": 0.0, "avg_logprob": -0.25614330616403136, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.00013525977556128055}, {"id": 187, "seek": 101348, "start": 1023.36, "end": 1028.16, "text": " It's all integers, and it's all unsigned, so the only thing I have to specify is the", "tokens": [467, 311, 439, 41674, 11, 293, 309, 311, 439, 2693, 16690, 11, 370, 264, 787, 551, 286, 362, 281, 16500, 307, 264], "temperature": 0.0, "avg_logprob": -0.25614330616403136, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.00013525977556128055}, {"id": 188, "seek": 101348, "start": 1028.16, "end": 1029.16, "text": " size.", "tokens": [2744, 13], "temperature": 0.0, "avg_logprob": -0.25614330616403136, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.00013525977556128055}, {"id": 189, "seek": 101348, "start": 1029.16, "end": 1037.08, "text": " Here I specify the magic is four bits, then I have my direction, one bit, and the attribute", "tokens": [1692, 286, 16500, 264, 5585, 307, 1451, 9239, 11, 550, 286, 362, 452, 3513, 11, 472, 857, 11, 293, 264, 19667], "temperature": 0.0, "avg_logprob": -0.25614330616403136, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.00013525977556128055}, {"id": 190, "seek": 101348, "start": 1037.08, "end": 1041.96, "text": " which is zero for getting the name.", "tokens": [597, 307, 4018, 337, 1242, 264, 1315, 13], "temperature": 0.0, "avg_logprob": -0.25614330616403136, "compression_ratio": 1.5951219512195123, "no_speech_prob": 0.00013525977556128055}, {"id": 191, "seek": 104196, "start": 1041.96, "end": 1047.1200000000001, "text": " This shows how we can use the bits and tags to encode, easily encode things which are", "tokens": [639, 3110, 577, 321, 393, 764, 264, 9239, 293, 18632, 281, 2058, 1429, 11, 3612, 2058, 1429, 721, 597, 366], "temperature": 0.0, "avg_logprob": -0.2853919400109185, "compression_ratio": 1.5290697674418605, "no_speech_prob": 6.670287984889e-05}, {"id": 192, "seek": 104196, "start": 1047.1200000000001, "end": 1051.1200000000001, "text": " smaller than bytes.", "tokens": [4356, 813, 36088, 13], "temperature": 0.0, "avg_logprob": -0.2853919400109185, "compression_ratio": 1.5290697674418605, "no_speech_prob": 6.670287984889e-05}, {"id": 193, "seek": 104196, "start": 1051.1200000000001, "end": 1057.16, "text": " The reply that comes back looks like this.", "tokens": [440, 16972, 300, 1487, 646, 1542, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.2853919400109185, "compression_ratio": 1.5290697674418605, "no_speech_prob": 6.670287984889e-05}, {"id": 194, "seek": 104196, "start": 1057.16, "end": 1061.08, "text": " When we receive the goodbye, we do like this.", "tokens": [1133, 321, 4774, 264, 12084, 11, 321, 360, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.2853919400109185, "compression_ratio": 1.5290697674418605, "no_speech_prob": 6.670287984889e-05}, {"id": 195, "seek": 104196, "start": 1061.08, "end": 1069.68, "text": " First I want to assert that the message I get back is what I expect.", "tokens": [2386, 286, 528, 281, 19810, 300, 264, 3636, 286, 483, 646, 307, 437, 286, 2066, 13], "temperature": 0.0, "avg_logprob": -0.2853919400109185, "compression_ratio": 1.5290697674418605, "no_speech_prob": 6.670287984889e-05}, {"id": 196, "seek": 106968, "start": 1069.68, "end": 1073.92, "text": " In place of the header, I assert that the values are what I expect.", "tokens": [682, 1081, 295, 264, 23117, 11, 286, 19810, 300, 264, 4190, 366, 437, 286, 2066, 13], "temperature": 0.0, "avg_logprob": -0.15281437812967502, "compression_ratio": 1.7447916666666667, "no_speech_prob": 0.00018187596288044006}, {"id": 197, "seek": 106968, "start": 1073.92, "end": 1080.4, "text": " I assert that I get the magic bits first, that the direction bit is high so that I know", "tokens": [286, 19810, 300, 286, 483, 264, 5585, 9239, 700, 11, 300, 264, 3513, 857, 307, 1090, 370, 300, 286, 458], "temperature": 0.0, "avg_logprob": -0.15281437812967502, "compression_ratio": 1.7447916666666667, "no_speech_prob": 0.00018187596288044006}, {"id": 198, "seek": 106968, "start": 1080.4, "end": 1088.5600000000002, "text": " it's a reply, and that the attribute is zero so that I know it's the name.", "tokens": [309, 311, 257, 16972, 11, 293, 300, 264, 19667, 307, 4018, 370, 300, 286, 458, 309, 311, 264, 1315, 13], "temperature": 0.0, "avg_logprob": -0.15281437812967502, "compression_ratio": 1.7447916666666667, "no_speech_prob": 0.00018187596288044006}, {"id": 199, "seek": 106968, "start": 1088.5600000000002, "end": 1089.5600000000002, "text": " This is all true.", "tokens": [639, 307, 439, 2074, 13], "temperature": 0.0, "avg_logprob": -0.15281437812967502, "compression_ratio": 1.7447916666666667, "no_speech_prob": 0.00018187596288044006}, {"id": 200, "seek": 106968, "start": 1089.5600000000002, "end": 1099.16, "text": " I know that the rest of the message is 12 bytes long, and I want to assign that to the", "tokens": [286, 458, 300, 264, 1472, 295, 264, 3636, 307, 2272, 36088, 938, 11, 293, 286, 528, 281, 6269, 300, 281, 264], "temperature": 0.0, "avg_logprob": -0.15281437812967502, "compression_ratio": 1.7447916666666667, "no_speech_prob": 0.00018187596288044006}, {"id": 201, "seek": 109916, "start": 1099.16, "end": 1100.16, "text": " variable name.", "tokens": [7006, 1315, 13], "temperature": 0.0, "avg_logprob": -0.23382065322372939, "compression_ratio": 1.6536585365853658, "no_speech_prob": 0.0006233575404621661}, {"id": 202, "seek": 109916, "start": 1100.16, "end": 1104.3600000000001, "text": " Here you can see I will use the bytes modifier.", "tokens": [1692, 291, 393, 536, 286, 486, 764, 264, 36088, 38011, 13], "temperature": 0.0, "avg_logprob": -0.23382065322372939, "compression_ratio": 1.6536585365853658, "no_speech_prob": 0.0006233575404621661}, {"id": 203, "seek": 109916, "start": 1104.3600000000001, "end": 1111.0400000000002, "text": " This changes the type, and it changes the size, or it changes the unit property.", "tokens": [639, 2962, 264, 2010, 11, 293, 309, 2962, 264, 2744, 11, 420, 309, 2962, 264, 4985, 4707, 13], "temperature": 0.0, "avg_logprob": -0.23382065322372939, "compression_ratio": 1.6536585365853658, "no_speech_prob": 0.0006233575404621661}, {"id": 204, "seek": 109916, "start": 1111.0400000000002, "end": 1115.1200000000001, "text": " Before with integers, I would specify, like in the header you can see it's two colon", "tokens": [4546, 365, 41674, 11, 286, 576, 16500, 11, 411, 294, 264, 23117, 291, 393, 536, 309, 311, 732, 8255], "temperature": 0.0, "avg_logprob": -0.23382065322372939, "compression_ratio": 1.6536585365853658, "no_speech_prob": 0.0006233575404621661}, {"id": 205, "seek": 109916, "start": 1115.1200000000001, "end": 1116.88, "text": " colon four for the magic.", "tokens": [8255, 1451, 337, 264, 5585, 13], "temperature": 0.0, "avg_logprob": -0.23382065322372939, "compression_ratio": 1.6536585365853658, "no_speech_prob": 0.0006233575404621661}, {"id": 206, "seek": 109916, "start": 1116.88, "end": 1123.3200000000002, "text": " That means four bits, but when I specify bytes, that the type of name is bytes, then", "tokens": [663, 1355, 1451, 9239, 11, 457, 562, 286, 16500, 36088, 11, 300, 264, 2010, 295, 1315, 307, 36088, 11, 550], "temperature": 0.0, "avg_logprob": -0.23382065322372939, "compression_ratio": 1.6536585365853658, "no_speech_prob": 0.0006233575404621661}, {"id": 207, "seek": 112332, "start": 1123.32, "end": 1134.04, "text": " I also say that the 12 means 12 bytes long and not 12 bits long.", "tokens": [286, 611, 584, 300, 264, 2272, 1355, 2272, 36088, 938, 293, 406, 2272, 9239, 938, 13], "temperature": 0.0, "avg_logprob": -0.2577260732650757, "compression_ratio": 1.49375, "no_speech_prob": 4.7956644266378134e-05}, {"id": 208, "seek": 112332, "start": 1134.04, "end": 1141.8799999999999, "text": " That's just to say that the bytes is a type and has different defaults than integers.", "tokens": [663, 311, 445, 281, 584, 300, 264, 36088, 307, 257, 2010, 293, 575, 819, 7576, 82, 813, 41674, 13], "temperature": 0.0, "avg_logprob": -0.2577260732650757, "compression_ratio": 1.49375, "no_speech_prob": 4.7956644266378134e-05}, {"id": 209, "seek": 112332, "start": 1141.8799999999999, "end": 1147.24, "text": " When I get the Tbox temperature, I request it like this, pretty much the same as before,", "tokens": [1133, 286, 483, 264, 314, 4995, 4292, 11, 286, 5308, 309, 411, 341, 11, 1238, 709, 264, 912, 382, 949, 11], "temperature": 0.0, "avg_logprob": -0.2577260732650757, "compression_ratio": 1.49375, "no_speech_prob": 4.7956644266378134e-05}, {"id": 210, "seek": 114724, "start": 1147.24, "end": 1153.68, "text": " just with a one for the attribute, and for the reply, I again assert on the header that", "tokens": [445, 365, 257, 472, 337, 264, 19667, 11, 293, 337, 264, 16972, 11, 286, 797, 19810, 322, 264, 23117, 300], "temperature": 0.0, "avg_logprob": -0.19381406469252502, "compression_ratio": 1.6460176991150441, "no_speech_prob": 0.00012794177746400237}, {"id": 211, "seek": 114724, "start": 1153.68, "end": 1157.04, "text": " I get back what I expect.", "tokens": [286, 483, 646, 437, 286, 2066, 13], "temperature": 0.0, "avg_logprob": -0.19381406469252502, "compression_ratio": 1.6460176991150441, "no_speech_prob": 0.00012794177746400237}, {"id": 212, "seek": 114724, "start": 1157.04, "end": 1162.96, "text": " Then I have the timestamp, which was the 32-bit integer, but little indian, so let's put that", "tokens": [1396, 286, 362, 264, 49108, 1215, 11, 597, 390, 264, 8858, 12, 5260, 24922, 11, 457, 707, 1016, 952, 11, 370, 718, 311, 829, 300], "temperature": 0.0, "avg_logprob": -0.19381406469252502, "compression_ratio": 1.6460176991150441, "no_speech_prob": 0.00012794177746400237}, {"id": 213, "seek": 114724, "start": 1162.96, "end": 1169.92, "text": " in there, and the temperature, which is a float, 16 bits, also little indian.", "tokens": [294, 456, 11, 293, 264, 4292, 11, 597, 307, 257, 15706, 11, 3165, 9239, 11, 611, 707, 1016, 952, 13], "temperature": 0.0, "avg_logprob": -0.19381406469252502, "compression_ratio": 1.6460176991150441, "no_speech_prob": 0.00012794177746400237}, {"id": 214, "seek": 114724, "start": 1169.92, "end": 1174.44, "text": " Then I discard six bits from the cube byte because they were not used, and then I just", "tokens": [1396, 286, 31597, 2309, 9239, 490, 264, 13728, 40846, 570, 436, 645, 406, 1143, 11, 293, 550, 286, 445], "temperature": 0.0, "avg_logprob": -0.19381406469252502, "compression_ratio": 1.6460176991150441, "no_speech_prob": 0.00012794177746400237}, {"id": 215, "seek": 117444, "start": 1174.44, "end": 1184.8, "text": " plug the second to last and the last bit out as clock error and temperature error.", "tokens": [5452, 264, 1150, 281, 1036, 293, 264, 1036, 857, 484, 382, 7830, 6713, 293, 4292, 6713, 13], "temperature": 0.0, "avg_logprob": -0.21976870706636611, "compression_ratio": 1.5425531914893618, "no_speech_prob": 4.050145435030572e-05}, {"id": 216, "seek": 117444, "start": 1184.8, "end": 1188.68, "text": " That's the basics of bits and tacks.", "tokens": [663, 311, 264, 14688, 295, 9239, 293, 256, 7424, 13], "temperature": 0.0, "avg_logprob": -0.21976870706636611, "compression_ratio": 1.5425531914893618, "no_speech_prob": 4.050145435030572e-05}, {"id": 217, "seek": 117444, "start": 1188.68, "end": 1192.8400000000001, "text": " There's so much more to cover with writing whole applications or libraries to do this", "tokens": [821, 311, 370, 709, 544, 281, 2060, 365, 3579, 1379, 5821, 420, 15148, 281, 360, 341], "temperature": 0.0, "avg_logprob": -0.21976870706636611, "compression_ratio": 1.5425531914893618, "no_speech_prob": 4.050145435030572e-05}, {"id": 218, "seek": 117444, "start": 1192.8400000000001, "end": 1197.88, "text": " kind of stuff, like what do we do when you don't receive the entire message at once,", "tokens": [733, 295, 1507, 11, 411, 437, 360, 321, 360, 562, 291, 500, 380, 4774, 264, 2302, 3636, 412, 1564, 11], "temperature": 0.0, "avg_logprob": -0.21976870706636611, "compression_ratio": 1.5425531914893618, "no_speech_prob": 4.050145435030572e-05}, {"id": 219, "seek": 119788, "start": 1197.88, "end": 1205.2, "text": " you have to frame messages when you're streaming them or receiving them as a stream.", "tokens": [291, 362, 281, 3920, 7897, 562, 291, 434, 11791, 552, 420, 10040, 552, 382, 257, 4309, 13], "temperature": 0.0, "avg_logprob": -0.1980913235591008, "compression_ratio": 1.715415019762846, "no_speech_prob": 0.00011293461284367368}, {"id": 220, "seek": 119788, "start": 1205.2, "end": 1211.2800000000002, "text": " There's generators, there's a special, well, it looks like just a normal forward generator,", "tokens": [821, 311, 38662, 11, 456, 311, 257, 2121, 11, 731, 11, 309, 1542, 411, 445, 257, 2710, 2128, 19265, 11], "temperature": 0.0, "avg_logprob": -0.1980913235591008, "compression_ratio": 1.715415019762846, "no_speech_prob": 0.00011293461284367368}, {"id": 221, "seek": 119788, "start": 1211.2800000000002, "end": 1216.5200000000002, "text": " but it actually has some special optimizations for working with binaries when you need to", "tokens": [457, 309, 767, 575, 512, 2121, 5028, 14455, 337, 1364, 365, 5171, 4889, 562, 291, 643, 281], "temperature": 0.0, "avg_logprob": -0.1980913235591008, "compression_ratio": 1.715415019762846, "no_speech_prob": 0.00011293461284367368}, {"id": 222, "seek": 119788, "start": 1216.5200000000002, "end": 1218.68, "text": " generate a binary.", "tokens": [8460, 257, 17434, 13], "temperature": 0.0, "avg_logprob": -0.1980913235591008, "compression_ratio": 1.715415019762846, "no_speech_prob": 0.00011293461284367368}, {"id": 223, "seek": 119788, "start": 1218.68, "end": 1223.72, "text": " We could talk about performance tuning, but as I said, I've been working with this for", "tokens": [492, 727, 751, 466, 3389, 15164, 11, 457, 382, 286, 848, 11, 286, 600, 668, 1364, 365, 341, 337], "temperature": 0.0, "avg_logprob": -0.1980913235591008, "compression_ratio": 1.715415019762846, "no_speech_prob": 0.00011293461284367368}, {"id": 224, "seek": 119788, "start": 1223.72, "end": 1226.88, "text": " years and I've never had to really do any performance tuning.", "tokens": [924, 293, 286, 600, 1128, 632, 281, 534, 360, 604, 3389, 15164, 13], "temperature": 0.0, "avg_logprob": -0.1980913235591008, "compression_ratio": 1.715415019762846, "no_speech_prob": 0.00011293461284367368}, {"id": 225, "seek": 122688, "start": 1226.88, "end": 1229.6000000000001, "text": " It's pretty performant as is.", "tokens": [467, 311, 1238, 2042, 394, 382, 307, 13], "temperature": 0.0, "avg_logprob": -0.22976477602694897, "compression_ratio": 1.6064814814814814, "no_speech_prob": 0.000157135131303221}, {"id": 226, "seek": 122688, "start": 1229.6000000000001, "end": 1236.5600000000002, "text": " That's also one of the points in the paper by Claes and Tony is that this is performant.", "tokens": [663, 311, 611, 472, 295, 264, 2793, 294, 264, 3035, 538, 12947, 279, 293, 10902, 307, 300, 341, 307, 2042, 394, 13], "temperature": 0.0, "avg_logprob": -0.22976477602694897, "compression_ratio": 1.6064814814814814, "no_speech_prob": 0.000157135131303221}, {"id": 227, "seek": 122688, "start": 1236.5600000000002, "end": 1243.8000000000002, "text": " Yeah, there are many other tools for working with binaries that help us when we're looking", "tokens": [865, 11, 456, 366, 867, 661, 3873, 337, 1364, 365, 5171, 4889, 300, 854, 505, 562, 321, 434, 1237], "temperature": 0.0, "avg_logprob": -0.22976477602694897, "compression_ratio": 1.6064814814814814, "no_speech_prob": 0.000157135131303221}, {"id": 228, "seek": 122688, "start": 1243.8000000000002, "end": 1248.2800000000002, "text": " at this data and not understanding why it's not doing what we expect.", "tokens": [412, 341, 1412, 293, 406, 3701, 983, 309, 311, 406, 884, 437, 321, 2066, 13], "temperature": 0.0, "avg_logprob": -0.22976477602694897, "compression_ratio": 1.6064814814814814, "no_speech_prob": 0.000157135131303221}, {"id": 229, "seek": 122688, "start": 1248.2800000000002, "end": 1251.3600000000001, "text": " Wireshark is definitely one of them.", "tokens": [343, 3145, 71, 809, 307, 2138, 472, 295, 552, 13], "temperature": 0.0, "avg_logprob": -0.22976477602694897, "compression_ratio": 1.6064814814814814, "no_speech_prob": 0.000157135131303221}, {"id": 230, "seek": 122688, "start": 1251.3600000000001, "end": 1255.96, "text": " I recommend checking that out.", "tokens": [286, 2748, 8568, 300, 484, 13], "temperature": 0.0, "avg_logprob": -0.22976477602694897, "compression_ratio": 1.6064814814814814, "no_speech_prob": 0.000157135131303221}, {"id": 231, "seek": 125596, "start": 1255.96, "end": 1261.92, "text": " I also recommend if you want to explore more depth, that you check out Protohackers, which", "tokens": [286, 611, 2748, 498, 291, 528, 281, 6839, 544, 7161, 11, 300, 291, 1520, 484, 10019, 1445, 501, 433, 11, 597], "temperature": 0.0, "avg_logprob": -0.26505392724341087, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.00029586334130726755}, {"id": 232, "seek": 125596, "start": 1261.92, "end": 1271.24, "text": " is a sort of advent of code challenge thing about their networking protocols, and Andrea", "tokens": [307, 257, 1333, 295, 7045, 295, 3089, 3430, 551, 466, 641, 17985, 20618, 11, 293, 24215], "temperature": 0.0, "avg_logprob": -0.26505392724341087, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.00029586334130726755}, {"id": 233, "seek": 125596, "start": 1271.24, "end": 1276.16, "text": " Lopardi from the Elixir core team has a live stream on YouTube or has streams on YouTube", "tokens": [441, 404, 38126, 490, 264, 2699, 970, 347, 4965, 1469, 575, 257, 1621, 4309, 322, 3088, 420, 575, 15842, 322, 3088], "temperature": 0.0, "avg_logprob": -0.26505392724341087, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.00029586334130726755}, {"id": 234, "seek": 125596, "start": 1276.16, "end": 1281.08, "text": " where he sort of goes through the problems one by one, so that's very good for learning", "tokens": [689, 415, 1333, 295, 1709, 807, 264, 2740, 472, 538, 472, 11, 370, 300, 311, 588, 665, 337, 2539], "temperature": 0.0, "avg_logprob": -0.26505392724341087, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.00029586334130726755}, {"id": 235, "seek": 125596, "start": 1281.08, "end": 1282.08, "text": " that.", "tokens": [300, 13], "temperature": 0.0, "avg_logprob": -0.26505392724341087, "compression_ratio": 1.553648068669528, "no_speech_prob": 0.00029586334130726755}, {"id": 236, "seek": 128208, "start": 1282.08, "end": 1287.8, "text": " Andrea has also started writing a book about this kind of stuff.", "tokens": [24215, 575, 611, 1409, 3579, 257, 1446, 466, 341, 733, 295, 1507, 13], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 237, "seek": 128208, "start": 1287.8, "end": 1288.8, "text": " So that's it.", "tokens": [407, 300, 311, 309, 13], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 238, "seek": 128208, "start": 1288.8, "end": 1289.8, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 239, "seek": 128208, "start": 1289.8, "end": 1299.36, "text": " Thank you for your thoughts, Rolf.", "tokens": [1044, 291, 337, 428, 4598, 11, 497, 7491, 13], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 240, "seek": 128208, "start": 1299.36, "end": 1304.56, "text": " Do you have any questions?", "tokens": [1144, 291, 362, 604, 1651, 30], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 241, "seek": 128208, "start": 1304.56, "end": 1306.6, "text": " Hi.", "tokens": [2421, 13], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 242, "seek": 128208, "start": 1306.6, "end": 1308.3999999999999, "text": " Thanks.", "tokens": [2561, 13], "temperature": 0.0, "avg_logprob": -0.5282078811100551, "compression_ratio": 1.2834645669291338, "no_speech_prob": 0.0014737488236278296}, {"id": 243, "seek": 130840, "start": 1308.4, "end": 1318.2, "text": " So I've done, I've implemented a few binary protocols like network protocols like HTTP", "tokens": [407, 286, 600, 1096, 11, 286, 600, 12270, 257, 1326, 17434, 20618, 411, 3209, 20618, 411, 33283], "temperature": 0.0, "avg_logprob": -0.25511887494255514, "compression_ratio": 1.5824175824175823, "no_speech_prob": 0.005267434287816286}, {"id": 244, "seek": 130840, "start": 1318.2, "end": 1320.8000000000002, "text": " 2 or other stuff like that.", "tokens": [568, 420, 661, 1507, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.25511887494255514, "compression_ratio": 1.5824175824175823, "no_speech_prob": 0.005267434287816286}, {"id": 245, "seek": 130840, "start": 1320.8000000000002, "end": 1329.72, "text": " I'd love to know how you, if you have done any streaming of data and passing of messages", "tokens": [286, 1116, 959, 281, 458, 577, 291, 11, 498, 291, 362, 1096, 604, 11791, 295, 1412, 293, 8437, 295, 7897], "temperature": 0.0, "avg_logprob": -0.25511887494255514, "compression_ratio": 1.5824175824175823, "no_speech_prob": 0.005267434287816286}, {"id": 246, "seek": 130840, "start": 1329.72, "end": 1334.2800000000002, "text": " coming from streaming data and generators also would be interesting just to know how", "tokens": [1348, 490, 11791, 1412, 293, 38662, 611, 576, 312, 1880, 445, 281, 458, 577], "temperature": 0.0, "avg_logprob": -0.25511887494255514, "compression_ratio": 1.5824175824175823, "no_speech_prob": 0.005267434287816286}, {"id": 247, "seek": 133428, "start": 1334.28, "end": 1339.56, "text": " you approached it because I know I did something but I don't know how we did it.", "tokens": [291, 17247, 309, 570, 286, 458, 286, 630, 746, 457, 286, 500, 380, 458, 577, 321, 630, 309, 13], "temperature": 0.0, "avg_logprob": -0.21388286093006964, "compression_ratio": 1.5814977973568283, "no_speech_prob": 0.0028147620614618063}, {"id": 248, "seek": 133428, "start": 1339.56, "end": 1344.32, "text": " I think I've implemented a few protocols that use, for example, TCP as the underlying", "tokens": [286, 519, 286, 600, 12270, 257, 1326, 20618, 300, 764, 11, 337, 1365, 11, 48965, 382, 264, 14217], "temperature": 0.0, "avg_logprob": -0.21388286093006964, "compression_ratio": 1.5814977973568283, "no_speech_prob": 0.0028147620614618063}, {"id": 249, "seek": 133428, "start": 1344.32, "end": 1347.24, "text": " transport and then that's like a stream.", "tokens": [5495, 293, 550, 300, 311, 411, 257, 4309, 13], "temperature": 0.0, "avg_logprob": -0.21388286093006964, "compression_ratio": 1.5814977973568283, "no_speech_prob": 0.0028147620614618063}, {"id": 250, "seek": 133428, "start": 1347.24, "end": 1351.0, "text": " And then there are a few patterns for how you want to handle that.", "tokens": [400, 550, 456, 366, 257, 1326, 8294, 337, 577, 291, 528, 281, 4813, 300, 13], "temperature": 0.0, "avg_logprob": -0.21388286093006964, "compression_ratio": 1.5814977973568283, "no_speech_prob": 0.0028147620614618063}, {"id": 251, "seek": 133428, "start": 1351.0, "end": 1360.68, "text": " I think Frank Honloth and the nerve team wrote a sort of framing behavior, which way", "tokens": [286, 519, 6823, 6625, 75, 900, 293, 264, 16355, 1469, 4114, 257, 1333, 295, 28971, 5223, 11, 597, 636], "temperature": 0.0, "avg_logprob": -0.21388286093006964, "compression_ratio": 1.5814977973568283, "no_speech_prob": 0.0028147620614618063}, {"id": 252, "seek": 136068, "start": 1360.68, "end": 1364.8, "text": " you have a couple of callbacks that you need to implement in order to handle a stream so", "tokens": [291, 362, 257, 1916, 295, 818, 17758, 300, 291, 643, 281, 4445, 294, 1668, 281, 4813, 257, 4309, 370], "temperature": 0.0, "avg_logprob": -0.1759424487363945, "compression_ratio": 1.664, "no_speech_prob": 0.00023559526016470045}, {"id": 253, "seek": 136068, "start": 1364.8, "end": 1370.88, "text": " that they give you bytes and then you return back messages when you see a full message.", "tokens": [300, 436, 976, 291, 36088, 293, 550, 291, 2736, 646, 7897, 562, 291, 536, 257, 1577, 3636, 13], "temperature": 0.0, "avg_logprob": -0.1759424487363945, "compression_ratio": 1.664, "no_speech_prob": 0.00023559526016470045}, {"id": 254, "seek": 136068, "start": 1370.88, "end": 1374.96, "text": " It's actually a very good sort of guideline for how to do that.", "tokens": [467, 311, 767, 257, 588, 665, 1333, 295, 41653, 337, 577, 281, 360, 300, 13], "temperature": 0.0, "avg_logprob": -0.1759424487363945, "compression_ratio": 1.664, "no_speech_prob": 0.00023559526016470045}, {"id": 255, "seek": 136068, "start": 1374.96, "end": 1381.76, "text": " Another approach is taken by Andrea Leopardi in his library for Redis where it's like", "tokens": [3996, 3109, 307, 2726, 538, 24215, 1456, 22918, 72, 294, 702, 6405, 337, 4477, 271, 689, 309, 311, 411], "temperature": 0.0, "avg_logprob": -0.1759424487363945, "compression_ratio": 1.664, "no_speech_prob": 0.00023559526016470045}, {"id": 256, "seek": 136068, "start": 1381.76, "end": 1389.16, "text": " you call, when you call the decoding function and it returns a result, the result will be", "tokens": [291, 818, 11, 562, 291, 818, 264, 979, 8616, 2445, 293, 309, 11247, 257, 1874, 11, 264, 1874, 486, 312], "temperature": 0.0, "avg_logprob": -0.1759424487363945, "compression_ratio": 1.664, "no_speech_prob": 0.00023559526016470045}, {"id": 257, "seek": 138916, "start": 1389.16, "end": 1394.4, "text": " whatever messages was in that binary you gave it and then a continuation function which", "tokens": [2035, 7897, 390, 294, 300, 17434, 291, 2729, 309, 293, 550, 257, 29357, 2445, 597], "temperature": 0.0, "avg_logprob": -0.24460325379302536, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.00021254377497825772}, {"id": 258, "seek": 138916, "start": 1394.4, "end": 1405.52, "text": " you call next time with more bytes so that it continues to return new messages, yeah.", "tokens": [291, 818, 958, 565, 365, 544, 36088, 370, 300, 309, 6515, 281, 2736, 777, 7897, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.24460325379302536, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.00021254377497825772}, {"id": 259, "seek": 138916, "start": 1405.52, "end": 1411.8400000000001, "text": " Any question?", "tokens": [2639, 1168, 30], "temperature": 0.0, "avg_logprob": -0.24460325379302536, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.00021254377497825772}, {"id": 260, "seek": 138916, "start": 1411.8400000000001, "end": 1418.3600000000001, "text": " If I would buy a T-box from you, do I still get support in about 16 years from now?", "tokens": [759, 286, 576, 2256, 257, 314, 12, 4995, 490, 291, 11, 360, 286, 920, 483, 1406, 294, 466, 3165, 924, 490, 586, 30], "temperature": 0.0, "avg_logprob": -0.24460325379302536, "compression_ratio": 1.456989247311828, "no_speech_prob": 0.00021254377497825772}, {"id": 261, "seek": 141836, "start": 1418.36, "end": 1422.8799999999999, "text": " Maybe five minutes.", "tokens": [2704, 1732, 2077, 13], "temperature": 0.0, "avg_logprob": -0.2420512712918795, "compression_ratio": 1.5751295336787565, "no_speech_prob": 0.0003902513417415321}, {"id": 262, "seek": 141836, "start": 1422.8799999999999, "end": 1426.76, "text": " I actually have a question for you if there are no other questions.", "tokens": [286, 767, 362, 257, 1168, 337, 291, 498, 456, 366, 572, 661, 1651, 13], "temperature": 0.0, "avg_logprob": -0.2420512712918795, "compression_ratio": 1.5751295336787565, "no_speech_prob": 0.0003902513417415321}, {"id": 263, "seek": 141836, "start": 1426.76, "end": 1432.04, "text": " Do you have a library you suggest to see?", "tokens": [1144, 291, 362, 257, 6405, 291, 3402, 281, 536, 30], "temperature": 0.0, "avg_logprob": -0.2420512712918795, "compression_ratio": 1.5751295336787565, "no_speech_prob": 0.0003902513417415321}, {"id": 264, "seek": 141836, "start": 1432.04, "end": 1439.3999999999999, "text": " Because I implemented a library to decode the QOEI which is the quite okay image format", "tokens": [1436, 286, 12270, 257, 6405, 281, 979, 1429, 264, 1249, 46, 36, 40, 597, 307, 264, 1596, 1392, 3256, 7877], "temperature": 0.0, "avg_logprob": -0.2420512712918795, "compression_ratio": 1.5751295336787565, "no_speech_prob": 0.0003902513417415321}, {"id": 265, "seek": 141836, "start": 1439.3999999999999, "end": 1445.24, "text": " which is a new image format just to get my irons dirty with binary pattern matching in", "tokens": [597, 307, 257, 777, 3256, 7877, 445, 281, 483, 452, 3418, 892, 9360, 365, 17434, 5102, 14324, 294], "temperature": 0.0, "avg_logprob": -0.2420512712918795, "compression_ratio": 1.5751295336787565, "no_speech_prob": 0.0003902513417415321}, {"id": 266, "seek": 144524, "start": 1445.24, "end": 1449.28, "text": " Elixir but it gets very unwieldy very fast.", "tokens": [2699, 970, 347, 457, 309, 2170, 588, 14853, 1789, 88, 588, 2370, 13], "temperature": 0.0, "avg_logprob": -0.20164241560970445, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.000399770651711151}, {"id": 267, "seek": 144524, "start": 1449.28, "end": 1454.4, "text": " So I saw like in JSON they have some macros that generate binary pattern matching.", "tokens": [407, 286, 1866, 411, 294, 31828, 436, 362, 512, 7912, 2635, 300, 8460, 17434, 5102, 14324, 13], "temperature": 0.0, "avg_logprob": -0.20164241560970445, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.000399770651711151}, {"id": 268, "seek": 144524, "start": 1454.4, "end": 1459.52, "text": " Do you have any libraries you recommend to check out?", "tokens": [1144, 291, 362, 604, 15148, 291, 2748, 281, 1520, 484, 30], "temperature": 0.0, "avg_logprob": -0.20164241560970445, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.000399770651711151}, {"id": 269, "seek": 144524, "start": 1459.52, "end": 1464.56, "text": " I think the Redis library is pretty nice.", "tokens": [286, 519, 264, 4477, 271, 6405, 307, 1238, 1481, 13], "temperature": 0.0, "avg_logprob": -0.20164241560970445, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.000399770651711151}, {"id": 270, "seek": 144524, "start": 1464.56, "end": 1470.2, "text": " I also have a KNX library which is like a smart home protocol which I don't know if", "tokens": [286, 611, 362, 257, 26967, 55, 6405, 597, 307, 411, 257, 4069, 1280, 10336, 597, 286, 500, 380, 458, 498], "temperature": 0.0, "avg_logprob": -0.20164241560970445, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.000399770651711151}, {"id": 271, "seek": 147020, "start": 1470.2, "end": 1477.8, "text": " I would recommend but when I wrote it I thought it was made sense, yeah.", "tokens": [286, 576, 2748, 457, 562, 286, 4114, 309, 286, 1194, 309, 390, 1027, 2020, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 272, "seek": 147020, "start": 1477.8, "end": 1478.8, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 273, "seek": 147020, "start": 1478.8, "end": 1483.0800000000002, "text": " Any other questions?", "tokens": [2639, 661, 1651, 30], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 274, "seek": 147020, "start": 1483.0800000000002, "end": 1485.8, "text": " The last one I guess.", "tokens": [440, 1036, 472, 286, 2041, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 275, "seek": 147020, "start": 1485.8, "end": 1490.0, "text": " Maybe a word about exceptions when patterns don't match.", "tokens": [2704, 257, 1349, 466, 22847, 562, 8294, 500, 380, 2995, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 276, "seek": 147020, "start": 1490.0, "end": 1491.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 277, "seek": 147020, "start": 1491.0, "end": 1493.3600000000001, "text": " You didn't talk about that if I'm correct.", "tokens": [509, 994, 380, 751, 466, 300, 498, 286, 478, 3006, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 278, "seek": 147020, "start": 1493.3600000000001, "end": 1494.3600000000001, "text": " That's true.", "tokens": [663, 311, 2074, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 279, "seek": 147020, "start": 1494.3600000000001, "end": 1498.8, "text": " I mean sometimes we say we should just let it crash in this community.", "tokens": [286, 914, 2171, 321, 584, 321, 820, 445, 718, 309, 8252, 294, 341, 1768, 13], "temperature": 0.0, "avg_logprob": -0.2782977524624076, "compression_ratio": 1.4766355140186915, "no_speech_prob": 0.0007636595400981605}, {"id": 280, "seek": 149880, "start": 1498.8, "end": 1500.96, "text": " That's not always the case.", "tokens": [663, 311, 406, 1009, 264, 1389, 13], "temperature": 0.0, "avg_logprob": -0.12858850877363603, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.00018024117161985487}, {"id": 281, "seek": 149880, "start": 1500.96, "end": 1507.1599999999999, "text": " Sometimes the protocol will say that if you're unable to decode a message you must ignore", "tokens": [4803, 264, 10336, 486, 584, 300, 498, 291, 434, 11299, 281, 979, 1429, 257, 3636, 291, 1633, 11200], "temperature": 0.0, "avg_logprob": -0.12858850877363603, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.00018024117161985487}, {"id": 282, "seek": 149880, "start": 1507.1599999999999, "end": 1508.9199999999998, "text": " it and just continue going.", "tokens": [309, 293, 445, 2354, 516, 13], "temperature": 0.0, "avg_logprob": -0.12858850877363603, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.00018024117161985487}, {"id": 283, "seek": 149880, "start": 1508.9199999999998, "end": 1519.0, "text": " In that case what I usually do is I define functions where I match on the data I received", "tokens": [682, 300, 1389, 437, 286, 2673, 360, 307, 286, 6964, 6828, 689, 286, 2995, 322, 264, 1412, 286, 4613], "temperature": 0.0, "avg_logprob": -0.12858850877363603, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.00018024117161985487}, {"id": 284, "seek": 149880, "start": 1519.0, "end": 1523.48, "text": " and then I always need to have a fallback clause in case it didn't match anything and", "tokens": [293, 550, 286, 1009, 643, 281, 362, 257, 2100, 3207, 25925, 294, 1389, 309, 994, 380, 2995, 1340, 293], "temperature": 0.0, "avg_logprob": -0.12858850877363603, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.00018024117161985487}, {"id": 285, "seek": 149880, "start": 1523.48, "end": 1528.6399999999999, "text": " then just lock an error and continue.", "tokens": [550, 445, 4017, 364, 6713, 293, 2354, 13], "temperature": 0.0, "avg_logprob": -0.12858850877363603, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.00018024117161985487}, {"id": 286, "seek": 152864, "start": 1528.64, "end": 1536.72, "text": " But I mean probably the proper thing to do in Erlang is to try to just die.", "tokens": [583, 286, 914, 1391, 264, 2296, 551, 281, 360, 294, 3300, 25241, 307, 281, 853, 281, 445, 978, 13], "temperature": 0.0, "avg_logprob": -0.24569652194068545, "compression_ratio": 1.6059113300492611, "no_speech_prob": 7.234536315081641e-05}, {"id": 287, "seek": 152864, "start": 1536.72, "end": 1540.5200000000002, "text": " There's also you could when you receive a message you could have a special process that", "tokens": [821, 311, 611, 291, 727, 562, 291, 4774, 257, 3636, 291, 727, 362, 257, 2121, 1399, 300], "temperature": 0.0, "avg_logprob": -0.24569652194068545, "compression_ratio": 1.6059113300492611, "no_speech_prob": 7.234536315081641e-05}, {"id": 288, "seek": 152864, "start": 1540.5200000000002, "end": 1547.16, "text": " is only for decoding so you start a task, decode a message and get the data structure", "tokens": [307, 787, 337, 979, 8616, 370, 291, 722, 257, 5633, 11, 979, 1429, 257, 3636, 293, 483, 264, 1412, 3877], "temperature": 0.0, "avg_logprob": -0.24569652194068545, "compression_ratio": 1.6059113300492611, "no_speech_prob": 7.234536315081641e-05}, {"id": 289, "seek": 152864, "start": 1547.16, "end": 1554.3600000000001, "text": " back but I think it depends on the use case how you want to handle bad data.", "tokens": [646, 457, 286, 519, 309, 5946, 322, 264, 764, 1389, 577, 291, 528, 281, 4813, 1578, 1412, 13], "temperature": 0.0, "avg_logprob": -0.24569652194068545, "compression_ratio": 1.6059113300492611, "no_speech_prob": 7.234536315081641e-05}, {"id": 290, "seek": 155436, "start": 1554.36, "end": 1558.8, "text": " Okay, thank you very much.", "tokens": [50364, 1033, 11, 1309, 291, 588, 709, 13, 50586], "temperature": 0.0, "avg_logprob": -0.3583702564239502, "compression_ratio": 0.7647058823529411, "no_speech_prob": 0.0008677710429765284}], "language": "en"}