{"text": " Hi, welcome to my talk. My name is Bartosz Gowaszewski. I work for Linaro. And today I wanted to talk about an issue that had been bothering me for some time, namely a certain family of youth after free bucks in the kernel that has been, for a long time, blamed on Devres and then that I decided to investigate a bit and only to find out that reality is often disappointing and everything is broken and the problem is actually much worse than if that was Devres' fault. So yeah, without further ado, let's stack in because the time is short. So typically your typical probe function in a device driver would look something like this without Devres. So you allocate some resource. If it fails, you bail out. You allocate a second resource. If it fails, you free the previous one, bail out, and so on and so forth. So every next resource would need, if it fails, you need to free the previous ones. Alternatively, you would do something like this. You would have labels at the end of the function and just jump to it when it's one of the allocations or resources. You wouldn't be able to acquire one of the resources. You would jump to it and free every previously allocated resource in reverse order. And then you need your remove function that would also drop these resources in reverse order. But you can use Devres and in this case it looks much better. You allocate a resource. If it fails, you bail out. You allocate a second resource. If it fails, you bail out immediately. You don't have to free those resources yourself. When a driver is detached, they will be dropped automatically in reverse order and with that you no longer need your remove function. So that is pretty sweet. But you will notice, if you send enough patches to different subsystems, you will notice that certain maintainers show a version to Devres. You would get comments like, oh no, keep Devres out of my subsystem or don't you know, Devres leads to, using these interfaces leads to crashes. But without, you would probably not get a lot of explanation on what the problem is. And so last year I stumbled upon a talk by Laurent Panchard from last year's Linux Plumbers conference. It's actually, the link is below so you can watch it. And yes, I watched that and then I started browsing Lore and noticed that Laurent actually had sent an email about that already in 2015 saying that if you open a device node in user space and you unbind the driver that exposed it, exported it, and try to do something with that open file descriptor called one of the system calls, you will get a nice stack trace in your kernel log. So I thought, okay, that's interesting. I read throughout discussion. I found out that there were several such discussions previously, of which I had not been aware. And I don't want to go into much detail, but the gist of it is that there are certain users in the kernel, mostly device drivers, or only device drivers, that allocate using devres, like case alloc in this example, allocate memory that is dropped in remove, but that's actually still referenced elsewhere, which leads to use after freebacks. And the first thing that popped in my mind was how is that different from calling any, from dropping these resources in remove. And I wasn't the only one, because many people asked about it. And one of the responses when something like this, it's not, it's the same thing, but the problem is that people don't understand the lifetime rules and expect magic interfaces to fix it for them. So I thought that this, while this is certainly true, I think that driver developers should not be expected to understand every detail of how kernel subsystems work, because they actually should care more about making the device work. And I would argue that you should actually expect magic interfaces in drivers to fix stuff for you. And if it's not straightforward, then it's a problem of the subsystem or of given interface and not of device driver developers. So I decided to investigate and see if maybe something changed. And I do maintain the GPIO subsystem. So this was the first one that I tried. I had this serial to USB converter cable plugged in that actually also has four GPIO pins. So I opened the GPIO device. I unplugged the cable. I tried to read the value of the pin and sure enough, it crashed, no point under reference. I was like, okay, that's interesting. I did not expect that, but it's certainly interesting. So I tried a different subsystem. I tried I2C. Surprisingly, it didn't crash. It just, like, when I tried to unbind the driver, it just hang, froze and did nothing. Okay, so that's interesting. But I realized that when I unplugged the cable, I had my picocon console open and it just, it didn't crash. It just exited. So certainly, UART is doing something right and other subsystems are not doing it correctly. So I decided to investigate a bit. So in the GPIO subsystem, we have two types of structures. One that the drivers see. This is the GPIO chip. And the second one that the drivers, the GPIO providers don't touch, don't even have access to, which is the GPIO device. And so this will be important in a second. So I looked at the crash that I had in GPIO and it turned out that it was a no pointer to reference at a certain line, the one that you can see above. And at the moment where I, like, I still had my device open, I tried to call one of the system calls and it turned out that the chip that you can see above, when the referencing gdev was no, was already gone. So this is nothing to do with DeVres. It's just that we had a bug in the GPIO character device code where when we, when the driver is going away and it calls GPIO chip remove, it can be called from DeVres or it can be called in your remove function. We simply said the chip to null because the driver is gone, but the, the, the, the, the, the, the struct device still can be referenced elsewhere. So we just numbed it down, which is the correct thing to do, but it, it still, it still needs to be, needs to be checked in the, in the character device code. This is, this was what we were not doing and this needs fixing clearly. And there is also a question of a race condition in the, in the, in the system call callbacks where if, even if we do check it in the beginning, we still need some locking because otherwise the, the driver can be removed when we are still executing the system call. So I looked at that and I thought, okay, this is easy enough to fix and that, that's definitely not, not linked to those errors that the discussion in, in the email thread was about. So I went over to I2C. I decided to see what's, what's going on in I2C. Why, why does it, why it can't I unbind the driver as for as long as I keep the device open? And it turned out that there is this strange completion and a comment about it, making it so that when the driver, when the driver is trying to delete the I2C adapter, it waits for as long as there are still references to the underlying struct device. Okay. It's, it's, it's not definitely the, the, the, the, the freezing when, when you're trying to unbind the driver is not the correct way, but at least it doesn't crash and someone had something, there was a purpose to, to doing that. So I, I thought, okay, so why, why does UART work? I, I looked at the UART code and figured out that actually UART does a smart thing. First, when you go into any of the, of the system call callbacks in the kernel, you check, you have a similar split like GPIO when you have a, where you have a structure that lives for as long as the struct device lives and a separate structure that is allocated by the driver. So it turned out that, yeah, it, it first checks if the driver is still there. If it is, then it locks it so that it cannot go away from under an executing system call. Okay. So this definitely makes sense. And I also noticed that spy def works fine, but upon further instruction, inspection of the code, it turns out that it also suffers from a race condition because the, when the spy def spy is checked, the spin lock is only taken for the duration of the check or like for, for reading that, for reading of the pointer, but later it's still that drive, the underlying driver can still go away while the lock is already released. So this is a concurrency issue. So I started thinking that there is, there is some misconception about Devers. I decided to fix some things. I started with GPIO. I sent some patches. They, they were, they, they went into, into mainline. They, they seemed like in this case, they did fix the issues. The, the, the user space would no longer crash. The kernel would no longer crash when the user space would unbind the driver and use the character device. I also sent some fixes to, for spy def. And then I send a fix for ITC. I remove this completion. This is when, when things went sideways actually. I, I removed that completion. I added locking. I started fiddling with this character device and I was proud of myself because I, I thought that I fixed this problem that has for, for a long time existed in ITC. And Wolfram, the maintainer of ITC, took that patch, reviewed it, said it passes all the, all his stress testing, but he's, he's having a gut feeling that something is wrong. And after a couple of days, he sends me an email and says that, okay, I found this discussion from a couple of years ago where this was explained in detail. And what happened? So what, what turned out, turned out to be the, the case with ITC. It turns out that ITC is a subsystem where drivers allocate the ITC, the struct ITC adapter, which embeds struct device. And they allocate that structure as part of a usually bigger structure that contains driver specific fields in probe. And then on remove, in the remove callback, they drop that memory, but it contains struct device, which is reference counted, unlike the, the, the structure that embeds it. So this is, this is why this, this whole completion waiting for completion is, is there in ITC because you must not drop free this memory containing struct device for as long as there are references to struct device. And I noticed that this is not the only subsystem that does it. There are, so every driver subsystem does things a bit differently. Some of them have that split, some of them don't. For instance, spy has the same problem as ITC, but unlike ITC, it doesn't expect the driver to allocate that data as part of the driver data. It expects it to be allocated separately and hand it over to, to the spy subsystem, which is not probably, it could use some improvement, but at least it doesn't crash and doesn't require the same type of weight, synchronous waiting for, for, for dropping all the, all the references to struct device. So actually this, this talk should be called don't let drivers allocate and control the lifetime of struct device because this is the, the, the culprit basically. So we, we have those systems that allocate struct device and there are more references to it. It's still referenced elsewhere. And then we drop this memory and we still, when the reference is like the, the, the, the, the driver along the, the struct device no longer exists, but it's, it's still referenced somewhere. And then the subsystem, the driver model tries to call, for instance, the release callback of the device and there's nothing there. So we, we have those crashes. So I, I, I didn't look at all the subsystems clearly and there are too many, but I, I just noticed that certain parts of the kernel get it right. So GPIO now with those fixes is, is fine. You are just fine. Word.doc is fine. They, they have this split where the struct device is allocated and managed by the subsystem while driver data does not contain the struct device. I'm not talking about the struct device that is passed to probe. I'm talking about struct device that is allocated by the drivers or the, the, the respective subsystems for those proper underlying devices. So like we have this, let's say a platform device for a GPIO chip and then we allocate a struct device per every bank. Just an example and many subsystems do that too. So there, there's this problem, but there are also other problems. So even those subsystems that get this part right often suffer from concurrency issues because there is no locking in the system call, callbacks in the kernel. So even if they do check if the, if the driver is still there or the device is still there or attached to the driver, they often don't lock the state. So it's, it's, it's possible that the driver will go away one, while they're still executing and they're referencing that pointer. This was the case in, in spy for instance. And I think that the issue is just about the logical scope of objects and not the scope in understood as, as, as a scope of a variable in a C programming language, but more, more like a logical scope of objects where you have, if something is allocated in probe, when you, when you attach, first attach the device to the driver and, and you allocate something in probe, it should only need to exist for as long as the driver is attached and as, as soon as it goes away, it should be freed and removed, be it in, with dev res or, or, or in remove. And yeah, so, so there is this problem with, with many subsystems that they don't have this and they let drivers allocate some data in probe and then handle it over to the subsystem or, or even do it implicitly, which leads to all these errors. So I, I know that Laurent's area of interest will probably be media and DRM, so I just skimmed through, through the use, user space device notes, codes in, in those subsystems and noticed that they seem to be getting part of it correctly, but there are concurrency issues as well. And the problem with DRM is that the RAM, the, the device handling code, the, the, the, the character block device, the, the handling code is not, is, is not centralized within the files, within the subsystem, meaning that we have many different struct file operations with different implementations for different callbacks, correct me if I'm wrong afterwards, but it, it, it seemed like, like it from, I'm not an expert on DRM, but it seemed like it just from looking at it. So what about dev res? Is it safe? I have found no evidence that it isn't. And if something can be freed and removed, it can be freed with dev res because dev res will do just that. It will, as soon as the driver gets detached from the device, the other way around, it will, it will free all, all resources allocated with dev res in reverse order. There is, there are some, some, some issues like dev mk realloc could use some semantic clarification because as, as it is right now, it's not clear whether the order, if you call dev mk realloc, does the order change or not when, when releasing those resources. In any case, I, is my strong belief that dev res makes code much more readable, safer, and it actually should be encouraged and, and not discouraged, but it has a limited scope. And on that point, how can we supplement it? Because a certain semblance of resource, of automated resource management, RAII, if you will, in C would be useful in the kernel. So yeah, the first thing that comes to mind would be using Rust. With Rust, these situations that I described would never, would clearly never, never be allowed to happen. But that's not, for, for now, we're still coding in C. So I was thinking that if you've ever coded in, in, in a user space library like Gillib, for instance, which is, I, I, I believe a golden standard of C programming in, in user space, you would notice that they use, make a, use of a lot of, clean up, clean up attributes. And this is something that GCC and Clang support, and I haven't seen that in the kernel, and I'm wondering why it's, because if we would use reference counting in conjunction with cleanup, we could actually make it. If I can interject for one second, but actually, at least not in core kernel code, but Peter Zilstra used this in somewhere in the kernel source code tree, at least. And I had proposed something like this, at least in person to a couple of people before, because I want to make use of this as well. So I would be very happy if this happened. Yeah. So I have a small example. So if you are, if you are not familiar with the cleanup attribute, it allows you to specify a cleanup function for a variable. And when the variable goes out of scope, it's called, so it's like a destructor in C++ basically. Alone, it's, it's useful within the scope of a single code block or a single function, but in conjunction, well, this is just another example of how to, how to use it, but in conjunction with reference counting, it's, it's quite useful because you can, like, you can see the, the, the foo and bar, foo create and bar functions on the right. You allocate a, a reference counted, automatically reference counted resource. You do something with it. If you bail out, the reference count goes to zero and then it's freed. But if you return it while also increasing the ref count and then grab it in another function in bar in this, in this case, then as soon as the, the, the foo create function returns, the reference count is decreased, but it's already two. So it goes down to one and we, without having to control free those resources manually, we just keep track of the references just by using reference counting and cleanup. And this is what Gillib does a lot. And it, and it works quite nice. It's, it makes programming in C in this space much easier. And what to do about the offending subsystems? It's a case by case issue because every subsystem does it differently. And I tried, I, I spoke to Wolfram a bit about what can we do in I2C. And it's, it would be very hard because you would have to do a sweeping change across the entire subsystem to make drivers not allocate I2C adapter, not, not I2C adapter, but rather the underlying struct device on its own instead let it handle, let, let I2C, the I2C subsystem handle it. Yes, I just wanted to bring that up and that's, that's it. I'm right on time. All right, questions? Thank you. I, I, I like your second slide. I felt when you say I was not completely wrong with my talk, so thank you for that. I was a bit worried. A few comments. It's multiple problems actually that you're trying to solve here. One is the race condition between IOC TL, so use space access in general and the remove function. And for everything that's based on character devices, there's a patch from Dan Williams that was posted in 2021. I think I don't know if you've seen that one, that attempts to fix it at the C dev level, which I think is the right place to do it instead of duplicating the same fix in all the subsystems. So it has been positively reviewed, not merged. I think it was just one review command that said that debug FS and proc FS had similar constructs. And so he was asked to just refactor the code to reuse the same instead of duplicating it. But that should be something we could upstream and solve. So that's one of them. This, I agree with you that there's nothing wrong with dev res or managed API in general. It was mostly DevM case at the lock in particular that I had trouble with. Things like DevM, IO remap for instance, is perfectly fine because you tie the lifetime management of the resource with the physical strike device, which is removed at the end of the remove function, and that is what you should do. So that's totally fine. The issues with the DevM functions come when we try to tie, as you said, the lifetime of a resource to the wrong device. DRM has grown its custom managed helpers based on dev res. So not DevM, but it's DRMM. That does do it relatively right. They tie the memory management to the CDEV that's exposed to user space. But where it breaks is when you have one physical device that exposed multiple CDEVs because then you have a top level data structure that covers all of those. So even if you allocate each of them dynamically, you will need to make sure that the top level structure will be released only when nothing else can have a reference to it. So I think there will always be cases where reference counting will be needed and the drivers will have to handle that. But in many cases, helpers should be possible to make it simpler. And also I mentioned that on the slide that I didn't say it out loud. You have some diverse resource, the diverse helpers that reach into other subsystems, which also have their own issues. So this can be dangerous as well. So I have seen in multiple places where drivers are allocating the strike device that is then getting passed to the framework. But then the solution that they are using is that they are basically instead of freeing the device in remove, they are just dropping the reference to that device that has been allocated. So someone is taking the ownership of that device and then you rely on the reference counting to that device and then freeing that strike device only from the release callback that is then set by the driver itself. This is what SPY does. But I2C is a worse example because you usually have a driver data. Inside it you have I2C adapter. Inside it you have strike device. And this strike device has this release callback. But in the release callback, you are in the subsystem, it cannot know what the outer layer structure is and where is it, what offset it adds to free it. So it sets the release callback of the strike device. It's another workaround I guess. It seems to me that the right thing to do is not let drivers allocate strike device instead do it in the subsystem if you need to. This also hides some additional complexity from the driver developers. On the slide about the state of the current subsystems you had a question mark after SPY. I wonder if you have doubts if it's fine today. Yeah, I think, no, this is the one, right? That one. This one? Yeah, there is a question mark in the SPY. Yes, I put it there because I haven't investigated that in detail so I wasn't sure if it works fine. It looks to be working fine, like just from testing it. I wasn't sure if it's correctly implemented, let's say, because it sounds good in theory. All right, the last question. So for systems like I2C, has anybody calculated the amount of pain for things like the I2C, has anybody calculated the amount of actual work to fix this? It looks like it's a lot because I did send some proposition to Wolfram about wrapping every the reference of the I2C adapter that dev into a helper that would then allow us to change that strike device into a pointer instead of the proper structure and allocate that inside the subsystem but it's not going to be easy. This is why I dropped the patch. I told Wolfram not to pursue that because it looks to me like it's not going to be that easy and I don't really want to get my hands that dirty. So for somebody else then? It's been like this for a long time so I'm not sure if anyone's going to step up to try to fix that. Okay, thank you. All right, thanks. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.120000000000001, "text": " Hi, welcome to my talk. My name is Bartosz Gowaszewski. I work for Linaro. And today", "tokens": [2421, 11, 2928, 281, 452, 751, 13, 1222, 1315, 307, 22338, 329, 89, 460, 305, 19601, 1023, 18020, 13, 286, 589, 337, 441, 6470, 78, 13, 400, 965], "temperature": 0.0, "avg_logprob": -0.27100714047749835, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.3938415050506592}, {"id": 1, "seek": 0, "start": 10.120000000000001, "end": 15.48, "text": " I wanted to talk about an issue that had been bothering me for some time, namely a certain", "tokens": [286, 1415, 281, 751, 466, 364, 2734, 300, 632, 668, 31432, 385, 337, 512, 565, 11, 20926, 257, 1629], "temperature": 0.0, "avg_logprob": -0.27100714047749835, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.3938415050506592}, {"id": 2, "seek": 0, "start": 15.48, "end": 21.64, "text": " family of youth after free bucks in the kernel that has been, for a long time, blamed on", "tokens": [1605, 295, 7503, 934, 1737, 11829, 294, 264, 28256, 300, 575, 668, 11, 337, 257, 938, 565, 11, 32027, 322], "temperature": 0.0, "avg_logprob": -0.27100714047749835, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.3938415050506592}, {"id": 3, "seek": 0, "start": 21.64, "end": 27.12, "text": " Devres and then that I decided to investigate a bit and only to find out that reality is", "tokens": [9096, 495, 293, 550, 300, 286, 3047, 281, 15013, 257, 857, 293, 787, 281, 915, 484, 300, 4103, 307], "temperature": 0.0, "avg_logprob": -0.27100714047749835, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.3938415050506592}, {"id": 4, "seek": 2712, "start": 27.12, "end": 31.8, "text": " often disappointing and everything is broken and the problem is actually much worse than", "tokens": [2049, 25054, 293, 1203, 307, 5463, 293, 264, 1154, 307, 767, 709, 5324, 813], "temperature": 0.0, "avg_logprob": -0.17282718082643905, "compression_ratio": 1.734375, "no_speech_prob": 0.0001524153194623068}, {"id": 5, "seek": 2712, "start": 31.8, "end": 39.64, "text": " if that was Devres' fault. So yeah, without further ado, let's stack in because the time", "tokens": [498, 300, 390, 9096, 495, 6, 7441, 13, 407, 1338, 11, 1553, 3052, 22450, 11, 718, 311, 8630, 294, 570, 264, 565], "temperature": 0.0, "avg_logprob": -0.17282718082643905, "compression_ratio": 1.734375, "no_speech_prob": 0.0001524153194623068}, {"id": 6, "seek": 2712, "start": 39.64, "end": 44.88, "text": " is short. So typically your typical probe function in a device driver would look something", "tokens": [307, 2099, 13, 407, 5850, 428, 7476, 22715, 2445, 294, 257, 4302, 6787, 576, 574, 746], "temperature": 0.0, "avg_logprob": -0.17282718082643905, "compression_ratio": 1.734375, "no_speech_prob": 0.0001524153194623068}, {"id": 7, "seek": 2712, "start": 44.88, "end": 49.28, "text": " like this without Devres. So you allocate some resource. If it fails, you bail out. You", "tokens": [411, 341, 1553, 9096, 495, 13, 407, 291, 35713, 512, 7684, 13, 759, 309, 18199, 11, 291, 19313, 484, 13, 509], "temperature": 0.0, "avg_logprob": -0.17282718082643905, "compression_ratio": 1.734375, "no_speech_prob": 0.0001524153194623068}, {"id": 8, "seek": 2712, "start": 49.28, "end": 55.120000000000005, "text": " allocate a second resource. If it fails, you free the previous one, bail out, and so on", "tokens": [35713, 257, 1150, 7684, 13, 759, 309, 18199, 11, 291, 1737, 264, 3894, 472, 11, 19313, 484, 11, 293, 370, 322], "temperature": 0.0, "avg_logprob": -0.17282718082643905, "compression_ratio": 1.734375, "no_speech_prob": 0.0001524153194623068}, {"id": 9, "seek": 5512, "start": 55.12, "end": 62.08, "text": " and so forth. So every next resource would need, if it fails, you need to free the previous", "tokens": [293, 370, 5220, 13, 407, 633, 958, 7684, 576, 643, 11, 498, 309, 18199, 11, 291, 643, 281, 1737, 264, 3894], "temperature": 0.0, "avg_logprob": -0.15507903189029335, "compression_ratio": 1.8907563025210083, "no_speech_prob": 4.815242937183939e-05}, {"id": 10, "seek": 5512, "start": 62.08, "end": 65.6, "text": " ones. Alternatively, you would do something like this. You would have labels at the end", "tokens": [2306, 13, 46167, 11, 291, 576, 360, 746, 411, 341, 13, 509, 576, 362, 16949, 412, 264, 917], "temperature": 0.0, "avg_logprob": -0.15507903189029335, "compression_ratio": 1.8907563025210083, "no_speech_prob": 4.815242937183939e-05}, {"id": 11, "seek": 5512, "start": 65.6, "end": 75.72, "text": " of the function and just jump to it when it's one of the allocations or resources. You wouldn't", "tokens": [295, 264, 2445, 293, 445, 3012, 281, 309, 562, 309, 311, 472, 295, 264, 12660, 763, 420, 3593, 13, 509, 2759, 380], "temperature": 0.0, "avg_logprob": -0.15507903189029335, "compression_ratio": 1.8907563025210083, "no_speech_prob": 4.815242937183939e-05}, {"id": 12, "seek": 5512, "start": 75.72, "end": 79.44, "text": " be able to acquire one of the resources. You would jump to it and free every previously", "tokens": [312, 1075, 281, 20001, 472, 295, 264, 3593, 13, 509, 576, 3012, 281, 309, 293, 1737, 633, 8046], "temperature": 0.0, "avg_logprob": -0.15507903189029335, "compression_ratio": 1.8907563025210083, "no_speech_prob": 4.815242937183939e-05}, {"id": 13, "seek": 5512, "start": 79.44, "end": 84.24, "text": " allocated resource in reverse order. And then you need your remove function that would", "tokens": [29772, 7684, 294, 9943, 1668, 13, 400, 550, 291, 643, 428, 4159, 2445, 300, 576], "temperature": 0.0, "avg_logprob": -0.15507903189029335, "compression_ratio": 1.8907563025210083, "no_speech_prob": 4.815242937183939e-05}, {"id": 14, "seek": 8424, "start": 84.24, "end": 91.0, "text": " also drop these resources in reverse order. But you can use Devres and in this case it", "tokens": [611, 3270, 613, 3593, 294, 9943, 1668, 13, 583, 291, 393, 764, 9096, 495, 293, 294, 341, 1389, 309], "temperature": 0.0, "avg_logprob": -0.1028526838009174, "compression_ratio": 1.7868852459016393, "no_speech_prob": 1.6417588994954713e-05}, {"id": 15, "seek": 8424, "start": 91.0, "end": 94.72, "text": " looks much better. You allocate a resource. If it fails, you bail out. You allocate a", "tokens": [1542, 709, 1101, 13, 509, 35713, 257, 7684, 13, 759, 309, 18199, 11, 291, 19313, 484, 13, 509, 35713, 257], "temperature": 0.0, "avg_logprob": -0.1028526838009174, "compression_ratio": 1.7868852459016393, "no_speech_prob": 1.6417588994954713e-05}, {"id": 16, "seek": 8424, "start": 94.72, "end": 99.8, "text": " second resource. If it fails, you bail out immediately. You don't have to free those", "tokens": [1150, 7684, 13, 759, 309, 18199, 11, 291, 19313, 484, 4258, 13, 509, 500, 380, 362, 281, 1737, 729], "temperature": 0.0, "avg_logprob": -0.1028526838009174, "compression_ratio": 1.7868852459016393, "no_speech_prob": 1.6417588994954713e-05}, {"id": 17, "seek": 8424, "start": 99.8, "end": 105.03999999999999, "text": " resources yourself. When a driver is detached, they will be dropped automatically in reverse", "tokens": [3593, 1803, 13, 1133, 257, 6787, 307, 42050, 11, 436, 486, 312, 8119, 6772, 294, 9943], "temperature": 0.0, "avg_logprob": -0.1028526838009174, "compression_ratio": 1.7868852459016393, "no_speech_prob": 1.6417588994954713e-05}, {"id": 18, "seek": 8424, "start": 105.03999999999999, "end": 111.03999999999999, "text": " order and with that you no longer need your remove function. So that is pretty sweet.", "tokens": [1668, 293, 365, 300, 291, 572, 2854, 643, 428, 4159, 2445, 13, 407, 300, 307, 1238, 3844, 13], "temperature": 0.0, "avg_logprob": -0.1028526838009174, "compression_ratio": 1.7868852459016393, "no_speech_prob": 1.6417588994954713e-05}, {"id": 19, "seek": 11104, "start": 111.04, "end": 115.88000000000001, "text": " But you will notice, if you send enough patches to different subsystems, you will notice that", "tokens": [583, 291, 486, 3449, 11, 498, 291, 2845, 1547, 26531, 281, 819, 2090, 9321, 82, 11, 291, 486, 3449, 300], "temperature": 0.0, "avg_logprob": -0.16118471963065012, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00039870713953860104}, {"id": 20, "seek": 11104, "start": 115.88000000000001, "end": 121.64, "text": " certain maintainers show a version to Devres. You would get comments like, oh no, keep Devres", "tokens": [1629, 6909, 433, 855, 257, 3037, 281, 9096, 495, 13, 509, 576, 483, 3053, 411, 11, 1954, 572, 11, 1066, 9096, 495], "temperature": 0.0, "avg_logprob": -0.16118471963065012, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00039870713953860104}, {"id": 21, "seek": 11104, "start": 121.64, "end": 126.68, "text": " out of my subsystem or don't you know, Devres leads to, using these interfaces leads to", "tokens": [484, 295, 452, 2090, 9321, 420, 500, 380, 291, 458, 11, 9096, 495, 6689, 281, 11, 1228, 613, 28416, 6689, 281], "temperature": 0.0, "avg_logprob": -0.16118471963065012, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00039870713953860104}, {"id": 22, "seek": 11104, "start": 126.68, "end": 135.44, "text": " crashes. But without, you would probably not get a lot of explanation on what the problem", "tokens": [28642, 13, 583, 1553, 11, 291, 576, 1391, 406, 483, 257, 688, 295, 10835, 322, 437, 264, 1154], "temperature": 0.0, "avg_logprob": -0.16118471963065012, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00039870713953860104}, {"id": 23, "seek": 13544, "start": 135.44, "end": 143.16, "text": " is. And so last year I stumbled upon a talk by Laurent Panchard from last year's Linux", "tokens": [307, 13, 400, 370, 1036, 1064, 286, 36668, 3564, 257, 751, 538, 49357, 48792, 515, 490, 1036, 1064, 311, 18734], "temperature": 0.0, "avg_logprob": -0.21051451217296513, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.00016339789726771414}, {"id": 24, "seek": 13544, "start": 143.16, "end": 150.52, "text": " Plumbers conference. It's actually, the link is below so you can watch it. And yes, I watched", "tokens": [2149, 36353, 7586, 13, 467, 311, 767, 11, 264, 2113, 307, 2507, 370, 291, 393, 1159, 309, 13, 400, 2086, 11, 286, 6337], "temperature": 0.0, "avg_logprob": -0.21051451217296513, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.00016339789726771414}, {"id": 25, "seek": 13544, "start": 150.52, "end": 155.2, "text": " that and then I started browsing Lore and noticed that Laurent actually had sent an", "tokens": [300, 293, 550, 286, 1409, 38602, 36994, 293, 5694, 300, 49357, 767, 632, 2279, 364], "temperature": 0.0, "avg_logprob": -0.21051451217296513, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.00016339789726771414}, {"id": 26, "seek": 13544, "start": 155.2, "end": 161.16, "text": " email about that already in 2015 saying that if you open a device node in user space and", "tokens": [3796, 466, 300, 1217, 294, 7546, 1566, 300, 498, 291, 1269, 257, 4302, 9984, 294, 4195, 1901, 293], "temperature": 0.0, "avg_logprob": -0.21051451217296513, "compression_ratio": 1.568888888888889, "no_speech_prob": 0.00016339789726771414}, {"id": 27, "seek": 16116, "start": 161.16, "end": 168.24, "text": " you unbind the driver that exposed it, exported it, and try to do something with that open", "tokens": [291, 517, 65, 471, 264, 6787, 300, 9495, 309, 11, 42055, 309, 11, 293, 853, 281, 360, 746, 365, 300, 1269], "temperature": 0.0, "avg_logprob": -0.17928307397024973, "compression_ratio": 1.6531365313653137, "no_speech_prob": 9.422809671377763e-05}, {"id": 28, "seek": 16116, "start": 168.24, "end": 174.28, "text": " file descriptor called one of the system calls, you will get a nice stack trace in your kernel", "tokens": [3991, 31280, 284, 1219, 472, 295, 264, 1185, 5498, 11, 291, 486, 483, 257, 1481, 8630, 13508, 294, 428, 28256], "temperature": 0.0, "avg_logprob": -0.17928307397024973, "compression_ratio": 1.6531365313653137, "no_speech_prob": 9.422809671377763e-05}, {"id": 29, "seek": 16116, "start": 174.28, "end": 179.28, "text": " log. So I thought, okay, that's interesting. I read throughout discussion. I found out", "tokens": [3565, 13, 407, 286, 1194, 11, 1392, 11, 300, 311, 1880, 13, 286, 1401, 3710, 5017, 13, 286, 1352, 484], "temperature": 0.0, "avg_logprob": -0.17928307397024973, "compression_ratio": 1.6531365313653137, "no_speech_prob": 9.422809671377763e-05}, {"id": 30, "seek": 16116, "start": 179.28, "end": 184.4, "text": " that there were several such discussions previously, of which I had not been aware.", "tokens": [300, 456, 645, 2940, 1270, 11088, 8046, 11, 295, 597, 286, 632, 406, 668, 3650, 13], "temperature": 0.0, "avg_logprob": -0.17928307397024973, "compression_ratio": 1.6531365313653137, "no_speech_prob": 9.422809671377763e-05}, {"id": 31, "seek": 16116, "start": 184.4, "end": 189.16, "text": " And I don't want to go into much detail, but the gist of it is that there are certain users", "tokens": [400, 286, 500, 380, 528, 281, 352, 666, 709, 2607, 11, 457, 264, 290, 468, 295, 309, 307, 300, 456, 366, 1629, 5022], "temperature": 0.0, "avg_logprob": -0.17928307397024973, "compression_ratio": 1.6531365313653137, "no_speech_prob": 9.422809671377763e-05}, {"id": 32, "seek": 18916, "start": 189.16, "end": 196.35999999999999, "text": " in the kernel, mostly device drivers, or only device drivers, that allocate using devres,", "tokens": [294, 264, 28256, 11, 5240, 4302, 11590, 11, 420, 787, 4302, 11590, 11, 300, 35713, 1228, 1905, 495, 11], "temperature": 0.0, "avg_logprob": -0.2516613006591797, "compression_ratio": 1.6952380952380952, "no_speech_prob": 3.160693449899554e-05}, {"id": 33, "seek": 18916, "start": 196.35999999999999, "end": 203.32, "text": " like case alloc in this example, allocate memory that is dropped in remove, but that's", "tokens": [411, 1389, 12660, 294, 341, 1365, 11, 35713, 4675, 300, 307, 8119, 294, 4159, 11, 457, 300, 311], "temperature": 0.0, "avg_logprob": -0.2516613006591797, "compression_ratio": 1.6952380952380952, "no_speech_prob": 3.160693449899554e-05}, {"id": 34, "seek": 18916, "start": 203.32, "end": 210.76, "text": " actually still referenced elsewhere, which leads to use after freebacks. And the first", "tokens": [767, 920, 32734, 14517, 11, 597, 6689, 281, 764, 934, 1737, 17758, 13, 400, 264, 700], "temperature": 0.0, "avg_logprob": -0.2516613006591797, "compression_ratio": 1.6952380952380952, "no_speech_prob": 3.160693449899554e-05}, {"id": 35, "seek": 18916, "start": 210.76, "end": 217.84, "text": " thing that popped in my mind was how is that different from calling any, from dropping these", "tokens": [551, 300, 21545, 294, 452, 1575, 390, 577, 307, 300, 819, 490, 5141, 604, 11, 490, 13601, 613], "temperature": 0.0, "avg_logprob": -0.2516613006591797, "compression_ratio": 1.6952380952380952, "no_speech_prob": 3.160693449899554e-05}, {"id": 36, "seek": 21784, "start": 217.84, "end": 223.76, "text": " resources in remove. And I wasn't the only one, because many people asked about it. And", "tokens": [3593, 294, 4159, 13, 400, 286, 2067, 380, 264, 787, 472, 11, 570, 867, 561, 2351, 466, 309, 13, 400], "temperature": 0.0, "avg_logprob": -0.12188529076977311, "compression_ratio": 1.663003663003663, "no_speech_prob": 2.207854231528472e-05}, {"id": 37, "seek": 21784, "start": 223.76, "end": 229.16, "text": " one of the responses when something like this, it's not, it's the same thing, but the problem", "tokens": [472, 295, 264, 13019, 562, 746, 411, 341, 11, 309, 311, 406, 11, 309, 311, 264, 912, 551, 11, 457, 264, 1154], "temperature": 0.0, "avg_logprob": -0.12188529076977311, "compression_ratio": 1.663003663003663, "no_speech_prob": 2.207854231528472e-05}, {"id": 38, "seek": 21784, "start": 229.16, "end": 233.56, "text": " is that people don't understand the lifetime rules and expect magic interfaces to fix it", "tokens": [307, 300, 561, 500, 380, 1223, 264, 11364, 4474, 293, 2066, 5585, 28416, 281, 3191, 309], "temperature": 0.0, "avg_logprob": -0.12188529076977311, "compression_ratio": 1.663003663003663, "no_speech_prob": 2.207854231528472e-05}, {"id": 39, "seek": 21784, "start": 233.56, "end": 240.68, "text": " for them. So I thought that this, while this is certainly true, I think that driver developers", "tokens": [337, 552, 13, 407, 286, 1194, 300, 341, 11, 1339, 341, 307, 3297, 2074, 11, 286, 519, 300, 6787, 8849], "temperature": 0.0, "avg_logprob": -0.12188529076977311, "compression_ratio": 1.663003663003663, "no_speech_prob": 2.207854231528472e-05}, {"id": 40, "seek": 21784, "start": 240.68, "end": 245.16, "text": " should not be expected to understand every detail of how kernel subsystems work, because", "tokens": [820, 406, 312, 5176, 281, 1223, 633, 2607, 295, 577, 28256, 2090, 9321, 82, 589, 11, 570], "temperature": 0.0, "avg_logprob": -0.12188529076977311, "compression_ratio": 1.663003663003663, "no_speech_prob": 2.207854231528472e-05}, {"id": 41, "seek": 24516, "start": 245.16, "end": 249.64, "text": " they actually should care more about making the device work. And I would argue that you", "tokens": [436, 767, 820, 1127, 544, 466, 1455, 264, 4302, 589, 13, 400, 286, 576, 9695, 300, 291], "temperature": 0.0, "avg_logprob": -0.1587665034275429, "compression_ratio": 1.6653846153846155, "no_speech_prob": 6.843289884272963e-05}, {"id": 42, "seek": 24516, "start": 249.64, "end": 254.92, "text": " should actually expect magic interfaces in drivers to fix stuff for you. And if it's", "tokens": [820, 767, 2066, 5585, 28416, 294, 11590, 281, 3191, 1507, 337, 291, 13, 400, 498, 309, 311], "temperature": 0.0, "avg_logprob": -0.1587665034275429, "compression_ratio": 1.6653846153846155, "no_speech_prob": 6.843289884272963e-05}, {"id": 43, "seek": 24516, "start": 254.92, "end": 260.04, "text": " not straightforward, then it's a problem of the subsystem or of given interface and", "tokens": [406, 15325, 11, 550, 309, 311, 257, 1154, 295, 264, 2090, 9321, 420, 295, 2212, 9226, 293], "temperature": 0.0, "avg_logprob": -0.1587665034275429, "compression_ratio": 1.6653846153846155, "no_speech_prob": 6.843289884272963e-05}, {"id": 44, "seek": 24516, "start": 260.04, "end": 268.24, "text": " not of device driver developers. So I decided to investigate and see if maybe something", "tokens": [406, 295, 4302, 6787, 8849, 13, 407, 286, 3047, 281, 15013, 293, 536, 498, 1310, 746], "temperature": 0.0, "avg_logprob": -0.1587665034275429, "compression_ratio": 1.6653846153846155, "no_speech_prob": 6.843289884272963e-05}, {"id": 45, "seek": 24516, "start": 268.24, "end": 273.92, "text": " changed. And I do maintain the GPIO subsystem. So this was the first one that I tried. I", "tokens": [3105, 13, 400, 286, 360, 6909, 264, 26039, 15167, 2090, 9321, 13, 407, 341, 390, 264, 700, 472, 300, 286, 3031, 13, 286], "temperature": 0.0, "avg_logprob": -0.1587665034275429, "compression_ratio": 1.6653846153846155, "no_speech_prob": 6.843289884272963e-05}, {"id": 46, "seek": 27392, "start": 273.92, "end": 284.16, "text": " had this serial to USB converter cable plugged in that actually also has four GPIO pins.", "tokens": [632, 341, 17436, 281, 10109, 33905, 8220, 25679, 294, 300, 767, 611, 575, 1451, 26039, 15167, 16392, 13], "temperature": 0.0, "avg_logprob": -0.16153919055897703, "compression_ratio": 1.5745614035087718, "no_speech_prob": 3.0677987524541095e-05}, {"id": 47, "seek": 27392, "start": 284.16, "end": 289.64000000000004, "text": " So I opened the GPIO device. I unplugged the cable. I tried to read the value of the pin", "tokens": [407, 286, 5625, 264, 26039, 15167, 4302, 13, 286, 39456, 3004, 264, 8220, 13, 286, 3031, 281, 1401, 264, 2158, 295, 264, 5447], "temperature": 0.0, "avg_logprob": -0.16153919055897703, "compression_ratio": 1.5745614035087718, "no_speech_prob": 3.0677987524541095e-05}, {"id": 48, "seek": 27392, "start": 289.64000000000004, "end": 295.8, "text": " and sure enough, it crashed, no point under reference. I was like, okay, that's interesting.", "tokens": [293, 988, 1547, 11, 309, 24190, 11, 572, 935, 833, 6408, 13, 286, 390, 411, 11, 1392, 11, 300, 311, 1880, 13], "temperature": 0.0, "avg_logprob": -0.16153919055897703, "compression_ratio": 1.5745614035087718, "no_speech_prob": 3.0677987524541095e-05}, {"id": 49, "seek": 27392, "start": 295.8, "end": 300.76, "text": " I did not expect that, but it's certainly interesting. So I tried a different subsystem.", "tokens": [286, 630, 406, 2066, 300, 11, 457, 309, 311, 3297, 1880, 13, 407, 286, 3031, 257, 819, 2090, 9321, 13], "temperature": 0.0, "avg_logprob": -0.16153919055897703, "compression_ratio": 1.5745614035087718, "no_speech_prob": 3.0677987524541095e-05}, {"id": 50, "seek": 30076, "start": 300.76, "end": 305.92, "text": " I tried I2C. Surprisingly, it didn't crash. It just, like, when I tried to unbind the", "tokens": [286, 3031, 286, 17, 34, 13, 49908, 11, 309, 994, 380, 8252, 13, 467, 445, 11, 411, 11, 562, 286, 3031, 281, 517, 65, 471, 264], "temperature": 0.0, "avg_logprob": -0.17426905822753908, "compression_ratio": 1.6245353159851301, "no_speech_prob": 3.3708671253407374e-05}, {"id": 51, "seek": 30076, "start": 305.92, "end": 313.15999999999997, "text": " driver, it just hang, froze and did nothing. Okay, so that's interesting. But I realized", "tokens": [6787, 11, 309, 445, 3967, 11, 46077, 293, 630, 1825, 13, 1033, 11, 370, 300, 311, 1880, 13, 583, 286, 5334], "temperature": 0.0, "avg_logprob": -0.17426905822753908, "compression_ratio": 1.6245353159851301, "no_speech_prob": 3.3708671253407374e-05}, {"id": 52, "seek": 30076, "start": 313.15999999999997, "end": 317.71999999999997, "text": " that when I unplugged the cable, I had my picocon console open and it just, it didn't", "tokens": [300, 562, 286, 39456, 3004, 264, 8220, 11, 286, 632, 452, 13363, 905, 266, 11076, 1269, 293, 309, 445, 11, 309, 994, 380], "temperature": 0.0, "avg_logprob": -0.17426905822753908, "compression_ratio": 1.6245353159851301, "no_speech_prob": 3.3708671253407374e-05}, {"id": 53, "seek": 30076, "start": 317.71999999999997, "end": 322.28, "text": " crash. It just exited. So certainly, UART is doing something right and other subsystems", "tokens": [8252, 13, 467, 445, 454, 1226, 13, 407, 3297, 11, 624, 15118, 307, 884, 746, 558, 293, 661, 2090, 9321, 82], "temperature": 0.0, "avg_logprob": -0.17426905822753908, "compression_ratio": 1.6245353159851301, "no_speech_prob": 3.3708671253407374e-05}, {"id": 54, "seek": 30076, "start": 322.28, "end": 329.71999999999997, "text": " are not doing it correctly. So I decided to investigate a bit. So in the GPIO subsystem,", "tokens": [366, 406, 884, 309, 8944, 13, 407, 286, 3047, 281, 15013, 257, 857, 13, 407, 294, 264, 26039, 15167, 2090, 9321, 11], "temperature": 0.0, "avg_logprob": -0.17426905822753908, "compression_ratio": 1.6245353159851301, "no_speech_prob": 3.3708671253407374e-05}, {"id": 55, "seek": 32972, "start": 329.72, "end": 335.68, "text": " we have two types of structures. One that the drivers see. This is the GPIO chip. And", "tokens": [321, 362, 732, 3467, 295, 9227, 13, 1485, 300, 264, 11590, 536, 13, 639, 307, 264, 26039, 15167, 11409, 13, 400], "temperature": 0.0, "avg_logprob": -0.13501862918629365, "compression_ratio": 1.7211155378486056, "no_speech_prob": 2.2046846424927935e-05}, {"id": 56, "seek": 32972, "start": 335.68, "end": 340.92, "text": " the second one that the drivers, the GPIO providers don't touch, don't even have access", "tokens": [264, 1150, 472, 300, 264, 11590, 11, 264, 26039, 15167, 11330, 500, 380, 2557, 11, 500, 380, 754, 362, 2105], "temperature": 0.0, "avg_logprob": -0.13501862918629365, "compression_ratio": 1.7211155378486056, "no_speech_prob": 2.2046846424927935e-05}, {"id": 57, "seek": 32972, "start": 340.92, "end": 349.08000000000004, "text": " to, which is the GPIO device. And so this will be important in a second. So I looked", "tokens": [281, 11, 597, 307, 264, 26039, 15167, 4302, 13, 400, 370, 341, 486, 312, 1021, 294, 257, 1150, 13, 407, 286, 2956], "temperature": 0.0, "avg_logprob": -0.13501862918629365, "compression_ratio": 1.7211155378486056, "no_speech_prob": 2.2046846424927935e-05}, {"id": 58, "seek": 32972, "start": 349.08000000000004, "end": 353.28000000000003, "text": " at the crash that I had in GPIO and it turned out that it was a no pointer to reference", "tokens": [412, 264, 8252, 300, 286, 632, 294, 26039, 15167, 293, 309, 3574, 484, 300, 309, 390, 257, 572, 23918, 281, 6408], "temperature": 0.0, "avg_logprob": -0.13501862918629365, "compression_ratio": 1.7211155378486056, "no_speech_prob": 2.2046846424927935e-05}, {"id": 59, "seek": 32972, "start": 353.28000000000003, "end": 358.84000000000003, "text": " at a certain line, the one that you can see above. And at the moment where I, like, I", "tokens": [412, 257, 1629, 1622, 11, 264, 472, 300, 291, 393, 536, 3673, 13, 400, 412, 264, 1623, 689, 286, 11, 411, 11, 286], "temperature": 0.0, "avg_logprob": -0.13501862918629365, "compression_ratio": 1.7211155378486056, "no_speech_prob": 2.2046846424927935e-05}, {"id": 60, "seek": 35884, "start": 358.84, "end": 363.32, "text": " still had my device open, I tried to call one of the system calls and it turned out", "tokens": [920, 632, 452, 4302, 1269, 11, 286, 3031, 281, 818, 472, 295, 264, 1185, 5498, 293, 309, 3574, 484], "temperature": 0.0, "avg_logprob": -0.20617251560605807, "compression_ratio": 1.704724409448819, "no_speech_prob": 8.32575824460946e-05}, {"id": 61, "seek": 35884, "start": 363.32, "end": 369.67999999999995, "text": " that the chip that you can see above, when the referencing gdev was no, was already gone.", "tokens": [300, 264, 11409, 300, 291, 393, 536, 3673, 11, 562, 264, 40582, 290, 40343, 390, 572, 11, 390, 1217, 2780, 13], "temperature": 0.0, "avg_logprob": -0.20617251560605807, "compression_ratio": 1.704724409448819, "no_speech_prob": 8.32575824460946e-05}, {"id": 62, "seek": 35884, "start": 369.67999999999995, "end": 375.79999999999995, "text": " So this is nothing to do with DeVres. It's just that we had a bug in the GPIO character", "tokens": [407, 341, 307, 1825, 281, 360, 365, 1346, 53, 495, 13, 467, 311, 445, 300, 321, 632, 257, 7426, 294, 264, 26039, 15167, 2517], "temperature": 0.0, "avg_logprob": -0.20617251560605807, "compression_ratio": 1.704724409448819, "no_speech_prob": 8.32575824460946e-05}, {"id": 63, "seek": 35884, "start": 375.79999999999995, "end": 382.64, "text": " device code where when we, when the driver is going away and it calls GPIO chip remove,", "tokens": [4302, 3089, 689, 562, 321, 11, 562, 264, 6787, 307, 516, 1314, 293, 309, 5498, 26039, 15167, 11409, 4159, 11], "temperature": 0.0, "avg_logprob": -0.20617251560605807, "compression_ratio": 1.704724409448819, "no_speech_prob": 8.32575824460946e-05}, {"id": 64, "seek": 35884, "start": 382.64, "end": 386.0, "text": " it can be called from DeVres or it can be called in your remove function. We simply", "tokens": [309, 393, 312, 1219, 490, 1346, 53, 495, 420, 309, 393, 312, 1219, 294, 428, 4159, 2445, 13, 492, 2935], "temperature": 0.0, "avg_logprob": -0.20617251560605807, "compression_ratio": 1.704724409448819, "no_speech_prob": 8.32575824460946e-05}, {"id": 65, "seek": 38600, "start": 386.0, "end": 392.96, "text": " said the chip to null because the driver is gone, but the, the, the, the, the, the, the", "tokens": [848, 264, 11409, 281, 18184, 570, 264, 6787, 307, 2780, 11, 457, 264, 11, 264, 11, 264, 11, 264, 11, 264, 11, 264, 11, 264], "temperature": 0.0, "avg_logprob": -0.1861611335508285, "compression_ratio": 1.8663967611336032, "no_speech_prob": 0.0001242969010490924}, {"id": 66, "seek": 38600, "start": 392.96, "end": 397.56, "text": " struct device still can be referenced elsewhere. So we just numbed it down, which is the correct", "tokens": [6594, 4302, 920, 393, 312, 32734, 14517, 13, 407, 321, 445, 1031, 2883, 309, 760, 11, 597, 307, 264, 3006], "temperature": 0.0, "avg_logprob": -0.1861611335508285, "compression_ratio": 1.8663967611336032, "no_speech_prob": 0.0001242969010490924}, {"id": 67, "seek": 38600, "start": 397.56, "end": 404.08, "text": " thing to do, but it, it still, it still needs to be, needs to be checked in the, in the", "tokens": [551, 281, 360, 11, 457, 309, 11, 309, 920, 11, 309, 920, 2203, 281, 312, 11, 2203, 281, 312, 10033, 294, 264, 11, 294, 264], "temperature": 0.0, "avg_logprob": -0.1861611335508285, "compression_ratio": 1.8663967611336032, "no_speech_prob": 0.0001242969010490924}, {"id": 68, "seek": 38600, "start": 404.08, "end": 408.52, "text": " character device code. This is, this was what we were not doing and this needs fixing clearly.", "tokens": [2517, 4302, 3089, 13, 639, 307, 11, 341, 390, 437, 321, 645, 406, 884, 293, 341, 2203, 19442, 4448, 13], "temperature": 0.0, "avg_logprob": -0.1861611335508285, "compression_ratio": 1.8663967611336032, "no_speech_prob": 0.0001242969010490924}, {"id": 69, "seek": 38600, "start": 408.52, "end": 414.56, "text": " And there is also a question of a race condition in the, in the, in the system call callbacks", "tokens": [400, 456, 307, 611, 257, 1168, 295, 257, 4569, 4188, 294, 264, 11, 294, 264, 11, 294, 264, 1185, 818, 818, 17758], "temperature": 0.0, "avg_logprob": -0.1861611335508285, "compression_ratio": 1.8663967611336032, "no_speech_prob": 0.0001242969010490924}, {"id": 70, "seek": 41456, "start": 414.56, "end": 419.32, "text": " where if, even if we do check it in the beginning, we still need some locking because otherwise", "tokens": [689, 498, 11, 754, 498, 321, 360, 1520, 309, 294, 264, 2863, 11, 321, 920, 643, 512, 23954, 570, 5911], "temperature": 0.0, "avg_logprob": -0.12799812720073916, "compression_ratio": 1.6642066420664208, "no_speech_prob": 6.762637349311262e-05}, {"id": 71, "seek": 41456, "start": 419.32, "end": 425.2, "text": " the, the driver can be removed when we are still executing the system call. So I looked", "tokens": [264, 11, 264, 6787, 393, 312, 7261, 562, 321, 366, 920, 32368, 264, 1185, 818, 13, 407, 286, 2956], "temperature": 0.0, "avg_logprob": -0.12799812720073916, "compression_ratio": 1.6642066420664208, "no_speech_prob": 6.762637349311262e-05}, {"id": 72, "seek": 41456, "start": 425.2, "end": 430.4, "text": " at that and I thought, okay, this is easy enough to fix and that, that's definitely", "tokens": [412, 300, 293, 286, 1194, 11, 1392, 11, 341, 307, 1858, 1547, 281, 3191, 293, 300, 11, 300, 311, 2138], "temperature": 0.0, "avg_logprob": -0.12799812720073916, "compression_ratio": 1.6642066420664208, "no_speech_prob": 6.762637349311262e-05}, {"id": 73, "seek": 41456, "start": 430.4, "end": 436.96, "text": " not, not linked to those errors that the discussion in, in the email thread was about. So I went", "tokens": [406, 11, 406, 9408, 281, 729, 13603, 300, 264, 5017, 294, 11, 294, 264, 3796, 7207, 390, 466, 13, 407, 286, 1437], "temperature": 0.0, "avg_logprob": -0.12799812720073916, "compression_ratio": 1.6642066420664208, "no_speech_prob": 6.762637349311262e-05}, {"id": 74, "seek": 41456, "start": 436.96, "end": 442.04, "text": " over to I2C. I decided to see what's, what's going on in I2C. Why, why does it, why it", "tokens": [670, 281, 286, 17, 34, 13, 286, 3047, 281, 536, 437, 311, 11, 437, 311, 516, 322, 294, 286, 17, 34, 13, 1545, 11, 983, 775, 309, 11, 983, 309], "temperature": 0.0, "avg_logprob": -0.12799812720073916, "compression_ratio": 1.6642066420664208, "no_speech_prob": 6.762637349311262e-05}, {"id": 75, "seek": 44204, "start": 442.04, "end": 446.96000000000004, "text": " can't I unbind the driver as for as long as I keep the device open? And it turned out", "tokens": [393, 380, 286, 517, 65, 471, 264, 6787, 382, 337, 382, 938, 382, 286, 1066, 264, 4302, 1269, 30, 400, 309, 3574, 484], "temperature": 0.0, "avg_logprob": -0.15939471062193525, "compression_ratio": 1.676056338028169, "no_speech_prob": 2.9701812309212983e-05}, {"id": 76, "seek": 44204, "start": 446.96000000000004, "end": 452.44, "text": " that there is this strange completion and a comment about it, making it so that when", "tokens": [300, 456, 307, 341, 5861, 19372, 293, 257, 2871, 466, 309, 11, 1455, 309, 370, 300, 562], "temperature": 0.0, "avg_logprob": -0.15939471062193525, "compression_ratio": 1.676056338028169, "no_speech_prob": 2.9701812309212983e-05}, {"id": 77, "seek": 44204, "start": 452.44, "end": 459.24, "text": " the driver, when the driver is trying to delete the I2C adapter, it waits for as long as there", "tokens": [264, 6787, 11, 562, 264, 6787, 307, 1382, 281, 12097, 264, 286, 17, 34, 22860, 11, 309, 40597, 337, 382, 938, 382, 456], "temperature": 0.0, "avg_logprob": -0.15939471062193525, "compression_ratio": 1.676056338028169, "no_speech_prob": 2.9701812309212983e-05}, {"id": 78, "seek": 44204, "start": 459.24, "end": 465.96000000000004, "text": " are still references to the underlying struct device. Okay. It's, it's, it's not definitely", "tokens": [366, 920, 15400, 281, 264, 14217, 6594, 4302, 13, 1033, 13, 467, 311, 11, 309, 311, 11, 309, 311, 406, 2138], "temperature": 0.0, "avg_logprob": -0.15939471062193525, "compression_ratio": 1.676056338028169, "no_speech_prob": 2.9701812309212983e-05}, {"id": 79, "seek": 46596, "start": 465.96, "end": 472.12, "text": " the, the, the, the, the freezing when, when you're trying to unbind the driver is not", "tokens": [264, 11, 264, 11, 264, 11, 264, 11, 264, 20200, 562, 11, 562, 291, 434, 1382, 281, 517, 65, 471, 264, 6787, 307, 406], "temperature": 0.0, "avg_logprob": -0.1521199143777682, "compression_ratio": 1.6908396946564885, "no_speech_prob": 6.334195404633647e-06}, {"id": 80, "seek": 46596, "start": 472.12, "end": 476.76, "text": " the correct way, but at least it doesn't crash and someone had something, there was a purpose", "tokens": [264, 3006, 636, 11, 457, 412, 1935, 309, 1177, 380, 8252, 293, 1580, 632, 746, 11, 456, 390, 257, 4334], "temperature": 0.0, "avg_logprob": -0.1521199143777682, "compression_ratio": 1.6908396946564885, "no_speech_prob": 6.334195404633647e-06}, {"id": 81, "seek": 46596, "start": 476.76, "end": 484.35999999999996, "text": " to, to doing that. So I, I thought, okay, so why, why does UART work? I, I looked at", "tokens": [281, 11, 281, 884, 300, 13, 407, 286, 11, 286, 1194, 11, 1392, 11, 370, 983, 11, 983, 775, 624, 15118, 589, 30, 286, 11, 286, 2956, 412], "temperature": 0.0, "avg_logprob": -0.1521199143777682, "compression_ratio": 1.6908396946564885, "no_speech_prob": 6.334195404633647e-06}, {"id": 82, "seek": 46596, "start": 484.35999999999996, "end": 488.79999999999995, "text": " the UART code and figured out that actually UART does a smart thing. First, when you go", "tokens": [264, 624, 15118, 3089, 293, 8932, 484, 300, 767, 624, 15118, 775, 257, 4069, 551, 13, 2386, 11, 562, 291, 352], "temperature": 0.0, "avg_logprob": -0.1521199143777682, "compression_ratio": 1.6908396946564885, "no_speech_prob": 6.334195404633647e-06}, {"id": 83, "seek": 46596, "start": 488.79999999999995, "end": 495.12, "text": " into any of the, of the system call callbacks in the kernel, you check, you have a similar", "tokens": [666, 604, 295, 264, 11, 295, 264, 1185, 818, 818, 17758, 294, 264, 28256, 11, 291, 1520, 11, 291, 362, 257, 2531], "temperature": 0.0, "avg_logprob": -0.1521199143777682, "compression_ratio": 1.6908396946564885, "no_speech_prob": 6.334195404633647e-06}, {"id": 84, "seek": 49512, "start": 495.12, "end": 498.96, "text": " split like GPIO when you have a, where you have a structure that lives for as long as", "tokens": [7472, 411, 26039, 15167, 562, 291, 362, 257, 11, 689, 291, 362, 257, 3877, 300, 2909, 337, 382, 938, 382], "temperature": 0.0, "avg_logprob": -0.11546515370463277, "compression_ratio": 1.663594470046083, "no_speech_prob": 7.054202342260396e-06}, {"id": 85, "seek": 49512, "start": 498.96, "end": 506.72, "text": " the struct device lives and a separate structure that is allocated by the driver. So it turned", "tokens": [264, 6594, 4302, 2909, 293, 257, 4994, 3877, 300, 307, 29772, 538, 264, 6787, 13, 407, 309, 3574], "temperature": 0.0, "avg_logprob": -0.11546515370463277, "compression_ratio": 1.663594470046083, "no_speech_prob": 7.054202342260396e-06}, {"id": 86, "seek": 49512, "start": 506.72, "end": 511.68, "text": " out that, yeah, it, it first checks if the driver is still there. If it is, then it locks", "tokens": [484, 300, 11, 1338, 11, 309, 11, 309, 700, 13834, 498, 264, 6787, 307, 920, 456, 13, 759, 309, 307, 11, 550, 309, 20703], "temperature": 0.0, "avg_logprob": -0.11546515370463277, "compression_ratio": 1.663594470046083, "no_speech_prob": 7.054202342260396e-06}, {"id": 87, "seek": 49512, "start": 511.68, "end": 517.88, "text": " it so that it cannot go away from under an executing system call. Okay. So this definitely", "tokens": [309, 370, 300, 309, 2644, 352, 1314, 490, 833, 364, 32368, 1185, 818, 13, 1033, 13, 407, 341, 2138], "temperature": 0.0, "avg_logprob": -0.11546515370463277, "compression_ratio": 1.663594470046083, "no_speech_prob": 7.054202342260396e-06}, {"id": 88, "seek": 51788, "start": 517.88, "end": 525.64, "text": " makes sense. And I also noticed that spy def works fine, but upon further instruction,", "tokens": [1669, 2020, 13, 400, 286, 611, 5694, 300, 20752, 1060, 1985, 2489, 11, 457, 3564, 3052, 10951, 11], "temperature": 0.0, "avg_logprob": -0.19553943013035974, "compression_ratio": 1.6990291262135921, "no_speech_prob": 1.0600027053442318e-05}, {"id": 89, "seek": 51788, "start": 525.64, "end": 529.52, "text": " inspection of the code, it turns out that it also suffers from a race condition because", "tokens": [22085, 295, 264, 3089, 11, 309, 4523, 484, 300, 309, 611, 33776, 490, 257, 4569, 4188, 570], "temperature": 0.0, "avg_logprob": -0.19553943013035974, "compression_ratio": 1.6990291262135921, "no_speech_prob": 1.0600027053442318e-05}, {"id": 90, "seek": 51788, "start": 529.52, "end": 536.36, "text": " the, when the spy def spy is checked, the spin lock is only taken for the duration of", "tokens": [264, 11, 562, 264, 20752, 1060, 20752, 307, 10033, 11, 264, 6060, 4017, 307, 787, 2726, 337, 264, 16365, 295], "temperature": 0.0, "avg_logprob": -0.19553943013035974, "compression_ratio": 1.6990291262135921, "no_speech_prob": 1.0600027053442318e-05}, {"id": 91, "seek": 51788, "start": 536.36, "end": 543.24, "text": " the check or like for, for reading that, for reading of the pointer, but later it's still", "tokens": [264, 1520, 420, 411, 337, 11, 337, 3760, 300, 11, 337, 3760, 295, 264, 23918, 11, 457, 1780, 309, 311, 920], "temperature": 0.0, "avg_logprob": -0.19553943013035974, "compression_ratio": 1.6990291262135921, "no_speech_prob": 1.0600027053442318e-05}, {"id": 92, "seek": 54324, "start": 543.24, "end": 548.04, "text": " that drive, the underlying driver can still go away while the lock is already released.", "tokens": [300, 3332, 11, 264, 14217, 6787, 393, 920, 352, 1314, 1339, 264, 4017, 307, 1217, 4736, 13], "temperature": 0.0, "avg_logprob": -0.20526463409949994, "compression_ratio": 1.7413127413127414, "no_speech_prob": 1.0283452866133302e-05}, {"id": 93, "seek": 54324, "start": 548.04, "end": 555.2, "text": " So this is a concurrency issue. So I started thinking that there is, there is some misconception", "tokens": [407, 341, 307, 257, 23702, 10457, 2734, 13, 407, 286, 1409, 1953, 300, 456, 307, 11, 456, 307, 512, 41350], "temperature": 0.0, "avg_logprob": -0.20526463409949994, "compression_ratio": 1.7413127413127414, "no_speech_prob": 1.0283452866133302e-05}, {"id": 94, "seek": 54324, "start": 555.2, "end": 561.36, "text": " about Devers. I decided to fix some things. I started with GPIO. I sent some patches.", "tokens": [466, 1346, 840, 13, 286, 3047, 281, 3191, 512, 721, 13, 286, 1409, 365, 26039, 15167, 13, 286, 2279, 512, 26531, 13], "temperature": 0.0, "avg_logprob": -0.20526463409949994, "compression_ratio": 1.7413127413127414, "no_speech_prob": 1.0283452866133302e-05}, {"id": 95, "seek": 54324, "start": 561.36, "end": 566.76, "text": " They, they were, they, they went into, into mainline. They, they seemed like in this case,", "tokens": [814, 11, 436, 645, 11, 436, 11, 436, 1437, 666, 11, 666, 2135, 1889, 13, 814, 11, 436, 6576, 411, 294, 341, 1389, 11], "temperature": 0.0, "avg_logprob": -0.20526463409949994, "compression_ratio": 1.7413127413127414, "no_speech_prob": 1.0283452866133302e-05}, {"id": 96, "seek": 54324, "start": 566.76, "end": 571.36, "text": " they did fix the issues. The, the, the user space would no longer crash. The kernel would", "tokens": [436, 630, 3191, 264, 2663, 13, 440, 11, 264, 11, 264, 4195, 1901, 576, 572, 2854, 8252, 13, 440, 28256, 576], "temperature": 0.0, "avg_logprob": -0.20526463409949994, "compression_ratio": 1.7413127413127414, "no_speech_prob": 1.0283452866133302e-05}, {"id": 97, "seek": 57136, "start": 571.36, "end": 578.2, "text": " no longer crash when the user space would unbind the driver and use the character device.", "tokens": [572, 2854, 8252, 562, 264, 4195, 1901, 576, 517, 65, 471, 264, 6787, 293, 764, 264, 2517, 4302, 13], "temperature": 0.0, "avg_logprob": -0.17640668153762817, "compression_ratio": 1.663716814159292, "no_speech_prob": 4.3556456148508005e-06}, {"id": 98, "seek": 57136, "start": 578.2, "end": 586.72, "text": " I also sent some fixes to, for spy def. And then I send a fix for ITC. I remove this completion.", "tokens": [286, 611, 2279, 512, 32539, 281, 11, 337, 20752, 1060, 13, 400, 550, 286, 2845, 257, 3191, 337, 6783, 34, 13, 286, 4159, 341, 19372, 13], "temperature": 0.0, "avg_logprob": -0.17640668153762817, "compression_ratio": 1.663716814159292, "no_speech_prob": 4.3556456148508005e-06}, {"id": 99, "seek": 57136, "start": 586.72, "end": 594.32, "text": " This is when, when things went sideways actually. I, I removed that completion. I added locking.", "tokens": [639, 307, 562, 11, 562, 721, 1437, 26092, 767, 13, 286, 11, 286, 7261, 300, 19372, 13, 286, 3869, 23954, 13], "temperature": 0.0, "avg_logprob": -0.17640668153762817, "compression_ratio": 1.663716814159292, "no_speech_prob": 4.3556456148508005e-06}, {"id": 100, "seek": 57136, "start": 594.32, "end": 599.2, "text": " I started fiddling with this character device and I was proud of myself because I, I thought", "tokens": [286, 1409, 283, 14273, 1688, 365, 341, 2517, 4302, 293, 286, 390, 4570, 295, 2059, 570, 286, 11, 286, 1194], "temperature": 0.0, "avg_logprob": -0.17640668153762817, "compression_ratio": 1.663716814159292, "no_speech_prob": 4.3556456148508005e-06}, {"id": 101, "seek": 59920, "start": 599.2, "end": 604.0400000000001, "text": " that I fixed this problem that has for, for a long time existed in ITC. And Wolfram, the", "tokens": [300, 286, 6806, 341, 1154, 300, 575, 337, 11, 337, 257, 938, 565, 13135, 294, 6783, 34, 13, 400, 16634, 2356, 11, 264], "temperature": 0.0, "avg_logprob": -0.1637326073400753, "compression_ratio": 1.5663716814159292, "no_speech_prob": 0.0004002107307314873}, {"id": 102, "seek": 59920, "start": 604.0400000000001, "end": 609.8000000000001, "text": " maintainer of ITC, took that patch, reviewed it, said it passes all the, all his stress", "tokens": [6909, 260, 295, 6783, 34, 11, 1890, 300, 9972, 11, 18429, 309, 11, 848, 309, 11335, 439, 264, 11, 439, 702, 4244], "temperature": 0.0, "avg_logprob": -0.1637326073400753, "compression_ratio": 1.5663716814159292, "no_speech_prob": 0.0004002107307314873}, {"id": 103, "seek": 59920, "start": 609.8000000000001, "end": 615.5600000000001, "text": " testing, but he's, he's having a gut feeling that something is wrong. And after a couple", "tokens": [4997, 11, 457, 415, 311, 11, 415, 311, 1419, 257, 5228, 2633, 300, 746, 307, 2085, 13, 400, 934, 257, 1916], "temperature": 0.0, "avg_logprob": -0.1637326073400753, "compression_ratio": 1.5663716814159292, "no_speech_prob": 0.0004002107307314873}, {"id": 104, "seek": 59920, "start": 615.5600000000001, "end": 620.44, "text": " of days, he sends me an email and says that, okay, I found this discussion from a couple", "tokens": [295, 1708, 11, 415, 14790, 385, 364, 3796, 293, 1619, 300, 11, 1392, 11, 286, 1352, 341, 5017, 490, 257, 1916], "temperature": 0.0, "avg_logprob": -0.1637326073400753, "compression_ratio": 1.5663716814159292, "no_speech_prob": 0.0004002107307314873}, {"id": 105, "seek": 62044, "start": 620.44, "end": 629.44, "text": " of years ago where this was explained in detail. And what happened? So what, what turned out,", "tokens": [295, 924, 2057, 689, 341, 390, 8825, 294, 2607, 13, 400, 437, 2011, 30, 407, 437, 11, 437, 3574, 484, 11], "temperature": 0.0, "avg_logprob": -0.1804771851957514, "compression_ratio": 1.6883720930232557, "no_speech_prob": 2.190079067077022e-05}, {"id": 106, "seek": 62044, "start": 629.44, "end": 635.9200000000001, "text": " turned out to be the, the case with ITC. It turns out that ITC is a subsystem where drivers", "tokens": [3574, 484, 281, 312, 264, 11, 264, 1389, 365, 6783, 34, 13, 467, 4523, 484, 300, 6783, 34, 307, 257, 2090, 9321, 689, 11590], "temperature": 0.0, "avg_logprob": -0.1804771851957514, "compression_ratio": 1.6883720930232557, "no_speech_prob": 2.190079067077022e-05}, {"id": 107, "seek": 62044, "start": 635.9200000000001, "end": 642.48, "text": " allocate the ITC, the struct ITC adapter, which embeds struct device. And they allocate", "tokens": [35713, 264, 6783, 34, 11, 264, 6594, 6783, 34, 22860, 11, 597, 12240, 82, 6594, 4302, 13, 400, 436, 35713], "temperature": 0.0, "avg_logprob": -0.1804771851957514, "compression_ratio": 1.6883720930232557, "no_speech_prob": 2.190079067077022e-05}, {"id": 108, "seek": 62044, "start": 642.48, "end": 649.6800000000001, "text": " that structure as part of a usually bigger structure that contains driver specific fields", "tokens": [300, 3877, 382, 644, 295, 257, 2673, 3801, 3877, 300, 8306, 6787, 2685, 7909], "temperature": 0.0, "avg_logprob": -0.1804771851957514, "compression_ratio": 1.6883720930232557, "no_speech_prob": 2.190079067077022e-05}, {"id": 109, "seek": 64968, "start": 649.68, "end": 656.88, "text": " in probe. And then on remove, in the remove callback, they drop that memory, but it contains", "tokens": [294, 22715, 13, 400, 550, 322, 4159, 11, 294, 264, 4159, 818, 3207, 11, 436, 3270, 300, 4675, 11, 457, 309, 8306], "temperature": 0.0, "avg_logprob": -0.1808363713255716, "compression_ratio": 1.8326530612244898, "no_speech_prob": 4.857429757976206e-06}, {"id": 110, "seek": 64968, "start": 656.88, "end": 661.52, "text": " struct device, which is reference counted, unlike the, the, the structure that embeds", "tokens": [6594, 4302, 11, 597, 307, 6408, 20150, 11, 8343, 264, 11, 264, 11, 264, 3877, 300, 12240, 82], "temperature": 0.0, "avg_logprob": -0.1808363713255716, "compression_ratio": 1.8326530612244898, "no_speech_prob": 4.857429757976206e-06}, {"id": 111, "seek": 64968, "start": 661.52, "end": 667.1999999999999, "text": " it. So this is, this is why this, this whole completion waiting for completion is, is there", "tokens": [309, 13, 407, 341, 307, 11, 341, 307, 983, 341, 11, 341, 1379, 19372, 3806, 337, 19372, 307, 11, 307, 456], "temperature": 0.0, "avg_logprob": -0.1808363713255716, "compression_ratio": 1.8326530612244898, "no_speech_prob": 4.857429757976206e-06}, {"id": 112, "seek": 64968, "start": 667.1999999999999, "end": 673.1999999999999, "text": " in ITC because you must not drop free this memory containing struct device for as long", "tokens": [294, 6783, 34, 570, 291, 1633, 406, 3270, 1737, 341, 4675, 19273, 6594, 4302, 337, 382, 938], "temperature": 0.0, "avg_logprob": -0.1808363713255716, "compression_ratio": 1.8326530612244898, "no_speech_prob": 4.857429757976206e-06}, {"id": 113, "seek": 64968, "start": 673.1999999999999, "end": 677.12, "text": " as there are references to struct device. And I noticed that this is not the only subsystem", "tokens": [382, 456, 366, 15400, 281, 6594, 4302, 13, 400, 286, 5694, 300, 341, 307, 406, 264, 787, 2090, 9321], "temperature": 0.0, "avg_logprob": -0.1808363713255716, "compression_ratio": 1.8326530612244898, "no_speech_prob": 4.857429757976206e-06}, {"id": 114, "seek": 67712, "start": 677.12, "end": 682.0, "text": " that does it. There are, so every driver subsystem does things a bit differently. Some of them", "tokens": [300, 775, 309, 13, 821, 366, 11, 370, 633, 6787, 2090, 9321, 775, 721, 257, 857, 7614, 13, 2188, 295, 552], "temperature": 0.0, "avg_logprob": -0.14093219127851664, "compression_ratio": 1.6894977168949772, "no_speech_prob": 1.6165091437869705e-05}, {"id": 115, "seek": 67712, "start": 682.0, "end": 689.76, "text": " have that split, some of them don't. For instance, spy has the same problem as ITC, but unlike", "tokens": [362, 300, 7472, 11, 512, 295, 552, 500, 380, 13, 1171, 5197, 11, 20752, 575, 264, 912, 1154, 382, 6783, 34, 11, 457, 8343], "temperature": 0.0, "avg_logprob": -0.14093219127851664, "compression_ratio": 1.6894977168949772, "no_speech_prob": 1.6165091437869705e-05}, {"id": 116, "seek": 67712, "start": 689.76, "end": 697.68, "text": " ITC, it doesn't expect the driver to allocate that data as part of the driver data. It expects", "tokens": [6783, 34, 11, 309, 1177, 380, 2066, 264, 6787, 281, 35713, 300, 1412, 382, 644, 295, 264, 6787, 1412, 13, 467, 33280], "temperature": 0.0, "avg_logprob": -0.14093219127851664, "compression_ratio": 1.6894977168949772, "no_speech_prob": 1.6165091437869705e-05}, {"id": 117, "seek": 67712, "start": 697.68, "end": 704.36, "text": " it to be allocated separately and hand it over to, to the spy subsystem, which is not", "tokens": [309, 281, 312, 29772, 14759, 293, 1011, 309, 670, 281, 11, 281, 264, 20752, 2090, 9321, 11, 597, 307, 406], "temperature": 0.0, "avg_logprob": -0.14093219127851664, "compression_ratio": 1.6894977168949772, "no_speech_prob": 1.6165091437869705e-05}, {"id": 118, "seek": 70436, "start": 704.36, "end": 709.8000000000001, "text": " probably, it could use some improvement, but at least it doesn't crash and doesn't require", "tokens": [1391, 11, 309, 727, 764, 512, 10444, 11, 457, 412, 1935, 309, 1177, 380, 8252, 293, 1177, 380, 3651], "temperature": 0.0, "avg_logprob": -0.16662560631247128, "compression_ratio": 1.6681818181818182, "no_speech_prob": 5.331612101144856e-06}, {"id": 119, "seek": 70436, "start": 709.8000000000001, "end": 716.6, "text": " the same type of weight, synchronous waiting for, for, for dropping all the, all the references", "tokens": [264, 912, 2010, 295, 3364, 11, 44743, 3806, 337, 11, 337, 11, 337, 13601, 439, 264, 11, 439, 264, 15400], "temperature": 0.0, "avg_logprob": -0.16662560631247128, "compression_ratio": 1.6681818181818182, "no_speech_prob": 5.331612101144856e-06}, {"id": 120, "seek": 70436, "start": 716.6, "end": 723.32, "text": " to struct device. So actually this, this talk should be called don't let drivers allocate", "tokens": [281, 6594, 4302, 13, 407, 767, 341, 11, 341, 751, 820, 312, 1219, 500, 380, 718, 11590, 35713], "temperature": 0.0, "avg_logprob": -0.16662560631247128, "compression_ratio": 1.6681818181818182, "no_speech_prob": 5.331612101144856e-06}, {"id": 121, "seek": 70436, "start": 723.32, "end": 730.16, "text": " and control the lifetime of struct device because this is the, the, the culprit basically.", "tokens": [293, 1969, 264, 11364, 295, 6594, 4302, 570, 341, 307, 264, 11, 264, 11, 264, 39220, 1936, 13], "temperature": 0.0, "avg_logprob": -0.16662560631247128, "compression_ratio": 1.6681818181818182, "no_speech_prob": 5.331612101144856e-06}, {"id": 122, "seek": 73016, "start": 730.16, "end": 736.92, "text": " So we, we have those systems that allocate struct device and there are more references", "tokens": [407, 321, 11, 321, 362, 729, 3652, 300, 35713, 6594, 4302, 293, 456, 366, 544, 15400], "temperature": 0.0, "avg_logprob": -0.20548397029211762, "compression_ratio": 1.9732142857142858, "no_speech_prob": 1.111379788198974e-05}, {"id": 123, "seek": 73016, "start": 736.92, "end": 743.16, "text": " to it. It's still referenced elsewhere. And then we drop this memory and we still, when", "tokens": [281, 309, 13, 467, 311, 920, 32734, 14517, 13, 400, 550, 321, 3270, 341, 4675, 293, 321, 920, 11, 562], "temperature": 0.0, "avg_logprob": -0.20548397029211762, "compression_ratio": 1.9732142857142858, "no_speech_prob": 1.111379788198974e-05}, {"id": 124, "seek": 73016, "start": 743.16, "end": 747.6, "text": " the reference is like the, the, the, the, the driver along the, the struct device no", "tokens": [264, 6408, 307, 411, 264, 11, 264, 11, 264, 11, 264, 11, 264, 6787, 2051, 264, 11, 264, 6594, 4302, 572], "temperature": 0.0, "avg_logprob": -0.20548397029211762, "compression_ratio": 1.9732142857142858, "no_speech_prob": 1.111379788198974e-05}, {"id": 125, "seek": 73016, "start": 747.6, "end": 752.12, "text": " longer exists, but it's, it's still referenced somewhere. And then the subsystem, the driver", "tokens": [2854, 8198, 11, 457, 309, 311, 11, 309, 311, 920, 32734, 4079, 13, 400, 550, 264, 2090, 9321, 11, 264, 6787], "temperature": 0.0, "avg_logprob": -0.20548397029211762, "compression_ratio": 1.9732142857142858, "no_speech_prob": 1.111379788198974e-05}, {"id": 126, "seek": 73016, "start": 752.12, "end": 756.8399999999999, "text": " model tries to call, for instance, the release callback of the device and there's nothing", "tokens": [2316, 9898, 281, 818, 11, 337, 5197, 11, 264, 4374, 818, 3207, 295, 264, 4302, 293, 456, 311, 1825], "temperature": 0.0, "avg_logprob": -0.20548397029211762, "compression_ratio": 1.9732142857142858, "no_speech_prob": 1.111379788198974e-05}, {"id": 127, "seek": 75684, "start": 756.84, "end": 762.76, "text": " there. So we, we have those crashes. So I, I, I didn't look at all the subsystems clearly", "tokens": [456, 13, 407, 321, 11, 321, 362, 729, 28642, 13, 407, 286, 11, 286, 11, 286, 994, 380, 574, 412, 439, 264, 2090, 9321, 82, 4448], "temperature": 0.0, "avg_logprob": -0.17036601279279312, "compression_ratio": 1.881118881118881, "no_speech_prob": 2.0427398339961655e-05}, {"id": 128, "seek": 75684, "start": 762.76, "end": 767.6, "text": " and there are too many, but I, I just noticed that certain parts of the kernel get it right.", "tokens": [293, 456, 366, 886, 867, 11, 457, 286, 11, 286, 445, 5694, 300, 1629, 3166, 295, 264, 28256, 483, 309, 558, 13], "temperature": 0.0, "avg_logprob": -0.17036601279279312, "compression_ratio": 1.881118881118881, "no_speech_prob": 2.0427398339961655e-05}, {"id": 129, "seek": 75684, "start": 767.6, "end": 772.4, "text": " So GPIO now with those fixes is, is fine. You are just fine. Word.doc is fine. They,", "tokens": [407, 26039, 15167, 586, 365, 729, 32539, 307, 11, 307, 2489, 13, 509, 366, 445, 2489, 13, 8725, 13, 39966, 307, 2489, 13, 814, 11], "temperature": 0.0, "avg_logprob": -0.17036601279279312, "compression_ratio": 1.881118881118881, "no_speech_prob": 2.0427398339961655e-05}, {"id": 130, "seek": 75684, "start": 772.4, "end": 776.32, "text": " they have this split where the struct device is allocated and managed by the subsystem", "tokens": [436, 362, 341, 7472, 689, 264, 6594, 4302, 307, 29772, 293, 6453, 538, 264, 2090, 9321], "temperature": 0.0, "avg_logprob": -0.17036601279279312, "compression_ratio": 1.881118881118881, "no_speech_prob": 2.0427398339961655e-05}, {"id": 131, "seek": 75684, "start": 776.32, "end": 781.5600000000001, "text": " while driver data does not contain the struct device. I'm not talking about the struct device", "tokens": [1339, 6787, 1412, 775, 406, 5304, 264, 6594, 4302, 13, 286, 478, 406, 1417, 466, 264, 6594, 4302], "temperature": 0.0, "avg_logprob": -0.17036601279279312, "compression_ratio": 1.881118881118881, "no_speech_prob": 2.0427398339961655e-05}, {"id": 132, "seek": 75684, "start": 781.5600000000001, "end": 785.4000000000001, "text": " that is passed to probe. I'm talking about struct device that is allocated by the drivers", "tokens": [300, 307, 4678, 281, 22715, 13, 286, 478, 1417, 466, 6594, 4302, 300, 307, 29772, 538, 264, 11590], "temperature": 0.0, "avg_logprob": -0.17036601279279312, "compression_ratio": 1.881118881118881, "no_speech_prob": 2.0427398339961655e-05}, {"id": 133, "seek": 78540, "start": 785.4, "end": 790.8, "text": " or the, the, the respective subsystems for those proper underlying devices. So like we", "tokens": [420, 264, 11, 264, 11, 264, 23649, 2090, 9321, 82, 337, 729, 2296, 14217, 5759, 13, 407, 411, 321], "temperature": 0.0, "avg_logprob": -0.1524153803731059, "compression_ratio": 1.669811320754717, "no_speech_prob": 3.0173045161063783e-05}, {"id": 134, "seek": 78540, "start": 790.8, "end": 795.0799999999999, "text": " have this, let's say a platform device for a GPIO chip and then we allocate a struct", "tokens": [362, 341, 11, 718, 311, 584, 257, 3663, 4302, 337, 257, 26039, 15167, 11409, 293, 550, 321, 35713, 257, 6594], "temperature": 0.0, "avg_logprob": -0.1524153803731059, "compression_ratio": 1.669811320754717, "no_speech_prob": 3.0173045161063783e-05}, {"id": 135, "seek": 78540, "start": 795.0799999999999, "end": 804.4, "text": " device per every bank. Just an example and many subsystems do that too. So there, there's", "tokens": [4302, 680, 633, 3765, 13, 1449, 364, 1365, 293, 867, 2090, 9321, 82, 360, 300, 886, 13, 407, 456, 11, 456, 311], "temperature": 0.0, "avg_logprob": -0.1524153803731059, "compression_ratio": 1.669811320754717, "no_speech_prob": 3.0173045161063783e-05}, {"id": 136, "seek": 78540, "start": 804.4, "end": 810.0799999999999, "text": " this problem, but there are also other problems. So even those subsystems that get this part", "tokens": [341, 1154, 11, 457, 456, 366, 611, 661, 2740, 13, 407, 754, 729, 2090, 9321, 82, 300, 483, 341, 644], "temperature": 0.0, "avg_logprob": -0.1524153803731059, "compression_ratio": 1.669811320754717, "no_speech_prob": 3.0173045161063783e-05}, {"id": 137, "seek": 81008, "start": 810.08, "end": 815.88, "text": " right often suffer from concurrency issues because there is no locking in the system", "tokens": [558, 2049, 9753, 490, 23702, 10457, 2663, 570, 456, 307, 572, 23954, 294, 264, 1185], "temperature": 0.0, "avg_logprob": -0.16090456077030726, "compression_ratio": 1.7975708502024292, "no_speech_prob": 3.5716129787033424e-05}, {"id": 138, "seek": 81008, "start": 815.88, "end": 822.1600000000001, "text": " call, callbacks in the kernel. So even if they do check if the, if the driver is still", "tokens": [818, 11, 818, 17758, 294, 264, 28256, 13, 407, 754, 498, 436, 360, 1520, 498, 264, 11, 498, 264, 6787, 307, 920], "temperature": 0.0, "avg_logprob": -0.16090456077030726, "compression_ratio": 1.7975708502024292, "no_speech_prob": 3.5716129787033424e-05}, {"id": 139, "seek": 81008, "start": 822.1600000000001, "end": 827.76, "text": " there or the device is still there or attached to the driver, they often don't lock the state.", "tokens": [456, 420, 264, 4302, 307, 920, 456, 420, 8570, 281, 264, 6787, 11, 436, 2049, 500, 380, 4017, 264, 1785, 13], "temperature": 0.0, "avg_logprob": -0.16090456077030726, "compression_ratio": 1.7975708502024292, "no_speech_prob": 3.5716129787033424e-05}, {"id": 140, "seek": 81008, "start": 827.76, "end": 832.96, "text": " So it's, it's, it's possible that the driver will go away one, while they're still executing", "tokens": [407, 309, 311, 11, 309, 311, 11, 309, 311, 1944, 300, 264, 6787, 486, 352, 1314, 472, 11, 1339, 436, 434, 920, 32368], "temperature": 0.0, "avg_logprob": -0.16090456077030726, "compression_ratio": 1.7975708502024292, "no_speech_prob": 3.5716129787033424e-05}, {"id": 141, "seek": 81008, "start": 832.96, "end": 839.48, "text": " and they're referencing that pointer. This was the case in, in spy for instance. And", "tokens": [293, 436, 434, 40582, 300, 23918, 13, 639, 390, 264, 1389, 294, 11, 294, 20752, 337, 5197, 13, 400], "temperature": 0.0, "avg_logprob": -0.16090456077030726, "compression_ratio": 1.7975708502024292, "no_speech_prob": 3.5716129787033424e-05}, {"id": 142, "seek": 83948, "start": 839.48, "end": 844.24, "text": " I think that the issue is just about the logical scope of objects and not the scope", "tokens": [286, 519, 300, 264, 2734, 307, 445, 466, 264, 14978, 11923, 295, 6565, 293, 406, 264, 11923], "temperature": 0.0, "avg_logprob": -0.14661117735363188, "compression_ratio": 1.8782608695652174, "no_speech_prob": 7.069666480674641e-06}, {"id": 143, "seek": 83948, "start": 844.24, "end": 849.64, "text": " in understood as, as, as a scope of a variable in a C programming language, but more, more", "tokens": [294, 7320, 382, 11, 382, 11, 382, 257, 11923, 295, 257, 7006, 294, 257, 383, 9410, 2856, 11, 457, 544, 11, 544], "temperature": 0.0, "avg_logprob": -0.14661117735363188, "compression_ratio": 1.8782608695652174, "no_speech_prob": 7.069666480674641e-06}, {"id": 144, "seek": 83948, "start": 849.64, "end": 856.6800000000001, "text": " like a logical scope of objects where you have, if something is allocated in probe,", "tokens": [411, 257, 14978, 11923, 295, 6565, 689, 291, 362, 11, 498, 746, 307, 29772, 294, 22715, 11], "temperature": 0.0, "avg_logprob": -0.14661117735363188, "compression_ratio": 1.8782608695652174, "no_speech_prob": 7.069666480674641e-06}, {"id": 145, "seek": 83948, "start": 856.6800000000001, "end": 859.9200000000001, "text": " when you, when you attach, first attach the device to the driver and, and you allocate", "tokens": [562, 291, 11, 562, 291, 5085, 11, 700, 5085, 264, 4302, 281, 264, 6787, 293, 11, 293, 291, 35713], "temperature": 0.0, "avg_logprob": -0.14661117735363188, "compression_ratio": 1.8782608695652174, "no_speech_prob": 7.069666480674641e-06}, {"id": 146, "seek": 83948, "start": 859.9200000000001, "end": 864.96, "text": " something in probe, it should only need to exist for as long as the driver is attached", "tokens": [746, 294, 22715, 11, 309, 820, 787, 643, 281, 2514, 337, 382, 938, 382, 264, 6787, 307, 8570], "temperature": 0.0, "avg_logprob": -0.14661117735363188, "compression_ratio": 1.8782608695652174, "no_speech_prob": 7.069666480674641e-06}, {"id": 147, "seek": 86496, "start": 864.96, "end": 869.88, "text": " and as, as soon as it goes away, it should be freed and removed, be it in, with dev res", "tokens": [293, 382, 11, 382, 2321, 382, 309, 1709, 1314, 11, 309, 820, 312, 21796, 293, 7261, 11, 312, 309, 294, 11, 365, 1905, 725], "temperature": 0.0, "avg_logprob": -0.16189773636634905, "compression_ratio": 1.7184466019417475, "no_speech_prob": 1.7216845662915148e-05}, {"id": 148, "seek": 86496, "start": 869.88, "end": 876.2800000000001, "text": " or, or, or in remove. And yeah, so, so there is this problem with, with many subsystems", "tokens": [420, 11, 420, 11, 420, 294, 4159, 13, 400, 1338, 11, 370, 11, 370, 456, 307, 341, 1154, 365, 11, 365, 867, 2090, 9321, 82], "temperature": 0.0, "avg_logprob": -0.16189773636634905, "compression_ratio": 1.7184466019417475, "no_speech_prob": 1.7216845662915148e-05}, {"id": 149, "seek": 86496, "start": 876.2800000000001, "end": 882.44, "text": " that they don't have this and they let drivers allocate some data in probe and then handle", "tokens": [300, 436, 500, 380, 362, 341, 293, 436, 718, 11590, 35713, 512, 1412, 294, 22715, 293, 550, 4813], "temperature": 0.0, "avg_logprob": -0.16189773636634905, "compression_ratio": 1.7184466019417475, "no_speech_prob": 1.7216845662915148e-05}, {"id": 150, "seek": 86496, "start": 882.44, "end": 890.48, "text": " it over to the subsystem or, or even do it implicitly, which leads to all these errors.", "tokens": [309, 670, 281, 264, 2090, 9321, 420, 11, 420, 754, 360, 309, 26947, 356, 11, 597, 6689, 281, 439, 613, 13603, 13], "temperature": 0.0, "avg_logprob": -0.16189773636634905, "compression_ratio": 1.7184466019417475, "no_speech_prob": 1.7216845662915148e-05}, {"id": 151, "seek": 89048, "start": 890.48, "end": 895.88, "text": " So I, I know that Laurent's area of interest will probably be media and DRM, so I just", "tokens": [407, 286, 11, 286, 458, 300, 49357, 311, 1859, 295, 1179, 486, 1391, 312, 3021, 293, 12118, 44, 11, 370, 286, 445], "temperature": 0.0, "avg_logprob": -0.2819331757565762, "compression_ratio": 1.5550660792951543, "no_speech_prob": 9.473144746152684e-05}, {"id": 152, "seek": 89048, "start": 895.88, "end": 902.0, "text": " skimmed through, through the use, user space device notes, codes in, in those subsystems", "tokens": [1110, 332, 1912, 807, 11, 807, 264, 764, 11, 4195, 1901, 4302, 5570, 11, 14211, 294, 11, 294, 729, 2090, 9321, 82], "temperature": 0.0, "avg_logprob": -0.2819331757565762, "compression_ratio": 1.5550660792951543, "no_speech_prob": 9.473144746152684e-05}, {"id": 153, "seek": 89048, "start": 902.0, "end": 909.04, "text": " and noticed that they seem to be getting part of it correctly, but there are concurrency", "tokens": [293, 5694, 300, 436, 1643, 281, 312, 1242, 644, 295, 309, 8944, 11, 457, 456, 366, 23702, 10457], "temperature": 0.0, "avg_logprob": -0.2819331757565762, "compression_ratio": 1.5550660792951543, "no_speech_prob": 9.473144746152684e-05}, {"id": 154, "seek": 89048, "start": 909.04, "end": 915.24, "text": " issues as well. And the problem with DRM is that the RAM, the, the device handling code,", "tokens": [2663, 382, 731, 13, 400, 264, 1154, 365, 12118, 44, 307, 300, 264, 14561, 11, 264, 11, 264, 4302, 13175, 3089, 11], "temperature": 0.0, "avg_logprob": -0.2819331757565762, "compression_ratio": 1.5550660792951543, "no_speech_prob": 9.473144746152684e-05}, {"id": 155, "seek": 91524, "start": 915.24, "end": 923.04, "text": " the, the, the, the character block device, the, the handling code is not, is, is not", "tokens": [264, 11, 264, 11, 264, 11, 264, 2517, 3461, 4302, 11, 264, 11, 264, 13175, 3089, 307, 406, 11, 307, 11, 307, 406], "temperature": 0.2, "avg_logprob": -0.2369733843310126, "compression_ratio": 1.7480314960629921, "no_speech_prob": 2.9689517759834416e-05}, {"id": 156, "seek": 91524, "start": 923.04, "end": 927.5600000000001, "text": " centralized within the files, within the subsystem, meaning that we have many different struct", "tokens": [32395, 1951, 264, 7098, 11, 1951, 264, 2090, 9321, 11, 3620, 300, 321, 362, 867, 819, 6594], "temperature": 0.2, "avg_logprob": -0.2369733843310126, "compression_ratio": 1.7480314960629921, "no_speech_prob": 2.9689517759834416e-05}, {"id": 157, "seek": 91524, "start": 927.5600000000001, "end": 931.6800000000001, "text": " file operations with different implementations for different callbacks, correct me if I'm", "tokens": [3991, 7705, 365, 819, 4445, 763, 337, 819, 818, 17758, 11, 3006, 385, 498, 286, 478], "temperature": 0.2, "avg_logprob": -0.2369733843310126, "compression_ratio": 1.7480314960629921, "no_speech_prob": 2.9689517759834416e-05}, {"id": 158, "seek": 91524, "start": 931.6800000000001, "end": 936.08, "text": " wrong afterwards, but it, it, it seemed like, like it from, I'm not an expert on DRM, but", "tokens": [2085, 10543, 11, 457, 309, 11, 309, 11, 309, 6576, 411, 11, 411, 309, 490, 11, 286, 478, 406, 364, 5844, 322, 12118, 44, 11, 457], "temperature": 0.2, "avg_logprob": -0.2369733843310126, "compression_ratio": 1.7480314960629921, "no_speech_prob": 2.9689517759834416e-05}, {"id": 159, "seek": 91524, "start": 936.08, "end": 941.5600000000001, "text": " it seemed like it just from looking at it. So what about dev res? Is it safe? I have", "tokens": [309, 6576, 411, 309, 445, 490, 1237, 412, 309, 13, 407, 437, 466, 1905, 725, 30, 1119, 309, 3273, 30, 286, 362], "temperature": 0.2, "avg_logprob": -0.2369733843310126, "compression_ratio": 1.7480314960629921, "no_speech_prob": 2.9689517759834416e-05}, {"id": 160, "seek": 94156, "start": 941.56, "end": 946.8399999999999, "text": " found no evidence that it isn't. And if something can be freed and removed, it can be freed", "tokens": [1352, 572, 4467, 300, 309, 1943, 380, 13, 400, 498, 746, 393, 312, 21796, 293, 7261, 11, 309, 393, 312, 21796], "temperature": 0.0, "avg_logprob": -0.1622919308937202, "compression_ratio": 1.7837837837837838, "no_speech_prob": 4.532750972430222e-05}, {"id": 161, "seek": 94156, "start": 946.8399999999999, "end": 950.68, "text": " with dev res because dev res will do just that. It will, as soon as the driver gets", "tokens": [365, 1905, 725, 570, 1905, 725, 486, 360, 445, 300, 13, 467, 486, 11, 382, 2321, 382, 264, 6787, 2170], "temperature": 0.0, "avg_logprob": -0.1622919308937202, "compression_ratio": 1.7837837837837838, "no_speech_prob": 4.532750972430222e-05}, {"id": 162, "seek": 94156, "start": 950.68, "end": 957.52, "text": " detached from the device, the other way around, it will, it will free all, all resources allocated", "tokens": [42050, 490, 264, 4302, 11, 264, 661, 636, 926, 11, 309, 486, 11, 309, 486, 1737, 439, 11, 439, 3593, 29772], "temperature": 0.0, "avg_logprob": -0.1622919308937202, "compression_ratio": 1.7837837837837838, "no_speech_prob": 4.532750972430222e-05}, {"id": 163, "seek": 94156, "start": 957.52, "end": 963.1199999999999, "text": " with dev res in reverse order. There is, there are some, some, some issues like dev mk realloc", "tokens": [365, 1905, 725, 294, 9943, 1668, 13, 821, 307, 11, 456, 366, 512, 11, 512, 11, 512, 2663, 411, 1905, 275, 74, 319, 336, 905], "temperature": 0.0, "avg_logprob": -0.1622919308937202, "compression_ratio": 1.7837837837837838, "no_speech_prob": 4.532750972430222e-05}, {"id": 164, "seek": 94156, "start": 963.1199999999999, "end": 967.28, "text": " could use some semantic clarification because as, as it is right now, it's not clear whether", "tokens": [727, 764, 512, 47982, 34449, 570, 382, 11, 382, 309, 307, 558, 586, 11, 309, 311, 406, 1850, 1968], "temperature": 0.0, "avg_logprob": -0.1622919308937202, "compression_ratio": 1.7837837837837838, "no_speech_prob": 4.532750972430222e-05}, {"id": 165, "seek": 96728, "start": 967.28, "end": 972.72, "text": " the order, if you call dev mk realloc, does the order change or not when, when releasing", "tokens": [264, 1668, 11, 498, 291, 818, 1905, 275, 74, 319, 336, 905, 11, 775, 264, 1668, 1319, 420, 406, 562, 11, 562, 16327], "temperature": 0.0, "avg_logprob": -0.1826797083804482, "compression_ratio": 1.6043478260869566, "no_speech_prob": 4.385247302707285e-05}, {"id": 166, "seek": 96728, "start": 972.72, "end": 980.24, "text": " those resources. In any case, I, is my strong belief that dev res makes code much more readable,", "tokens": [729, 3593, 13, 682, 604, 1389, 11, 286, 11, 307, 452, 2068, 7107, 300, 1905, 725, 1669, 3089, 709, 544, 49857, 11], "temperature": 0.0, "avg_logprob": -0.1826797083804482, "compression_ratio": 1.6043478260869566, "no_speech_prob": 4.385247302707285e-05}, {"id": 167, "seek": 96728, "start": 980.24, "end": 986.28, "text": " safer, and it actually should be encouraged and, and not discouraged, but it has a limited", "tokens": [15856, 11, 293, 309, 767, 820, 312, 14658, 293, 11, 293, 406, 35010, 11, 457, 309, 575, 257, 5567], "temperature": 0.0, "avg_logprob": -0.1826797083804482, "compression_ratio": 1.6043478260869566, "no_speech_prob": 4.385247302707285e-05}, {"id": 168, "seek": 96728, "start": 986.28, "end": 995.8, "text": " scope. And on that point, how can we supplement it? Because a certain semblance of resource,", "tokens": [11923, 13, 400, 322, 300, 935, 11, 577, 393, 321, 15436, 309, 30, 1436, 257, 1629, 20775, 37271, 295, 7684, 11], "temperature": 0.0, "avg_logprob": -0.1826797083804482, "compression_ratio": 1.6043478260869566, "no_speech_prob": 4.385247302707285e-05}, {"id": 169, "seek": 99580, "start": 995.8, "end": 1001.9599999999999, "text": " of automated resource management, RAII, if you will, in C would be useful in the kernel.", "tokens": [295, 18473, 7684, 4592, 11, 14626, 9503, 11, 498, 291, 486, 11, 294, 383, 576, 312, 4420, 294, 264, 28256, 13], "temperature": 0.0, "avg_logprob": -0.1805689586856501, "compression_ratio": 1.6593406593406594, "no_speech_prob": 3.0210669137886725e-05}, {"id": 170, "seek": 99580, "start": 1001.9599999999999, "end": 1006.16, "text": " So yeah, the first thing that comes to mind would be using Rust. With Rust, these situations", "tokens": [407, 1338, 11, 264, 700, 551, 300, 1487, 281, 1575, 576, 312, 1228, 34952, 13, 2022, 34952, 11, 613, 6851], "temperature": 0.0, "avg_logprob": -0.1805689586856501, "compression_ratio": 1.6593406593406594, "no_speech_prob": 3.0210669137886725e-05}, {"id": 171, "seek": 99580, "start": 1006.16, "end": 1010.88, "text": " that I described would never, would clearly never, never be allowed to happen. But that's", "tokens": [300, 286, 7619, 576, 1128, 11, 576, 4448, 1128, 11, 1128, 312, 4350, 281, 1051, 13, 583, 300, 311], "temperature": 0.0, "avg_logprob": -0.1805689586856501, "compression_ratio": 1.6593406593406594, "no_speech_prob": 3.0210669137886725e-05}, {"id": 172, "seek": 99580, "start": 1010.88, "end": 1016.4799999999999, "text": " not, for, for now, we're still coding in C. So I was thinking that if you've ever coded", "tokens": [406, 11, 337, 11, 337, 586, 11, 321, 434, 920, 17720, 294, 383, 13, 407, 286, 390, 1953, 300, 498, 291, 600, 1562, 34874], "temperature": 0.0, "avg_logprob": -0.1805689586856501, "compression_ratio": 1.6593406593406594, "no_speech_prob": 3.0210669137886725e-05}, {"id": 173, "seek": 99580, "start": 1016.4799999999999, "end": 1022.24, "text": " in, in, in a user space library like Gillib, for instance, which is, I, I, I believe a golden", "tokens": [294, 11, 294, 11, 294, 257, 4195, 1901, 6405, 411, 27709, 897, 11, 337, 5197, 11, 597, 307, 11, 286, 11, 286, 11, 286, 1697, 257, 9729], "temperature": 0.0, "avg_logprob": -0.1805689586856501, "compression_ratio": 1.6593406593406594, "no_speech_prob": 3.0210669137886725e-05}, {"id": 174, "seek": 102224, "start": 1022.24, "end": 1027.8, "text": " standard of C programming in, in user space, you would notice that they use, make a, use", "tokens": [3832, 295, 383, 9410, 294, 11, 294, 4195, 1901, 11, 291, 576, 3449, 300, 436, 764, 11, 652, 257, 11, 764], "temperature": 0.0, "avg_logprob": -0.2283172607421875, "compression_ratio": 1.6641509433962265, "no_speech_prob": 0.0001318396971328184}, {"id": 175, "seek": 102224, "start": 1027.8, "end": 1033.36, "text": " of a lot of, clean up, clean up attributes. And this is something that GCC and Clang support,", "tokens": [295, 257, 688, 295, 11, 2541, 493, 11, 2541, 493, 17212, 13, 400, 341, 307, 746, 300, 460, 11717, 293, 2033, 656, 1406, 11], "temperature": 0.0, "avg_logprob": -0.2283172607421875, "compression_ratio": 1.6641509433962265, "no_speech_prob": 0.0001318396971328184}, {"id": 176, "seek": 102224, "start": 1033.36, "end": 1037.56, "text": " and I haven't seen that in the kernel, and I'm wondering why it's, because if we would", "tokens": [293, 286, 2378, 380, 1612, 300, 294, 264, 28256, 11, 293, 286, 478, 6359, 983, 309, 311, 11, 570, 498, 321, 576], "temperature": 0.0, "avg_logprob": -0.2283172607421875, "compression_ratio": 1.6641509433962265, "no_speech_prob": 0.0001318396971328184}, {"id": 177, "seek": 102224, "start": 1037.56, "end": 1042.64, "text": " use reference counting in conjunction with cleanup, we could actually make it.", "tokens": [764, 6408, 13251, 294, 27482, 365, 40991, 11, 321, 727, 767, 652, 309, 13], "temperature": 0.0, "avg_logprob": -0.2283172607421875, "compression_ratio": 1.6641509433962265, "no_speech_prob": 0.0001318396971328184}, {"id": 178, "seek": 102224, "start": 1042.64, "end": 1049.76, "text": " If I can interject for one second, but actually, at least not in core kernel code, but Peter", "tokens": [759, 286, 393, 46787, 337, 472, 1150, 11, 457, 767, 11, 412, 1935, 406, 294, 4965, 28256, 3089, 11, 457, 6508], "temperature": 0.0, "avg_logprob": -0.2283172607421875, "compression_ratio": 1.6641509433962265, "no_speech_prob": 0.0001318396971328184}, {"id": 179, "seek": 104976, "start": 1049.76, "end": 1057.44, "text": " Zilstra used this in somewhere in the kernel source code tree, at least. And I had proposed", "tokens": [1176, 388, 19639, 1143, 341, 294, 4079, 294, 264, 28256, 4009, 3089, 4230, 11, 412, 1935, 13, 400, 286, 632, 10348], "temperature": 0.0, "avg_logprob": -0.17319306539833, "compression_ratio": 1.6796875, "no_speech_prob": 5.7001430832315236e-05}, {"id": 180, "seek": 104976, "start": 1057.44, "end": 1061.36, "text": " something like this, at least in person to a couple of people before, because I want", "tokens": [746, 411, 341, 11, 412, 1935, 294, 954, 281, 257, 1916, 295, 561, 949, 11, 570, 286, 528], "temperature": 0.0, "avg_logprob": -0.17319306539833, "compression_ratio": 1.6796875, "no_speech_prob": 5.7001430832315236e-05}, {"id": 181, "seek": 104976, "start": 1061.36, "end": 1064.72, "text": " to make use of this as well. So I would be very happy if this happened.", "tokens": [281, 652, 764, 295, 341, 382, 731, 13, 407, 286, 576, 312, 588, 2055, 498, 341, 2011, 13], "temperature": 0.0, "avg_logprob": -0.17319306539833, "compression_ratio": 1.6796875, "no_speech_prob": 5.7001430832315236e-05}, {"id": 182, "seek": 104976, "start": 1064.72, "end": 1070.48, "text": " Yeah. So I have a small example. So if you are, if you are not familiar with the cleanup", "tokens": [865, 13, 407, 286, 362, 257, 1359, 1365, 13, 407, 498, 291, 366, 11, 498, 291, 366, 406, 4963, 365, 264, 40991], "temperature": 0.0, "avg_logprob": -0.17319306539833, "compression_ratio": 1.6796875, "no_speech_prob": 5.7001430832315236e-05}, {"id": 183, "seek": 104976, "start": 1070.48, "end": 1075.44, "text": " attribute, it allows you to specify a cleanup function for a variable. And when the variable", "tokens": [19667, 11, 309, 4045, 291, 281, 16500, 257, 40991, 2445, 337, 257, 7006, 13, 400, 562, 264, 7006], "temperature": 0.0, "avg_logprob": -0.17319306539833, "compression_ratio": 1.6796875, "no_speech_prob": 5.7001430832315236e-05}, {"id": 184, "seek": 107544, "start": 1075.44, "end": 1081.92, "text": " goes out of scope, it's called, so it's like a destructor in C++ basically. Alone, it's,", "tokens": [1709, 484, 295, 11923, 11, 309, 311, 1219, 11, 370, 309, 311, 411, 257, 2677, 14535, 294, 383, 25472, 1936, 13, 42056, 11, 309, 311, 11], "temperature": 0.0, "avg_logprob": -0.1957264404296875, "compression_ratio": 1.834008097165992, "no_speech_prob": 1.4271461623138748e-05}, {"id": 185, "seek": 107544, "start": 1081.92, "end": 1086.72, "text": " it's useful within the scope of a single code block or a single function, but in conjunction,", "tokens": [309, 311, 4420, 1951, 264, 11923, 295, 257, 2167, 3089, 3461, 420, 257, 2167, 2445, 11, 457, 294, 27482, 11], "temperature": 0.0, "avg_logprob": -0.1957264404296875, "compression_ratio": 1.834008097165992, "no_speech_prob": 1.4271461623138748e-05}, {"id": 186, "seek": 107544, "start": 1086.72, "end": 1091.0, "text": " well, this is just another example of how to, how to use it, but in conjunction with reference", "tokens": [731, 11, 341, 307, 445, 1071, 1365, 295, 577, 281, 11, 577, 281, 764, 309, 11, 457, 294, 27482, 365, 6408], "temperature": 0.0, "avg_logprob": -0.1957264404296875, "compression_ratio": 1.834008097165992, "no_speech_prob": 1.4271461623138748e-05}, {"id": 187, "seek": 107544, "start": 1091.0, "end": 1094.56, "text": " counting, it's, it's quite useful because you can, like, you can see the, the, the foo", "tokens": [13251, 11, 309, 311, 11, 309, 311, 1596, 4420, 570, 291, 393, 11, 411, 11, 291, 393, 536, 264, 11, 264, 11, 264, 726, 78], "temperature": 0.0, "avg_logprob": -0.1957264404296875, "compression_ratio": 1.834008097165992, "no_speech_prob": 1.4271461623138748e-05}, {"id": 188, "seek": 107544, "start": 1094.56, "end": 1101.8400000000001, "text": " and bar, foo create and bar functions on the right. You allocate a, a reference counted,", "tokens": [293, 2159, 11, 726, 78, 1884, 293, 2159, 6828, 322, 264, 558, 13, 509, 35713, 257, 11, 257, 6408, 20150, 11], "temperature": 0.0, "avg_logprob": -0.1957264404296875, "compression_ratio": 1.834008097165992, "no_speech_prob": 1.4271461623138748e-05}, {"id": 189, "seek": 110184, "start": 1101.84, "end": 1106.3999999999999, "text": " automatically reference counted resource. You do something with it. If you bail out, the", "tokens": [6772, 6408, 20150, 7684, 13, 509, 360, 746, 365, 309, 13, 759, 291, 19313, 484, 11, 264], "temperature": 0.0, "avg_logprob": -0.14536466511017684, "compression_ratio": 1.816326530612245, "no_speech_prob": 1.4967049537517596e-05}, {"id": 190, "seek": 110184, "start": 1106.3999999999999, "end": 1111.84, "text": " reference count goes to zero and then it's freed. But if you return it while also increasing", "tokens": [6408, 1207, 1709, 281, 4018, 293, 550, 309, 311, 21796, 13, 583, 498, 291, 2736, 309, 1339, 611, 5662], "temperature": 0.0, "avg_logprob": -0.14536466511017684, "compression_ratio": 1.816326530612245, "no_speech_prob": 1.4967049537517596e-05}, {"id": 191, "seek": 110184, "start": 1111.84, "end": 1116.72, "text": " the ref count and then grab it in another function in bar in this, in this case, then", "tokens": [264, 1895, 1207, 293, 550, 4444, 309, 294, 1071, 2445, 294, 2159, 294, 341, 11, 294, 341, 1389, 11, 550], "temperature": 0.0, "avg_logprob": -0.14536466511017684, "compression_ratio": 1.816326530612245, "no_speech_prob": 1.4967049537517596e-05}, {"id": 192, "seek": 110184, "start": 1116.72, "end": 1123.1999999999998, "text": " as soon as the, the, the foo create function returns, the reference count is decreased,", "tokens": [382, 2321, 382, 264, 11, 264, 11, 264, 726, 78, 1884, 2445, 11247, 11, 264, 6408, 1207, 307, 24436, 11], "temperature": 0.0, "avg_logprob": -0.14536466511017684, "compression_ratio": 1.816326530612245, "no_speech_prob": 1.4967049537517596e-05}, {"id": 193, "seek": 110184, "start": 1123.1999999999998, "end": 1128.52, "text": " but it's already two. So it goes down to one and we, without having to control free those", "tokens": [457, 309, 311, 1217, 732, 13, 407, 309, 1709, 760, 281, 472, 293, 321, 11, 1553, 1419, 281, 1969, 1737, 729], "temperature": 0.0, "avg_logprob": -0.14536466511017684, "compression_ratio": 1.816326530612245, "no_speech_prob": 1.4967049537517596e-05}, {"id": 194, "seek": 112852, "start": 1128.52, "end": 1132.84, "text": " resources manually, we just keep track of the references just by using reference counting", "tokens": [3593, 16945, 11, 321, 445, 1066, 2837, 295, 264, 15400, 445, 538, 1228, 6408, 13251], "temperature": 0.0, "avg_logprob": -0.21764480969137398, "compression_ratio": 1.6420664206642066, "no_speech_prob": 3.261723031755537e-05}, {"id": 195, "seek": 112852, "start": 1132.84, "end": 1137.2, "text": " and cleanup. And this is what Gillib does a lot. And it, and it works quite nice. It's,", "tokens": [293, 40991, 13, 400, 341, 307, 437, 27709, 897, 775, 257, 688, 13, 400, 309, 11, 293, 309, 1985, 1596, 1481, 13, 467, 311, 11], "temperature": 0.0, "avg_logprob": -0.21764480969137398, "compression_ratio": 1.6420664206642066, "no_speech_prob": 3.261723031755537e-05}, {"id": 196, "seek": 112852, "start": 1137.2, "end": 1142.92, "text": " it makes programming in C in this space much easier. And what to do about the offending", "tokens": [309, 1669, 9410, 294, 383, 294, 341, 1901, 709, 3571, 13, 400, 437, 281, 360, 466, 264, 766, 2029], "temperature": 0.0, "avg_logprob": -0.21764480969137398, "compression_ratio": 1.6420664206642066, "no_speech_prob": 3.261723031755537e-05}, {"id": 197, "seek": 112852, "start": 1142.92, "end": 1150.08, "text": " subsystems? It's a case by case issue because every subsystem does it differently. And I", "tokens": [2090, 9321, 82, 30, 467, 311, 257, 1389, 538, 1389, 2734, 570, 633, 2090, 9321, 775, 309, 7614, 13, 400, 286], "temperature": 0.0, "avg_logprob": -0.21764480969137398, "compression_ratio": 1.6420664206642066, "no_speech_prob": 3.261723031755537e-05}, {"id": 198, "seek": 112852, "start": 1150.08, "end": 1154.84, "text": " tried, I, I spoke to Wolfram a bit about what can we do in I2C. And it's, it would be very", "tokens": [3031, 11, 286, 11, 286, 7179, 281, 16634, 2356, 257, 857, 466, 437, 393, 321, 360, 294, 286, 17, 34, 13, 400, 309, 311, 11, 309, 576, 312, 588], "temperature": 0.0, "avg_logprob": -0.21764480969137398, "compression_ratio": 1.6420664206642066, "no_speech_prob": 3.261723031755537e-05}, {"id": 199, "seek": 115484, "start": 1154.84, "end": 1159.3999999999999, "text": " hard because you would have to do a sweeping change across the entire subsystem to make", "tokens": [1152, 570, 291, 576, 362, 281, 360, 257, 33285, 1319, 2108, 264, 2302, 2090, 9321, 281, 652], "temperature": 0.0, "avg_logprob": -0.19981494015210297, "compression_ratio": 1.5406976744186047, "no_speech_prob": 0.00020142133871559054}, {"id": 200, "seek": 115484, "start": 1159.3999999999999, "end": 1167.1599999999999, "text": " drivers not allocate I2C adapter, not, not I2C adapter, but rather the underlying struct", "tokens": [11590, 406, 35713, 286, 17, 34, 22860, 11, 406, 11, 406, 286, 17, 34, 22860, 11, 457, 2831, 264, 14217, 6594], "temperature": 0.0, "avg_logprob": -0.19981494015210297, "compression_ratio": 1.5406976744186047, "no_speech_prob": 0.00020142133871559054}, {"id": 201, "seek": 115484, "start": 1167.1599999999999, "end": 1174.36, "text": " device on its own instead let it handle, let, let I2C, the I2C subsystem handle it. Yes,", "tokens": [4302, 322, 1080, 1065, 2602, 718, 309, 4813, 11, 718, 11, 718, 286, 17, 34, 11, 264, 286, 17, 34, 2090, 9321, 4813, 309, 13, 1079, 11], "temperature": 0.0, "avg_logprob": -0.19981494015210297, "compression_ratio": 1.5406976744186047, "no_speech_prob": 0.00020142133871559054}, {"id": 202, "seek": 117436, "start": 1174.36, "end": 1190.1599999999999, "text": " I just wanted to bring that up and that's, that's it. I'm right on time. All right, questions?", "tokens": [286, 445, 1415, 281, 1565, 300, 493, 293, 300, 311, 11, 300, 311, 309, 13, 286, 478, 558, 322, 565, 13, 1057, 558, 11, 1651, 30], "temperature": 0.0, "avg_logprob": -0.23292911052703857, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.00021985646162647754}, {"id": 203, "seek": 117436, "start": 1190.1599999999999, "end": 1195.6799999999998, "text": " Thank you. I, I, I like your second slide. I felt when you say I was not completely wrong", "tokens": [1044, 291, 13, 286, 11, 286, 11, 286, 411, 428, 1150, 4137, 13, 286, 2762, 562, 291, 584, 286, 390, 406, 2584, 2085], "temperature": 0.0, "avg_logprob": -0.23292911052703857, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.00021985646162647754}, {"id": 204, "seek": 117436, "start": 1195.6799999999998, "end": 1202.7199999999998, "text": " with my talk, so thank you for that. I was a bit worried. A few comments. It's multiple", "tokens": [365, 452, 751, 11, 370, 1309, 291, 337, 300, 13, 286, 390, 257, 857, 5804, 13, 316, 1326, 3053, 13, 467, 311, 3866], "temperature": 0.0, "avg_logprob": -0.23292911052703857, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.00021985646162647754}, {"id": 205, "seek": 120272, "start": 1202.72, "end": 1206.48, "text": " problems actually that you're trying to solve here. One is the race condition between IOC", "tokens": [2740, 767, 300, 291, 434, 1382, 281, 5039, 510, 13, 1485, 307, 264, 4569, 4188, 1296, 286, 30087], "temperature": 0.0, "avg_logprob": -0.23871127703717646, "compression_ratio": 1.6130030959752322, "no_speech_prob": 0.0008740167832002044}, {"id": 206, "seek": 120272, "start": 1206.48, "end": 1210.6000000000001, "text": " TL, so use space access in general and the remove function. And for everything that's", "tokens": [40277, 11, 370, 764, 1901, 2105, 294, 2674, 293, 264, 4159, 2445, 13, 400, 337, 1203, 300, 311], "temperature": 0.0, "avg_logprob": -0.23871127703717646, "compression_ratio": 1.6130030959752322, "no_speech_prob": 0.0008740167832002044}, {"id": 207, "seek": 120272, "start": 1210.6000000000001, "end": 1215.28, "text": " based on character devices, there's a patch from Dan Williams that was posted in 2021.", "tokens": [2361, 322, 2517, 5759, 11, 456, 311, 257, 9972, 490, 3394, 12929, 300, 390, 9437, 294, 7201, 13], "temperature": 0.0, "avg_logprob": -0.23871127703717646, "compression_ratio": 1.6130030959752322, "no_speech_prob": 0.0008740167832002044}, {"id": 208, "seek": 120272, "start": 1215.28, "end": 1219.0, "text": " I think I don't know if you've seen that one, that attempts to fix it at the C dev level,", "tokens": [286, 519, 286, 500, 380, 458, 498, 291, 600, 1612, 300, 472, 11, 300, 15257, 281, 3191, 309, 412, 264, 383, 1905, 1496, 11], "temperature": 0.0, "avg_logprob": -0.23871127703717646, "compression_ratio": 1.6130030959752322, "no_speech_prob": 0.0008740167832002044}, {"id": 209, "seek": 120272, "start": 1219.0, "end": 1221.76, "text": " which I think is the right place to do it instead of duplicating the same fix in all", "tokens": [597, 286, 519, 307, 264, 558, 1081, 281, 360, 309, 2602, 295, 17154, 990, 264, 912, 3191, 294, 439], "temperature": 0.0, "avg_logprob": -0.23871127703717646, "compression_ratio": 1.6130030959752322, "no_speech_prob": 0.0008740167832002044}, {"id": 210, "seek": 120272, "start": 1221.76, "end": 1227.52, "text": " the subsystems. So it has been positively reviewed, not merged. I think it was just", "tokens": [264, 2090, 9321, 82, 13, 407, 309, 575, 668, 25795, 18429, 11, 406, 36427, 13, 286, 519, 309, 390, 445], "temperature": 0.0, "avg_logprob": -0.23871127703717646, "compression_ratio": 1.6130030959752322, "no_speech_prob": 0.0008740167832002044}, {"id": 211, "seek": 122752, "start": 1227.52, "end": 1232.6399999999999, "text": " one review command that said that debug FS and proc FS had similar constructs. And so", "tokens": [472, 3131, 5622, 300, 848, 300, 24083, 41138, 293, 9510, 41138, 632, 2531, 7690, 82, 13, 400, 370], "temperature": 0.0, "avg_logprob": -0.23527570601997025, "compression_ratio": 1.586080586080586, "no_speech_prob": 0.00026831767172552645}, {"id": 212, "seek": 122752, "start": 1232.6399999999999, "end": 1237.72, "text": " he was asked to just refactor the code to reuse the same instead of duplicating it.", "tokens": [415, 390, 2351, 281, 445, 1895, 15104, 264, 3089, 281, 26225, 264, 912, 2602, 295, 17154, 990, 309, 13], "temperature": 0.0, "avg_logprob": -0.23527570601997025, "compression_ratio": 1.586080586080586, "no_speech_prob": 0.00026831767172552645}, {"id": 213, "seek": 122752, "start": 1237.72, "end": 1243.12, "text": " But that should be something we could upstream and solve. So that's one of them. This, I", "tokens": [583, 300, 820, 312, 746, 321, 727, 33915, 293, 5039, 13, 407, 300, 311, 472, 295, 552, 13, 639, 11, 286], "temperature": 0.0, "avg_logprob": -0.23527570601997025, "compression_ratio": 1.586080586080586, "no_speech_prob": 0.00026831767172552645}, {"id": 214, "seek": 122752, "start": 1243.12, "end": 1247.96, "text": " agree with you that there's nothing wrong with dev res or managed API in general. It", "tokens": [3986, 365, 291, 300, 456, 311, 1825, 2085, 365, 1905, 725, 420, 6453, 9362, 294, 2674, 13, 467], "temperature": 0.0, "avg_logprob": -0.23527570601997025, "compression_ratio": 1.586080586080586, "no_speech_prob": 0.00026831767172552645}, {"id": 215, "seek": 122752, "start": 1247.96, "end": 1253.16, "text": " was mostly DevM case at the lock in particular that I had trouble with. Things like DevM,", "tokens": [390, 5240, 9096, 44, 1389, 412, 264, 4017, 294, 1729, 300, 286, 632, 5253, 365, 13, 9514, 411, 9096, 44, 11], "temperature": 0.0, "avg_logprob": -0.23527570601997025, "compression_ratio": 1.586080586080586, "no_speech_prob": 0.00026831767172552645}, {"id": 216, "seek": 125316, "start": 1253.16, "end": 1259.4, "text": " IO remap for instance, is perfectly fine because you tie the lifetime management of the resource", "tokens": [39839, 890, 569, 337, 5197, 11, 307, 6239, 2489, 570, 291, 7582, 264, 11364, 4592, 295, 264, 7684], "temperature": 0.0, "avg_logprob": -0.2007169308869735, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.0005404508556239307}, {"id": 217, "seek": 125316, "start": 1259.4, "end": 1263.6000000000001, "text": " with the physical strike device, which is removed at the end of the remove function,", "tokens": [365, 264, 4001, 9302, 4302, 11, 597, 307, 7261, 412, 264, 917, 295, 264, 4159, 2445, 11], "temperature": 0.0, "avg_logprob": -0.2007169308869735, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.0005404508556239307}, {"id": 218, "seek": 125316, "start": 1263.6000000000001, "end": 1268.64, "text": " and that is what you should do. So that's totally fine. The issues with the DevM functions", "tokens": [293, 300, 307, 437, 291, 820, 360, 13, 407, 300, 311, 3879, 2489, 13, 440, 2663, 365, 264, 9096, 44, 6828], "temperature": 0.0, "avg_logprob": -0.2007169308869735, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.0005404508556239307}, {"id": 219, "seek": 125316, "start": 1268.64, "end": 1274.6000000000001, "text": " come when we try to tie, as you said, the lifetime of a resource to the wrong device.", "tokens": [808, 562, 321, 853, 281, 7582, 11, 382, 291, 848, 11, 264, 11364, 295, 257, 7684, 281, 264, 2085, 4302, 13], "temperature": 0.0, "avg_logprob": -0.2007169308869735, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.0005404508556239307}, {"id": 220, "seek": 125316, "start": 1274.6000000000001, "end": 1283.1000000000001, "text": " DRM has grown its custom managed helpers based on dev res. So not DevM, but it's DRMM. That", "tokens": [12118, 44, 575, 7709, 1080, 2375, 6453, 854, 433, 2361, 322, 1905, 725, 13, 407, 406, 9096, 44, 11, 457, 309, 311, 12118, 17365, 13, 663], "temperature": 0.0, "avg_logprob": -0.2007169308869735, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.0005404508556239307}, {"id": 221, "seek": 128310, "start": 1283.1, "end": 1289.3999999999999, "text": " does do it relatively right. They tie the memory management to the CDEV that's exposed", "tokens": [775, 360, 309, 7226, 558, 13, 814, 7582, 264, 4675, 4592, 281, 264, 6743, 36, 53, 300, 311, 9495], "temperature": 0.0, "avg_logprob": -0.1826920509338379, "compression_ratio": 1.6227272727272728, "no_speech_prob": 0.00035274107358418405}, {"id": 222, "seek": 128310, "start": 1289.3999999999999, "end": 1294.6399999999999, "text": " to user space. But where it breaks is when you have one physical device that exposed", "tokens": [281, 4195, 1901, 13, 583, 689, 309, 9857, 307, 562, 291, 362, 472, 4001, 4302, 300, 9495], "temperature": 0.0, "avg_logprob": -0.1826920509338379, "compression_ratio": 1.6227272727272728, "no_speech_prob": 0.00035274107358418405}, {"id": 223, "seek": 128310, "start": 1294.6399999999999, "end": 1299.9199999999998, "text": " multiple CDEVs because then you have a top level data structure that covers all of those.", "tokens": [3866, 6743, 36, 53, 82, 570, 550, 291, 362, 257, 1192, 1496, 1412, 3877, 300, 10538, 439, 295, 729, 13], "temperature": 0.0, "avg_logprob": -0.1826920509338379, "compression_ratio": 1.6227272727272728, "no_speech_prob": 0.00035274107358418405}, {"id": 224, "seek": 128310, "start": 1299.9199999999998, "end": 1308.6799999999998, "text": " So even if you allocate each of them dynamically, you will need to make sure that the top level", "tokens": [407, 754, 498, 291, 35713, 1184, 295, 552, 43492, 11, 291, 486, 643, 281, 652, 988, 300, 264, 1192, 1496], "temperature": 0.0, "avg_logprob": -0.1826920509338379, "compression_ratio": 1.6227272727272728, "no_speech_prob": 0.00035274107358418405}, {"id": 225, "seek": 130868, "start": 1308.68, "end": 1314.6000000000001, "text": " structure will be released only when nothing else can have a reference to it. So I think", "tokens": [3877, 486, 312, 4736, 787, 562, 1825, 1646, 393, 362, 257, 6408, 281, 309, 13, 407, 286, 519], "temperature": 0.0, "avg_logprob": -0.19018031529017856, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.00014849081344436854}, {"id": 226, "seek": 130868, "start": 1314.6000000000001, "end": 1318.96, "text": " there will always be cases where reference counting will be needed and the drivers will", "tokens": [456, 486, 1009, 312, 3331, 689, 6408, 13251, 486, 312, 2978, 293, 264, 11590, 486], "temperature": 0.0, "avg_logprob": -0.19018031529017856, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.00014849081344436854}, {"id": 227, "seek": 130868, "start": 1318.96, "end": 1325.4, "text": " have to handle that. But in many cases, helpers should be possible to make it simpler.", "tokens": [362, 281, 4813, 300, 13, 583, 294, 867, 3331, 11, 854, 433, 820, 312, 1944, 281, 652, 309, 18587, 13], "temperature": 0.0, "avg_logprob": -0.19018031529017856, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.00014849081344436854}, {"id": 228, "seek": 130868, "start": 1325.4, "end": 1329.64, "text": " And also I mentioned that on the slide that I didn't say it out loud. You have some diverse", "tokens": [400, 611, 286, 2835, 300, 322, 264, 4137, 300, 286, 994, 380, 584, 309, 484, 6588, 13, 509, 362, 512, 9521], "temperature": 0.0, "avg_logprob": -0.19018031529017856, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.00014849081344436854}, {"id": 229, "seek": 130868, "start": 1329.64, "end": 1335.48, "text": " resource, the diverse helpers that reach into other subsystems, which also have their own", "tokens": [7684, 11, 264, 9521, 854, 433, 300, 2524, 666, 661, 2090, 9321, 82, 11, 597, 611, 362, 641, 1065], "temperature": 0.0, "avg_logprob": -0.19018031529017856, "compression_ratio": 1.7115384615384615, "no_speech_prob": 0.00014849081344436854}, {"id": 230, "seek": 133548, "start": 1335.48, "end": 1342.0, "text": " issues. So this can be dangerous as well.", "tokens": [2663, 13, 407, 341, 393, 312, 5795, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.15781663538335444, "compression_ratio": 1.7841409691629957, "no_speech_prob": 0.00023640893050469458}, {"id": 231, "seek": 133548, "start": 1342.0, "end": 1347.28, "text": " So I have seen in multiple places where drivers are allocating the strike device that is then", "tokens": [407, 286, 362, 1612, 294, 3866, 3190, 689, 11590, 366, 12660, 990, 264, 9302, 4302, 300, 307, 550], "temperature": 0.0, "avg_logprob": -0.15781663538335444, "compression_ratio": 1.7841409691629957, "no_speech_prob": 0.00023640893050469458}, {"id": 232, "seek": 133548, "start": 1347.28, "end": 1351.64, "text": " getting passed to the framework. But then the solution that they are using is that they", "tokens": [1242, 4678, 281, 264, 8388, 13, 583, 550, 264, 3827, 300, 436, 366, 1228, 307, 300, 436], "temperature": 0.0, "avg_logprob": -0.15781663538335444, "compression_ratio": 1.7841409691629957, "no_speech_prob": 0.00023640893050469458}, {"id": 233, "seek": 133548, "start": 1351.64, "end": 1356.72, "text": " are basically instead of freeing the device in remove, they are just dropping the reference", "tokens": [366, 1936, 2602, 295, 1737, 278, 264, 4302, 294, 4159, 11, 436, 366, 445, 13601, 264, 6408], "temperature": 0.0, "avg_logprob": -0.15781663538335444, "compression_ratio": 1.7841409691629957, "no_speech_prob": 0.00023640893050469458}, {"id": 234, "seek": 133548, "start": 1356.72, "end": 1361.48, "text": " to that device that has been allocated. So someone is taking the ownership of that device", "tokens": [281, 300, 4302, 300, 575, 668, 29772, 13, 407, 1580, 307, 1940, 264, 15279, 295, 300, 4302], "temperature": 0.0, "avg_logprob": -0.15781663538335444, "compression_ratio": 1.7841409691629957, "no_speech_prob": 0.00023640893050469458}, {"id": 235, "seek": 136148, "start": 1361.48, "end": 1366.08, "text": " and then you rely on the reference counting to that device and then freeing that strike", "tokens": [293, 550, 291, 10687, 322, 264, 6408, 13251, 281, 300, 4302, 293, 550, 1737, 278, 300, 9302], "temperature": 0.0, "avg_logprob": -0.15554549477317117, "compression_ratio": 1.875, "no_speech_prob": 0.00015083584003150463}, {"id": 236, "seek": 136148, "start": 1366.08, "end": 1372.92, "text": " device only from the release callback that is then set by the driver itself.", "tokens": [4302, 787, 490, 264, 4374, 818, 3207, 300, 307, 550, 992, 538, 264, 6787, 2564, 13], "temperature": 0.0, "avg_logprob": -0.15554549477317117, "compression_ratio": 1.875, "no_speech_prob": 0.00015083584003150463}, {"id": 237, "seek": 136148, "start": 1372.92, "end": 1380.08, "text": " This is what SPY does. But I2C is a worse example because you usually have a driver data.", "tokens": [639, 307, 437, 8420, 56, 775, 13, 583, 286, 17, 34, 307, 257, 5324, 1365, 570, 291, 2673, 362, 257, 6787, 1412, 13], "temperature": 0.0, "avg_logprob": -0.15554549477317117, "compression_ratio": 1.875, "no_speech_prob": 0.00015083584003150463}, {"id": 238, "seek": 136148, "start": 1380.08, "end": 1384.08, "text": " Inside it you have I2C adapter. Inside it you have strike device. And this strike device", "tokens": [15123, 309, 291, 362, 286, 17, 34, 22860, 13, 15123, 309, 291, 362, 9302, 4302, 13, 400, 341, 9302, 4302], "temperature": 0.0, "avg_logprob": -0.15554549477317117, "compression_ratio": 1.875, "no_speech_prob": 0.00015083584003150463}, {"id": 239, "seek": 136148, "start": 1384.08, "end": 1389.3600000000001, "text": " has this release callback. But in the release callback, you are in the subsystem, it cannot", "tokens": [575, 341, 4374, 818, 3207, 13, 583, 294, 264, 4374, 818, 3207, 11, 291, 366, 294, 264, 2090, 9321, 11, 309, 2644], "temperature": 0.0, "avg_logprob": -0.15554549477317117, "compression_ratio": 1.875, "no_speech_prob": 0.00015083584003150463}, {"id": 240, "seek": 138936, "start": 1389.36, "end": 1397.28, "text": " know what the outer layer structure is and where is it, what offset it adds to free it.", "tokens": [458, 437, 264, 10847, 4583, 3877, 307, 293, 689, 307, 309, 11, 437, 18687, 309, 10860, 281, 1737, 309, 13], "temperature": 0.0, "avg_logprob": -0.3810714224110479, "compression_ratio": 1.3700787401574803, "no_speech_prob": 0.0002384953695582226}, {"id": 241, "seek": 138936, "start": 1397.28, "end": 1408.28, "text": " So it sets the release callback of the strike device. It's another workaround I guess.", "tokens": [407, 309, 6352, 264, 4374, 818, 3207, 295, 264, 9302, 4302, 13, 467, 311, 1071, 589, 25762, 286, 2041, 13], "temperature": 0.0, "avg_logprob": -0.3810714224110479, "compression_ratio": 1.3700787401574803, "no_speech_prob": 0.0002384953695582226}, {"id": 242, "seek": 140828, "start": 1408.28, "end": 1431.32, "text": " It seems to me that the right thing to do is not let drivers allocate strike device instead", "tokens": [467, 2544, 281, 385, 300, 264, 558, 551, 281, 360, 307, 406, 718, 11590, 35713, 9302, 4302, 2602], "temperature": 0.0, "avg_logprob": -0.23192655472528367, "compression_ratio": 1.3692307692307693, "no_speech_prob": 0.00016177658108063042}, {"id": 243, "seek": 140828, "start": 1431.32, "end": 1436.56, "text": " do it in the subsystem if you need to. This also hides some additional complexity from", "tokens": [360, 309, 294, 264, 2090, 9321, 498, 291, 643, 281, 13, 639, 611, 35953, 512, 4497, 14024, 490], "temperature": 0.0, "avg_logprob": -0.23192655472528367, "compression_ratio": 1.3692307692307693, "no_speech_prob": 0.00016177658108063042}, {"id": 244, "seek": 143656, "start": 1436.56, "end": 1440.9199999999998, "text": " the driver developers.", "tokens": [264, 6787, 8849, 13], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 245, "seek": 143656, "start": 1440.9199999999998, "end": 1446.08, "text": " On the slide about the state of the current subsystems you had a question mark after SPY.", "tokens": [1282, 264, 4137, 466, 264, 1785, 295, 264, 2190, 2090, 9321, 82, 291, 632, 257, 1168, 1491, 934, 8420, 56, 13], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 246, "seek": 143656, "start": 1446.08, "end": 1449.28, "text": " I wonder if you have doubts if it's fine today.", "tokens": [286, 2441, 498, 291, 362, 22618, 498, 309, 311, 2489, 965, 13], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 247, "seek": 143656, "start": 1449.28, "end": 1452.72, "text": " Yeah, I think, no, this is the one, right?", "tokens": [865, 11, 286, 519, 11, 572, 11, 341, 307, 264, 472, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 248, "seek": 143656, "start": 1452.72, "end": 1453.72, "text": " That one.", "tokens": [663, 472, 13], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 249, "seek": 143656, "start": 1453.72, "end": 1454.72, "text": " This one?", "tokens": [639, 472, 30], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 250, "seek": 143656, "start": 1454.72, "end": 1457.6799999999998, "text": " Yeah, there is a question mark in the SPY.", "tokens": [865, 11, 456, 307, 257, 1168, 1491, 294, 264, 8420, 56, 13], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 251, "seek": 143656, "start": 1457.6799999999998, "end": 1464.12, "text": " Yes, I put it there because I haven't investigated that in detail so I wasn't sure if it works", "tokens": [1079, 11, 286, 829, 309, 456, 570, 286, 2378, 380, 30070, 300, 294, 2607, 370, 286, 2067, 380, 988, 498, 309, 1985], "temperature": 0.0, "avg_logprob": -0.27931120636266304, "compression_ratio": 1.6116071428571428, "no_speech_prob": 0.0005284688086248934}, {"id": 252, "seek": 146412, "start": 1464.12, "end": 1473.0, "text": " fine. It looks to be working fine, like just from testing it. I wasn't sure if it's correctly", "tokens": [2489, 13, 467, 1542, 281, 312, 1364, 2489, 11, 411, 445, 490, 4997, 309, 13, 286, 2067, 380, 988, 498, 309, 311, 8944], "temperature": 0.0, "avg_logprob": -0.23372300465901694, "compression_ratio": 1.6262135922330097, "no_speech_prob": 0.00029081496177241206}, {"id": 253, "seek": 146412, "start": 1473.0, "end": 1476.6399999999999, "text": " implemented, let's say, because it sounds good in theory.", "tokens": [12270, 11, 718, 311, 584, 11, 570, 309, 3263, 665, 294, 5261, 13], "temperature": 0.0, "avg_logprob": -0.23372300465901694, "compression_ratio": 1.6262135922330097, "no_speech_prob": 0.00029081496177241206}, {"id": 254, "seek": 146412, "start": 1476.6399999999999, "end": 1481.36, "text": " All right, the last question.", "tokens": [1057, 558, 11, 264, 1036, 1168, 13], "temperature": 0.0, "avg_logprob": -0.23372300465901694, "compression_ratio": 1.6262135922330097, "no_speech_prob": 0.00029081496177241206}, {"id": 255, "seek": 146412, "start": 1481.36, "end": 1488.52, "text": " So for systems like I2C, has anybody calculated the amount of pain for things like the I2C,", "tokens": [407, 337, 3652, 411, 286, 17, 34, 11, 575, 4472, 15598, 264, 2372, 295, 1822, 337, 721, 411, 264, 286, 17, 34, 11], "temperature": 0.0, "avg_logprob": -0.23372300465901694, "compression_ratio": 1.6262135922330097, "no_speech_prob": 0.00029081496177241206}, {"id": 256, "seek": 146412, "start": 1488.52, "end": 1493.4399999999998, "text": " has anybody calculated the amount of actual work to fix this?", "tokens": [575, 4472, 15598, 264, 2372, 295, 3539, 589, 281, 3191, 341, 30], "temperature": 0.0, "avg_logprob": -0.23372300465901694, "compression_ratio": 1.6262135922330097, "no_speech_prob": 0.00029081496177241206}, {"id": 257, "seek": 149344, "start": 1493.44, "end": 1502.8400000000001, "text": " It looks like it's a lot because I did send some proposition to Wolfram about wrapping", "tokens": [467, 1542, 411, 309, 311, 257, 688, 570, 286, 630, 2845, 512, 24830, 281, 16634, 2356, 466, 21993], "temperature": 0.0, "avg_logprob": -0.14207190696639244, "compression_ratio": 1.6626016260162602, "no_speech_prob": 0.0001504036335973069}, {"id": 258, "seek": 149344, "start": 1502.8400000000001, "end": 1509.24, "text": " every the reference of the I2C adapter that dev into a helper that would then allow us", "tokens": [633, 264, 6408, 295, 264, 286, 17, 34, 22860, 300, 1905, 666, 257, 36133, 300, 576, 550, 2089, 505], "temperature": 0.0, "avg_logprob": -0.14207190696639244, "compression_ratio": 1.6626016260162602, "no_speech_prob": 0.0001504036335973069}, {"id": 259, "seek": 149344, "start": 1509.24, "end": 1514.96, "text": " to change that strike device into a pointer instead of the proper structure and allocate", "tokens": [281, 1319, 300, 9302, 4302, 666, 257, 23918, 2602, 295, 264, 2296, 3877, 293, 35713], "temperature": 0.0, "avg_logprob": -0.14207190696639244, "compression_ratio": 1.6626016260162602, "no_speech_prob": 0.0001504036335973069}, {"id": 260, "seek": 149344, "start": 1514.96, "end": 1518.52, "text": " that inside the subsystem but it's not going to be easy.", "tokens": [300, 1854, 264, 2090, 9321, 457, 309, 311, 406, 516, 281, 312, 1858, 13], "temperature": 0.0, "avg_logprob": -0.14207190696639244, "compression_ratio": 1.6626016260162602, "no_speech_prob": 0.0001504036335973069}, {"id": 261, "seek": 149344, "start": 1518.52, "end": 1522.8, "text": " This is why I dropped the patch. I told Wolfram not to pursue that because it looks to me", "tokens": [639, 307, 983, 286, 8119, 264, 9972, 13, 286, 1907, 16634, 2356, 406, 281, 12392, 300, 570, 309, 1542, 281, 385], "temperature": 0.0, "avg_logprob": -0.14207190696639244, "compression_ratio": 1.6626016260162602, "no_speech_prob": 0.0001504036335973069}, {"id": 262, "seek": 152280, "start": 1522.8, "end": 1530.2, "text": " like it's not going to be that easy and I don't really want to get my hands that dirty.", "tokens": [411, 309, 311, 406, 516, 281, 312, 300, 1858, 293, 286, 500, 380, 534, 528, 281, 483, 452, 2377, 300, 9360, 13], "temperature": 0.0, "avg_logprob": -0.2123438195337223, "compression_ratio": 1.4678362573099415, "no_speech_prob": 0.0008048561285249889}, {"id": 263, "seek": 152280, "start": 1530.2, "end": 1533.56, "text": " So for somebody else then?", "tokens": [407, 337, 2618, 1646, 550, 30], "temperature": 0.0, "avg_logprob": -0.2123438195337223, "compression_ratio": 1.4678362573099415, "no_speech_prob": 0.0008048561285249889}, {"id": 264, "seek": 152280, "start": 1533.56, "end": 1539.2, "text": " It's been like this for a long time so I'm not sure if anyone's going to step up to try", "tokens": [467, 311, 668, 411, 341, 337, 257, 938, 565, 370, 286, 478, 406, 988, 498, 2878, 311, 516, 281, 1823, 493, 281, 853], "temperature": 0.0, "avg_logprob": -0.2123438195337223, "compression_ratio": 1.4678362573099415, "no_speech_prob": 0.0008048561285249889}, {"id": 265, "seek": 152280, "start": 1539.2, "end": 1540.2, "text": " to fix that.", "tokens": [281, 3191, 300, 13], "temperature": 0.0, "avg_logprob": -0.2123438195337223, "compression_ratio": 1.4678362573099415, "no_speech_prob": 0.0008048561285249889}, {"id": 266, "seek": 152280, "start": 1540.2, "end": 1541.2, "text": " Okay, thank you.", "tokens": [1033, 11, 1309, 291, 13], "temperature": 0.0, "avg_logprob": -0.2123438195337223, "compression_ratio": 1.4678362573099415, "no_speech_prob": 0.0008048561285249889}, {"id": 267, "seek": 152280, "start": 1541.2, "end": 1542.2, "text": " All right, thanks.", "tokens": [1057, 558, 11, 3231, 13], "temperature": 0.0, "avg_logprob": -0.2123438195337223, "compression_ratio": 1.4678362573099415, "no_speech_prob": 0.0008048561285249889}, {"id": 268, "seek": 154220, "start": 1542.2, "end": 1552.64, "text": " Thank you.", "tokens": [50364, 1044, 291, 13, 50886], "temperature": 0.2, "avg_logprob": -0.9763691425323486, "compression_ratio": 0.5555555555555556, "no_speech_prob": 0.0006838383269496262}], "language": "en"}