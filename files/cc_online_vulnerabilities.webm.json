{"text": " Hello everyone, I am Hugo Le Feuvel, PhD student at the University of Manchester. In this talk, I will present the result of my research on compartments interface vulnerabilities, a work that will appear in NDSS 23. This is the result of a collaboration between Manchester, Bucharest, Rice and Unicraft.io. Before starting to talk about interface vulnerabilities, let me bring a little bit of necessary background. And a very important notion in this work is compartmentalization. Compartmentalization is about decomposing software into lesser-privileged components, such that components only have access to what they need to do their job on. Compartmentalization is not particularly something new, so let me illustrate it with a real-world example, web servers. Typically, web servers are composed of components that do, on the one hand, privilege things like listening to port 80, and on the other hand, of other components that perform risky operations like parsing network-provided data. If we have these two components in the same process, then this process has to be root, and that's problematic because if an attacker manages to compromise the network-facing component, for example, then it will immediately own the root process. So what people do in practice is decomposing or compartmentalizing the server into two entities in separate processes, the master, which is privileged and not exposed to risky operations, and the worker, which is deprivileged and exposed to network data. Both entities then communicate over shared memory. Thus, if the worker gets compromised, it will not be able to perform privileged operations and will remain contained. Recently, we have seen really nice advances in the field of compartmentalization. People have been taking more fine-grained, more arbitrary, and more automatic approaches to compartmentalization. And what these work do is taking arbitrary applications, identifying a particular component that may be untrusted or risky, or trusted and critical, and compartmentalizing it automatically or semi-automatically. The granularity of the component can be very variable, ranging from libraries to blocks of code. Notice that I'm talking about compartments here, not processes, as the isolation technology too is very variable. In short, the goal of these works is quite ambitious. It's about compartmentalizing legacy software with a low engineering effort and a low performance cost. Unfortunately, as we're highlighting in this work, things are not as easy as they might seem. And privileged separated software, cross-component interfaces are the attack surface. And there, all sorts of things can go wrong security-wise. Let me give you a few examples. Let's say we have two compartments. One on the left, malicious, and the other one on the right, trusted, protecting some secret. The compartmentalization mechanism guarantees us that Compartment 1 cannot access Compartment 2's memory directly. So that doesn't work. However, Compartment 1 is still able to do legitimate API calls to Compartment 2 with, for example, an invalid pointer. If Compartment 2 doesn't validate the pointer, it will risk exploitation. Another example is the usage of corrupted indexing information, for example, a size, index, or bounds, as is done in this function. Another one is the usage of a corrupted object, such as a tampered file pointer. And there are many others which will go through partially in the next slide. In this work, we unify all of these vulnerabilities under the concept of compartment interface vulnerabilities, or SIVs. SIVs encompass traditional confused deputies, IAGO attacks, which are SIVs specific for the system called API, and their references and their influences under influence and probably many others. They are all attacks revolving around misuse of a legitimate interface. SIVs are very common when compartmentalizing and modified applications, as we further highlight in this talk. They affect all compartmentalization framework because they are a fundamental part of the problem of privilege separation. To put it in more precise words, we define SIVs as the set of vulnerabilities that arise due to lack of or improper control and data flow validation at Compartment Boundaries. We observe three classes of SIVs, data leakages, data corruption, and temporal violations. Within data leakages, we differentiate between address leakages, which can be leveraged to de-rentamize compartments and mount further attacks, and compartment confidential data leakages, which result in information disclosure. Both are due to data oversharing and sharing of uninitialized memory. We have already illustrated a range of data corruption attacks in the previous slide, but generally, there are not to happen in situations where interface-crossing data is used without appropriate sanitization. They can affect control as well as non-control data. Finally, temporal violations include vulnerabilities like expectation of API usage ordering, usage of corruptive synchronization primitives, or a shared memory time of check to time of use. Temporal violations are usually caused by a wide range of behaviors, including missing copies, double fetches, and generally lack of enforcement of API semantics. This is a broad and succent overview, but the paper provides a full taxonomy including an analysis of existing defenses. So having observed and characterized the problem, we asked a few questions. How many SIVs are there at legacy-imported APIs? Are all APIs similarly affected by SIVs, for example, taking library API generally versus module APIs generally? Do we observe systematic differences? How hard are these SIVs to address when compartmentalizing? And finally, how bad are they? If for some reason you don't fix one of them or just decide to not fix them at all, what is the impact on the guarantees that compartmentalization can give to you? We believe that it is really critical to understand these points to be able to provide countermeasures that are adequate, systematic, and usable. And so the approach that we take in this work to answer these questions is to design a tool, and more particularly a fuzzer, specialized to detect SIVs at arbitrary interfaces, and we call this tool Comfuzz. Then we apply Comfuzz at scale to a range of applications and interfaces to gather a dataset of real-world SIVs. Finally, we study, systematize, patronize the resulting dataset to extract numerous insights on the problem of SIVs in compartmentalization. In the next slides, I will give a quick overview of Comfuzz before focusing on the dataset and insights. So let me give you a high-level overview of the fuzzer first. Taking unmodified applications, we instrument them to intercept cross-compartment calls. Compartments are freely defined, for example, a particular library boundary or an internal component interface. We based our prototype on dynamic binary instrumentation using Intel PIN, but also explored other instrumentation approaches, for example, LLVN-based. The interface between the trusted and untrusted components is automatically detected using binary debug information. Our fuzzing monitor then drives the exploration by ordering mutations of the data flow to simulate attacks from the malicious compartment to the trusted compartment. The workload used to drive the program is application-specific, for example, benchmark tools, test suites, custom workloads, etc. You could even plug another fuzzer like OSS there. Finally, the fuzzer automatically triages and stores crash reports that includes de-duplicating, reproducing, minimizing, etc. The paper provides much greater details on these technical matters, and I will be happy to elaborate if you have questions. Using Comfuzz, we gathered a substantial dataset that we carefully dissected. Here you can see the paper's big table that summarizes the dataset. Let's have a closer look at it. Overall, we applied Comfuzz to 25 applications and 36 APIs, for a total of 39 scenarios. We considered a selection of library APIs, module APIs, and internal component APIs, trying to focus on scenarios that make sense in popular software. In fact, 16 of these scenarios have been previously considered by about 12 studies in the literature, and the attacks that we find apply to them as well. In total, we find 629 SIVs. We classify these SIVs in five impact classes, read impact, write impact, execution, memory allocator corruption, and null point under reference. With this data, the first questions that we try to answer are how many SIVs are there at legacy or unmodified arbitrary APIs, and are all APIs or code similarly affected? And looking into this, we quickly confirmed that SIVs are absolutely widespread among unmodified APIs or code. Having said that, we also highlighted significant disparities of prevalence among scenarios, and that's the really interesting part. For example, we observed variations of SIV counts from 0 to 105 across APIs. That's quite significant. Take a look at this plot, which represents for each scenario the number of vulnerable API endpoints versus non-vulnerable. It clearly shows that SIV prevalence among applications and APIs is very heterogeneous. We have large and almost totally SIV-free APIs, and small and fully vulnerable APIs. In fact, we show an entire absence of correlation between API size and SIV count in this dataset. So while clearly, yes, SIVs are widespread, no, not all APIs are similarly affected. This motivates us to look into the patterns and effects that influence these observations. And doing so, we observe recurring APIs and patterns that result in SIVs. This really comforts us in the idea that the presence of SIVs is influenced by structural properties of the API, rather than API size or quantity of shared data. In this talk, I will present one of these patterns, but there are more in the paper. And the particular pattern I want to go through concerns modular APIs. Indeed, we noticed that modular or module APIs are the most SIV-vulnerable interfaces in our study. On average, we observe that module APIs feature more SIVs and worse SIVs than any other class of APIs. And looking at the structure of these interfaces, it makes sense. Unlike library APIs, module APIs must be very generic and yield high performance. As a consequence, we have patterns with the application exposing its core internals and its core states to the module to achieve their generosity and performance. But this results in a much larger attack surface exposed to the module. Take the example of this data structure exposed to potential malicious modules by the Apache HTTP core. It is a very complex with over 75 fields, 60% of which point us, referencing core data structures like memory pools, connection state structures, or mutexes. What we observe with this pattern is a somewhat counter-intuitive thing. Modularity is not always good for compartmentalization, and in many cases, it can even be counterproductive. This is only one of the patterns that we highlight, and there are more in the paper. Now, having shown that SIVs are widespread but affecting applications unequally, or APIs, let's look at their concrete security impact. And the first thing that we confirm is that they are quite impactful. In fact, over 75% of scenarios present in our dataset show at least one right vulnerability. And worse than that, about 70% of write and read and 50% of execute vulnerabilities are arbitrary, which means that the attacker, which means that when the attacker controls a write or read primitive, then they are likely to be able to read and write anywhere. And while only a smaller portion of these scenarios have execution impact, it is likely that read and write primitives will be combinable to achieve execution capabilities. In this talk, I will be concretely illustrating this impact with practical scenarios and real-world SIVs taken from the dataset, where we demonstrate key extraction from a protected OpenSSL. Once again, here, we show more details in the paper. So here, we assume a scenario with two compartments, where the goal is to isolate OpenSSL. For example, from a compromised web server engine X. Isolating OpenSSL, or part of OpenSSL, is a popular application of compartmentalization, both in the literature and in the industry. Thus, here, the compartment interface and therefore the attack surface is the OpenSSL public API. Unfortunately, we find several SIVs that enable for read, write, and execution impact. Take this option setting primitive, for example, which is part of the OpenSSL public API. It differences an interface crossing pointer, sets it, and returns it, clearly resulting in an arbitrary read and write oracle. Any attacker that can compromise the application's control flow will likely be able to extract SSL keys easily. Thus, clearly, if the API is not carefully enough sanitized, the benefits will be pretty low, at most a form of weak hardening. Now, you could tell me that it's not a good idea to protect at the public API anyways, and that we should rather choose the OpenSSL internal key API that's much smaller. So, let's take a look at it. This time, we have NGINX and most of OpenSSL in the untrusted compartment, while we have the small key handling part of OpenSSL together with the keys in the protected compartment. Unfortunately, here too, we find several SIVs. Take a look at this function of the internal key API, for example. I only put the signature for simplicity's sake because the function is implemented in per-generated assembly. You can manipulate the in pointer to point to the key that you cannot directly access, encrypt with a known key, and then decrypt to get the secrets. Hence, here again, attackers that can manage to compromise the application are likely to be able to easily extract the key. Unfortunately here, fixing the SIVs requires to make the component stateful, which is a fairly drastic design change. Overall, through these two examples, I showed how existing OpenSSL isolation strategies collapse when confronted to SIVs, and how important they are security-wise. To conclude this talk, let's take a quick look at countermeasures. How do we tackle SIVs? Overall, we see two ways. First, making progress on automatic and systematic countermeasures. Our paper highlights the limitations as part of our SIV taxonomy. Second, learning from our study of patterns. We also believe that software component APIs should be designed to feature low compartmentalization complexity in the first place. We provide a set of guidelines to achieve this. The two approaches are complementary. Even in the presence of countermeasures, well-designed APIs are wishable, as the first point is known to be fundamentally harder. I will not have enough time to go over all the guidelines, but let me try to give you the gist of them. First, not every interface is a good boundary for privilege separation. Maybe a particular API doesn't fit privilege separation, and that's fine. In this case, it will be hard to harden anyways. Second, we recommend that major attention should be dedicated to reducing the complexity of interface crossing objects. Avoiding, for example, sharing of resource handle, system resource extracts, synchronization primitives, et cetera. If this is not possible, it should bring us back to the first point. The interface is probably not the right point to compartmentalize. For example, because components are too deeply entangled. Third, compartmentalizable components should enforce API semantics to be safe. For example, ordering or concurrency support. Under distrust scenarios, it is not acceptable anymore to assume that the caller will respect them or face the consequences. We are slowly coming towards the end of this talk, so let me summarize the key points that I wanted to make. Civs should be at the center of every compartmentalization approach, and you will likely not achieve tangible security benefits without considering them. API design patterns influence the presence of civs and their severity. Overall, it's not so much about the size of the API. It's about the complexity of API crossing objects. Addressing civs is not just a matter of writing a few checks. In fact, strong solutions often require refactoring the API. Thus, compartmentalizing apps goes much further than just setting and enforcing bounds. We want this work to be an appeal for more research towards addressing the problem of civs, systematically finding them, addressing them, or telling you what interface may good compartmentalization boundaries. If you are interested in this work, I invite you to check out our paper and the code and data set of Confuzz. I will now be more than happy to take questions. Thank you. Thank you, Hugo, for this very accessible talk on this important topic of securing interfaces. One question maybe that I can start with is something that you brought up yourself as well. You say it's more about compartmentalization, but it also applies obviously to TEs. Can you comment a bit on that? Is that something you consider Confuzz, your physics could be extended to something like Gromine? Actually, maybe there are two different parts. I think the conceptual part about compartment interface vulnerabilities, maybe we could remove the compartment out of interface, out of compartment interface vulnerabilities, and just get interface vulnerabilities. I think it has also been described by other works previously, notably some of the work that you did, Joe. I think that applies to TEs really, really well. I think it's just a generic problem about interfaces, and that fully applies to TEs. Regarding the fuzzer, from a very technical point of view, I think that it might need some adaptation to be run on existing TE software, but it's absolutely feasible. I think that it could apply there as well. We didn't really explore it because obviously at some point we needed to restrict the scope of what we're doing, but I think it makes sense. Following up on that as well, I think you mentioned in your slides one of the technologies that you could use for compartmentalization. It's not only TEs, it's also something like Cherry. It uses capabilities, and I'm wondering, TEs are not great in these vulnerabilities because you have these confused specialty attacks that you explained also, where you have a pointer that you essentially can dereference. With Cherry, with capabilities, you have sort of native mitigations for many of those, capabilities I think were made with the idea of avoiding confused deputy. Can you comment a bit on what underlying technology can mean for the vulnerability of compartmentalization? I'm not sure if I can, I don't think I can share my screen, but maybe I can. But you can put a link maybe in the chat for people. Actually in the paper we did talk about this, so I'm just going to share my screen, but maybe I can. I'm sorry, I just broke everything. I just posted the link, I don't know if I triggered something terrible. I think I see the link, I think you unmuted that or something. So the paper goes in data, can you summarize maybe in the minute that remains? Absolutely, yes. So Cherry provides some features that as you said are really nice in addressing some of the spatial part of the compartment interface spectrum, of the SIV spectrum. It does not solve everything, it's not magic. Like many of the leakage issues remain, many of the temporal issues remain as well, because to some extent they are a little bit more high level than just spatial things on memory. So they still apply. For example, the issues with ordering of interface calls. If you have an interface that has some ordering expectations, for example calling function one before function two, and you don't respect that, Cherry is not necessarily going to help you. So this is going to remain. So it does address part of it, but it's not necessarily going to help you. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 22.96, "text": " Hello everyone, I am Hugo Le Feuvel, PhD student at the University of Manchester.", "tokens": [2425, 1518, 11, 286, 669, 32504, 1456, 3697, 84, 779, 11, 14476, 3107, 412, 264, 3535, 295, 27180, 13], "temperature": 0.0, "avg_logprob": -0.34728921845901845, "compression_ratio": 1.2877697841726619, "no_speech_prob": 0.06518706679344177}, {"id": 1, "seek": 0, "start": 22.96, "end": 28.12, "text": " In this talk, I will present the result of my research on compartments interface vulnerabilities,", "tokens": [682, 341, 751, 11, 286, 486, 1974, 264, 1874, 295, 452, 2132, 322, 18113, 1117, 9226, 37633, 11], "temperature": 0.0, "avg_logprob": -0.34728921845901845, "compression_ratio": 1.2877697841726619, "no_speech_prob": 0.06518706679344177}, {"id": 2, "seek": 2812, "start": 28.12, "end": 34.44, "text": " a work that will appear in NDSS 23. This is the result of a collaboration between Manchester,", "tokens": [257, 589, 300, 486, 4204, 294, 426, 11844, 50, 6673, 13, 639, 307, 264, 1874, 295, 257, 9363, 1296, 27180, 11], "temperature": 0.0, "avg_logprob": -0.1976689232720269, "compression_ratio": 1.5, "no_speech_prob": 0.00029604751034639776}, {"id": 3, "seek": 2812, "start": 34.44, "end": 42.400000000000006, "text": " Bucharest, Rice and Unicraft.io. Before starting to talk about interface", "tokens": [25818, 17363, 11, 19386, 293, 1156, 299, 4469, 13, 1004, 13, 4546, 2891, 281, 751, 466, 9226], "temperature": 0.0, "avg_logprob": -0.1976689232720269, "compression_ratio": 1.5, "no_speech_prob": 0.00029604751034639776}, {"id": 4, "seek": 2812, "start": 42.400000000000006, "end": 47.68, "text": " vulnerabilities, let me bring a little bit of necessary background. And a very important", "tokens": [37633, 11, 718, 385, 1565, 257, 707, 857, 295, 4818, 3678, 13, 400, 257, 588, 1021], "temperature": 0.0, "avg_logprob": -0.1976689232720269, "compression_ratio": 1.5, "no_speech_prob": 0.00029604751034639776}, {"id": 5, "seek": 2812, "start": 47.68, "end": 53.52, "text": " notion in this work is compartmentalization. Compartmentalization is about decomposing", "tokens": [10710, 294, 341, 589, 307, 26505, 304, 2144, 13, 6620, 3033, 304, 2144, 307, 466, 22867, 6110], "temperature": 0.0, "avg_logprob": -0.1976689232720269, "compression_ratio": 1.5, "no_speech_prob": 0.00029604751034639776}, {"id": 6, "seek": 5352, "start": 53.52, "end": 58.84, "text": " software into lesser-privileged components, such that components only have access to what", "tokens": [4722, 666, 22043, 12, 79, 29994, 794, 3004, 6677, 11, 1270, 300, 6677, 787, 362, 2105, 281, 437], "temperature": 0.0, "avg_logprob": -0.13560091000851068, "compression_ratio": 1.7238805970149254, "no_speech_prob": 0.00012063305621268228}, {"id": 7, "seek": 5352, "start": 58.84, "end": 64.36, "text": " they need to do their job on. Compartmentalization is not particularly something new, so let", "tokens": [436, 643, 281, 360, 641, 1691, 322, 13, 6620, 3033, 304, 2144, 307, 406, 4098, 746, 777, 11, 370, 718], "temperature": 0.0, "avg_logprob": -0.13560091000851068, "compression_ratio": 1.7238805970149254, "no_speech_prob": 0.00012063305621268228}, {"id": 8, "seek": 5352, "start": 64.36, "end": 70.24000000000001, "text": " me illustrate it with a real-world example, web servers. Typically, web servers are composed", "tokens": [385, 23221, 309, 365, 257, 957, 12, 13217, 1365, 11, 3670, 15909, 13, 23129, 11, 3670, 15909, 366, 18204], "temperature": 0.0, "avg_logprob": -0.13560091000851068, "compression_ratio": 1.7238805970149254, "no_speech_prob": 0.00012063305621268228}, {"id": 9, "seek": 5352, "start": 70.24000000000001, "end": 75.96000000000001, "text": " of components that do, on the one hand, privilege things like listening to port 80, and on the", "tokens": [295, 6677, 300, 360, 11, 322, 264, 472, 1011, 11, 12122, 721, 411, 4764, 281, 2436, 4688, 11, 293, 322, 264], "temperature": 0.0, "avg_logprob": -0.13560091000851068, "compression_ratio": 1.7238805970149254, "no_speech_prob": 0.00012063305621268228}, {"id": 10, "seek": 5352, "start": 75.96000000000001, "end": 81.28, "text": " other hand, of other components that perform risky operations like parsing network-provided", "tokens": [661, 1011, 11, 295, 661, 6677, 300, 2042, 21137, 7705, 411, 21156, 278, 3209, 12, 49911, 2112], "temperature": 0.0, "avg_logprob": -0.13560091000851068, "compression_ratio": 1.7238805970149254, "no_speech_prob": 0.00012063305621268228}, {"id": 11, "seek": 8128, "start": 81.28, "end": 87.08, "text": " data. If we have these two components in the same process, then this process has to be", "tokens": [1412, 13, 759, 321, 362, 613, 732, 6677, 294, 264, 912, 1399, 11, 550, 341, 1399, 575, 281, 312], "temperature": 0.0, "avg_logprob": -0.1175535800410252, "compression_ratio": 1.7358490566037736, "no_speech_prob": 0.00017646381456870586}, {"id": 12, "seek": 8128, "start": 87.08, "end": 92.48, "text": " root, and that's problematic because if an attacker manages to compromise the network-facing", "tokens": [5593, 11, 293, 300, 311, 19011, 570, 498, 364, 35871, 22489, 281, 18577, 264, 3209, 12, 44046], "temperature": 0.0, "avg_logprob": -0.1175535800410252, "compression_ratio": 1.7358490566037736, "no_speech_prob": 0.00017646381456870586}, {"id": 13, "seek": 8128, "start": 92.48, "end": 98.36, "text": " component, for example, then it will immediately own the root process. So what people do in", "tokens": [6542, 11, 337, 1365, 11, 550, 309, 486, 4258, 1065, 264, 5593, 1399, 13, 407, 437, 561, 360, 294], "temperature": 0.0, "avg_logprob": -0.1175535800410252, "compression_ratio": 1.7358490566037736, "no_speech_prob": 0.00017646381456870586}, {"id": 14, "seek": 8128, "start": 98.36, "end": 105.32, "text": " practice is decomposing or compartmentalizing the server into two entities in separate processes,", "tokens": [3124, 307, 22867, 6110, 420, 26505, 304, 3319, 264, 7154, 666, 732, 16667, 294, 4994, 7555, 11], "temperature": 0.0, "avg_logprob": -0.1175535800410252, "compression_ratio": 1.7358490566037736, "no_speech_prob": 0.00017646381456870586}, {"id": 15, "seek": 8128, "start": 105.32, "end": 110.56, "text": " the master, which is privileged and not exposed to risky operations, and the worker, which", "tokens": [264, 4505, 11, 597, 307, 25293, 293, 406, 9495, 281, 21137, 7705, 11, 293, 264, 11346, 11, 597], "temperature": 0.0, "avg_logprob": -0.1175535800410252, "compression_ratio": 1.7358490566037736, "no_speech_prob": 0.00017646381456870586}, {"id": 16, "seek": 11056, "start": 110.56, "end": 116.28, "text": " is deprivileged and exposed to network data. Both entities then communicate over shared", "tokens": [307, 1367, 29994, 794, 3004, 293, 9495, 281, 3209, 1412, 13, 6767, 16667, 550, 7890, 670, 5507], "temperature": 0.0, "avg_logprob": -0.138993552236846, "compression_ratio": 1.7056603773584906, "no_speech_prob": 4.902139335172251e-05}, {"id": 17, "seek": 11056, "start": 116.28, "end": 121.48, "text": " memory. Thus, if the worker gets compromised, it will not be able to perform privileged", "tokens": [4675, 13, 13827, 11, 498, 264, 11346, 2170, 32463, 11, 309, 486, 406, 312, 1075, 281, 2042, 25293], "temperature": 0.0, "avg_logprob": -0.138993552236846, "compression_ratio": 1.7056603773584906, "no_speech_prob": 4.902139335172251e-05}, {"id": 18, "seek": 11056, "start": 121.48, "end": 128.08, "text": " operations and will remain contained. Recently, we have seen really nice advances in the field", "tokens": [7705, 293, 486, 6222, 16212, 13, 20072, 11, 321, 362, 1612, 534, 1481, 25297, 294, 264, 2519], "temperature": 0.0, "avg_logprob": -0.138993552236846, "compression_ratio": 1.7056603773584906, "no_speech_prob": 4.902139335172251e-05}, {"id": 19, "seek": 11056, "start": 128.08, "end": 133.12, "text": " of compartmentalization. People have been taking more fine-grained, more arbitrary,", "tokens": [295, 26505, 304, 2144, 13, 3432, 362, 668, 1940, 544, 2489, 12, 20735, 2001, 11, 544, 23211, 11], "temperature": 0.0, "avg_logprob": -0.138993552236846, "compression_ratio": 1.7056603773584906, "no_speech_prob": 4.902139335172251e-05}, {"id": 20, "seek": 11056, "start": 133.12, "end": 139.2, "text": " and more automatic approaches to compartmentalization. And what these work do is taking arbitrary", "tokens": [293, 544, 12509, 11587, 281, 26505, 304, 2144, 13, 400, 437, 613, 589, 360, 307, 1940, 23211], "temperature": 0.0, "avg_logprob": -0.138993552236846, "compression_ratio": 1.7056603773584906, "no_speech_prob": 4.902139335172251e-05}, {"id": 21, "seek": 13920, "start": 139.2, "end": 146.39999999999998, "text": " applications, identifying a particular component that may be untrusted or risky, or trusted", "tokens": [5821, 11, 16696, 257, 1729, 6542, 300, 815, 312, 1701, 81, 6589, 420, 21137, 11, 420, 16034], "temperature": 0.0, "avg_logprob": -0.13331367419316217, "compression_ratio": 1.7471698113207548, "no_speech_prob": 7.59738904889673e-05}, {"id": 22, "seek": 13920, "start": 146.39999999999998, "end": 153.16, "text": " and critical, and compartmentalizing it automatically or semi-automatically. The granularity of", "tokens": [293, 4924, 11, 293, 26505, 304, 3319, 309, 6772, 420, 12909, 12, 1375, 298, 5030, 13, 440, 39962, 507, 295], "temperature": 0.0, "avg_logprob": -0.13331367419316217, "compression_ratio": 1.7471698113207548, "no_speech_prob": 7.59738904889673e-05}, {"id": 23, "seek": 13920, "start": 153.16, "end": 158.76, "text": " the component can be very variable, ranging from libraries to blocks of code. Notice that", "tokens": [264, 6542, 393, 312, 588, 7006, 11, 25532, 490, 15148, 281, 8474, 295, 3089, 13, 13428, 300], "temperature": 0.0, "avg_logprob": -0.13331367419316217, "compression_ratio": 1.7471698113207548, "no_speech_prob": 7.59738904889673e-05}, {"id": 24, "seek": 13920, "start": 158.76, "end": 163.35999999999999, "text": " I'm talking about compartments here, not processes, as the isolation technology too", "tokens": [286, 478, 1417, 466, 18113, 1117, 510, 11, 406, 7555, 11, 382, 264, 16001, 2899, 886], "temperature": 0.0, "avg_logprob": -0.13331367419316217, "compression_ratio": 1.7471698113207548, "no_speech_prob": 7.59738904889673e-05}, {"id": 25, "seek": 13920, "start": 163.35999999999999, "end": 169.16, "text": " is very variable. In short, the goal of these works is quite ambitious. It's about compartmentalizing", "tokens": [307, 588, 7006, 13, 682, 2099, 11, 264, 3387, 295, 613, 1985, 307, 1596, 20239, 13, 467, 311, 466, 26505, 304, 3319], "temperature": 0.0, "avg_logprob": -0.13331367419316217, "compression_ratio": 1.7471698113207548, "no_speech_prob": 7.59738904889673e-05}, {"id": 26, "seek": 16916, "start": 169.16, "end": 176.48, "text": " legacy software with a low engineering effort and a low performance cost. Unfortunately,", "tokens": [11711, 4722, 365, 257, 2295, 7043, 4630, 293, 257, 2295, 3389, 2063, 13, 8590, 11], "temperature": 0.0, "avg_logprob": -0.11208560046027688, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.0001558198273414746}, {"id": 27, "seek": 16916, "start": 176.48, "end": 182.24, "text": " as we're highlighting in this work, things are not as easy as they might seem. And privileged", "tokens": [382, 321, 434, 26551, 294, 341, 589, 11, 721, 366, 406, 382, 1858, 382, 436, 1062, 1643, 13, 400, 25293], "temperature": 0.0, "avg_logprob": -0.11208560046027688, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.0001558198273414746}, {"id": 28, "seek": 16916, "start": 182.24, "end": 188.76, "text": " separated software, cross-component interfaces are the attack surface. And there, all sorts", "tokens": [12005, 4722, 11, 3278, 12, 21541, 30365, 28416, 366, 264, 2690, 3753, 13, 400, 456, 11, 439, 7527], "temperature": 0.0, "avg_logprob": -0.11208560046027688, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.0001558198273414746}, {"id": 29, "seek": 16916, "start": 188.76, "end": 194.72, "text": " of things can go wrong security-wise. Let me give you a few examples. Let's say we have", "tokens": [295, 721, 393, 352, 2085, 3825, 12, 3711, 13, 961, 385, 976, 291, 257, 1326, 5110, 13, 961, 311, 584, 321, 362], "temperature": 0.0, "avg_logprob": -0.11208560046027688, "compression_ratio": 1.567099567099567, "no_speech_prob": 0.0001558198273414746}, {"id": 30, "seek": 19472, "start": 194.72, "end": 200.56, "text": " two compartments. One on the left, malicious, and the other one on the right, trusted, protecting", "tokens": [732, 18113, 1117, 13, 1485, 322, 264, 1411, 11, 33496, 11, 293, 264, 661, 472, 322, 264, 558, 11, 16034, 11, 12316], "temperature": 0.0, "avg_logprob": -0.1220138506455855, "compression_ratio": 1.608695652173913, "no_speech_prob": 9.900751319946721e-05}, {"id": 31, "seek": 19472, "start": 200.56, "end": 206.8, "text": " some secret. The compartmentalization mechanism guarantees us that Compartment 1 cannot access", "tokens": [512, 4054, 13, 440, 26505, 304, 2144, 7513, 32567, 505, 300, 6620, 3033, 502, 2644, 2105], "temperature": 0.0, "avg_logprob": -0.1220138506455855, "compression_ratio": 1.608695652173913, "no_speech_prob": 9.900751319946721e-05}, {"id": 32, "seek": 19472, "start": 206.8, "end": 213.07999999999998, "text": " Compartment 2's memory directly. So that doesn't work. However, Compartment 1 is still able", "tokens": [6620, 3033, 568, 311, 4675, 3838, 13, 407, 300, 1177, 380, 589, 13, 2908, 11, 6620, 3033, 502, 307, 920, 1075], "temperature": 0.0, "avg_logprob": -0.1220138506455855, "compression_ratio": 1.608695652173913, "no_speech_prob": 9.900751319946721e-05}, {"id": 33, "seek": 19472, "start": 213.07999999999998, "end": 220.24, "text": " to do legitimate API calls to Compartment 2 with, for example, an invalid pointer. If", "tokens": [281, 360, 17956, 9362, 5498, 281, 6620, 3033, 568, 365, 11, 337, 1365, 11, 364, 34702, 23918, 13, 759], "temperature": 0.0, "avg_logprob": -0.1220138506455855, "compression_ratio": 1.608695652173913, "no_speech_prob": 9.900751319946721e-05}, {"id": 34, "seek": 22024, "start": 220.24, "end": 225.88, "text": " Compartment 2 doesn't validate the pointer, it will risk exploitation. Another example", "tokens": [6620, 3033, 568, 1177, 380, 29562, 264, 23918, 11, 309, 486, 3148, 33122, 13, 3996, 1365], "temperature": 0.0, "avg_logprob": -0.13143463134765626, "compression_ratio": 1.7300380228136882, "no_speech_prob": 2.1104067855048925e-05}, {"id": 35, "seek": 22024, "start": 225.88, "end": 232.0, "text": " is the usage of corrupted indexing information, for example, a size, index, or bounds, as", "tokens": [307, 264, 14924, 295, 39480, 8186, 278, 1589, 11, 337, 1365, 11, 257, 2744, 11, 8186, 11, 420, 29905, 11, 382], "temperature": 0.0, "avg_logprob": -0.13143463134765626, "compression_ratio": 1.7300380228136882, "no_speech_prob": 2.1104067855048925e-05}, {"id": 36, "seek": 22024, "start": 232.0, "end": 237.88, "text": " is done in this function. Another one is the usage of a corrupted object, such as a tampered", "tokens": [307, 1096, 294, 341, 2445, 13, 3996, 472, 307, 264, 14924, 295, 257, 39480, 2657, 11, 1270, 382, 257, 7677, 40004], "temperature": 0.0, "avg_logprob": -0.13143463134765626, "compression_ratio": 1.7300380228136882, "no_speech_prob": 2.1104067855048925e-05}, {"id": 37, "seek": 22024, "start": 237.88, "end": 244.84, "text": " file pointer. And there are many others which will go through partially in the next slide.", "tokens": [3991, 23918, 13, 400, 456, 366, 867, 2357, 597, 486, 352, 807, 18886, 294, 264, 958, 4137, 13], "temperature": 0.0, "avg_logprob": -0.13143463134765626, "compression_ratio": 1.7300380228136882, "no_speech_prob": 2.1104067855048925e-05}, {"id": 38, "seek": 22024, "start": 244.84, "end": 250.08, "text": " In this work, we unify all of these vulnerabilities under the concept of compartment interface", "tokens": [682, 341, 589, 11, 321, 517, 2505, 439, 295, 613, 37633, 833, 264, 3410, 295, 26505, 9226], "temperature": 0.0, "avg_logprob": -0.13143463134765626, "compression_ratio": 1.7300380228136882, "no_speech_prob": 2.1104067855048925e-05}, {"id": 39, "seek": 25008, "start": 250.08, "end": 257.08000000000004, "text": " vulnerabilities, or SIVs. SIVs encompass traditional confused deputies, IAGO attacks, which are", "tokens": [37633, 11, 420, 318, 10375, 82, 13, 318, 10375, 82, 28268, 5164, 9019, 1367, 17899, 11, 286, 32, 11601, 8122, 11, 597, 366], "temperature": 0.0, "avg_logprob": -0.20482563150340113, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0001070403668563813}, {"id": 40, "seek": 25008, "start": 257.08000000000004, "end": 262.36, "text": " SIVs specific for the system called API, and their references and their influences under", "tokens": [318, 10375, 82, 2685, 337, 264, 1185, 1219, 9362, 11, 293, 641, 15400, 293, 641, 21222, 833], "temperature": 0.0, "avg_logprob": -0.20482563150340113, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0001070403668563813}, {"id": 41, "seek": 25008, "start": 262.36, "end": 268.84000000000003, "text": " influence and probably many others. They are all attacks revolving around misuse of a legitimate", "tokens": [6503, 293, 1391, 867, 2357, 13, 814, 366, 439, 8122, 16908, 798, 926, 3346, 438, 295, 257, 17956], "temperature": 0.0, "avg_logprob": -0.20482563150340113, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0001070403668563813}, {"id": 42, "seek": 25008, "start": 268.84000000000003, "end": 275.08000000000004, "text": " interface. SIVs are very common when compartmentalizing and modified applications, as we further", "tokens": [9226, 13, 318, 10375, 82, 366, 588, 2689, 562, 26505, 304, 3319, 293, 15873, 5821, 11, 382, 321, 3052], "temperature": 0.0, "avg_logprob": -0.20482563150340113, "compression_ratio": 1.5684647302904564, "no_speech_prob": 0.0001070403668563813}, {"id": 43, "seek": 27508, "start": 275.08, "end": 281.71999999999997, "text": " highlight in this talk. They affect all compartmentalization framework because they are a fundamental", "tokens": [5078, 294, 341, 751, 13, 814, 3345, 439, 26505, 304, 2144, 8388, 570, 436, 366, 257, 8088], "temperature": 0.0, "avg_logprob": -0.15681253477584484, "compression_ratio": 1.5854700854700854, "no_speech_prob": 3.761439802474342e-05}, {"id": 44, "seek": 27508, "start": 281.71999999999997, "end": 288.08, "text": " part of the problem of privilege separation. To put it in more precise words, we define", "tokens": [644, 295, 264, 1154, 295, 12122, 14634, 13, 1407, 829, 309, 294, 544, 13600, 2283, 11, 321, 6964], "temperature": 0.0, "avg_logprob": -0.15681253477584484, "compression_ratio": 1.5854700854700854, "no_speech_prob": 3.761439802474342e-05}, {"id": 45, "seek": 27508, "start": 288.08, "end": 294.79999999999995, "text": " SIVs as the set of vulnerabilities that arise due to lack of or improper control and data", "tokens": [318, 10375, 82, 382, 264, 992, 295, 37633, 300, 20288, 3462, 281, 5011, 295, 420, 40651, 1969, 293, 1412], "temperature": 0.0, "avg_logprob": -0.15681253477584484, "compression_ratio": 1.5854700854700854, "no_speech_prob": 3.761439802474342e-05}, {"id": 46, "seek": 27508, "start": 294.79999999999995, "end": 301.91999999999996, "text": " flow validation at Compartment Boundaries. We observe three classes of SIVs, data leakages,", "tokens": [3095, 24071, 412, 6620, 3033, 363, 554, 4889, 13, 492, 11441, 1045, 5359, 295, 318, 10375, 82, 11, 1412, 17143, 1660, 11], "temperature": 0.0, "avg_logprob": -0.15681253477584484, "compression_ratio": 1.5854700854700854, "no_speech_prob": 3.761439802474342e-05}, {"id": 47, "seek": 30192, "start": 301.92, "end": 307.2, "text": " data corruption, and temporal violations. Within data leakages, we differentiate between", "tokens": [1412, 17959, 11, 293, 30881, 30405, 13, 15996, 1412, 17143, 1660, 11, 321, 23203, 1296], "temperature": 0.0, "avg_logprob": -0.1578848964036113, "compression_ratio": 1.744186046511628, "no_speech_prob": 5.5559357861056924e-05}, {"id": 48, "seek": 30192, "start": 307.2, "end": 311.8, "text": " address leakages, which can be leveraged to de-rentamize compartments and mount further", "tokens": [2985, 17143, 1660, 11, 597, 393, 312, 12451, 2980, 281, 368, 12, 1753, 335, 1125, 18113, 1117, 293, 3746, 3052], "temperature": 0.0, "avg_logprob": -0.1578848964036113, "compression_ratio": 1.744186046511628, "no_speech_prob": 5.5559357861056924e-05}, {"id": 49, "seek": 30192, "start": 311.8, "end": 318.76, "text": " attacks, and compartment confidential data leakages, which result in information disclosure.", "tokens": [8122, 11, 293, 26505, 27054, 1412, 17143, 1660, 11, 597, 1874, 294, 1589, 30392, 13], "temperature": 0.0, "avg_logprob": -0.1578848964036113, "compression_ratio": 1.744186046511628, "no_speech_prob": 5.5559357861056924e-05}, {"id": 50, "seek": 30192, "start": 318.76, "end": 324.92, "text": " Both are due to data oversharing and sharing of uninitialized memory. We have already illustrated", "tokens": [6767, 366, 3462, 281, 1412, 670, 2716, 1921, 293, 5414, 295, 43456, 270, 831, 1602, 4675, 13, 492, 362, 1217, 33875], "temperature": 0.0, "avg_logprob": -0.1578848964036113, "compression_ratio": 1.744186046511628, "no_speech_prob": 5.5559357861056924e-05}, {"id": 51, "seek": 30192, "start": 324.92, "end": 330.04, "text": " a range of data corruption attacks in the previous slide, but generally, there are", "tokens": [257, 3613, 295, 1412, 17959, 8122, 294, 264, 3894, 4137, 11, 457, 5101, 11, 456, 366], "temperature": 0.0, "avg_logprob": -0.1578848964036113, "compression_ratio": 1.744186046511628, "no_speech_prob": 5.5559357861056924e-05}, {"id": 52, "seek": 33004, "start": 330.04, "end": 336.52000000000004, "text": " not to happen in situations where interface-crossing data is used without appropriate sanitization.", "tokens": [406, 281, 1051, 294, 6851, 689, 9226, 12, 35418, 278, 1412, 307, 1143, 1553, 6854, 24533, 2144, 13], "temperature": 0.0, "avg_logprob": -0.1894593860792077, "compression_ratio": 1.65, "no_speech_prob": 3.217330959159881e-05}, {"id": 53, "seek": 33004, "start": 336.52000000000004, "end": 340.24, "text": " They can affect control as well as non-control data.", "tokens": [814, 393, 3345, 1969, 382, 731, 382, 2107, 12, 40905, 1412, 13], "temperature": 0.0, "avg_logprob": -0.1894593860792077, "compression_ratio": 1.65, "no_speech_prob": 3.217330959159881e-05}, {"id": 54, "seek": 33004, "start": 340.24, "end": 347.20000000000005, "text": " Finally, temporal violations include vulnerabilities like expectation of API usage ordering, usage", "tokens": [6288, 11, 30881, 30405, 4090, 37633, 411, 14334, 295, 9362, 14924, 21739, 11, 14924], "temperature": 0.0, "avg_logprob": -0.1894593860792077, "compression_ratio": 1.65, "no_speech_prob": 3.217330959159881e-05}, {"id": 55, "seek": 33004, "start": 347.20000000000005, "end": 351.6, "text": " of corruptive synchronization primitives, or a shared memory time of check to time of", "tokens": [295, 17366, 488, 19331, 2144, 2886, 38970, 11, 420, 257, 5507, 4675, 565, 295, 1520, 281, 565, 295], "temperature": 0.0, "avg_logprob": -0.1894593860792077, "compression_ratio": 1.65, "no_speech_prob": 3.217330959159881e-05}, {"id": 56, "seek": 33004, "start": 351.6, "end": 357.44, "text": " use. Temporal violations are usually caused by a wide range of behaviors, including missing", "tokens": [764, 13, 8095, 2816, 304, 30405, 366, 2673, 7008, 538, 257, 4874, 3613, 295, 15501, 11, 3009, 5361], "temperature": 0.0, "avg_logprob": -0.1894593860792077, "compression_ratio": 1.65, "no_speech_prob": 3.217330959159881e-05}, {"id": 57, "seek": 35744, "start": 357.44, "end": 364.12, "text": " copies, double fetches, and generally lack of enforcement of API semantics. This is a", "tokens": [14341, 11, 3834, 15136, 3781, 11, 293, 5101, 5011, 295, 11475, 295, 9362, 4361, 45298, 13, 639, 307, 257], "temperature": 0.0, "avg_logprob": -0.13095914233814587, "compression_ratio": 1.4897119341563787, "no_speech_prob": 4.194259599898942e-05}, {"id": 58, "seek": 35744, "start": 364.12, "end": 369.64, "text": " broad and succent overview, but the paper provides a full taxonomy including an analysis", "tokens": [4152, 293, 21578, 317, 12492, 11, 457, 264, 3035, 6417, 257, 1577, 3366, 23423, 3009, 364, 5215], "temperature": 0.0, "avg_logprob": -0.13095914233814587, "compression_ratio": 1.4897119341563787, "no_speech_prob": 4.194259599898942e-05}, {"id": 59, "seek": 35744, "start": 369.64, "end": 378.2, "text": " of existing defenses. So having observed and characterized the problem, we asked a few questions.", "tokens": [295, 6741, 35989, 13, 407, 1419, 13095, 293, 29361, 264, 1154, 11, 321, 2351, 257, 1326, 1651, 13], "temperature": 0.0, "avg_logprob": -0.13095914233814587, "compression_ratio": 1.4897119341563787, "no_speech_prob": 4.194259599898942e-05}, {"id": 60, "seek": 35744, "start": 378.2, "end": 385.12, "text": " How many SIVs are there at legacy-imported APIs? Are all APIs similarly affected by SIVs,", "tokens": [1012, 867, 318, 10375, 82, 366, 456, 412, 11711, 12, 20737, 292, 21445, 30, 2014, 439, 21445, 14138, 8028, 538, 318, 10375, 82, 11], "temperature": 0.0, "avg_logprob": -0.13095914233814587, "compression_ratio": 1.4897119341563787, "no_speech_prob": 4.194259599898942e-05}, {"id": 61, "seek": 38512, "start": 385.12, "end": 390.08, "text": " for example, taking library API generally versus module APIs generally? Do we observe", "tokens": [337, 1365, 11, 1940, 6405, 9362, 5101, 5717, 10088, 21445, 5101, 30, 1144, 321, 11441], "temperature": 0.0, "avg_logprob": -0.11685712970032984, "compression_ratio": 1.5817490494296578, "no_speech_prob": 6.202617078088224e-05}, {"id": 62, "seek": 38512, "start": 390.08, "end": 396.16, "text": " systematic differences? How hard are these SIVs to address when compartmentalizing?", "tokens": [27249, 7300, 30, 1012, 1152, 366, 613, 318, 10375, 82, 281, 2985, 562, 26505, 304, 3319, 30], "temperature": 0.0, "avg_logprob": -0.11685712970032984, "compression_ratio": 1.5817490494296578, "no_speech_prob": 6.202617078088224e-05}, {"id": 63, "seek": 38512, "start": 396.16, "end": 400.64, "text": " And finally, how bad are they? If for some reason you don't fix one of them or just", "tokens": [400, 2721, 11, 577, 1578, 366, 436, 30, 759, 337, 512, 1778, 291, 500, 380, 3191, 472, 295, 552, 420, 445], "temperature": 0.0, "avg_logprob": -0.11685712970032984, "compression_ratio": 1.5817490494296578, "no_speech_prob": 6.202617078088224e-05}, {"id": 64, "seek": 38512, "start": 400.64, "end": 406.4, "text": " decide to not fix them at all, what is the impact on the guarantees that compartmentalization", "tokens": [4536, 281, 406, 3191, 552, 412, 439, 11, 437, 307, 264, 2712, 322, 264, 32567, 300, 26505, 304, 2144], "temperature": 0.0, "avg_logprob": -0.11685712970032984, "compression_ratio": 1.5817490494296578, "no_speech_prob": 6.202617078088224e-05}, {"id": 65, "seek": 38512, "start": 406.4, "end": 411.48, "text": " can give to you? We believe that it is really critical to understand", "tokens": [393, 976, 281, 291, 30, 492, 1697, 300, 309, 307, 534, 4924, 281, 1223], "temperature": 0.0, "avg_logprob": -0.11685712970032984, "compression_ratio": 1.5817490494296578, "no_speech_prob": 6.202617078088224e-05}, {"id": 66, "seek": 41148, "start": 411.48, "end": 417.96000000000004, "text": " these points to be able to provide countermeasures that are adequate, systematic, and usable.", "tokens": [613, 2793, 281, 312, 1075, 281, 2893, 5682, 1398, 20044, 300, 366, 20927, 11, 27249, 11, 293, 29975, 13], "temperature": 0.0, "avg_logprob": -0.14422160976535672, "compression_ratio": 1.626086956521739, "no_speech_prob": 4.4669752242043614e-05}, {"id": 67, "seek": 41148, "start": 417.96000000000004, "end": 423.36, "text": " And so the approach that we take in this work to answer these questions is to design a tool,", "tokens": [400, 370, 264, 3109, 300, 321, 747, 294, 341, 589, 281, 1867, 613, 1651, 307, 281, 1715, 257, 2290, 11], "temperature": 0.0, "avg_logprob": -0.14422160976535672, "compression_ratio": 1.626086956521739, "no_speech_prob": 4.4669752242043614e-05}, {"id": 68, "seek": 41148, "start": 423.36, "end": 428.32, "text": " and more particularly a fuzzer, specialized to detect SIVs at arbitrary interfaces, and", "tokens": [293, 544, 4098, 257, 283, 3334, 4527, 11, 19813, 281, 5531, 318, 10375, 82, 412, 23211, 28416, 11, 293], "temperature": 0.0, "avg_logprob": -0.14422160976535672, "compression_ratio": 1.626086956521739, "no_speech_prob": 4.4669752242043614e-05}, {"id": 69, "seek": 41148, "start": 428.32, "end": 435.64000000000004, "text": " we call this tool Comfuzz. Then we apply Comfuzz at scale to a range of applications and interfaces", "tokens": [321, 818, 341, 2290, 2432, 69, 16740, 13, 1396, 321, 3079, 2432, 69, 16740, 412, 4373, 281, 257, 3613, 295, 5821, 293, 28416], "temperature": 0.0, "avg_logprob": -0.14422160976535672, "compression_ratio": 1.626086956521739, "no_speech_prob": 4.4669752242043614e-05}, {"id": 70, "seek": 43564, "start": 435.64, "end": 442.36, "text": " to gather a dataset of real-world SIVs. Finally, we study, systematize, patronize", "tokens": [281, 5448, 257, 28872, 295, 957, 12, 13217, 318, 10375, 82, 13, 6288, 11, 321, 2979, 11, 1185, 267, 1125, 11, 21843, 1125], "temperature": 0.0, "avg_logprob": -0.10033299876194374, "compression_ratio": 1.5783132530120483, "no_speech_prob": 2.3908394723548554e-05}, {"id": 71, "seek": 43564, "start": 442.36, "end": 449.47999999999996, "text": " the resulting dataset to extract numerous insights on the problem of SIVs in compartmentalization.", "tokens": [264, 16505, 28872, 281, 8947, 12546, 14310, 322, 264, 1154, 295, 318, 10375, 82, 294, 26505, 304, 2144, 13], "temperature": 0.0, "avg_logprob": -0.10033299876194374, "compression_ratio": 1.5783132530120483, "no_speech_prob": 2.3908394723548554e-05}, {"id": 72, "seek": 43564, "start": 449.47999999999996, "end": 453.8, "text": " In the next slides, I will give a quick overview of Comfuzz before focusing on the dataset", "tokens": [682, 264, 958, 9788, 11, 286, 486, 976, 257, 1702, 12492, 295, 2432, 69, 16740, 949, 8416, 322, 264, 28872], "temperature": 0.0, "avg_logprob": -0.10033299876194374, "compression_ratio": 1.5783132530120483, "no_speech_prob": 2.3908394723548554e-05}, {"id": 73, "seek": 43564, "start": 453.8, "end": 458.32, "text": " and insights. So let me give you a high-level overview", "tokens": [293, 14310, 13, 407, 718, 385, 976, 291, 257, 1090, 12, 12418, 12492], "temperature": 0.0, "avg_logprob": -0.10033299876194374, "compression_ratio": 1.5783132530120483, "no_speech_prob": 2.3908394723548554e-05}, {"id": 74, "seek": 43564, "start": 458.32, "end": 463.28, "text": " of the fuzzer first. Taking unmodified applications, we instrument", "tokens": [295, 264, 283, 3334, 4527, 700, 13, 17837, 517, 8014, 2587, 5821, 11, 321, 7198], "temperature": 0.0, "avg_logprob": -0.10033299876194374, "compression_ratio": 1.5783132530120483, "no_speech_prob": 2.3908394723548554e-05}, {"id": 75, "seek": 46328, "start": 463.28, "end": 468.32, "text": " them to intercept cross-compartment calls. Compartments are freely defined, for example,", "tokens": [552, 281, 24700, 3278, 12, 21541, 3033, 5498, 13, 6620, 446, 1117, 366, 16433, 7642, 11, 337, 1365, 11], "temperature": 0.0, "avg_logprob": -0.11843078136444092, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.00011011308379238471}, {"id": 76, "seek": 46328, "start": 468.32, "end": 474.23999999999995, "text": " a particular library boundary or an internal component interface.", "tokens": [257, 1729, 6405, 12866, 420, 364, 6920, 6542, 9226, 13], "temperature": 0.0, "avg_logprob": -0.11843078136444092, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.00011011308379238471}, {"id": 77, "seek": 46328, "start": 474.23999999999995, "end": 480.52, "text": " We based our prototype on dynamic binary instrumentation using Intel PIN, but also explored other", "tokens": [492, 2361, 527, 19475, 322, 8546, 17434, 7198, 399, 1228, 19762, 430, 1464, 11, 457, 611, 24016, 661], "temperature": 0.0, "avg_logprob": -0.11843078136444092, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.00011011308379238471}, {"id": 78, "seek": 46328, "start": 480.52, "end": 487.64, "text": " instrumentation approaches, for example, LLVN-based. The interface between the trusted and untrusted", "tokens": [7198, 399, 11587, 11, 337, 1365, 11, 441, 43, 53, 45, 12, 6032, 13, 440, 9226, 1296, 264, 16034, 293, 1701, 81, 6589], "temperature": 0.0, "avg_logprob": -0.11843078136444092, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.00011011308379238471}, {"id": 79, "seek": 48764, "start": 487.64, "end": 493.4, "text": " components is automatically detected using binary debug information.", "tokens": [6677, 307, 6772, 21896, 1228, 17434, 24083, 1589, 13], "temperature": 0.0, "avg_logprob": -0.1442876355401401, "compression_ratio": 1.6062992125984252, "no_speech_prob": 6.904129986651242e-05}, {"id": 80, "seek": 48764, "start": 493.4, "end": 498.71999999999997, "text": " Our fuzzing monitor then drives the exploration by ordering mutations of the data flow to", "tokens": [2621, 283, 3334, 8781, 6002, 550, 11754, 264, 16197, 538, 21739, 29243, 295, 264, 1412, 3095, 281], "temperature": 0.0, "avg_logprob": -0.1442876355401401, "compression_ratio": 1.6062992125984252, "no_speech_prob": 6.904129986651242e-05}, {"id": 81, "seek": 48764, "start": 498.71999999999997, "end": 504.64, "text": " simulate attacks from the malicious compartment to the trusted compartment.", "tokens": [27817, 8122, 490, 264, 33496, 26505, 281, 264, 16034, 26505, 13], "temperature": 0.0, "avg_logprob": -0.1442876355401401, "compression_ratio": 1.6062992125984252, "no_speech_prob": 6.904129986651242e-05}, {"id": 82, "seek": 48764, "start": 504.64, "end": 509.12, "text": " The workload used to drive the program is application-specific, for example, benchmark", "tokens": [440, 20139, 1143, 281, 3332, 264, 1461, 307, 3861, 12, 29258, 11, 337, 1365, 11, 18927], "temperature": 0.0, "avg_logprob": -0.1442876355401401, "compression_ratio": 1.6062992125984252, "no_speech_prob": 6.904129986651242e-05}, {"id": 83, "seek": 48764, "start": 509.12, "end": 515.12, "text": " tools, test suites, custom workloads, etc. You could even plug another fuzzer like OSS", "tokens": [3873, 11, 1500, 459, 3324, 11, 2375, 32452, 11, 5183, 13, 509, 727, 754, 5452, 1071, 283, 3334, 4527, 411, 12731, 50], "temperature": 0.0, "avg_logprob": -0.1442876355401401, "compression_ratio": 1.6062992125984252, "no_speech_prob": 6.904129986651242e-05}, {"id": 84, "seek": 51512, "start": 515.12, "end": 519.52, "text": " there. Finally, the fuzzer automatically triages", "tokens": [456, 13, 6288, 11, 264, 283, 3334, 4527, 6772, 1376, 1660], "temperature": 0.0, "avg_logprob": -0.11050166664542732, "compression_ratio": 1.5406504065040652, "no_speech_prob": 7.617218943778425e-05}, {"id": 85, "seek": 51512, "start": 519.52, "end": 528.12, "text": " and stores crash reports that includes de-duplicating, reproducing, minimizing, etc.", "tokens": [293, 9512, 8252, 7122, 300, 5974, 368, 12, 769, 4770, 990, 11, 11408, 2175, 11, 46608, 11, 5183, 13], "temperature": 0.0, "avg_logprob": -0.11050166664542732, "compression_ratio": 1.5406504065040652, "no_speech_prob": 7.617218943778425e-05}, {"id": 86, "seek": 51512, "start": 528.12, "end": 532.32, "text": " The paper provides much greater details on these technical matters, and I will be happy", "tokens": [440, 3035, 6417, 709, 5044, 4365, 322, 613, 6191, 7001, 11, 293, 286, 486, 312, 2055], "temperature": 0.0, "avg_logprob": -0.11050166664542732, "compression_ratio": 1.5406504065040652, "no_speech_prob": 7.617218943778425e-05}, {"id": 87, "seek": 51512, "start": 532.32, "end": 537.2, "text": " to elaborate if you have questions. Using Comfuzz, we gathered a substantial", "tokens": [281, 20945, 498, 291, 362, 1651, 13, 11142, 2432, 69, 16740, 11, 321, 13032, 257, 16726], "temperature": 0.0, "avg_logprob": -0.11050166664542732, "compression_ratio": 1.5406504065040652, "no_speech_prob": 7.617218943778425e-05}, {"id": 88, "seek": 51512, "start": 537.2, "end": 542.72, "text": " dataset that we carefully dissected. Here you can see the paper's big table that", "tokens": [28872, 300, 321, 7500, 48332, 292, 13, 1692, 291, 393, 536, 264, 3035, 311, 955, 3199, 300], "temperature": 0.0, "avg_logprob": -0.11050166664542732, "compression_ratio": 1.5406504065040652, "no_speech_prob": 7.617218943778425e-05}, {"id": 89, "seek": 54272, "start": 542.72, "end": 547.1600000000001, "text": " summarizes the dataset. Let's have a closer look at it.", "tokens": [14611, 5660, 264, 28872, 13, 961, 311, 362, 257, 4966, 574, 412, 309, 13], "temperature": 0.0, "avg_logprob": -0.11261562590903425, "compression_ratio": 1.5328185328185329, "no_speech_prob": 7.478251791326329e-05}, {"id": 90, "seek": 54272, "start": 547.1600000000001, "end": 555.72, "text": " Overall, we applied Comfuzz to 25 applications and 36 APIs, for a total of 39 scenarios.", "tokens": [18420, 11, 321, 6456, 2432, 69, 16740, 281, 3552, 5821, 293, 8652, 21445, 11, 337, 257, 3217, 295, 15238, 15077, 13], "temperature": 0.0, "avg_logprob": -0.11261562590903425, "compression_ratio": 1.5328185328185329, "no_speech_prob": 7.478251791326329e-05}, {"id": 91, "seek": 54272, "start": 555.72, "end": 561.84, "text": " We considered a selection of library APIs, module APIs, and internal component APIs, trying", "tokens": [492, 4888, 257, 9450, 295, 6405, 21445, 11, 10088, 21445, 11, 293, 6920, 6542, 21445, 11, 1382], "temperature": 0.0, "avg_logprob": -0.11261562590903425, "compression_ratio": 1.5328185328185329, "no_speech_prob": 7.478251791326329e-05}, {"id": 92, "seek": 54272, "start": 561.84, "end": 566.44, "text": " to focus on scenarios that make sense in popular software.", "tokens": [281, 1879, 322, 15077, 300, 652, 2020, 294, 3743, 4722, 13], "temperature": 0.0, "avg_logprob": -0.11261562590903425, "compression_ratio": 1.5328185328185329, "no_speech_prob": 7.478251791326329e-05}, {"id": 93, "seek": 54272, "start": 566.44, "end": 572.6, "text": " In fact, 16 of these scenarios have been previously considered by about 12 studies in the literature,", "tokens": [682, 1186, 11, 3165, 295, 613, 15077, 362, 668, 8046, 4888, 538, 466, 2272, 5313, 294, 264, 10394, 11], "temperature": 0.0, "avg_logprob": -0.11261562590903425, "compression_ratio": 1.5328185328185329, "no_speech_prob": 7.478251791326329e-05}, {"id": 94, "seek": 57260, "start": 572.6, "end": 575.16, "text": " and the attacks that we find apply to them as well.", "tokens": [293, 264, 8122, 300, 321, 915, 3079, 281, 552, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.2213771314506071, "compression_ratio": 1.5707070707070707, "no_speech_prob": 3.757758895517327e-05}, {"id": 95, "seek": 57260, "start": 575.16, "end": 584.6800000000001, "text": " In total, we find 629 SIVs. We classify these SIVs in five impact classes, read impact,", "tokens": [682, 3217, 11, 321, 915, 1386, 11871, 318, 10375, 82, 13, 492, 33872, 613, 318, 10375, 82, 294, 1732, 2712, 5359, 11, 1401, 2712, 11], "temperature": 0.0, "avg_logprob": -0.2213771314506071, "compression_ratio": 1.5707070707070707, "no_speech_prob": 3.757758895517327e-05}, {"id": 96, "seek": 57260, "start": 584.6800000000001, "end": 591.5600000000001, "text": " write impact, execution, memory allocator corruption, and null point under reference.", "tokens": [2464, 2712, 11, 15058, 11, 4675, 12660, 1639, 17959, 11, 293, 18184, 935, 833, 6408, 13], "temperature": 0.0, "avg_logprob": -0.2213771314506071, "compression_ratio": 1.5707070707070707, "no_speech_prob": 3.757758895517327e-05}, {"id": 97, "seek": 57260, "start": 591.5600000000001, "end": 596.4, "text": " With this data, the first questions that we try to answer are how many SIVs are there", "tokens": [2022, 341, 1412, 11, 264, 700, 1651, 300, 321, 853, 281, 1867, 366, 577, 867, 318, 10375, 82, 366, 456], "temperature": 0.0, "avg_logprob": -0.2213771314506071, "compression_ratio": 1.5707070707070707, "no_speech_prob": 3.757758895517327e-05}, {"id": 98, "seek": 59640, "start": 596.4, "end": 604.12, "text": " at legacy or unmodified arbitrary APIs, and are all APIs or code similarly affected?", "tokens": [412, 11711, 420, 517, 8014, 2587, 23211, 21445, 11, 293, 366, 439, 21445, 420, 3089, 14138, 8028, 30], "temperature": 0.0, "avg_logprob": -0.11496800961701767, "compression_ratio": 1.5576923076923077, "no_speech_prob": 4.981286474503577e-05}, {"id": 99, "seek": 59640, "start": 604.12, "end": 609.52, "text": " And looking into this, we quickly confirmed that SIVs are absolutely widespread among", "tokens": [400, 1237, 666, 341, 11, 321, 2661, 11341, 300, 318, 10375, 82, 366, 3122, 22679, 3654], "temperature": 0.0, "avg_logprob": -0.11496800961701767, "compression_ratio": 1.5576923076923077, "no_speech_prob": 4.981286474503577e-05}, {"id": 100, "seek": 59640, "start": 609.52, "end": 615.0, "text": " unmodified APIs or code. Having said that, we also highlighted significant", "tokens": [517, 8014, 2587, 21445, 420, 3089, 13, 10222, 848, 300, 11, 321, 611, 17173, 4776], "temperature": 0.0, "avg_logprob": -0.11496800961701767, "compression_ratio": 1.5576923076923077, "no_speech_prob": 4.981286474503577e-05}, {"id": 101, "seek": 59640, "start": 615.0, "end": 620.12, "text": " disparities of prevalence among scenarios, and that's the really interesting part.", "tokens": [32514, 295, 42583, 3654, 15077, 11, 293, 300, 311, 264, 534, 1880, 644, 13], "temperature": 0.0, "avg_logprob": -0.11496800961701767, "compression_ratio": 1.5576923076923077, "no_speech_prob": 4.981286474503577e-05}, {"id": 102, "seek": 59640, "start": 620.12, "end": 626.12, "text": " For example, we observed variations of SIV counts from 0 to 105 across APIs.", "tokens": [1171, 1365, 11, 321, 13095, 17840, 295, 318, 10375, 14893, 490, 1958, 281, 33705, 2108, 21445, 13], "temperature": 0.0, "avg_logprob": -0.11496800961701767, "compression_ratio": 1.5576923076923077, "no_speech_prob": 4.981286474503577e-05}, {"id": 103, "seek": 62612, "start": 626.12, "end": 629.16, "text": " That's quite significant. Take a look at this plot, which represents", "tokens": [663, 311, 1596, 4776, 13, 3664, 257, 574, 412, 341, 7542, 11, 597, 8855], "temperature": 0.0, "avg_logprob": -0.08369880676269531, "compression_ratio": 1.5871212121212122, "no_speech_prob": 6.395616219379008e-05}, {"id": 104, "seek": 62612, "start": 629.16, "end": 635.52, "text": " for each scenario the number of vulnerable API endpoints versus non-vulnerable.", "tokens": [337, 1184, 9005, 264, 1230, 295, 10955, 9362, 917, 20552, 5717, 2107, 12, 85, 425, 1193, 712, 13], "temperature": 0.0, "avg_logprob": -0.08369880676269531, "compression_ratio": 1.5871212121212122, "no_speech_prob": 6.395616219379008e-05}, {"id": 105, "seek": 62612, "start": 635.52, "end": 641.48, "text": " It clearly shows that SIV prevalence among applications and APIs is very heterogeneous.", "tokens": [467, 4448, 3110, 300, 318, 10375, 42583, 3654, 5821, 293, 21445, 307, 588, 20789, 31112, 13], "temperature": 0.0, "avg_logprob": -0.08369880676269531, "compression_ratio": 1.5871212121212122, "no_speech_prob": 6.395616219379008e-05}, {"id": 106, "seek": 62612, "start": 641.48, "end": 648.5600000000001, "text": " We have large and almost totally SIV-free APIs, and small and fully vulnerable APIs.", "tokens": [492, 362, 2416, 293, 1920, 3879, 318, 10375, 12, 10792, 21445, 11, 293, 1359, 293, 4498, 10955, 21445, 13], "temperature": 0.0, "avg_logprob": -0.08369880676269531, "compression_ratio": 1.5871212121212122, "no_speech_prob": 6.395616219379008e-05}, {"id": 107, "seek": 62612, "start": 648.5600000000001, "end": 655.84, "text": " In fact, we show an entire absence of correlation between API size and SIV count in this dataset.", "tokens": [682, 1186, 11, 321, 855, 364, 2302, 17145, 295, 20009, 1296, 9362, 2744, 293, 318, 10375, 1207, 294, 341, 28872, 13], "temperature": 0.0, "avg_logprob": -0.08369880676269531, "compression_ratio": 1.5871212121212122, "no_speech_prob": 6.395616219379008e-05}, {"id": 108, "seek": 65584, "start": 655.84, "end": 663.36, "text": " So while clearly, yes, SIVs are widespread, no, not all APIs are similarly affected.", "tokens": [407, 1339, 4448, 11, 2086, 11, 318, 10375, 82, 366, 22679, 11, 572, 11, 406, 439, 21445, 366, 14138, 8028, 13], "temperature": 0.0, "avg_logprob": -0.07012413769233518, "compression_ratio": 1.6142857142857143, "no_speech_prob": 1.6950669305515476e-05}, {"id": 109, "seek": 65584, "start": 663.36, "end": 669.6, "text": " This motivates us to look into the patterns and effects that influence these observations.", "tokens": [639, 42569, 505, 281, 574, 666, 264, 8294, 293, 5065, 300, 6503, 613, 18163, 13], "temperature": 0.0, "avg_logprob": -0.07012413769233518, "compression_ratio": 1.6142857142857143, "no_speech_prob": 1.6950669305515476e-05}, {"id": 110, "seek": 65584, "start": 669.6, "end": 675.5600000000001, "text": " And doing so, we observe recurring APIs and patterns that result in SIVs.", "tokens": [400, 884, 370, 11, 321, 11441, 32279, 21445, 293, 8294, 300, 1874, 294, 318, 10375, 82, 13], "temperature": 0.0, "avg_logprob": -0.07012413769233518, "compression_ratio": 1.6142857142857143, "no_speech_prob": 1.6950669305515476e-05}, {"id": 111, "seek": 65584, "start": 675.5600000000001, "end": 680.72, "text": " This really comforts us in the idea that the presence of SIVs is influenced by structural", "tokens": [639, 534, 3400, 82, 505, 294, 264, 1558, 300, 264, 6814, 295, 318, 10375, 82, 307, 15269, 538, 15067], "temperature": 0.0, "avg_logprob": -0.07012413769233518, "compression_ratio": 1.6142857142857143, "no_speech_prob": 1.6950669305515476e-05}, {"id": 112, "seek": 68072, "start": 680.72, "end": 686.88, "text": " properties of the API, rather than API size or quantity of shared data.", "tokens": [7221, 295, 264, 9362, 11, 2831, 813, 9362, 2744, 420, 11275, 295, 5507, 1412, 13], "temperature": 0.0, "avg_logprob": -0.1361861792943811, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.122071550227702e-05}, {"id": 113, "seek": 68072, "start": 686.88, "end": 692.0, "text": " In this talk, I will present one of these patterns, but there are more in the paper.", "tokens": [682, 341, 751, 11, 286, 486, 1974, 472, 295, 613, 8294, 11, 457, 456, 366, 544, 294, 264, 3035, 13], "temperature": 0.0, "avg_logprob": -0.1361861792943811, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.122071550227702e-05}, {"id": 114, "seek": 68072, "start": 692.0, "end": 696.1600000000001, "text": " And the particular pattern I want to go through concerns modular APIs.", "tokens": [400, 264, 1729, 5102, 286, 528, 281, 352, 807, 7389, 31111, 21445, 13], "temperature": 0.0, "avg_logprob": -0.1361861792943811, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.122071550227702e-05}, {"id": 115, "seek": 68072, "start": 696.1600000000001, "end": 702.5600000000001, "text": " Indeed, we noticed that modular or module APIs are the most SIV-vulnerable interfaces", "tokens": [15061, 11, 321, 5694, 300, 31111, 420, 10088, 21445, 366, 264, 881, 318, 10375, 12, 85, 425, 1193, 712, 28416], "temperature": 0.0, "avg_logprob": -0.1361861792943811, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.122071550227702e-05}, {"id": 116, "seek": 68072, "start": 702.5600000000001, "end": 706.96, "text": " in our study. On average, we observe that module APIs feature", "tokens": [294, 527, 2979, 13, 1282, 4274, 11, 321, 11441, 300, 10088, 21445, 4111], "temperature": 0.0, "avg_logprob": -0.1361861792943811, "compression_ratio": 1.6163793103448276, "no_speech_prob": 4.122071550227702e-05}, {"id": 117, "seek": 70696, "start": 706.96, "end": 711.9200000000001, "text": " more SIVs and worse SIVs than any other class of APIs.", "tokens": [544, 318, 10375, 82, 293, 5324, 318, 10375, 82, 813, 604, 661, 1508, 295, 21445, 13], "temperature": 0.0, "avg_logprob": -0.14177338095272288, "compression_ratio": 1.6079295154185023, "no_speech_prob": 2.792901977954898e-05}, {"id": 118, "seek": 70696, "start": 711.9200000000001, "end": 715.84, "text": " And looking at the structure of these interfaces, it makes sense.", "tokens": [400, 1237, 412, 264, 3877, 295, 613, 28416, 11, 309, 1669, 2020, 13], "temperature": 0.0, "avg_logprob": -0.14177338095272288, "compression_ratio": 1.6079295154185023, "no_speech_prob": 2.792901977954898e-05}, {"id": 119, "seek": 70696, "start": 715.84, "end": 721.44, "text": " Unlike library APIs, module APIs must be very generic and yield high performance.", "tokens": [17657, 6405, 21445, 11, 10088, 21445, 1633, 312, 588, 19577, 293, 11257, 1090, 3389, 13], "temperature": 0.0, "avg_logprob": -0.14177338095272288, "compression_ratio": 1.6079295154185023, "no_speech_prob": 2.792901977954898e-05}, {"id": 120, "seek": 70696, "start": 721.44, "end": 727.2, "text": " As a consequence, we have patterns with the application exposing its core internals", "tokens": [1018, 257, 18326, 11, 321, 362, 8294, 365, 264, 3861, 33178, 1080, 4965, 2154, 1124], "temperature": 0.0, "avg_logprob": -0.14177338095272288, "compression_ratio": 1.6079295154185023, "no_speech_prob": 2.792901977954898e-05}, {"id": 121, "seek": 70696, "start": 727.2, "end": 732.1600000000001, "text": " and its core states to the module to achieve their generosity and performance.", "tokens": [293, 1080, 4965, 4368, 281, 264, 10088, 281, 4584, 641, 30178, 293, 3389, 13], "temperature": 0.0, "avg_logprob": -0.14177338095272288, "compression_ratio": 1.6079295154185023, "no_speech_prob": 2.792901977954898e-05}, {"id": 122, "seek": 73216, "start": 732.16, "end": 737.1999999999999, "text": " But this results in a much larger attack surface exposed to the module.", "tokens": [583, 341, 3542, 294, 257, 709, 4833, 2690, 3753, 9495, 281, 264, 10088, 13], "temperature": 0.0, "avg_logprob": -0.128825782327091, "compression_ratio": 1.5829787234042554, "no_speech_prob": 4.258718035998754e-05}, {"id": 123, "seek": 73216, "start": 737.1999999999999, "end": 743.04, "text": " Take the example of this data structure exposed to potential malicious modules by the Apache", "tokens": [3664, 264, 1365, 295, 341, 1412, 3877, 9495, 281, 3995, 33496, 16679, 538, 264, 46597], "temperature": 0.0, "avg_logprob": -0.128825782327091, "compression_ratio": 1.5829787234042554, "no_speech_prob": 4.258718035998754e-05}, {"id": 124, "seek": 73216, "start": 743.04, "end": 748.56, "text": " HTTP core. It is a very complex with over 75 fields,", "tokens": [33283, 4965, 13, 467, 307, 257, 588, 3997, 365, 670, 9562, 7909, 11], "temperature": 0.0, "avg_logprob": -0.128825782327091, "compression_ratio": 1.5829787234042554, "no_speech_prob": 4.258718035998754e-05}, {"id": 125, "seek": 73216, "start": 748.56, "end": 754.0799999999999, "text": " 60% of which point us, referencing core data structures like memory pools, connection", "tokens": [4060, 4, 295, 597, 935, 505, 11, 40582, 4965, 1412, 9227, 411, 4675, 28688, 11, 4984], "temperature": 0.0, "avg_logprob": -0.128825782327091, "compression_ratio": 1.5829787234042554, "no_speech_prob": 4.258718035998754e-05}, {"id": 126, "seek": 73216, "start": 754.0799999999999, "end": 759.92, "text": " state structures, or mutexes. What we observe with this pattern is a", "tokens": [1785, 9227, 11, 420, 24523, 47047, 13, 708, 321, 11441, 365, 341, 5102, 307, 257], "temperature": 0.0, "avg_logprob": -0.128825782327091, "compression_ratio": 1.5829787234042554, "no_speech_prob": 4.258718035998754e-05}, {"id": 127, "seek": 75992, "start": 759.92, "end": 768.3199999999999, "text": " somewhat counter-intuitive thing. Modularity is not always good for compartmentalization,", "tokens": [8344, 5682, 12, 686, 48314, 551, 13, 6583, 1040, 507, 307, 406, 1009, 665, 337, 26505, 304, 2144, 11], "temperature": 0.0, "avg_logprob": -0.1095904371012812, "compression_ratio": 1.4938271604938271, "no_speech_prob": 4.260517016518861e-05}, {"id": 128, "seek": 75992, "start": 768.3199999999999, "end": 772.24, "text": " and in many cases, it can even be counterproductive.", "tokens": [293, 294, 867, 3331, 11, 309, 393, 754, 312, 5682, 14314, 20221, 13], "temperature": 0.0, "avg_logprob": -0.1095904371012812, "compression_ratio": 1.4938271604938271, "no_speech_prob": 4.260517016518861e-05}, {"id": 129, "seek": 75992, "start": 772.24, "end": 775.68, "text": " This is only one of the patterns that we highlight, and there are more in the paper.", "tokens": [639, 307, 787, 472, 295, 264, 8294, 300, 321, 5078, 11, 293, 456, 366, 544, 294, 264, 3035, 13], "temperature": 0.0, "avg_logprob": -0.1095904371012812, "compression_ratio": 1.4938271604938271, "no_speech_prob": 4.260517016518861e-05}, {"id": 130, "seek": 75992, "start": 777.04, "end": 782.24, "text": " Now, having shown that SIVs are widespread but affecting applications unequally,", "tokens": [823, 11, 1419, 4898, 300, 318, 10375, 82, 366, 22679, 457, 17476, 5821, 2251, 358, 379, 11], "temperature": 0.0, "avg_logprob": -0.1095904371012812, "compression_ratio": 1.4938271604938271, "no_speech_prob": 4.260517016518861e-05}, {"id": 131, "seek": 75992, "start": 782.24, "end": 785.8399999999999, "text": " or APIs, let's look at their concrete security impact.", "tokens": [420, 21445, 11, 718, 311, 574, 412, 641, 9859, 3825, 2712, 13], "temperature": 0.0, "avg_logprob": -0.1095904371012812, "compression_ratio": 1.4938271604938271, "no_speech_prob": 4.260517016518861e-05}, {"id": 132, "seek": 78584, "start": 785.84, "end": 791.44, "text": " And the first thing that we confirm is that they are quite impactful. In fact,", "tokens": [400, 264, 700, 551, 300, 321, 9064, 307, 300, 436, 366, 1596, 30842, 13, 682, 1186, 11], "temperature": 0.0, "avg_logprob": -0.17178022706663454, "compression_ratio": 1.6231884057971016, "no_speech_prob": 6.914485857123509e-05}, {"id": 133, "seek": 78584, "start": 791.44, "end": 798.0, "text": " over 75% of scenarios present in our dataset show at least one right vulnerability.", "tokens": [670, 9562, 4, 295, 15077, 1974, 294, 527, 28872, 855, 412, 1935, 472, 558, 24210, 13], "temperature": 0.0, "avg_logprob": -0.17178022706663454, "compression_ratio": 1.6231884057971016, "no_speech_prob": 6.914485857123509e-05}, {"id": 134, "seek": 78584, "start": 798.64, "end": 804.96, "text": " And worse than that, about 70% of write and read and 50% of execute vulnerabilities", "tokens": [400, 5324, 813, 300, 11, 466, 5285, 4, 295, 2464, 293, 1401, 293, 2625, 4, 295, 14483, 37633], "temperature": 0.0, "avg_logprob": -0.17178022706663454, "compression_ratio": 1.6231884057971016, "no_speech_prob": 6.914485857123509e-05}, {"id": 135, "seek": 78584, "start": 804.96, "end": 811.0400000000001, "text": " are arbitrary, which means that the attacker, which means that when the attacker controls", "tokens": [366, 23211, 11, 597, 1355, 300, 264, 35871, 11, 597, 1355, 300, 562, 264, 35871, 9003], "temperature": 0.0, "avg_logprob": -0.17178022706663454, "compression_ratio": 1.6231884057971016, "no_speech_prob": 6.914485857123509e-05}, {"id": 136, "seek": 81104, "start": 811.04, "end": 816.24, "text": " a write or read primitive, then they are likely to be able to read and write anywhere.", "tokens": [257, 2464, 420, 1401, 28540, 11, 550, 436, 366, 3700, 281, 312, 1075, 281, 1401, 293, 2464, 4992, 13], "temperature": 0.0, "avg_logprob": -0.07399454895330936, "compression_ratio": 1.785425101214575, "no_speech_prob": 4.192943379166536e-05}, {"id": 137, "seek": 81104, "start": 817.04, "end": 821.52, "text": " And while only a smaller portion of these scenarios have execution impact,", "tokens": [400, 1339, 787, 257, 4356, 8044, 295, 613, 15077, 362, 15058, 2712, 11], "temperature": 0.0, "avg_logprob": -0.07399454895330936, "compression_ratio": 1.785425101214575, "no_speech_prob": 4.192943379166536e-05}, {"id": 138, "seek": 81104, "start": 821.52, "end": 826.7199999999999, "text": " it is likely that read and write primitives will be combinable to achieve execution capabilities.", "tokens": [309, 307, 3700, 300, 1401, 293, 2464, 2886, 38970, 486, 312, 38514, 712, 281, 4584, 15058, 10862, 13], "temperature": 0.0, "avg_logprob": -0.07399454895330936, "compression_ratio": 1.785425101214575, "no_speech_prob": 4.192943379166536e-05}, {"id": 139, "seek": 81104, "start": 827.68, "end": 832.0799999999999, "text": " In this talk, I will be concretely illustrating this impact with practical scenarios", "tokens": [682, 341, 751, 11, 286, 486, 312, 39481, 736, 8490, 8754, 341, 2712, 365, 8496, 15077], "temperature": 0.0, "avg_logprob": -0.07399454895330936, "compression_ratio": 1.785425101214575, "no_speech_prob": 4.192943379166536e-05}, {"id": 140, "seek": 81104, "start": 832.0799999999999, "end": 837.92, "text": " and real-world SIVs taken from the dataset, where we demonstrate key extraction from a protected", "tokens": [293, 957, 12, 13217, 318, 10375, 82, 2726, 490, 264, 28872, 11, 689, 321, 11698, 2141, 30197, 490, 257, 10594], "temperature": 0.0, "avg_logprob": -0.07399454895330936, "compression_ratio": 1.785425101214575, "no_speech_prob": 4.192943379166536e-05}, {"id": 141, "seek": 83792, "start": 837.92, "end": 842.3199999999999, "text": " OpenSSL. Once again, here, we show more details in the paper.", "tokens": [7238, 21929, 43, 13, 3443, 797, 11, 510, 11, 321, 855, 544, 4365, 294, 264, 3035, 13], "temperature": 0.0, "avg_logprob": -0.13596519769406787, "compression_ratio": 1.6593886462882097, "no_speech_prob": 7.822890620445833e-05}, {"id": 142, "seek": 83792, "start": 843.4399999999999, "end": 848.7199999999999, "text": " So here, we assume a scenario with two compartments, where the goal is to isolate OpenSSL.", "tokens": [407, 510, 11, 321, 6552, 257, 9005, 365, 732, 18113, 1117, 11, 689, 264, 3387, 307, 281, 25660, 7238, 21929, 43, 13], "temperature": 0.0, "avg_logprob": -0.13596519769406787, "compression_ratio": 1.6593886462882097, "no_speech_prob": 7.822890620445833e-05}, {"id": 143, "seek": 83792, "start": 849.92, "end": 853.1999999999999, "text": " For example, from a compromised web server engine X.", "tokens": [1171, 1365, 11, 490, 257, 32463, 3670, 7154, 2848, 1783, 13], "temperature": 0.0, "avg_logprob": -0.13596519769406787, "compression_ratio": 1.6593886462882097, "no_speech_prob": 7.822890620445833e-05}, {"id": 144, "seek": 83792, "start": 854.64, "end": 860.9599999999999, "text": " Isolating OpenSSL, or part of OpenSSL, is a popular application of compartmentalization,", "tokens": [1119, 401, 990, 7238, 21929, 43, 11, 420, 644, 295, 7238, 21929, 43, 11, 307, 257, 3743, 3861, 295, 26505, 304, 2144, 11], "temperature": 0.0, "avg_logprob": -0.13596519769406787, "compression_ratio": 1.6593886462882097, "no_speech_prob": 7.822890620445833e-05}, {"id": 145, "seek": 83792, "start": 860.9599999999999, "end": 866.24, "text": " both in the literature and in the industry. Thus, here, the compartment interface and", "tokens": [1293, 294, 264, 10394, 293, 294, 264, 3518, 13, 13827, 11, 510, 11, 264, 26505, 9226, 293], "temperature": 0.0, "avg_logprob": -0.13596519769406787, "compression_ratio": 1.6593886462882097, "no_speech_prob": 7.822890620445833e-05}, {"id": 146, "seek": 86624, "start": 866.24, "end": 873.36, "text": " therefore the attack surface is the OpenSSL public API. Unfortunately, we find several SIVs", "tokens": [4412, 264, 2690, 3753, 307, 264, 7238, 21929, 43, 1908, 9362, 13, 8590, 11, 321, 915, 2940, 318, 10375, 82], "temperature": 0.0, "avg_logprob": -0.08455180012902548, "compression_ratio": 1.6143497757847534, "no_speech_prob": 4.751236701849848e-05}, {"id": 147, "seek": 86624, "start": 873.36, "end": 879.6, "text": " that enable for read, write, and execution impact. Take this option setting primitive, for example,", "tokens": [300, 9528, 337, 1401, 11, 2464, 11, 293, 15058, 2712, 13, 3664, 341, 3614, 3287, 28540, 11, 337, 1365, 11], "temperature": 0.0, "avg_logprob": -0.08455180012902548, "compression_ratio": 1.6143497757847534, "no_speech_prob": 4.751236701849848e-05}, {"id": 148, "seek": 86624, "start": 879.6, "end": 886.24, "text": " which is part of the OpenSSL public API. It differences an interface crossing pointer,", "tokens": [597, 307, 644, 295, 264, 7238, 21929, 43, 1908, 9362, 13, 467, 7300, 364, 9226, 14712, 23918, 11], "temperature": 0.0, "avg_logprob": -0.08455180012902548, "compression_ratio": 1.6143497757847534, "no_speech_prob": 4.751236701849848e-05}, {"id": 149, "seek": 86624, "start": 886.24, "end": 891.52, "text": " sets it, and returns it, clearly resulting in an arbitrary read and write oracle.", "tokens": [6352, 309, 11, 293, 11247, 309, 11, 4448, 16505, 294, 364, 23211, 1401, 293, 2464, 420, 7041, 13], "temperature": 0.0, "avg_logprob": -0.08455180012902548, "compression_ratio": 1.6143497757847534, "no_speech_prob": 4.751236701849848e-05}, {"id": 150, "seek": 89152, "start": 891.52, "end": 896.64, "text": " Any attacker that can compromise the application's control flow will likely be able to extract", "tokens": [2639, 35871, 300, 393, 18577, 264, 3861, 311, 1969, 3095, 486, 3700, 312, 1075, 281, 8947], "temperature": 0.0, "avg_logprob": -0.15509502560484642, "compression_ratio": 1.537593984962406, "no_speech_prob": 3.320134783280082e-05}, {"id": 151, "seek": 89152, "start": 896.64, "end": 902.88, "text": " SSL keys easily. Thus, clearly, if the API is not carefully enough sanitized,", "tokens": [12238, 43, 9317, 3612, 13, 13827, 11, 4448, 11, 498, 264, 9362, 307, 406, 7500, 1547, 24533, 1602, 11], "temperature": 0.0, "avg_logprob": -0.15509502560484642, "compression_ratio": 1.537593984962406, "no_speech_prob": 3.320134783280082e-05}, {"id": 152, "seek": 89152, "start": 902.88, "end": 907.1999999999999, "text": " the benefits will be pretty low, at most a form of weak hardening.", "tokens": [264, 5311, 486, 312, 1238, 2295, 11, 412, 881, 257, 1254, 295, 5336, 1152, 4559, 13], "temperature": 0.0, "avg_logprob": -0.15509502560484642, "compression_ratio": 1.537593984962406, "no_speech_prob": 3.320134783280082e-05}, {"id": 153, "seek": 89152, "start": 909.1999999999999, "end": 914.48, "text": " Now, you could tell me that it's not a good idea to protect at the public API anyways,", "tokens": [823, 11, 291, 727, 980, 385, 300, 309, 311, 406, 257, 665, 1558, 281, 2371, 412, 264, 1908, 9362, 13448, 11], "temperature": 0.0, "avg_logprob": -0.15509502560484642, "compression_ratio": 1.537593984962406, "no_speech_prob": 3.320134783280082e-05}, {"id": 154, "seek": 89152, "start": 914.48, "end": 920.24, "text": " and that we should rather choose the OpenSSL internal key API that's much smaller.", "tokens": [293, 300, 321, 820, 2831, 2826, 264, 7238, 21929, 43, 6920, 2141, 9362, 300, 311, 709, 4356, 13], "temperature": 0.0, "avg_logprob": -0.15509502560484642, "compression_ratio": 1.537593984962406, "no_speech_prob": 3.320134783280082e-05}, {"id": 155, "seek": 92024, "start": 920.24, "end": 926.48, "text": " So, let's take a look at it. This time, we have NGINX and most of OpenSSL in the untrusted compartment,", "tokens": [407, 11, 718, 311, 747, 257, 574, 412, 309, 13, 639, 565, 11, 321, 362, 426, 38, 1464, 55, 293, 881, 295, 7238, 21929, 43, 294, 264, 1701, 81, 6589, 26505, 11], "temperature": 0.0, "avg_logprob": -0.19303197127122146, "compression_ratio": 1.6437246963562753, "no_speech_prob": 7.12666951585561e-05}, {"id": 156, "seek": 92024, "start": 926.48, "end": 932.88, "text": " while we have the small key handling part of OpenSSL together with the keys in the protected compartment.", "tokens": [1339, 321, 362, 264, 1359, 2141, 13175, 644, 295, 7238, 21929, 43, 1214, 365, 264, 9317, 294, 264, 10594, 26505, 13], "temperature": 0.0, "avg_logprob": -0.19303197127122146, "compression_ratio": 1.6437246963562753, "no_speech_prob": 7.12666951585561e-05}, {"id": 157, "seek": 92024, "start": 933.84, "end": 939.6, "text": " Unfortunately, here too, we find several SIVs. Take a look at this function of the internal key", "tokens": [8590, 11, 510, 886, 11, 321, 915, 2940, 318, 10375, 82, 13, 3664, 257, 574, 412, 341, 2445, 295, 264, 6920, 2141], "temperature": 0.0, "avg_logprob": -0.19303197127122146, "compression_ratio": 1.6437246963562753, "no_speech_prob": 7.12666951585561e-05}, {"id": 158, "seek": 92024, "start": 939.6, "end": 945.76, "text": " API, for example. I only put the signature for simplicity's sake because the function is implemented", "tokens": [9362, 11, 337, 1365, 13, 286, 787, 829, 264, 13397, 337, 25632, 311, 9717, 570, 264, 2445, 307, 12270], "temperature": 0.0, "avg_logprob": -0.19303197127122146, "compression_ratio": 1.6437246963562753, "no_speech_prob": 7.12666951585561e-05}, {"id": 159, "seek": 94576, "start": 945.76, "end": 953.28, "text": " in per-generated assembly. You can manipulate the in pointer to point to the key that you cannot", "tokens": [294, 680, 12, 21848, 770, 12103, 13, 509, 393, 20459, 264, 294, 23918, 281, 935, 281, 264, 2141, 300, 291, 2644], "temperature": 0.0, "avg_logprob": -0.17212237892570076, "compression_ratio": 1.597457627118644, "no_speech_prob": 2.623280306579545e-05}, {"id": 160, "seek": 94576, "start": 953.28, "end": 960.64, "text": " directly access, encrypt with a known key, and then decrypt to get the secrets. Hence, here again,", "tokens": [3838, 2105, 11, 17972, 662, 365, 257, 2570, 2141, 11, 293, 550, 979, 627, 662, 281, 483, 264, 14093, 13, 22229, 11, 510, 797, 11], "temperature": 0.0, "avg_logprob": -0.17212237892570076, "compression_ratio": 1.597457627118644, "no_speech_prob": 2.623280306579545e-05}, {"id": 161, "seek": 94576, "start": 960.64, "end": 965.84, "text": " attackers that can manage to compromise the application are likely to be able to easily", "tokens": [45129, 300, 393, 3067, 281, 18577, 264, 3861, 366, 3700, 281, 312, 1075, 281, 3612], "temperature": 0.0, "avg_logprob": -0.17212237892570076, "compression_ratio": 1.597457627118644, "no_speech_prob": 2.623280306579545e-05}, {"id": 162, "seek": 94576, "start": 965.84, "end": 972.64, "text": " extract the key. Unfortunately here, fixing the SIVs requires to make the component stateful,", "tokens": [8947, 264, 2141, 13, 8590, 510, 11, 19442, 264, 318, 10375, 82, 7029, 281, 652, 264, 6542, 1785, 906, 11], "temperature": 0.0, "avg_logprob": -0.17212237892570076, "compression_ratio": 1.597457627118644, "no_speech_prob": 2.623280306579545e-05}, {"id": 163, "seek": 97264, "start": 972.64, "end": 978.64, "text": " which is a fairly drastic design change. Overall, through these two examples,", "tokens": [597, 307, 257, 6457, 36821, 1715, 1319, 13, 18420, 11, 807, 613, 732, 5110, 11], "temperature": 0.0, "avg_logprob": -0.1190320157456672, "compression_ratio": 1.453781512605042, "no_speech_prob": 4.065704706590623e-05}, {"id": 164, "seek": 97264, "start": 978.64, "end": 984.64, "text": " I showed how existing OpenSSL isolation strategies collapse when confronted to SIVs,", "tokens": [286, 4712, 577, 6741, 7238, 21929, 43, 16001, 9029, 15584, 562, 31257, 281, 318, 10375, 82, 11], "temperature": 0.0, "avg_logprob": -0.1190320157456672, "compression_ratio": 1.453781512605042, "no_speech_prob": 4.065704706590623e-05}, {"id": 165, "seek": 97264, "start": 984.64, "end": 991.36, "text": " and how important they are security-wise. To conclude this talk, let's take a quick look", "tokens": [293, 577, 1021, 436, 366, 3825, 12, 3711, 13, 1407, 16886, 341, 751, 11, 718, 311, 747, 257, 1702, 574], "temperature": 0.0, "avg_logprob": -0.1190320157456672, "compression_ratio": 1.453781512605042, "no_speech_prob": 4.065704706590623e-05}, {"id": 166, "seek": 97264, "start": 991.36, "end": 998.64, "text": " at countermeasures. How do we tackle SIVs? Overall, we see two ways. First, making progress on", "tokens": [412, 5682, 1398, 20044, 13, 1012, 360, 321, 14896, 318, 10375, 82, 30, 18420, 11, 321, 536, 732, 2098, 13, 2386, 11, 1455, 4205, 322], "temperature": 0.0, "avg_logprob": -0.1190320157456672, "compression_ratio": 1.453781512605042, "no_speech_prob": 4.065704706590623e-05}, {"id": 167, "seek": 99864, "start": 998.64, "end": 1005.64, "text": " automatic and systematic countermeasures. Our paper highlights the limitations as part of our SIV taxonomy.", "tokens": [12509, 293, 27249, 5682, 1398, 20044, 13, 2621, 3035, 14254, 264, 15705, 382, 644, 295, 527, 318, 10375, 3366, 23423, 13], "temperature": 0.0, "avg_logprob": -0.14654022455215454, "compression_ratio": 1.4634146341463414, "no_speech_prob": 4.605570575222373e-05}, {"id": 168, "seek": 99864, "start": 1006.64, "end": 1012.64, "text": " Second, learning from our study of patterns. We also believe that software component APIs", "tokens": [5736, 11, 2539, 490, 527, 2979, 295, 8294, 13, 492, 611, 1697, 300, 4722, 6542, 21445], "temperature": 0.0, "avg_logprob": -0.14654022455215454, "compression_ratio": 1.4634146341463414, "no_speech_prob": 4.605570575222373e-05}, {"id": 169, "seek": 99864, "start": 1012.64, "end": 1020.64, "text": " should be designed to feature low compartmentalization complexity in the first place. We provide a set", "tokens": [820, 312, 4761, 281, 4111, 2295, 26505, 304, 2144, 14024, 294, 264, 700, 1081, 13, 492, 2893, 257, 992], "temperature": 0.0, "avg_logprob": -0.14654022455215454, "compression_ratio": 1.4634146341463414, "no_speech_prob": 4.605570575222373e-05}, {"id": 170, "seek": 102064, "start": 1020.64, "end": 1028.6399999999999, "text": " of guidelines to achieve this. The two approaches are complementary. Even in the presence of", "tokens": [295, 12470, 281, 4584, 341, 13, 440, 732, 11587, 366, 40705, 13, 2754, 294, 264, 6814, 295], "temperature": 0.0, "avg_logprob": -0.058938816615513395, "compression_ratio": 1.476923076923077, "no_speech_prob": 2.076380405924283e-05}, {"id": 171, "seek": 102064, "start": 1028.6399999999999, "end": 1034.6399999999999, "text": " countermeasures, well-designed APIs are wishable, as the first point is known to be fundamentally", "tokens": [5682, 1398, 20044, 11, 731, 12, 14792, 16690, 21445, 366, 3172, 712, 11, 382, 264, 700, 935, 307, 2570, 281, 312, 17879], "temperature": 0.0, "avg_logprob": -0.058938816615513395, "compression_ratio": 1.476923076923077, "no_speech_prob": 2.076380405924283e-05}, {"id": 172, "seek": 102064, "start": 1034.6399999999999, "end": 1040.6399999999999, "text": " harder. I will not have enough time to go over all the guidelines, but let me try to give you the", "tokens": [6081, 13, 286, 486, 406, 362, 1547, 565, 281, 352, 670, 439, 264, 12470, 11, 457, 718, 385, 853, 281, 976, 291, 264], "temperature": 0.0, "avg_logprob": -0.058938816615513395, "compression_ratio": 1.476923076923077, "no_speech_prob": 2.076380405924283e-05}, {"id": 173, "seek": 104064, "start": 1040.64, "end": 1050.64, "text": " gist of them. First, not every interface is a good boundary for privilege separation. Maybe a particular", "tokens": [290, 468, 295, 552, 13, 2386, 11, 406, 633, 9226, 307, 257, 665, 12866, 337, 12122, 14634, 13, 2704, 257, 1729], "temperature": 0.0, "avg_logprob": -0.09690241978086274, "compression_ratio": 1.5991902834008098, "no_speech_prob": 3.881004158756696e-05}, {"id": 174, "seek": 104064, "start": 1050.64, "end": 1056.64, "text": " API doesn't fit privilege separation, and that's fine. In this case, it will be hard to harden anyways.", "tokens": [9362, 1177, 380, 3318, 12122, 14634, 11, 293, 300, 311, 2489, 13, 682, 341, 1389, 11, 309, 486, 312, 1152, 281, 50203, 13448, 13], "temperature": 0.0, "avg_logprob": -0.09690241978086274, "compression_ratio": 1.5991902834008098, "no_speech_prob": 3.881004158756696e-05}, {"id": 175, "seek": 104064, "start": 1056.64, "end": 1062.64, "text": " Second, we recommend that major attention should be dedicated to reducing the complexity of", "tokens": [5736, 11, 321, 2748, 300, 2563, 3202, 820, 312, 8374, 281, 12245, 264, 14024, 295], "temperature": 0.0, "avg_logprob": -0.09690241978086274, "compression_ratio": 1.5991902834008098, "no_speech_prob": 3.881004158756696e-05}, {"id": 176, "seek": 104064, "start": 1062.64, "end": 1068.64, "text": " interface crossing objects. Avoiding, for example, sharing of resource handle, system resource", "tokens": [9226, 14712, 6565, 13, 36175, 2819, 11, 337, 1365, 11, 5414, 295, 7684, 4813, 11, 1185, 7684], "temperature": 0.0, "avg_logprob": -0.09690241978086274, "compression_ratio": 1.5991902834008098, "no_speech_prob": 3.881004158756696e-05}, {"id": 177, "seek": 106864, "start": 1068.64, "end": 1074.64, "text": " extracts, synchronization primitives, et cetera. If this is not possible, it should bring us back", "tokens": [8947, 82, 11, 19331, 2144, 2886, 38970, 11, 1030, 11458, 13, 759, 341, 307, 406, 1944, 11, 309, 820, 1565, 505, 646], "temperature": 0.0, "avg_logprob": -0.11596969040957364, "compression_ratio": 1.6394849785407726, "no_speech_prob": 0.00018209566769655794}, {"id": 178, "seek": 106864, "start": 1074.64, "end": 1080.64, "text": " to the first point. The interface is probably not the right point to compartmentalize. For example,", "tokens": [281, 264, 700, 935, 13, 440, 9226, 307, 1391, 406, 264, 558, 935, 281, 26505, 304, 1125, 13, 1171, 1365, 11], "temperature": 0.0, "avg_logprob": -0.11596969040957364, "compression_ratio": 1.6394849785407726, "no_speech_prob": 0.00018209566769655794}, {"id": 179, "seek": 106864, "start": 1080.64, "end": 1086.64, "text": " because components are too deeply entangled. Third, compartmentalizable components should", "tokens": [570, 6677, 366, 886, 8760, 948, 39101, 13, 12548, 11, 26505, 304, 22395, 6677, 820], "temperature": 0.0, "avg_logprob": -0.11596969040957364, "compression_ratio": 1.6394849785407726, "no_speech_prob": 0.00018209566769655794}, {"id": 180, "seek": 106864, "start": 1086.64, "end": 1092.64, "text": " enforce API semantics to be safe. For example, ordering or concurrency support. Under distrust", "tokens": [24825, 9362, 4361, 45298, 281, 312, 3273, 13, 1171, 1365, 11, 21739, 420, 23702, 10457, 1406, 13, 6974, 1483, 22326], "temperature": 0.0, "avg_logprob": -0.11596969040957364, "compression_ratio": 1.6394849785407726, "no_speech_prob": 0.00018209566769655794}, {"id": 181, "seek": 109264, "start": 1092.64, "end": 1098.64, "text": " scenarios, it is not acceptable anymore to assume that the caller will respect them or face the", "tokens": [15077, 11, 309, 307, 406, 15513, 3602, 281, 6552, 300, 264, 48324, 486, 3104, 552, 420, 1851, 264], "temperature": 0.0, "avg_logprob": -0.08477054891132173, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.326645648689009e-05}, {"id": 182, "seek": 109264, "start": 1098.64, "end": 1104.64, "text": " consequences. We are slowly coming towards the end of this talk, so let me summarize the key points", "tokens": [10098, 13, 492, 366, 5692, 1348, 3030, 264, 917, 295, 341, 751, 11, 370, 718, 385, 20858, 264, 2141, 2793], "temperature": 0.0, "avg_logprob": -0.08477054891132173, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.326645648689009e-05}, {"id": 183, "seek": 109264, "start": 1104.64, "end": 1112.64, "text": " that I wanted to make. Civs should be at the center of every compartmentalization approach, and you", "tokens": [300, 286, 1415, 281, 652, 13, 35452, 82, 820, 312, 412, 264, 3056, 295, 633, 26505, 304, 2144, 3109, 11, 293, 291], "temperature": 0.0, "avg_logprob": -0.08477054891132173, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.326645648689009e-05}, {"id": 184, "seek": 109264, "start": 1112.64, "end": 1118.64, "text": " will likely not achieve tangible security benefits without considering them. API design patterns", "tokens": [486, 3700, 406, 4584, 27094, 3825, 5311, 1553, 8079, 552, 13, 9362, 1715, 8294], "temperature": 0.0, "avg_logprob": -0.08477054891132173, "compression_ratio": 1.5555555555555556, "no_speech_prob": 4.326645648689009e-05}, {"id": 185, "seek": 111864, "start": 1118.64, "end": 1124.64, "text": " influence the presence of civs and their severity. Overall, it's not so much about the size of the", "tokens": [6503, 264, 6814, 295, 13779, 82, 293, 641, 35179, 13, 18420, 11, 309, 311, 406, 370, 709, 466, 264, 2744, 295, 264], "temperature": 0.0, "avg_logprob": -0.08230031474252765, "compression_ratio": 1.5869565217391304, "no_speech_prob": 3.8169971958268434e-05}, {"id": 186, "seek": 111864, "start": 1124.64, "end": 1132.64, "text": " API. It's about the complexity of API crossing objects. Addressing civs is not just a matter of", "tokens": [9362, 13, 467, 311, 466, 264, 14024, 295, 9362, 14712, 6565, 13, 5349, 18605, 13779, 82, 307, 406, 445, 257, 1871, 295], "temperature": 0.0, "avg_logprob": -0.08230031474252765, "compression_ratio": 1.5869565217391304, "no_speech_prob": 3.8169971958268434e-05}, {"id": 187, "seek": 111864, "start": 1132.64, "end": 1140.64, "text": " writing a few checks. In fact, strong solutions often require refactoring the API. Thus,", "tokens": [3579, 257, 1326, 13834, 13, 682, 1186, 11, 2068, 6547, 2049, 3651, 1895, 578, 3662, 264, 9362, 13, 13827, 11], "temperature": 0.0, "avg_logprob": -0.08230031474252765, "compression_ratio": 1.5869565217391304, "no_speech_prob": 3.8169971958268434e-05}, {"id": 188, "seek": 111864, "start": 1140.64, "end": 1146.64, "text": " compartmentalizing apps goes much further than just setting and enforcing bounds.", "tokens": [26505, 304, 3319, 7733, 1709, 709, 3052, 813, 445, 3287, 293, 25495, 2175, 29905, 13], "temperature": 0.0, "avg_logprob": -0.08230031474252765, "compression_ratio": 1.5869565217391304, "no_speech_prob": 3.8169971958268434e-05}, {"id": 189, "seek": 114664, "start": 1146.64, "end": 1154.64, "text": " We want this work to be an appeal for more research towards addressing the problem of civs,", "tokens": [492, 528, 341, 589, 281, 312, 364, 13668, 337, 544, 2132, 3030, 14329, 264, 1154, 295, 13779, 82, 11], "temperature": 0.0, "avg_logprob": -0.10835668857281025, "compression_ratio": 1.5392670157068062, "no_speech_prob": 5.1367223932174966e-05}, {"id": 190, "seek": 114664, "start": 1154.64, "end": 1160.64, "text": " systematically finding them, addressing them, or telling you what interface may good compartmentalization", "tokens": [39531, 5006, 552, 11, 14329, 552, 11, 420, 3585, 291, 437, 9226, 815, 665, 26505, 304, 2144], "temperature": 0.0, "avg_logprob": -0.10835668857281025, "compression_ratio": 1.5392670157068062, "no_speech_prob": 5.1367223932174966e-05}, {"id": 191, "seek": 114664, "start": 1160.64, "end": 1166.64, "text": " boundaries. If you are interested in this work, I invite you to check out our paper and the code", "tokens": [13180, 13, 759, 291, 366, 3102, 294, 341, 589, 11, 286, 7980, 291, 281, 1520, 484, 527, 3035, 293, 264, 3089], "temperature": 0.0, "avg_logprob": -0.10835668857281025, "compression_ratio": 1.5392670157068062, "no_speech_prob": 5.1367223932174966e-05}, {"id": 192, "seek": 116664, "start": 1166.64, "end": 1176.64, "text": " and data set of Confuzz. I will now be more than happy to take questions. Thank you.", "tokens": [50364, 293, 1412, 992, 295, 11701, 16740, 13, 286, 486, 586, 312, 544, 813, 2055, 281, 747, 1651, 13, 1044, 291, 13, 50864], "temperature": 0.0, "avg_logprob": -0.20558160543441772, "compression_ratio": 1.037037037037037, "no_speech_prob": 0.00029431760776787996}, {"id": 193, "seek": 119664, "start": 1196.64, "end": 1206.64, "text": " Thank you, Hugo, for this very accessible talk on this important topic of securing interfaces.", "tokens": [1044, 291, 11, 32504, 11, 337, 341, 588, 9515, 751, 322, 341, 1021, 4829, 295, 33640, 28416, 13], "temperature": 0.0, "avg_logprob": -0.17659971930763937, "compression_ratio": 1.4158415841584158, "no_speech_prob": 0.07025840133428574}, {"id": 194, "seek": 119664, "start": 1206.64, "end": 1214.64, "text": " One question maybe that I can start with is something that you brought up yourself as well.", "tokens": [1485, 1168, 1310, 300, 286, 393, 722, 365, 307, 746, 300, 291, 3038, 493, 1803, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.17659971930763937, "compression_ratio": 1.4158415841584158, "no_speech_prob": 0.07025840133428574}, {"id": 195, "seek": 119664, "start": 1214.64, "end": 1220.64, "text": " You say it's more about compartmentalization, but it also applies obviously to TEs. Can you comment", "tokens": [509, 584, 309, 311, 544, 466, 26505, 304, 2144, 11, 457, 309, 611, 13165, 2745, 281, 19744, 82, 13, 1664, 291, 2871], "temperature": 0.0, "avg_logprob": -0.17659971930763937, "compression_ratio": 1.4158415841584158, "no_speech_prob": 0.07025840133428574}, {"id": 196, "seek": 122064, "start": 1220.64, "end": 1228.64, "text": " a bit on that? Is that something you consider Confuzz, your physics could be extended to", "tokens": [257, 857, 322, 300, 30, 1119, 300, 746, 291, 1949, 11701, 16740, 11, 428, 10649, 727, 312, 10913, 281], "temperature": 0.0, "avg_logprob": -0.24717267354329428, "compression_ratio": 1.521978021978022, "no_speech_prob": 0.0002911803312599659}, {"id": 197, "seek": 122064, "start": 1228.64, "end": 1238.64, "text": " something like Gromine? Actually, maybe there are two different parts. I think the conceptual part", "tokens": [746, 411, 2606, 298, 533, 30, 5135, 11, 1310, 456, 366, 732, 819, 3166, 13, 286, 519, 264, 24106, 644], "temperature": 0.0, "avg_logprob": -0.24717267354329428, "compression_ratio": 1.521978021978022, "no_speech_prob": 0.0002911803312599659}, {"id": 198, "seek": 122064, "start": 1238.64, "end": 1244.64, "text": " about compartment interface vulnerabilities, maybe we could remove the compartment out of", "tokens": [466, 26505, 9226, 37633, 11, 1310, 321, 727, 4159, 264, 26505, 484, 295], "temperature": 0.0, "avg_logprob": -0.24717267354329428, "compression_ratio": 1.521978021978022, "no_speech_prob": 0.0002911803312599659}, {"id": 199, "seek": 124464, "start": 1244.64, "end": 1250.64, "text": " interface, out of compartment interface vulnerabilities, and just get interface vulnerabilities. I think", "tokens": [9226, 11, 484, 295, 26505, 9226, 37633, 11, 293, 445, 483, 9226, 37633, 13, 286, 519], "temperature": 0.0, "avg_logprob": -0.14222249777420706, "compression_ratio": 1.70995670995671, "no_speech_prob": 0.00011940932017751038}, {"id": 200, "seek": 124464, "start": 1250.64, "end": 1256.64, "text": " it has also been described by other works previously, notably some of the work that you did, Joe.", "tokens": [309, 575, 611, 668, 7619, 538, 661, 1985, 8046, 11, 31357, 512, 295, 264, 589, 300, 291, 630, 11, 6807, 13], "temperature": 0.0, "avg_logprob": -0.14222249777420706, "compression_ratio": 1.70995670995671, "no_speech_prob": 0.00011940932017751038}, {"id": 201, "seek": 124464, "start": 1256.64, "end": 1262.64, "text": " I think that applies to TEs really, really well. I think it's just a generic problem about", "tokens": [286, 519, 300, 13165, 281, 19744, 82, 534, 11, 534, 731, 13, 286, 519, 309, 311, 445, 257, 19577, 1154, 466], "temperature": 0.0, "avg_logprob": -0.14222249777420706, "compression_ratio": 1.70995670995671, "no_speech_prob": 0.00011940932017751038}, {"id": 202, "seek": 124464, "start": 1262.64, "end": 1272.64, "text": " interfaces, and that fully applies to TEs. Regarding the fuzzer, from a very technical point of view,", "tokens": [28416, 11, 293, 300, 4498, 13165, 281, 19744, 82, 13, 35523, 264, 283, 3334, 4527, 11, 490, 257, 588, 6191, 935, 295, 1910, 11], "temperature": 0.0, "avg_logprob": -0.14222249777420706, "compression_ratio": 1.70995670995671, "no_speech_prob": 0.00011940932017751038}, {"id": 203, "seek": 127264, "start": 1272.64, "end": 1282.64, "text": " I think that it might need some adaptation to be run on existing TE software, but it's absolutely", "tokens": [286, 519, 300, 309, 1062, 643, 512, 21549, 281, 312, 1190, 322, 6741, 19744, 4722, 11, 457, 309, 311, 3122], "temperature": 0.0, "avg_logprob": -0.09555217954847547, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0002855756029020995}, {"id": 204, "seek": 127264, "start": 1282.64, "end": 1288.64, "text": " feasible. I think that it could apply there as well. We didn't really explore it because", "tokens": [26648, 13, 286, 519, 300, 309, 727, 3079, 456, 382, 731, 13, 492, 994, 380, 534, 6839, 309, 570], "temperature": 0.0, "avg_logprob": -0.09555217954847547, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0002855756029020995}, {"id": 205, "seek": 127264, "start": 1288.64, "end": 1294.64, "text": " obviously at some point we needed to restrict the scope of what we're doing, but I think it makes", "tokens": [2745, 412, 512, 935, 321, 2978, 281, 7694, 264, 11923, 295, 437, 321, 434, 884, 11, 457, 286, 519, 309, 1669], "temperature": 0.0, "avg_logprob": -0.09555217954847547, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0002855756029020995}, {"id": 206, "seek": 127264, "start": 1294.64, "end": 1300.64, "text": " sense. Following up on that as well, I think you mentioned in your slides one of the technologies", "tokens": [2020, 13, 19192, 493, 322, 300, 382, 731, 11, 286, 519, 291, 2835, 294, 428, 9788, 472, 295, 264, 7943], "temperature": 0.0, "avg_logprob": -0.09555217954847547, "compression_ratio": 1.5916666666666666, "no_speech_prob": 0.0002855756029020995}, {"id": 207, "seek": 130064, "start": 1300.64, "end": 1306.64, "text": " that you could use for compartmentalization. It's not only TEs, it's also something like Cherry.", "tokens": [300, 291, 727, 764, 337, 26505, 304, 2144, 13, 467, 311, 406, 787, 19744, 82, 11, 309, 311, 611, 746, 411, 34831, 13], "temperature": 0.0, "avg_logprob": -0.18464516458057223, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.00018475533579476178}, {"id": 208, "seek": 130064, "start": 1306.64, "end": 1314.64, "text": " It uses capabilities, and I'm wondering, TEs are not great in these vulnerabilities because", "tokens": [467, 4960, 10862, 11, 293, 286, 478, 6359, 11, 19744, 82, 366, 406, 869, 294, 613, 37633, 570], "temperature": 0.0, "avg_logprob": -0.18464516458057223, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.00018475533579476178}, {"id": 209, "seek": 130064, "start": 1314.64, "end": 1318.64, "text": " you have these confused specialty attacks that you explained also, where you have a pointer", "tokens": [291, 362, 613, 9019, 22000, 8122, 300, 291, 8825, 611, 11, 689, 291, 362, 257, 23918], "temperature": 0.0, "avg_logprob": -0.18464516458057223, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.00018475533579476178}, {"id": 210, "seek": 130064, "start": 1318.64, "end": 1324.64, "text": " that you essentially can dereference. With Cherry, with capabilities, you have sort of", "tokens": [300, 291, 4476, 393, 15969, 5158, 13, 2022, 34831, 11, 365, 10862, 11, 291, 362, 1333, 295], "temperature": 0.0, "avg_logprob": -0.18464516458057223, "compression_ratio": 1.6383928571428572, "no_speech_prob": 0.00018475533579476178}, {"id": 211, "seek": 132464, "start": 1324.64, "end": 1332.64, "text": " native mitigations for many of those, capabilities I think were made with the idea of avoiding", "tokens": [8470, 15699, 763, 337, 867, 295, 729, 11, 10862, 286, 519, 645, 1027, 365, 264, 1558, 295, 20220], "temperature": 0.0, "avg_logprob": -0.17542412701775045, "compression_ratio": 1.467005076142132, "no_speech_prob": 0.00023303780471906066}, {"id": 212, "seek": 132464, "start": 1332.64, "end": 1338.64, "text": " confused deputy. Can you comment a bit on what underlying technology can mean for the vulnerability", "tokens": [9019, 26692, 13, 1664, 291, 2871, 257, 857, 322, 437, 14217, 2899, 393, 914, 337, 264, 24210], "temperature": 0.0, "avg_logprob": -0.17542412701775045, "compression_ratio": 1.467005076142132, "no_speech_prob": 0.00023303780471906066}, {"id": 213, "seek": 132464, "start": 1338.64, "end": 1348.64, "text": " of compartmentalization? I'm not sure if I can, I don't think I can share my screen, but maybe", "tokens": [295, 26505, 304, 2144, 30, 286, 478, 406, 988, 498, 286, 393, 11, 286, 500, 380, 519, 286, 393, 2073, 452, 2568, 11, 457, 1310], "temperature": 0.0, "avg_logprob": -0.17542412701775045, "compression_ratio": 1.467005076142132, "no_speech_prob": 0.00023303780471906066}, {"id": 214, "seek": 134864, "start": 1348.64, "end": 1356.64, "text": " I can. But you can put a link maybe in the chat for people. Actually in the paper we did", "tokens": [286, 393, 13, 583, 291, 393, 829, 257, 2113, 1310, 294, 264, 5081, 337, 561, 13, 5135, 294, 264, 3035, 321, 630], "temperature": 0.0, "avg_logprob": -0.19877841021563555, "compression_ratio": 1.4972067039106145, "no_speech_prob": 0.0003734686179086566}, {"id": 215, "seek": 134864, "start": 1356.64, "end": 1366.64, "text": " talk about this, so I'm just going to share my screen, but maybe I can. I'm sorry, I just", "tokens": [751, 466, 341, 11, 370, 286, 478, 445, 516, 281, 2073, 452, 2568, 11, 457, 1310, 286, 393, 13, 286, 478, 2597, 11, 286, 445], "temperature": 0.0, "avg_logprob": -0.19877841021563555, "compression_ratio": 1.4972067039106145, "no_speech_prob": 0.0003734686179086566}, {"id": 216, "seek": 134864, "start": 1366.64, "end": 1372.64, "text": " broke everything. I just posted the link, I don't know if I triggered something terrible.", "tokens": [6902, 1203, 13, 286, 445, 9437, 264, 2113, 11, 286, 500, 380, 458, 498, 286, 21710, 746, 6237, 13], "temperature": 0.0, "avg_logprob": -0.19877841021563555, "compression_ratio": 1.4972067039106145, "no_speech_prob": 0.0003734686179086566}, {"id": 217, "seek": 137264, "start": 1372.64, "end": 1378.64, "text": " I think I see the link, I think you unmuted that or something. So the paper goes in data,", "tokens": [286, 519, 286, 536, 264, 2113, 11, 286, 519, 291, 19334, 4866, 300, 420, 746, 13, 407, 264, 3035, 1709, 294, 1412, 11], "temperature": 0.0, "avg_logprob": -0.19689485004970006, "compression_ratio": 1.6342592592592593, "no_speech_prob": 0.00015555511345155537}, {"id": 218, "seek": 137264, "start": 1378.64, "end": 1386.64, "text": " can you summarize maybe in the minute that remains? Absolutely, yes. So Cherry provides", "tokens": [393, 291, 20858, 1310, 294, 264, 3456, 300, 7023, 30, 7021, 11, 2086, 13, 407, 34831, 6417], "temperature": 0.0, "avg_logprob": -0.19689485004970006, "compression_ratio": 1.6342592592592593, "no_speech_prob": 0.00015555511345155537}, {"id": 219, "seek": 137264, "start": 1386.64, "end": 1392.64, "text": " some features that as you said are really nice in addressing some of the spatial part", "tokens": [512, 4122, 300, 382, 291, 848, 366, 534, 1481, 294, 14329, 512, 295, 264, 23598, 644], "temperature": 0.0, "avg_logprob": -0.19689485004970006, "compression_ratio": 1.6342592592592593, "no_speech_prob": 0.00015555511345155537}, {"id": 220, "seek": 137264, "start": 1392.64, "end": 1400.64, "text": " of the compartment interface spectrum, of the SIV spectrum. It does not solve everything,", "tokens": [295, 264, 26505, 9226, 11143, 11, 295, 264, 318, 10375, 11143, 13, 467, 775, 406, 5039, 1203, 11], "temperature": 0.0, "avg_logprob": -0.19689485004970006, "compression_ratio": 1.6342592592592593, "no_speech_prob": 0.00015555511345155537}, {"id": 221, "seek": 140064, "start": 1400.64, "end": 1410.64, "text": " it's not magic. Like many of the leakage issues remain, many of the temporal issues remain", "tokens": [309, 311, 406, 5585, 13, 1743, 867, 295, 264, 47799, 2663, 6222, 11, 867, 295, 264, 30881, 2663, 6222], "temperature": 0.0, "avg_logprob": -0.10988539741152809, "compression_ratio": 1.5314285714285714, "no_speech_prob": 8.211676322389394e-05}, {"id": 222, "seek": 140064, "start": 1410.64, "end": 1418.64, "text": " as well, because to some extent they are a little bit more high level than just spatial", "tokens": [382, 731, 11, 570, 281, 512, 8396, 436, 366, 257, 707, 857, 544, 1090, 1496, 813, 445, 23598], "temperature": 0.0, "avg_logprob": -0.10988539741152809, "compression_ratio": 1.5314285714285714, "no_speech_prob": 8.211676322389394e-05}, {"id": 223, "seek": 140064, "start": 1418.64, "end": 1427.64, "text": " things on memory. So they still apply. For example, the issues with ordering of interface", "tokens": [721, 322, 4675, 13, 407, 436, 920, 3079, 13, 1171, 1365, 11, 264, 2663, 365, 21739, 295, 9226], "temperature": 0.0, "avg_logprob": -0.10988539741152809, "compression_ratio": 1.5314285714285714, "no_speech_prob": 8.211676322389394e-05}, {"id": 224, "seek": 142764, "start": 1427.64, "end": 1433.64, "text": " calls. If you have an interface that has some ordering expectations, for example calling", "tokens": [5498, 13, 759, 291, 362, 364, 9226, 300, 575, 512, 21739, 9843, 11, 337, 1365, 5141], "temperature": 0.0, "avg_logprob": -0.08043822508591872, "compression_ratio": 1.5257142857142858, "no_speech_prob": 0.00029789164545945823}, {"id": 225, "seek": 142764, "start": 1433.64, "end": 1439.64, "text": " function one before function two, and you don't respect that, Cherry is not necessarily", "tokens": [2445, 472, 949, 2445, 732, 11, 293, 291, 500, 380, 3104, 300, 11, 34831, 307, 406, 4725], "temperature": 0.0, "avg_logprob": -0.08043822508591872, "compression_ratio": 1.5257142857142858, "no_speech_prob": 0.00029789164545945823}, {"id": 226, "seek": 142764, "start": 1439.64, "end": 1446.64, "text": " going to help you. So this is going to remain. So it does address part of it, but it's not", "tokens": [516, 281, 854, 291, 13, 407, 341, 307, 516, 281, 6222, 13, 407, 309, 775, 2985, 644, 295, 309, 11, 457, 309, 311, 406], "temperature": 0.0, "avg_logprob": -0.08043822508591872, "compression_ratio": 1.5257142857142858, "no_speech_prob": 0.00029789164545945823}, {"id": 227, "seek": 144664, "start": 1446.64, "end": 1458.64, "text": " necessarily going to help you. Thank you.", "tokens": [50364, 4725, 516, 281, 854, 291, 13, 1044, 291, 13, 50964], "temperature": 0.0, "avg_logprob": -0.8771411577860514, "compression_ratio": 0.9111111111111111, "no_speech_prob": 0.0008399702492170036}], "language": "en"}