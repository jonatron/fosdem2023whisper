{"text": " The next presentation will be by Fabien Choteau. He will give an introduction on formal verification and will learn us how to mathematically prove this error box in your software. Thank you. I need the timer because I have quite a lot of things to say. Hi everyone, I'm Fabien and yet today I want to talk about formal verification, open source formal verification. First the disclaimer, I'm not an expert in formal verification, but I'm a user of this technology. What I'm an expert at is embedded software, but I use formal verification and I will explain later our work in a company that's developing some formal verification solutions. If we look at what Wikipedia says, formal verification is the act of proving or disproving the correctness of intended algorithms using formal methods of mathematics. So in practice, what does that mean? Let's take a very trivial example. If we look at this line of code and we want to prove that it's correct, that it never fails. First we will have to look at what can go wrong. So for instance here we can say well there's potentially a division by zero, right? That's bad. So if we want to prove that the line is correct, we have to prove that x minus 10 is different from zero, which in terms means we have to prove that x is different than 10. This is known as a verification condition, something that has to be true for our program to be correct. Now if we look at this line of code in a context, just a trivial example, here we see that there is an if statement that's guarding the expression. So we know that x is always different from 10 and therefore we know that there's no possible division by zero in this piece of code. So that was easy, right? But now let's look at another very trivial piece of code. Are you able to spot all the verification conditions? Are you able to check that they are respected or not? This is actually very, very difficult. Most programmers will know some of the things that can go wrong. Most of the time we will forget what they are. I'm looking at you, integral flow. And so that's why programming correctly is very difficult for human beings because we are not able to keep in mind all the verification conditions and play with them and check them all the time. Again, this is a very simple piece of code. And so what formal verification is, and in particular, automatic formal verification, well the goal is to have tools that will extract the verification conditions from the code and then run a mathematical proof to check that they are respected. And so today I want to talk about one framework for automatic formal verification, which is called Spark. So Spark is both a set of tools and a language to perform automatic formal verification. So on the tool side, we have different tools that are working together to achieve this goal. The first one is Gnatt Prove. It's developed by the company I work for, Aida Core. It's going to take Spark code as the input and translate it to another language called YML. Then we have this, the tool itself, Y3, developed by Inria in France. It's a research institute which, again, translates the code and extract the verification conditions and call the different solvers, which are on the right here, to ask them to prove the verification conditions. So we have different solvers that will have properties on different kinds of algorithms, Altergo, CVC5, Z3. And so this full tool chain is open source and developed by different entities, as I mentioned. And so the solvers, for instance, they are not only used for Spark, they are used for other formal verification frameworks, but all of them work together in this framework. And so on the other side, Spark is also a language. And actually Spark is a subset of the Aida programming language. And so the question you may ask is, why would you use Aida? Why would you use a subset of Aida for formal verification? So I'm going to take just two simple examples. Why Aida is great for when you want to do formal verification? Well, this language provides a lot of specification power. The developers can express very precisely what they want from the program, from the code, which then the formal verification framework will be able to check. Just a simple example, if you program in any other language, if you want to have in your application a percentage value, for instance, for the completion of a process or whatever, usually we'll say, OK, my percentage is a float. And I'm going to say I'm going to use the value from 0 to 1. And if you are an extremely good programmer, you're going to write that in a comment. Like, you know, my lowest value is 0, my highest value is 1. And that's just a comment. And then if five years down the line, you want to say, oh, actually, it's better if it's from 0 to 100. What happens to the comment? Maybe you update it. Maybe you don't. How do you make sure that everything, all the code is updated to follow this new rule? That's very difficult to maintain. So one example with Aida, you just define your own type and you say it's a float. It's a new float. It's a different kind of float. That has only valid value between 0 and 1. And so what's great here is that the solvers that will try to prove the code, they get a lot of information from here. First, they will add verification conditions when you try to cast from a regular float to this percentage value. Because if the value is not within the range, that's a bug in your program. And you want to know it. Also, you can extract information. Like, if you take two percentage value and you multiply them, you also know that the result is between 0 and 1. And so in turn, that means a lot of information for the provers to do their work. And so they will be able to more automatically reason and prove that the program is correct. Another example is the contract-based programming of Aida. So you can have preconditions and postconditions on your subprograms. So precondition is something that has to be true when you call the function or the procedure. Postcondition is something that has to be true when you return from the subprogram. So very simple example here with the stack. We implement the stack. We have functions to know if the stack is full or if it's empty. And we implement the push. And obviously, well, not obviously, but in this API, we say it doesn't make sense to push something on the stack if the stack is already full. So never do that. That's the contract that the procedure is asking from the caller. And then the implementation says if you push something on the stack, well, it's not empty anymore at the return. And so with Spark, what's great here is that you have formal verification both on the caller side. So Spark will prove that you never call the push function when the stack is full. And on the implementation side, it's going to prove that when you return from the push function, the stack is never empty. And so that's going into functional correctness verification, which means your software is doing what it's supposed to do and only what it's supposed to do. And so with the integrated pre and post conditions in ADA and other features that I don't have time to mention, well, this makes ADA a very great language for formal verification. So why should I care about Spark and I would say formal verification in general? So with Spark, you can have mathematical proof that there is no possible vulnerabilities in your application for any possible inputs. That means no buffer overflow, no division by zero, no integral overflow and so on. If you go beyond and you use contracts, you can also prove, as I mentioned, the functional correctness. So the program does what it's supposed to do and only what it's supposed to do. And in terms, that means you can avoid some of the testing efforts because, for instance, unit testing is more or less trying to achieve the same goal. So if you already have a mathematical proof that the functional correctness of your code, you don't need to do unit testing anymore. And so you're going to save time on that. Recently we published a case study from NVIDIA. So a few years ago, the NVIDIA security team was questioning their methodology for security and how to achieve their goals in terms of security. And so they said testing security is pretty much impossible. You cannot test all possible combinations of all possible values for your application. And so they decided to try provability. And they selected Spark as an experiment. And now they are deploying more and more Spark in the GPU. So if you get the latest, greatest NVIDIA GPU, there should be some Spark-proven code embedded in the firmware, which lets them actually focus on other parts of the security on more interesting verifications and more interesting properties, security properties of the application. They don't have to deal with buffer overflows and integers overflows. All the low-level stuff, it's already taken care of. And they can focus on more interesting points. So now let's do some proof. So for the A9 Spark programming language, we have this package manager called Alire. So here are a few instructions to make your first and prove your first piece of Spark code. So you don't know then install the package manager. So from the command line, we start by creating a project or a crate with Alire in it. We enter the directory. We add the net prove tool suite as a dependency. So it's going to download everything and set it up for you. Then we write some piece of code. So you can recognize our very nice equation here. Just for the declaration of the X constant, it doesn't matter what it is. I'm just taking an integer value that Spark doesn't know. So just to make sure I'm not cheating or anything. We go to the console again. We run a net prove. And so a net prove will tell us, well, there might be a division by zero error at these points. So as you can see, the message is pretty clear. Actually, it can be even better than that because the tool can provide counter examples. So if we add the switch, counter examples on, net prove will say division by zero might fail, for instance, when X equals 10. And so that's pretty easy to fix. We just add this if statement. And we run the tool again. And that's it. We proved our first piece of code. So as you can see, it was easy. If you want to try and learn a little bit of Spark, we have an online website. So learn.edocore.com. Online interactive website. So you don't even have to install what I showed before just to learn and try the tool sheets. So there's different chapters and one specific to Spark. So that's one way to get started. And for those who wondered, just the piece of code before, there are seven potential bugs or errors in this one. So I'll let you as an exercise to fix this one. Thank you very much. Thank you for the presentation. Let me unwrap you with a shot. Perhaps someone might have a question about that.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 18.52, "text": " The next presentation will be by Fabien Choteau.", "tokens": [440, 958, 5860, 486, 312, 538, 17440, 1053, 761, 1370, 1459, 13], "temperature": 0.0, "avg_logprob": -0.3482583550845875, "compression_ratio": 1.2695652173913043, "no_speech_prob": 0.236971914768219}, {"id": 1, "seek": 0, "start": 18.52, "end": 25.64, "text": " He will give an introduction on formal verification and will learn us how to mathematically prove", "tokens": [634, 486, 976, 364, 9339, 322, 9860, 30206, 293, 486, 1466, 505, 577, 281, 44003, 7081], "temperature": 0.0, "avg_logprob": -0.3482583550845875, "compression_ratio": 1.2695652173913043, "no_speech_prob": 0.236971914768219}, {"id": 2, "seek": 2564, "start": 25.64, "end": 36.2, "text": " this error box in your software. Thank you. I need the timer because I have quite a lot", "tokens": [341, 6713, 2424, 294, 428, 4722, 13, 1044, 291, 13, 286, 643, 264, 19247, 570, 286, 362, 1596, 257, 688], "temperature": 0.0, "avg_logprob": -0.3370376808055933, "compression_ratio": 1.5754189944134078, "no_speech_prob": 0.0018888013437390327}, {"id": 3, "seek": 2564, "start": 36.2, "end": 42.96, "text": " of things to say. Hi everyone, I'm Fabien and yet today I want to talk about formal verification,", "tokens": [295, 721, 281, 584, 13, 2421, 1518, 11, 286, 478, 17440, 1053, 293, 1939, 965, 286, 528, 281, 751, 466, 9860, 30206, 11], "temperature": 0.0, "avg_logprob": -0.3370376808055933, "compression_ratio": 1.5754189944134078, "no_speech_prob": 0.0018888013437390327}, {"id": 4, "seek": 2564, "start": 42.96, "end": 49.760000000000005, "text": " open source formal verification. First the disclaimer, I'm not an expert in formal verification,", "tokens": [1269, 4009, 9860, 30206, 13, 2386, 264, 40896, 11, 286, 478, 406, 364, 5844, 294, 9860, 30206, 11], "temperature": 0.0, "avg_logprob": -0.3370376808055933, "compression_ratio": 1.5754189944134078, "no_speech_prob": 0.0018888013437390327}, {"id": 5, "seek": 4976, "start": 49.76, "end": 55.68, "text": " but I'm a user of this technology. What I'm an expert at is embedded software, but I", "tokens": [457, 286, 478, 257, 4195, 295, 341, 2899, 13, 708, 286, 478, 364, 5844, 412, 307, 16741, 4722, 11, 457, 286], "temperature": 0.0, "avg_logprob": -0.16918809413909913, "compression_ratio": 1.6901408450704225, "no_speech_prob": 0.0003051962121389806}, {"id": 6, "seek": 4976, "start": 55.68, "end": 60.56, "text": " use formal verification and I will explain later our work in a company that's developing", "tokens": [764, 9860, 30206, 293, 286, 486, 2903, 1780, 527, 589, 294, 257, 2237, 300, 311, 6416], "temperature": 0.0, "avg_logprob": -0.16918809413909913, "compression_ratio": 1.6901408450704225, "no_speech_prob": 0.0003051962121389806}, {"id": 7, "seek": 4976, "start": 60.56, "end": 68.52, "text": " some formal verification solutions. If we look at what Wikipedia says, formal verification", "tokens": [512, 9860, 30206, 6547, 13, 759, 321, 574, 412, 437, 28999, 1619, 11, 9860, 30206], "temperature": 0.0, "avg_logprob": -0.16918809413909913, "compression_ratio": 1.6901408450704225, "no_speech_prob": 0.0003051962121389806}, {"id": 8, "seek": 4976, "start": 68.52, "end": 74.75999999999999, "text": " is the act of proving or disproving the correctness of intended algorithms using formal methods", "tokens": [307, 264, 605, 295, 27221, 420, 717, 4318, 798, 264, 3006, 1287, 295, 10226, 14642, 1228, 9860, 7150], "temperature": 0.0, "avg_logprob": -0.16918809413909913, "compression_ratio": 1.6901408450704225, "no_speech_prob": 0.0003051962121389806}, {"id": 9, "seek": 7476, "start": 74.76, "end": 84.88000000000001, "text": " of mathematics. So in practice, what does that mean? Let's take a very trivial example.", "tokens": [295, 18666, 13, 407, 294, 3124, 11, 437, 775, 300, 914, 30, 961, 311, 747, 257, 588, 26703, 1365, 13], "temperature": 0.0, "avg_logprob": -0.17201666678151778, "compression_ratio": 1.5675675675675675, "no_speech_prob": 5.259149838821031e-05}, {"id": 10, "seek": 7476, "start": 84.88000000000001, "end": 90.76, "text": " If we look at this line of code and we want to prove that it's correct, that it never", "tokens": [759, 321, 574, 412, 341, 1622, 295, 3089, 293, 321, 528, 281, 7081, 300, 309, 311, 3006, 11, 300, 309, 1128], "temperature": 0.0, "avg_logprob": -0.17201666678151778, "compression_ratio": 1.5675675675675675, "no_speech_prob": 5.259149838821031e-05}, {"id": 11, "seek": 7476, "start": 90.76, "end": 96.44, "text": " fails. First we will have to look at what can go wrong. So for instance here we can say", "tokens": [18199, 13, 2386, 321, 486, 362, 281, 574, 412, 437, 393, 352, 2085, 13, 407, 337, 5197, 510, 321, 393, 584], "temperature": 0.0, "avg_logprob": -0.17201666678151778, "compression_ratio": 1.5675675675675675, "no_speech_prob": 5.259149838821031e-05}, {"id": 12, "seek": 7476, "start": 96.44, "end": 102.64, "text": " well there's potentially a division by zero, right? That's bad. So if we want to prove", "tokens": [731, 456, 311, 7263, 257, 10044, 538, 4018, 11, 558, 30, 663, 311, 1578, 13, 407, 498, 321, 528, 281, 7081], "temperature": 0.0, "avg_logprob": -0.17201666678151778, "compression_ratio": 1.5675675675675675, "no_speech_prob": 5.259149838821031e-05}, {"id": 13, "seek": 10264, "start": 102.64, "end": 111.36, "text": " that the line is correct, we have to prove that x minus 10 is different from zero, which", "tokens": [300, 264, 1622, 307, 3006, 11, 321, 362, 281, 7081, 300, 2031, 3175, 1266, 307, 819, 490, 4018, 11, 597], "temperature": 0.0, "avg_logprob": -0.11731345617949072, "compression_ratio": 1.6242424242424243, "no_speech_prob": 1.806186446628999e-05}, {"id": 14, "seek": 10264, "start": 111.36, "end": 120.88, "text": " in terms means we have to prove that x is different than 10. This is known as a verification", "tokens": [294, 2115, 1355, 321, 362, 281, 7081, 300, 2031, 307, 819, 813, 1266, 13, 639, 307, 2570, 382, 257, 30206], "temperature": 0.0, "avg_logprob": -0.11731345617949072, "compression_ratio": 1.6242424242424243, "no_speech_prob": 1.806186446628999e-05}, {"id": 15, "seek": 10264, "start": 120.88, "end": 130.04, "text": " condition, something that has to be true for our program to be correct. Now if we look", "tokens": [4188, 11, 746, 300, 575, 281, 312, 2074, 337, 527, 1461, 281, 312, 3006, 13, 823, 498, 321, 574], "temperature": 0.0, "avg_logprob": -0.11731345617949072, "compression_ratio": 1.6242424242424243, "no_speech_prob": 1.806186446628999e-05}, {"id": 16, "seek": 13004, "start": 130.04, "end": 136.79999999999998, "text": " at this line of code in a context, just a trivial example, here we see that there is", "tokens": [412, 341, 1622, 295, 3089, 294, 257, 4319, 11, 445, 257, 26703, 1365, 11, 510, 321, 536, 300, 456, 307], "temperature": 0.0, "avg_logprob": -0.12780929433888402, "compression_ratio": 1.6338028169014085, "no_speech_prob": 1.7503396520623937e-05}, {"id": 17, "seek": 13004, "start": 136.79999999999998, "end": 142.72, "text": " an if statement that's guarding the expression. So we know that x is always different from", "tokens": [364, 498, 5629, 300, 311, 44077, 264, 6114, 13, 407, 321, 458, 300, 2031, 307, 1009, 819, 490], "temperature": 0.0, "avg_logprob": -0.12780929433888402, "compression_ratio": 1.6338028169014085, "no_speech_prob": 1.7503396520623937e-05}, {"id": 18, "seek": 13004, "start": 142.72, "end": 149.16, "text": " 10 and therefore we know that there's no possible division by zero in this piece of", "tokens": [1266, 293, 4412, 321, 458, 300, 456, 311, 572, 1944, 10044, 538, 4018, 294, 341, 2522, 295], "temperature": 0.0, "avg_logprob": -0.12780929433888402, "compression_ratio": 1.6338028169014085, "no_speech_prob": 1.7503396520623937e-05}, {"id": 19, "seek": 13004, "start": 149.16, "end": 157.84, "text": " code. So that was easy, right? But now let's look at another very trivial piece of code.", "tokens": [3089, 13, 407, 300, 390, 1858, 11, 558, 30, 583, 586, 718, 311, 574, 412, 1071, 588, 26703, 2522, 295, 3089, 13], "temperature": 0.0, "avg_logprob": -0.12780929433888402, "compression_ratio": 1.6338028169014085, "no_speech_prob": 1.7503396520623937e-05}, {"id": 20, "seek": 15784, "start": 157.84, "end": 162.28, "text": " Are you able to spot all the verification conditions? Are you able to check that they", "tokens": [2014, 291, 1075, 281, 4008, 439, 264, 30206, 4487, 30, 2014, 291, 1075, 281, 1520, 300, 436], "temperature": 0.0, "avg_logprob": -0.13685088559805628, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.00033838499803096056}, {"id": 21, "seek": 15784, "start": 162.28, "end": 171.88, "text": " are respected or not? This is actually very, very difficult. Most programmers will know", "tokens": [366, 20020, 420, 406, 30, 639, 307, 767, 588, 11, 588, 2252, 13, 4534, 41504, 486, 458], "temperature": 0.0, "avg_logprob": -0.13685088559805628, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.00033838499803096056}, {"id": 22, "seek": 15784, "start": 171.88, "end": 178.04, "text": " some of the things that can go wrong. Most of the time we will forget what they are.", "tokens": [512, 295, 264, 721, 300, 393, 352, 2085, 13, 4534, 295, 264, 565, 321, 486, 2870, 437, 436, 366, 13], "temperature": 0.0, "avg_logprob": -0.13685088559805628, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.00033838499803096056}, {"id": 23, "seek": 15784, "start": 178.04, "end": 185.72, "text": " I'm looking at you, integral flow. And so that's why programming correctly is very difficult", "tokens": [286, 478, 1237, 412, 291, 11, 11573, 3095, 13, 400, 370, 300, 311, 983, 9410, 8944, 307, 588, 2252], "temperature": 0.0, "avg_logprob": -0.13685088559805628, "compression_ratio": 1.6401869158878504, "no_speech_prob": 0.00033838499803096056}, {"id": 24, "seek": 18572, "start": 185.72, "end": 191.12, "text": " for human beings because we are not able to keep in mind all the verification conditions", "tokens": [337, 1952, 8958, 570, 321, 366, 406, 1075, 281, 1066, 294, 1575, 439, 264, 30206, 4487], "temperature": 0.0, "avg_logprob": -0.1563294205484511, "compression_ratio": 1.7939698492462313, "no_speech_prob": 9.740310633787885e-05}, {"id": 25, "seek": 18572, "start": 191.12, "end": 195.56, "text": " and play with them and check them all the time. Again, this is a very simple piece of", "tokens": [293, 862, 365, 552, 293, 1520, 552, 439, 264, 565, 13, 3764, 11, 341, 307, 257, 588, 2199, 2522, 295], "temperature": 0.0, "avg_logprob": -0.1563294205484511, "compression_ratio": 1.7939698492462313, "no_speech_prob": 9.740310633787885e-05}, {"id": 26, "seek": 18572, "start": 195.56, "end": 204.48, "text": " code. And so what formal verification is, and in particular, automatic formal verification,", "tokens": [3089, 13, 400, 370, 437, 9860, 30206, 307, 11, 293, 294, 1729, 11, 12509, 9860, 30206, 11], "temperature": 0.0, "avg_logprob": -0.1563294205484511, "compression_ratio": 1.7939698492462313, "no_speech_prob": 9.740310633787885e-05}, {"id": 27, "seek": 18572, "start": 204.48, "end": 210.32, "text": " well the goal is to have tools that will extract the verification conditions from the code", "tokens": [731, 264, 3387, 307, 281, 362, 3873, 300, 486, 8947, 264, 30206, 4487, 490, 264, 3089], "temperature": 0.0, "avg_logprob": -0.1563294205484511, "compression_ratio": 1.7939698492462313, "no_speech_prob": 9.740310633787885e-05}, {"id": 28, "seek": 21032, "start": 210.32, "end": 218.16, "text": " and then run a mathematical proof to check that they are respected. And so today I want", "tokens": [293, 550, 1190, 257, 18894, 8177, 281, 1520, 300, 436, 366, 20020, 13, 400, 370, 965, 286, 528], "temperature": 0.0, "avg_logprob": -0.12932474037696576, "compression_ratio": 1.5783132530120483, "no_speech_prob": 8.269006502814591e-05}, {"id": 29, "seek": 21032, "start": 218.16, "end": 227.35999999999999, "text": " to talk about one framework for automatic formal verification, which is called Spark.", "tokens": [281, 751, 466, 472, 8388, 337, 12509, 9860, 30206, 11, 597, 307, 1219, 23424, 13], "temperature": 0.0, "avg_logprob": -0.12932474037696576, "compression_ratio": 1.5783132530120483, "no_speech_prob": 8.269006502814591e-05}, {"id": 30, "seek": 21032, "start": 227.35999999999999, "end": 237.0, "text": " So Spark is both a set of tools and a language to perform automatic formal verification.", "tokens": [407, 23424, 307, 1293, 257, 992, 295, 3873, 293, 257, 2856, 281, 2042, 12509, 9860, 30206, 13], "temperature": 0.0, "avg_logprob": -0.12932474037696576, "compression_ratio": 1.5783132530120483, "no_speech_prob": 8.269006502814591e-05}, {"id": 31, "seek": 23700, "start": 237.0, "end": 242.56, "text": " So on the tool side, we have different tools that are working together to achieve this", "tokens": [407, 322, 264, 2290, 1252, 11, 321, 362, 819, 3873, 300, 366, 1364, 1214, 281, 4584, 341], "temperature": 0.0, "avg_logprob": -0.2282755546963092, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.00014386350812856108}, {"id": 32, "seek": 23700, "start": 242.56, "end": 249.56, "text": " goal. The first one is Gnatt Prove. It's developed by the company I work for, Aida Core. It's", "tokens": [3387, 13, 440, 700, 472, 307, 460, 77, 1591, 1705, 303, 13, 467, 311, 4743, 538, 264, 2237, 286, 589, 337, 11, 316, 2887, 14798, 13, 467, 311], "temperature": 0.0, "avg_logprob": -0.2282755546963092, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.00014386350812856108}, {"id": 33, "seek": 23700, "start": 249.56, "end": 256.28, "text": " going to take Spark code as the input and translate it to another language called YML.", "tokens": [516, 281, 747, 23424, 3089, 382, 264, 4846, 293, 13799, 309, 281, 1071, 2856, 1219, 398, 12683, 13], "temperature": 0.0, "avg_logprob": -0.2282755546963092, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.00014386350812856108}, {"id": 34, "seek": 23700, "start": 256.28, "end": 266.0, "text": " Then we have this, the tool itself, Y3, developed by Inria in France. It's a research institute", "tokens": [1396, 321, 362, 341, 11, 264, 2290, 2564, 11, 398, 18, 11, 4743, 538, 682, 4668, 294, 6190, 13, 467, 311, 257, 2132, 26860], "temperature": 0.0, "avg_logprob": -0.2282755546963092, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.00014386350812856108}, {"id": 35, "seek": 26600, "start": 266.0, "end": 274.68, "text": " which, again, translates the code and extract the verification conditions and call the different", "tokens": [597, 11, 797, 11, 28468, 264, 3089, 293, 8947, 264, 30206, 4487, 293, 818, 264, 819], "temperature": 0.0, "avg_logprob": -0.21329670860653832, "compression_ratio": 1.6837209302325582, "no_speech_prob": 7.841885962989181e-05}, {"id": 36, "seek": 26600, "start": 274.68, "end": 282.52, "text": " solvers, which are on the right here, to ask them to prove the verification conditions.", "tokens": [1404, 840, 11, 597, 366, 322, 264, 558, 510, 11, 281, 1029, 552, 281, 7081, 264, 30206, 4487, 13], "temperature": 0.0, "avg_logprob": -0.21329670860653832, "compression_ratio": 1.6837209302325582, "no_speech_prob": 7.841885962989181e-05}, {"id": 37, "seek": 26600, "start": 282.52, "end": 287.56, "text": " So we have different solvers that will have properties on different kinds of algorithms,", "tokens": [407, 321, 362, 819, 1404, 840, 300, 486, 362, 7221, 322, 819, 3685, 295, 14642, 11], "temperature": 0.0, "avg_logprob": -0.21329670860653832, "compression_ratio": 1.6837209302325582, "no_speech_prob": 7.841885962989181e-05}, {"id": 38, "seek": 26600, "start": 287.56, "end": 294.96, "text": " Altergo, CVC5, Z3. And so this full tool chain is open source and developed by different", "tokens": [32608, 1571, 11, 22995, 34, 20, 11, 1176, 18, 13, 400, 370, 341, 1577, 2290, 5021, 307, 1269, 4009, 293, 4743, 538, 819], "temperature": 0.0, "avg_logprob": -0.21329670860653832, "compression_ratio": 1.6837209302325582, "no_speech_prob": 7.841885962989181e-05}, {"id": 39, "seek": 29496, "start": 294.96, "end": 301.76, "text": " entities, as I mentioned. And so the solvers, for instance, they are not only used for Spark,", "tokens": [16667, 11, 382, 286, 2835, 13, 400, 370, 264, 1404, 840, 11, 337, 5197, 11, 436, 366, 406, 787, 1143, 337, 23424, 11], "temperature": 0.0, "avg_logprob": -0.1790399117903276, "compression_ratio": 1.6402439024390243, "no_speech_prob": 0.00014511060726363212}, {"id": 40, "seek": 29496, "start": 301.76, "end": 307.88, "text": " they are used for other formal verification frameworks, but all of them work together", "tokens": [436, 366, 1143, 337, 661, 9860, 30206, 29834, 11, 457, 439, 295, 552, 589, 1214], "temperature": 0.0, "avg_logprob": -0.1790399117903276, "compression_ratio": 1.6402439024390243, "no_speech_prob": 0.00014511060726363212}, {"id": 41, "seek": 29496, "start": 307.88, "end": 317.35999999999996, "text": " in this framework. And so on the other side, Spark is also a language. And actually Spark", "tokens": [294, 341, 8388, 13, 400, 370, 322, 264, 661, 1252, 11, 23424, 307, 611, 257, 2856, 13, 400, 767, 23424], "temperature": 0.0, "avg_logprob": -0.1790399117903276, "compression_ratio": 1.6402439024390243, "no_speech_prob": 0.00014511060726363212}, {"id": 42, "seek": 31736, "start": 317.36, "end": 325.2, "text": " is a subset of the Aida programming language. And so the question you may ask is, why would", "tokens": [307, 257, 25993, 295, 264, 316, 2887, 9410, 2856, 13, 400, 370, 264, 1168, 291, 815, 1029, 307, 11, 983, 576], "temperature": 0.0, "avg_logprob": -0.1360703839196099, "compression_ratio": 1.6467065868263473, "no_speech_prob": 5.090073682367802e-05}, {"id": 43, "seek": 31736, "start": 325.2, "end": 332.68, "text": " you use Aida? Why would you use a subset of Aida for formal verification? So I'm going", "tokens": [291, 764, 316, 2887, 30, 1545, 576, 291, 764, 257, 25993, 295, 316, 2887, 337, 9860, 30206, 30, 407, 286, 478, 516], "temperature": 0.0, "avg_logprob": -0.1360703839196099, "compression_ratio": 1.6467065868263473, "no_speech_prob": 5.090073682367802e-05}, {"id": 44, "seek": 31736, "start": 332.68, "end": 343.12, "text": " to take just two simple examples. Why Aida is great for when you want to do formal verification?", "tokens": [281, 747, 445, 732, 2199, 5110, 13, 1545, 316, 2887, 307, 869, 337, 562, 291, 528, 281, 360, 9860, 30206, 30], "temperature": 0.0, "avg_logprob": -0.1360703839196099, "compression_ratio": 1.6467065868263473, "no_speech_prob": 5.090073682367802e-05}, {"id": 45, "seek": 34312, "start": 343.12, "end": 352.32, "text": " Well, this language provides a lot of specification power. The developers can express very precisely", "tokens": [1042, 11, 341, 2856, 6417, 257, 688, 295, 31256, 1347, 13, 440, 8849, 393, 5109, 588, 13402], "temperature": 0.0, "avg_logprob": -0.12354527450189358, "compression_ratio": 1.6726457399103138, "no_speech_prob": 0.00018862431170418859}, {"id": 46, "seek": 34312, "start": 352.32, "end": 359.92, "text": " what they want from the program, from the code, which then the formal verification framework", "tokens": [437, 436, 528, 490, 264, 1461, 11, 490, 264, 3089, 11, 597, 550, 264, 9860, 30206, 8388], "temperature": 0.0, "avg_logprob": -0.12354527450189358, "compression_ratio": 1.6726457399103138, "no_speech_prob": 0.00018862431170418859}, {"id": 47, "seek": 34312, "start": 359.92, "end": 366.48, "text": " will be able to check. Just a simple example, if you program in any other language, if you", "tokens": [486, 312, 1075, 281, 1520, 13, 1449, 257, 2199, 1365, 11, 498, 291, 1461, 294, 604, 661, 2856, 11, 498, 291], "temperature": 0.0, "avg_logprob": -0.12354527450189358, "compression_ratio": 1.6726457399103138, "no_speech_prob": 0.00018862431170418859}, {"id": 48, "seek": 34312, "start": 366.48, "end": 371.72, "text": " want to have in your application a percentage value, for instance, for the completion of", "tokens": [528, 281, 362, 294, 428, 3861, 257, 9668, 2158, 11, 337, 5197, 11, 337, 264, 19372, 295], "temperature": 0.0, "avg_logprob": -0.12354527450189358, "compression_ratio": 1.6726457399103138, "no_speech_prob": 0.00018862431170418859}, {"id": 49, "seek": 37172, "start": 371.72, "end": 379.8, "text": " a process or whatever, usually we'll say, OK, my percentage is a float. And I'm going", "tokens": [257, 1399, 420, 2035, 11, 2673, 321, 603, 584, 11, 2264, 11, 452, 9668, 307, 257, 15706, 13, 400, 286, 478, 516], "temperature": 0.0, "avg_logprob": -0.1300167961726113, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.00012993034033570439}, {"id": 50, "seek": 37172, "start": 379.8, "end": 386.0, "text": " to say I'm going to use the value from 0 to 1. And if you are an extremely good programmer,", "tokens": [281, 584, 286, 478, 516, 281, 764, 264, 2158, 490, 1958, 281, 502, 13, 400, 498, 291, 366, 364, 4664, 665, 32116, 11], "temperature": 0.0, "avg_logprob": -0.1300167961726113, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.00012993034033570439}, {"id": 51, "seek": 37172, "start": 386.0, "end": 390.20000000000005, "text": " you're going to write that in a comment. Like, you know, my lowest value is 0, my highest", "tokens": [291, 434, 516, 281, 2464, 300, 294, 257, 2871, 13, 1743, 11, 291, 458, 11, 452, 12437, 2158, 307, 1958, 11, 452, 6343], "temperature": 0.0, "avg_logprob": -0.1300167961726113, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.00012993034033570439}, {"id": 52, "seek": 37172, "start": 390.20000000000005, "end": 396.32000000000005, "text": " value is 1. And that's just a comment. And then if five years down the line, you want", "tokens": [2158, 307, 502, 13, 400, 300, 311, 445, 257, 2871, 13, 400, 550, 498, 1732, 924, 760, 264, 1622, 11, 291, 528], "temperature": 0.0, "avg_logprob": -0.1300167961726113, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.00012993034033570439}, {"id": 53, "seek": 37172, "start": 396.32000000000005, "end": 401.6, "text": " to say, oh, actually, it's better if it's from 0 to 100. What happens to the comment?", "tokens": [281, 584, 11, 1954, 11, 767, 11, 309, 311, 1101, 498, 309, 311, 490, 1958, 281, 2319, 13, 708, 2314, 281, 264, 2871, 30], "temperature": 0.0, "avg_logprob": -0.1300167961726113, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.00012993034033570439}, {"id": 54, "seek": 40160, "start": 401.6, "end": 405.76000000000005, "text": " Maybe you update it. Maybe you don't. How do you make sure that everything, all the code", "tokens": [2704, 291, 5623, 309, 13, 2704, 291, 500, 380, 13, 1012, 360, 291, 652, 988, 300, 1203, 11, 439, 264, 3089], "temperature": 0.0, "avg_logprob": -0.13463997840881348, "compression_ratio": 1.5594713656387664, "no_speech_prob": 6.9839705247432e-05}, {"id": 55, "seek": 40160, "start": 405.76000000000005, "end": 411.84000000000003, "text": " is updated to follow this new rule? That's very difficult to maintain. So one example", "tokens": [307, 10588, 281, 1524, 341, 777, 4978, 30, 663, 311, 588, 2252, 281, 6909, 13, 407, 472, 1365], "temperature": 0.0, "avg_logprob": -0.13463997840881348, "compression_ratio": 1.5594713656387664, "no_speech_prob": 6.9839705247432e-05}, {"id": 56, "seek": 40160, "start": 411.84000000000003, "end": 417.36, "text": " with Aida, you just define your own type and you say it's a float. It's a new float. It's", "tokens": [365, 316, 2887, 11, 291, 445, 6964, 428, 1065, 2010, 293, 291, 584, 309, 311, 257, 15706, 13, 467, 311, 257, 777, 15706, 13, 467, 311], "temperature": 0.0, "avg_logprob": -0.13463997840881348, "compression_ratio": 1.5594713656387664, "no_speech_prob": 6.9839705247432e-05}, {"id": 57, "seek": 40160, "start": 417.36, "end": 425.88, "text": " a different kind of float. That has only valid value between 0 and 1. And so what's great", "tokens": [257, 819, 733, 295, 15706, 13, 663, 575, 787, 7363, 2158, 1296, 1958, 293, 502, 13, 400, 370, 437, 311, 869], "temperature": 0.0, "avg_logprob": -0.13463997840881348, "compression_ratio": 1.5594713656387664, "no_speech_prob": 6.9839705247432e-05}, {"id": 58, "seek": 42588, "start": 425.88, "end": 432.56, "text": " here is that the solvers that will try to prove the code, they get a lot of information", "tokens": [510, 307, 300, 264, 1404, 840, 300, 486, 853, 281, 7081, 264, 3089, 11, 436, 483, 257, 688, 295, 1589], "temperature": 0.0, "avg_logprob": -0.10357155056174742, "compression_ratio": 1.7374517374517375, "no_speech_prob": 3.512126932037063e-05}, {"id": 59, "seek": 42588, "start": 432.56, "end": 439.52, "text": " from here. First, they will add verification conditions when you try to cast from a regular", "tokens": [490, 510, 13, 2386, 11, 436, 486, 909, 30206, 4487, 562, 291, 853, 281, 4193, 490, 257, 3890], "temperature": 0.0, "avg_logprob": -0.10357155056174742, "compression_ratio": 1.7374517374517375, "no_speech_prob": 3.512126932037063e-05}, {"id": 60, "seek": 42588, "start": 439.52, "end": 444.36, "text": " float to this percentage value. Because if the value is not within the range, that's", "tokens": [15706, 281, 341, 9668, 2158, 13, 1436, 498, 264, 2158, 307, 406, 1951, 264, 3613, 11, 300, 311], "temperature": 0.0, "avg_logprob": -0.10357155056174742, "compression_ratio": 1.7374517374517375, "no_speech_prob": 3.512126932037063e-05}, {"id": 61, "seek": 42588, "start": 444.36, "end": 450.24, "text": " a bug in your program. And you want to know it. Also, you can extract information. Like,", "tokens": [257, 7426, 294, 428, 1461, 13, 400, 291, 528, 281, 458, 309, 13, 2743, 11, 291, 393, 8947, 1589, 13, 1743, 11], "temperature": 0.0, "avg_logprob": -0.10357155056174742, "compression_ratio": 1.7374517374517375, "no_speech_prob": 3.512126932037063e-05}, {"id": 62, "seek": 42588, "start": 450.24, "end": 454.84, "text": " if you take two percentage value and you multiply them, you also know that the result is between", "tokens": [498, 291, 747, 732, 9668, 2158, 293, 291, 12972, 552, 11, 291, 611, 458, 300, 264, 1874, 307, 1296], "temperature": 0.0, "avg_logprob": -0.10357155056174742, "compression_ratio": 1.7374517374517375, "no_speech_prob": 3.512126932037063e-05}, {"id": 63, "seek": 45484, "start": 454.84, "end": 460.56, "text": " 0 and 1. And so in turn, that means a lot of information for the provers to do their work.", "tokens": [1958, 293, 502, 13, 400, 370, 294, 1261, 11, 300, 1355, 257, 688, 295, 1589, 337, 264, 447, 840, 281, 360, 641, 589, 13], "temperature": 0.0, "avg_logprob": -0.12287186213902064, "compression_ratio": 1.550561797752809, "no_speech_prob": 4.083825115230866e-05}, {"id": 64, "seek": 45484, "start": 460.56, "end": 472.15999999999997, "text": " And so they will be able to more automatically reason and prove that the program is correct.", "tokens": [400, 370, 436, 486, 312, 1075, 281, 544, 6772, 1778, 293, 7081, 300, 264, 1461, 307, 3006, 13], "temperature": 0.0, "avg_logprob": -0.12287186213902064, "compression_ratio": 1.550561797752809, "no_speech_prob": 4.083825115230866e-05}, {"id": 65, "seek": 45484, "start": 472.15999999999997, "end": 480.52, "text": " Another example is the contract-based programming of Aida. So you can have preconditions and", "tokens": [3996, 1365, 307, 264, 4364, 12, 6032, 9410, 295, 316, 2887, 13, 407, 291, 393, 362, 4346, 684, 2451, 293], "temperature": 0.0, "avg_logprob": -0.12287186213902064, "compression_ratio": 1.550561797752809, "no_speech_prob": 4.083825115230866e-05}, {"id": 66, "seek": 48052, "start": 480.52, "end": 487.28, "text": " postconditions on your subprograms. So precondition is something that has to be true when you", "tokens": [2183, 18882, 2451, 322, 428, 1422, 32726, 82, 13, 407, 4346, 684, 849, 307, 746, 300, 575, 281, 312, 2074, 562, 291], "temperature": 0.0, "avg_logprob": -0.12602400249905057, "compression_ratio": 1.9206349206349207, "no_speech_prob": 6.806961027905345e-05}, {"id": 67, "seek": 48052, "start": 487.28, "end": 493.96, "text": " call the function or the procedure. Postcondition is something that has to be true when you", "tokens": [818, 264, 2445, 420, 264, 10747, 13, 10223, 18882, 849, 307, 746, 300, 575, 281, 312, 2074, 562, 291], "temperature": 0.0, "avg_logprob": -0.12602400249905057, "compression_ratio": 1.9206349206349207, "no_speech_prob": 6.806961027905345e-05}, {"id": 68, "seek": 48052, "start": 493.96, "end": 501.35999999999996, "text": " return from the subprogram. So very simple example here with the stack. We implement", "tokens": [2736, 490, 264, 1422, 32726, 13, 407, 588, 2199, 1365, 510, 365, 264, 8630, 13, 492, 4445], "temperature": 0.0, "avg_logprob": -0.12602400249905057, "compression_ratio": 1.9206349206349207, "no_speech_prob": 6.806961027905345e-05}, {"id": 69, "seek": 48052, "start": 501.35999999999996, "end": 507.35999999999996, "text": " the stack. We have functions to know if the stack is full or if it's empty. And we implement", "tokens": [264, 8630, 13, 492, 362, 6828, 281, 458, 498, 264, 8630, 307, 1577, 420, 498, 309, 311, 6707, 13, 400, 321, 4445], "temperature": 0.0, "avg_logprob": -0.12602400249905057, "compression_ratio": 1.9206349206349207, "no_speech_prob": 6.806961027905345e-05}, {"id": 70, "seek": 50736, "start": 507.36, "end": 513.5600000000001, "text": " the push. And obviously, well, not obviously, but in this API, we say it doesn't make sense", "tokens": [264, 2944, 13, 400, 2745, 11, 731, 11, 406, 2745, 11, 457, 294, 341, 9362, 11, 321, 584, 309, 1177, 380, 652, 2020], "temperature": 0.0, "avg_logprob": -0.10359968922354958, "compression_ratio": 1.6941747572815533, "no_speech_prob": 2.0517580196610652e-05}, {"id": 71, "seek": 50736, "start": 513.5600000000001, "end": 518.64, "text": " to push something on the stack if the stack is already full. So never do that. That's", "tokens": [281, 2944, 746, 322, 264, 8630, 498, 264, 8630, 307, 1217, 1577, 13, 407, 1128, 360, 300, 13, 663, 311], "temperature": 0.0, "avg_logprob": -0.10359968922354958, "compression_ratio": 1.6941747572815533, "no_speech_prob": 2.0517580196610652e-05}, {"id": 72, "seek": 50736, "start": 518.64, "end": 525.8000000000001, "text": " the contract that the procedure is asking from the caller. And then the implementation", "tokens": [264, 4364, 300, 264, 10747, 307, 3365, 490, 264, 48324, 13, 400, 550, 264, 11420], "temperature": 0.0, "avg_logprob": -0.10359968922354958, "compression_ratio": 1.6941747572815533, "no_speech_prob": 2.0517580196610652e-05}, {"id": 73, "seek": 50736, "start": 525.8000000000001, "end": 533.08, "text": " says if you push something on the stack, well, it's not empty anymore at the return.", "tokens": [1619, 498, 291, 2944, 746, 322, 264, 8630, 11, 731, 11, 309, 311, 406, 6707, 3602, 412, 264, 2736, 13], "temperature": 0.0, "avg_logprob": -0.10359968922354958, "compression_ratio": 1.6941747572815533, "no_speech_prob": 2.0517580196610652e-05}, {"id": 74, "seek": 53308, "start": 533.08, "end": 539.1600000000001, "text": " And so with Spark, what's great here is that you have formal verification both on the", "tokens": [400, 370, 365, 23424, 11, 437, 311, 869, 510, 307, 300, 291, 362, 9860, 30206, 1293, 322, 264], "temperature": 0.0, "avg_logprob": -0.11619529953922134, "compression_ratio": 1.763819095477387, "no_speech_prob": 1.935064938152209e-05}, {"id": 75, "seek": 53308, "start": 539.1600000000001, "end": 547.8000000000001, "text": " caller side. So Spark will prove that you never call the push function when the stack", "tokens": [48324, 1252, 13, 407, 23424, 486, 7081, 300, 291, 1128, 818, 264, 2944, 2445, 562, 264, 8630], "temperature": 0.0, "avg_logprob": -0.11619529953922134, "compression_ratio": 1.763819095477387, "no_speech_prob": 1.935064938152209e-05}, {"id": 76, "seek": 53308, "start": 547.8000000000001, "end": 553.6, "text": " is full. And on the implementation side, it's going to prove that when you return from", "tokens": [307, 1577, 13, 400, 322, 264, 11420, 1252, 11, 309, 311, 516, 281, 7081, 300, 562, 291, 2736, 490], "temperature": 0.0, "avg_logprob": -0.11619529953922134, "compression_ratio": 1.763819095477387, "no_speech_prob": 1.935064938152209e-05}, {"id": 77, "seek": 53308, "start": 553.6, "end": 560.2800000000001, "text": " the push function, the stack is never empty. And so that's going into functional correctness", "tokens": [264, 2944, 2445, 11, 264, 8630, 307, 1128, 6707, 13, 400, 370, 300, 311, 516, 666, 11745, 3006, 1287], "temperature": 0.0, "avg_logprob": -0.11619529953922134, "compression_ratio": 1.763819095477387, "no_speech_prob": 1.935064938152209e-05}, {"id": 78, "seek": 56028, "start": 560.28, "end": 568.48, "text": " verification, which means your software is doing what it's supposed to do and only what", "tokens": [30206, 11, 597, 1355, 428, 4722, 307, 884, 437, 309, 311, 3442, 281, 360, 293, 787, 437], "temperature": 0.0, "avg_logprob": -0.1282879902766301, "compression_ratio": 1.5480225988700564, "no_speech_prob": 3.819958874373697e-05}, {"id": 79, "seek": 56028, "start": 568.48, "end": 575.9599999999999, "text": " it's supposed to do. And so with the integrated pre and post conditions in ADA and other features", "tokens": [309, 311, 3442, 281, 360, 13, 400, 370, 365, 264, 10919, 659, 293, 2183, 4487, 294, 39354, 293, 661, 4122], "temperature": 0.0, "avg_logprob": -0.1282879902766301, "compression_ratio": 1.5480225988700564, "no_speech_prob": 3.819958874373697e-05}, {"id": 80, "seek": 56028, "start": 575.9599999999999, "end": 583.24, "text": " that I don't have time to mention, well, this makes ADA a very great language for formal", "tokens": [300, 286, 500, 380, 362, 565, 281, 2152, 11, 731, 11, 341, 1669, 39354, 257, 588, 869, 2856, 337, 9860], "temperature": 0.0, "avg_logprob": -0.1282879902766301, "compression_ratio": 1.5480225988700564, "no_speech_prob": 3.819958874373697e-05}, {"id": 81, "seek": 58324, "start": 583.24, "end": 593.6800000000001, "text": " verification. So why should I care about Spark and I would say formal verification in general?", "tokens": [30206, 13, 407, 983, 820, 286, 1127, 466, 23424, 293, 286, 576, 584, 9860, 30206, 294, 2674, 30], "temperature": 0.0, "avg_logprob": -0.0820857516506262, "compression_ratio": 1.5224719101123596, "no_speech_prob": 4.090917718713172e-05}, {"id": 82, "seek": 58324, "start": 593.6800000000001, "end": 600.0, "text": " So with Spark, you can have mathematical proof that there is no possible vulnerabilities", "tokens": [407, 365, 23424, 11, 291, 393, 362, 18894, 8177, 300, 456, 307, 572, 1944, 37633], "temperature": 0.0, "avg_logprob": -0.0820857516506262, "compression_ratio": 1.5224719101123596, "no_speech_prob": 4.090917718713172e-05}, {"id": 83, "seek": 58324, "start": 600.0, "end": 607.28, "text": " in your application for any possible inputs. That means no buffer overflow, no division", "tokens": [294, 428, 3861, 337, 604, 1944, 15743, 13, 663, 1355, 572, 21762, 37772, 11, 572, 10044], "temperature": 0.0, "avg_logprob": -0.0820857516506262, "compression_ratio": 1.5224719101123596, "no_speech_prob": 4.090917718713172e-05}, {"id": 84, "seek": 60728, "start": 607.28, "end": 615.92, "text": " by zero, no integral overflow and so on. If you go beyond and you use contracts, you can", "tokens": [538, 4018, 11, 572, 11573, 37772, 293, 370, 322, 13, 759, 291, 352, 4399, 293, 291, 764, 13952, 11, 291, 393], "temperature": 0.0, "avg_logprob": -0.12520407570732964, "compression_ratio": 1.663594470046083, "no_speech_prob": 3.2625765015836805e-05}, {"id": 85, "seek": 60728, "start": 615.92, "end": 621.72, "text": " also prove, as I mentioned, the functional correctness. So the program does what it's", "tokens": [611, 7081, 11, 382, 286, 2835, 11, 264, 11745, 3006, 1287, 13, 407, 264, 1461, 775, 437, 309, 311], "temperature": 0.0, "avg_logprob": -0.12520407570732964, "compression_ratio": 1.663594470046083, "no_speech_prob": 3.2625765015836805e-05}, {"id": 86, "seek": 60728, "start": 621.72, "end": 627.0799999999999, "text": " supposed to do and only what it's supposed to do. And in terms, that means you can avoid", "tokens": [3442, 281, 360, 293, 787, 437, 309, 311, 3442, 281, 360, 13, 400, 294, 2115, 11, 300, 1355, 291, 393, 5042], "temperature": 0.0, "avg_logprob": -0.12520407570732964, "compression_ratio": 1.663594470046083, "no_speech_prob": 3.2625765015836805e-05}, {"id": 87, "seek": 60728, "start": 627.0799999999999, "end": 633.36, "text": " some of the testing efforts because, for instance, unit testing is more or less trying to achieve", "tokens": [512, 295, 264, 4997, 6484, 570, 11, 337, 5197, 11, 4985, 4997, 307, 544, 420, 1570, 1382, 281, 4584], "temperature": 0.0, "avg_logprob": -0.12520407570732964, "compression_ratio": 1.663594470046083, "no_speech_prob": 3.2625765015836805e-05}, {"id": 88, "seek": 63336, "start": 633.36, "end": 640.08, "text": " the same goal. So if you already have a mathematical proof that the functional correctness of your", "tokens": [264, 912, 3387, 13, 407, 498, 291, 1217, 362, 257, 18894, 8177, 300, 264, 11745, 3006, 1287, 295, 428], "temperature": 0.0, "avg_logprob": -0.13311069958830532, "compression_ratio": 1.4387755102040816, "no_speech_prob": 2.5602410460123792e-05}, {"id": 89, "seek": 63336, "start": 640.08, "end": 647.4, "text": " code, you don't need to do unit testing anymore. And so you're going to save time on that.", "tokens": [3089, 11, 291, 500, 380, 643, 281, 360, 4985, 4997, 3602, 13, 400, 370, 291, 434, 516, 281, 3155, 565, 322, 300, 13], "temperature": 0.0, "avg_logprob": -0.13311069958830532, "compression_ratio": 1.4387755102040816, "no_speech_prob": 2.5602410460123792e-05}, {"id": 90, "seek": 63336, "start": 647.4, "end": 658.32, "text": " Recently we published a case study from NVIDIA. So a few years ago, the NVIDIA security team", "tokens": [20072, 321, 6572, 257, 1389, 2979, 490, 426, 3958, 6914, 13, 407, 257, 1326, 924, 2057, 11, 264, 426, 3958, 6914, 3825, 1469], "temperature": 0.0, "avg_logprob": -0.13311069958830532, "compression_ratio": 1.4387755102040816, "no_speech_prob": 2.5602410460123792e-05}, {"id": 91, "seek": 65832, "start": 658.32, "end": 664.9200000000001, "text": " was questioning their methodology for security and how to achieve their goals in terms of", "tokens": [390, 21257, 641, 24850, 337, 3825, 293, 577, 281, 4584, 641, 5493, 294, 2115, 295], "temperature": 0.0, "avg_logprob": -0.15192222595214844, "compression_ratio": 1.6952380952380952, "no_speech_prob": 9.777266677701846e-05}, {"id": 92, "seek": 65832, "start": 664.9200000000001, "end": 671.2, "text": " security. And so they said testing security is pretty much impossible. You cannot test", "tokens": [3825, 13, 400, 370, 436, 848, 4997, 3825, 307, 1238, 709, 6243, 13, 509, 2644, 1500], "temperature": 0.0, "avg_logprob": -0.15192222595214844, "compression_ratio": 1.6952380952380952, "no_speech_prob": 9.777266677701846e-05}, {"id": 93, "seek": 65832, "start": 671.2, "end": 675.6800000000001, "text": " all possible combinations of all possible values for your application. And so they decided", "tokens": [439, 1944, 21267, 295, 439, 1944, 4190, 337, 428, 3861, 13, 400, 370, 436, 3047], "temperature": 0.0, "avg_logprob": -0.15192222595214844, "compression_ratio": 1.6952380952380952, "no_speech_prob": 9.777266677701846e-05}, {"id": 94, "seek": 65832, "start": 675.6800000000001, "end": 683.2800000000001, "text": " to try provability. And they selected Spark as an experiment. And now they are deploying", "tokens": [281, 853, 1439, 2310, 13, 400, 436, 8209, 23424, 382, 364, 5120, 13, 400, 586, 436, 366, 34198], "temperature": 0.0, "avg_logprob": -0.15192222595214844, "compression_ratio": 1.6952380952380952, "no_speech_prob": 9.777266677701846e-05}, {"id": 95, "seek": 68328, "start": 683.28, "end": 689.9599999999999, "text": " more and more Spark in the GPU. So if you get the latest, greatest NVIDIA GPU, there", "tokens": [544, 293, 544, 23424, 294, 264, 18407, 13, 407, 498, 291, 483, 264, 6792, 11, 6636, 426, 3958, 6914, 18407, 11, 456], "temperature": 0.0, "avg_logprob": -0.12766725471220822, "compression_ratio": 1.6160714285714286, "no_speech_prob": 0.00013972664601169527}, {"id": 96, "seek": 68328, "start": 689.9599999999999, "end": 699.36, "text": " should be some Spark-proven code embedded in the firmware, which lets them actually focus", "tokens": [820, 312, 512, 23424, 12, 4318, 553, 3089, 16741, 294, 264, 30289, 11, 597, 6653, 552, 767, 1879], "temperature": 0.0, "avg_logprob": -0.12766725471220822, "compression_ratio": 1.6160714285714286, "no_speech_prob": 0.00013972664601169527}, {"id": 97, "seek": 68328, "start": 699.36, "end": 708.04, "text": " on other parts of the security on more interesting verifications and more interesting properties,", "tokens": [322, 661, 3166, 295, 264, 3825, 322, 544, 1880, 1306, 7833, 293, 544, 1880, 7221, 11], "temperature": 0.0, "avg_logprob": -0.12766725471220822, "compression_ratio": 1.6160714285714286, "no_speech_prob": 0.00013972664601169527}, {"id": 98, "seek": 68328, "start": 708.04, "end": 712.68, "text": " security properties of the application. They don't have to deal with buffer overflows and", "tokens": [3825, 7221, 295, 264, 3861, 13, 814, 500, 380, 362, 281, 2028, 365, 21762, 670, 33229, 293], "temperature": 0.0, "avg_logprob": -0.12766725471220822, "compression_ratio": 1.6160714285714286, "no_speech_prob": 0.00013972664601169527}, {"id": 99, "seek": 71268, "start": 712.68, "end": 716.76, "text": " integers overflows. All the low-level stuff, it's already taken care of. And they can focus", "tokens": [41674, 670, 33229, 13, 1057, 264, 2295, 12, 12418, 1507, 11, 309, 311, 1217, 2726, 1127, 295, 13, 400, 436, 393, 1879], "temperature": 0.0, "avg_logprob": -0.2231442587716239, "compression_ratio": 1.5956521739130434, "no_speech_prob": 4.8915659135673195e-05}, {"id": 100, "seek": 71268, "start": 716.76, "end": 727.1999999999999, "text": " on more interesting points. So now let's do some proof. So for the A9 Spark programming", "tokens": [322, 544, 1880, 2793, 13, 407, 586, 718, 311, 360, 512, 8177, 13, 407, 337, 264, 316, 24, 23424, 9410], "temperature": 0.0, "avg_logprob": -0.2231442587716239, "compression_ratio": 1.5956521739130434, "no_speech_prob": 4.8915659135673195e-05}, {"id": 101, "seek": 71268, "start": 727.1999999999999, "end": 733.16, "text": " language, we have this package manager called Alire. So here are a few instructions to make", "tokens": [2856, 11, 321, 362, 341, 7372, 6598, 1219, 967, 621, 13, 407, 510, 366, 257, 1326, 9415, 281, 652], "temperature": 0.0, "avg_logprob": -0.2231442587716239, "compression_ratio": 1.5956521739130434, "no_speech_prob": 4.8915659135673195e-05}, {"id": 102, "seek": 71268, "start": 733.16, "end": 739.8, "text": " your first and prove your first piece of Spark code. So you don't know then install the package", "tokens": [428, 700, 293, 7081, 428, 700, 2522, 295, 23424, 3089, 13, 407, 291, 500, 380, 458, 550, 3625, 264, 7372], "temperature": 0.0, "avg_logprob": -0.2231442587716239, "compression_ratio": 1.5956521739130434, "no_speech_prob": 4.8915659135673195e-05}, {"id": 103, "seek": 73980, "start": 739.8, "end": 746.12, "text": " manager. So from the command line, we start by creating a project or a crate with Alire", "tokens": [6598, 13, 407, 490, 264, 5622, 1622, 11, 321, 722, 538, 4084, 257, 1716, 420, 257, 42426, 365, 967, 621], "temperature": 0.0, "avg_logprob": -0.20353467729356553, "compression_ratio": 1.5502183406113537, "no_speech_prob": 1.7188218407682143e-05}, {"id": 104, "seek": 73980, "start": 746.12, "end": 753.88, "text": " in it. We enter the directory. We add the net prove tool suite as a dependency. So it's", "tokens": [294, 309, 13, 492, 3242, 264, 21120, 13, 492, 909, 264, 2533, 7081, 2290, 14205, 382, 257, 33621, 13, 407, 309, 311], "temperature": 0.0, "avg_logprob": -0.20353467729356553, "compression_ratio": 1.5502183406113537, "no_speech_prob": 1.7188218407682143e-05}, {"id": 105, "seek": 73980, "start": 753.88, "end": 759.28, "text": " going to download everything and set it up for you. Then we write some piece of code.", "tokens": [516, 281, 5484, 1203, 293, 992, 309, 493, 337, 291, 13, 1396, 321, 2464, 512, 2522, 295, 3089, 13], "temperature": 0.0, "avg_logprob": -0.20353467729356553, "compression_ratio": 1.5502183406113537, "no_speech_prob": 1.7188218407682143e-05}, {"id": 106, "seek": 73980, "start": 759.28, "end": 769.68, "text": " So you can recognize our very nice equation here. Just for the declaration of the X constant,", "tokens": [407, 291, 393, 5521, 527, 588, 1481, 5367, 510, 13, 1449, 337, 264, 27606, 295, 264, 1783, 5754, 11], "temperature": 0.0, "avg_logprob": -0.20353467729356553, "compression_ratio": 1.5502183406113537, "no_speech_prob": 1.7188218407682143e-05}, {"id": 107, "seek": 76968, "start": 769.68, "end": 775.8399999999999, "text": " it doesn't matter what it is. I'm just taking an integer value that Spark doesn't know.", "tokens": [309, 1177, 380, 1871, 437, 309, 307, 13, 286, 478, 445, 1940, 364, 24922, 2158, 300, 23424, 1177, 380, 458, 13], "temperature": 0.0, "avg_logprob": -0.16001918635417506, "compression_ratio": 1.5638766519823788, "no_speech_prob": 3.32597664964851e-05}, {"id": 108, "seek": 76968, "start": 775.8399999999999, "end": 783.8399999999999, "text": " So just to make sure I'm not cheating or anything. We go to the console again. We run a net", "tokens": [407, 445, 281, 652, 988, 286, 478, 406, 18309, 420, 1340, 13, 492, 352, 281, 264, 11076, 797, 13, 492, 1190, 257, 2533], "temperature": 0.0, "avg_logprob": -0.16001918635417506, "compression_ratio": 1.5638766519823788, "no_speech_prob": 3.32597664964851e-05}, {"id": 109, "seek": 76968, "start": 783.8399999999999, "end": 790.28, "text": " prove. And so a net prove will tell us, well, there might be a division by zero error at", "tokens": [7081, 13, 400, 370, 257, 2533, 7081, 486, 980, 505, 11, 731, 11, 456, 1062, 312, 257, 10044, 538, 4018, 6713, 412], "temperature": 0.0, "avg_logprob": -0.16001918635417506, "compression_ratio": 1.5638766519823788, "no_speech_prob": 3.32597664964851e-05}, {"id": 110, "seek": 76968, "start": 790.28, "end": 796.56, "text": " these points. So as you can see, the message is pretty clear. Actually, it can be even", "tokens": [613, 2793, 13, 407, 382, 291, 393, 536, 11, 264, 3636, 307, 1238, 1850, 13, 5135, 11, 309, 393, 312, 754], "temperature": 0.0, "avg_logprob": -0.16001918635417506, "compression_ratio": 1.5638766519823788, "no_speech_prob": 3.32597664964851e-05}, {"id": 111, "seek": 79656, "start": 796.56, "end": 802.56, "text": " better than that because the tool can provide counter examples. So if we add the switch,", "tokens": [1101, 813, 300, 570, 264, 2290, 393, 2893, 5682, 5110, 13, 407, 498, 321, 909, 264, 3679, 11], "temperature": 0.0, "avg_logprob": -0.21651305323061737, "compression_ratio": 1.481081081081081, "no_speech_prob": 3.6912126233801246e-05}, {"id": 112, "seek": 79656, "start": 802.56, "end": 809.8399999999999, "text": " counter examples on, net prove will say division by zero might fail, for instance, when X equals", "tokens": [5682, 5110, 322, 11, 2533, 7081, 486, 584, 10044, 538, 4018, 1062, 3061, 11, 337, 5197, 11, 562, 1783, 6915], "temperature": 0.0, "avg_logprob": -0.21651305323061737, "compression_ratio": 1.481081081081081, "no_speech_prob": 3.6912126233801246e-05}, {"id": 113, "seek": 79656, "start": 809.8399999999999, "end": 819.4799999999999, "text": " 10. And so that's pretty easy to fix. We just add this if statement. And we run the tool", "tokens": [1266, 13, 400, 370, 300, 311, 1238, 1858, 281, 3191, 13, 492, 445, 909, 341, 498, 5629, 13, 400, 321, 1190, 264, 2290], "temperature": 0.0, "avg_logprob": -0.21651305323061737, "compression_ratio": 1.481081081081081, "no_speech_prob": 3.6912126233801246e-05}, {"id": 114, "seek": 81948, "start": 819.48, "end": 829.72, "text": " again. And that's it. We proved our first piece of code. So as you can see, it was easy.", "tokens": [797, 13, 400, 300, 311, 309, 13, 492, 14617, 527, 700, 2522, 295, 3089, 13, 407, 382, 291, 393, 536, 11, 309, 390, 1858, 13], "temperature": 0.0, "avg_logprob": -0.15774210905417418, "compression_ratio": 1.481283422459893, "no_speech_prob": 3.282528996351175e-05}, {"id": 115, "seek": 81948, "start": 829.72, "end": 839.12, "text": " If you want to try and learn a little bit of Spark, we have an online website. So learn.edocore.com.", "tokens": [759, 291, 528, 281, 853, 293, 1466, 257, 707, 857, 295, 23424, 11, 321, 362, 364, 2950, 3144, 13, 407, 1466, 13, 292, 905, 418, 13, 1112, 13], "temperature": 0.0, "avg_logprob": -0.15774210905417418, "compression_ratio": 1.481283422459893, "no_speech_prob": 3.282528996351175e-05}, {"id": 116, "seek": 81948, "start": 839.12, "end": 844.9200000000001, "text": " Online interactive website. So you don't even have to install what I showed before just", "tokens": [16930, 15141, 3144, 13, 407, 291, 500, 380, 754, 362, 281, 3625, 437, 286, 4712, 949, 445], "temperature": 0.0, "avg_logprob": -0.15774210905417418, "compression_ratio": 1.481283422459893, "no_speech_prob": 3.282528996351175e-05}, {"id": 117, "seek": 84492, "start": 844.92, "end": 852.56, "text": " to learn and try the tool sheets. So there's different chapters and one specific to Spark.", "tokens": [281, 1466, 293, 853, 264, 2290, 15421, 13, 407, 456, 311, 819, 20013, 293, 472, 2685, 281, 23424, 13], "temperature": 0.0, "avg_logprob": -0.16671425548952018, "compression_ratio": 1.4715909090909092, "no_speech_prob": 0.00011099633411504328}, {"id": 118, "seek": 84492, "start": 852.56, "end": 860.16, "text": " So that's one way to get started. And for those who wondered, just the piece of code", "tokens": [407, 300, 311, 472, 636, 281, 483, 1409, 13, 400, 337, 729, 567, 17055, 11, 445, 264, 2522, 295, 3089], "temperature": 0.0, "avg_logprob": -0.16671425548952018, "compression_ratio": 1.4715909090909092, "no_speech_prob": 0.00011099633411504328}, {"id": 119, "seek": 84492, "start": 860.16, "end": 867.5999999999999, "text": " before, there are seven potential bugs or errors in this one. So I'll let you as an", "tokens": [949, 11, 456, 366, 3407, 3995, 15120, 420, 13603, 294, 341, 472, 13, 407, 286, 603, 718, 291, 382, 364], "temperature": 0.0, "avg_logprob": -0.16671425548952018, "compression_ratio": 1.4715909090909092, "no_speech_prob": 0.00011099633411504328}, {"id": 120, "seek": 86760, "start": 867.6, "end": 883.4, "text": " exercise to fix this one. Thank you very much.", "tokens": [5380, 281, 3191, 341, 472, 13, 1044, 291, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.18019709587097169, "compression_ratio": 0.8518518518518519, "no_speech_prob": 0.001276979106478393}, {"id": 121, "seek": 88340, "start": 883.4, "end": 901.36, "text": " Thank you for the presentation. Let me unwrap you with a shot.", "tokens": [1044, 291, 337, 264, 5860, 13, 961, 385, 14853, 4007, 291, 365, 257, 3347, 13], "temperature": 0.0, "avg_logprob": -0.45891284942626953, "compression_ratio": 0.9253731343283582, "no_speech_prob": 0.010336541570723057}, {"id": 122, "seek": 90136, "start": 901.36, "end": 916.48, "text": " Perhaps someone might have a question about that.", "tokens": [10517, 1580, 1062, 362, 257, 1168, 466, 300, 13], "temperature": 1.0, "avg_logprob": -1.70512082026555, "compression_ratio": 0.875, "no_speech_prob": 0.004482177086174488}], "language": "en"}