{"text": " Okay, so here is a quick overview of Haskell today. I am Julien DeRos, I am an assistant professor in computer science, and I use Haskell since 2015 initially for teaching functional programming. So since the beginning of the language, Haskell has many tools that have been created for developing in Haskell, and today most of the Haskell developers use GHC compiler for building Haskell projects. We have a nice tool such as a cabal or stack. Haskell is now quite well integrated in editors such as Visual Studio Code, Veeam or Emacs, thanks to LSP implementations such as HLS, and all these tools can be installed using some tools like GHC or Nix. In this talk, I will focus on cabal with VS Code and the Haskell plugin. First, we have some online tools such as a package, which is a package archive, so you can go to the website and search for packages. There is for example some libraries for doing whatever you want. These libraries, you can access their documentation so you can see what to do with this library and how to use it, and you also have access to their source code, with nice colors and code navigation, which is quite useful. We also have Google, which is Haskell Google, so it's a search engine, and you can type the name of a function, and Google will give you a link to the documentation of that function in the package. If you don't know the name of the function, you can also type, write the type of the function, and Google try to find a function that matches that type, so you can see its documentation on the package, and you can see if it's the function you are looking for. To work on a Haskell project, you can use cabal, which is a tool for building and packaging projects. To use cabal, we have to write a cabal file, which is a configuration file, where you can specify some information about your project, and also define the target you want to build in your project. For example, if you have a library or executables, you can write them here. You can also add some dependencies, for example, libraries available on Ackage. Then you can use the cabal tool once we have this file, so we can run cabal build to build our targets. When you do that, cabal will get the dependencies from Ackage and run the compiler to build all your files. We also have the cabal run command to run specific targets, and you can also give command line arguments if your program requires that. We have a repo, which is a read-eval-print loop. This runs the compiler in interpreter mode, so you can write some Haskell expressions, and the compiler will evaluate these expressions and print the results. It's very interesting for testing some code, and you have also more specific commands. For example, here, you can ask some information about a type, a function, or anything. Okay, so to work on a Haskell project, we can use editors like Visual Studio Code with HLS and the Haskell.haskell plugin. It's a very classic tool, so you have the file of your project. You can open them, edit them. You also have code navigation and documentation, so if I put the mouse pointer over a function, VS Code will show me the documentation of that function, and if I control-click on the function, VS Code goes to the definition of the function. We also have code compression, so VS Code tries to complete the code you are typing. We have integration of the compiler, so if there is an error in your code, VS Code will show you where is this error, and it can give you the message from the compiler. Even if your code is correct, Haskell, VS Code can help you improve your code. It can give some hints to refactor it. For example, here, it says that my code is correct, but it would be better if I use the FMAP operator instead of the FMAP function. We also have HLS, which is, let's say you are writing some code, and you don't know what to write at a specific pace. You can put this underscore character, and the compiler will tell you what you'd expect at this pace. For example, here, it says that it waits for a function that takes a string and returns an int. We have an inline ripple, so you can type some Haskell expressions as commands in your code with a specific prefix. When you do that, VS Code will print a button, it will show a button, and if you click on this button, it will evaluate your expressions and add the result of these expressions in the comments below. It can be very useful for adding some examples as commands in your code for documenting the code. Speaking of documentation, we have Hadock, which is a classic tool where we write the documentation of our project as commands inside the code, and then we can run kbalhadock, and this generates the documentation as HTML5, which looks like this. As you can see, it's a tool that is used for generating the documentation on the package. Finally, we have some tools for testing our project. First of all, Haskell has a quite powerful type system, so it already prevents us from writing many errors, but we still need to test our code. We can do that with a very classic unit test. For example, here, we just write a Haskell expression with a specific input, and we call a function on that input, and we can write the value that we expect for this input. So we can write many inputs to test and test many functions, and when we run a kbalh test, this will compile our testing program and run it, and it checks that every expression is evaluated and returns the expected value. If there is a problem in one of the tests, a kbalh test will tell us which function fails. We have more than that. We can use property-based testing. Instead of giving a specific input, we can write a property, which is a function that takes an argument, and return a Boolean. This Boolean says if the property is satisfied or not. And when we do that, QuickChat will generate random inputs. Here, it says that it has generated 100 inputs, and it tests the properties on each input. If one input makes the test fail, QuickChat will try to shrink the input to the smallest value, such that it's simpler for us to debug our program. To conclude, Haskell has done some nice tools for many years. All these tools, kbalh, Ripple, QuickChat are quite old and now very mature. Since more recently, we have very nice integrations in editors like VSCode or other editors. This is quite easy to install, at least on Linux. You just have to install VSCode, VSCode, and Haskell.Haskell.Pagin, and that's it. You have a nice Haskell environment for developing your project. This slide and the culture here are available at this link. You can also see the tooling below, which presents other alternatives. If you prefer to use VIM or MX, there is a tool you can use to do that. And that's all for me. Thank you for your attention. Thank you very much, Julia. There is time for questions. Five minutes. Just shout it out and we can repeat the question. Can you please repeat the question? What is the difference between the kbalh Ripple and the GHTI, which is the Ripple from the compiler? In fact, I think it's quite the same tool. Kbalh will call the GHTI, the Ripple from the compiler. But if you project some specific dependencies or some modules, the kbalh Ripple will take all of that into account so you can inspect that code and quite more powerful. But it's the same tool at the end. Which tools do you recommend for debugging Haskell? I don't use very much the Askell debugger. The debugging in Haskell is quite different from other languages, I think. So there is a debugger where you can inspect memory or the runtime system using the compiler. It's not something that I can do very well. So I won't recommend anything. In your examples, you showed that you can have comments evaluated as a Ripple. I know Rust has something quite similar and it made sure that examples in your documentation have tests. Can you do similar sorts of things? You had an example of a Ripple evaluated in comments in your code. This one. Is that specifically the VS Code extension? I think so. It's provided by Visual Studio Code with the Askell extension and it's automatic. Yeah, Rust has this feature. The evaluator is doing the test for you. Yeah, so what is very confusing for beginners sometimes, if you come from another language like Rust or so, then it's one way to build a project. In Haskell, you have like Carbal and Nix together and then you have Carbal v1, v2, new. Is there some plan to clean this up someday to give a simple way to build a Haskell project? In fact, Carbal and Stack doesn't do exactly the same. Stack is based on snapshots, so it's more secure if you want to have the same build for every project. But both tools are compatible, so Stack can use the Carbal file, so you can just write a Carbal file, then add the version of the snapshots you want to use for Stack and that's it. But I agree with you, there are many tools. I'm not familiar with Stack, but I thought that Carbal has something like log file nowadays, like a freeze. Is that similar to that? Carbal, a freeze. Nix with Carbal, so there is a freeze with Nix, but I don't use Carbal very much. Okay, we're out of time, so please once again thank Julio.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.74, "text": " Okay, so here is a quick overview of Haskell today. I am Julien DeRos, I am an assistant", "tokens": [1033, 11, 370, 510, 307, 257, 1702, 12492, 295, 8646, 43723, 965, 13, 286, 669, 7174, 1053, 1346, 49, 329, 11, 286, 669, 364, 10994], "temperature": 0.0, "avg_logprob": -0.30220781214096964, "compression_ratio": 1.5829596412556053, "no_speech_prob": 0.09375841170549393}, {"id": 1, "seek": 0, "start": 10.74, "end": 16.02, "text": " professor in computer science, and I use Haskell since 2015 initially for teaching", "tokens": [8304, 294, 3820, 3497, 11, 293, 286, 764, 8646, 43723, 1670, 7546, 9105, 337, 4571], "temperature": 0.0, "avg_logprob": -0.30220781214096964, "compression_ratio": 1.5829596412556053, "no_speech_prob": 0.09375841170549393}, {"id": 2, "seek": 0, "start": 16.02, "end": 23.48, "text": " functional programming. So since the beginning of the language, Haskell has many tools that", "tokens": [11745, 9410, 13, 407, 1670, 264, 2863, 295, 264, 2856, 11, 8646, 43723, 575, 867, 3873, 300], "temperature": 0.0, "avg_logprob": -0.30220781214096964, "compression_ratio": 1.5829596412556053, "no_speech_prob": 0.09375841170549393}, {"id": 3, "seek": 0, "start": 23.48, "end": 29.400000000000002, "text": " have been created for developing in Haskell, and today most of the Haskell developers use", "tokens": [362, 668, 2942, 337, 6416, 294, 8646, 43723, 11, 293, 965, 881, 295, 264, 8646, 43723, 8849, 764], "temperature": 0.0, "avg_logprob": -0.30220781214096964, "compression_ratio": 1.5829596412556053, "no_speech_prob": 0.09375841170549393}, {"id": 4, "seek": 2940, "start": 29.4, "end": 34.92, "text": " GHC compiler for building Haskell projects. We have a nice tool such as a cabal or stack.", "tokens": [40690, 34, 31958, 337, 2390, 8646, 43723, 4455, 13, 492, 362, 257, 1481, 2290, 1270, 382, 257, 5487, 304, 420, 8630, 13], "temperature": 0.0, "avg_logprob": -0.25675345120364673, "compression_ratio": 1.4479166666666667, "no_speech_prob": 0.00021623245265800506}, {"id": 5, "seek": 2940, "start": 34.92, "end": 43.08, "text": " Haskell is now quite well integrated in editors such as Visual Studio Code, Veeam or Emacs,", "tokens": [8646, 43723, 307, 586, 1596, 731, 10919, 294, 31446, 1270, 382, 23187, 13500, 15549, 11, 691, 1653, 335, 420, 3968, 44937, 11], "temperature": 0.0, "avg_logprob": -0.25675345120364673, "compression_ratio": 1.4479166666666667, "no_speech_prob": 0.00021623245265800506}, {"id": 6, "seek": 2940, "start": 43.08, "end": 52.2, "text": " thanks to LSP implementations such as HLS, and all these tools can be installed using some tools", "tokens": [3231, 281, 441, 27921, 4445, 763, 1270, 382, 389, 19198, 11, 293, 439, 613, 3873, 393, 312, 8899, 1228, 512, 3873], "temperature": 0.0, "avg_logprob": -0.25675345120364673, "compression_ratio": 1.4479166666666667, "no_speech_prob": 0.00021623245265800506}, {"id": 7, "seek": 5220, "start": 52.2, "end": 60.32000000000001, "text": " like GHC or Nix. In this talk, I will focus on cabal with VS Code and the Haskell plugin.", "tokens": [411, 40690, 34, 420, 426, 970, 13, 682, 341, 751, 11, 286, 486, 1879, 322, 5487, 304, 365, 25091, 15549, 293, 264, 8646, 43723, 23407, 13], "temperature": 0.0, "avg_logprob": -0.2466785596764606, "compression_ratio": 1.439306358381503, "no_speech_prob": 0.0001445242523914203}, {"id": 8, "seek": 5220, "start": 60.32000000000001, "end": 67.32000000000001, "text": " First, we have some online tools such as a package, which is a package archive,", "tokens": [2386, 11, 321, 362, 512, 2950, 3873, 1270, 382, 257, 7372, 11, 597, 307, 257, 7372, 23507, 11], "temperature": 0.0, "avg_logprob": -0.2466785596764606, "compression_ratio": 1.439306358381503, "no_speech_prob": 0.0001445242523914203}, {"id": 9, "seek": 5220, "start": 67.32000000000001, "end": 73.36, "text": " so you can go to the website and search for packages. There is for example some", "tokens": [370, 291, 393, 352, 281, 264, 3144, 293, 3164, 337, 17401, 13, 821, 307, 337, 1365, 512], "temperature": 0.0, "avg_logprob": -0.2466785596764606, "compression_ratio": 1.439306358381503, "no_speech_prob": 0.0001445242523914203}, {"id": 10, "seek": 7336, "start": 73.36, "end": 82.36, "text": " libraries for doing whatever you want. These libraries, you can access their documentation so", "tokens": [15148, 337, 884, 2035, 291, 528, 13, 1981, 15148, 11, 291, 393, 2105, 641, 14333, 370], "temperature": 0.0, "avg_logprob": -0.2521314322948456, "compression_ratio": 1.6809815950920246, "no_speech_prob": 0.0004277848929632455}, {"id": 11, "seek": 7336, "start": 82.36, "end": 88.68, "text": " you can see what to do with this library and how to use it, and you also have access to their", "tokens": [291, 393, 536, 437, 281, 360, 365, 341, 6405, 293, 577, 281, 764, 309, 11, 293, 291, 611, 362, 2105, 281, 641], "temperature": 0.0, "avg_logprob": -0.2521314322948456, "compression_ratio": 1.6809815950920246, "no_speech_prob": 0.0004277848929632455}, {"id": 12, "seek": 7336, "start": 88.68, "end": 96.12, "text": " source code, with nice colors and code navigation, which is quite useful. We also have", "tokens": [4009, 3089, 11, 365, 1481, 4577, 293, 3089, 17346, 11, 597, 307, 1596, 4420, 13, 492, 611, 362], "temperature": 0.0, "avg_logprob": -0.2521314322948456, "compression_ratio": 1.6809815950920246, "no_speech_prob": 0.0004277848929632455}, {"id": 13, "seek": 9612, "start": 96.12, "end": 103.16000000000001, "text": " Google, which is Haskell Google, so it's a search engine, and you can type the name of a function,", "tokens": [3329, 11, 597, 307, 8646, 43723, 3329, 11, 370, 309, 311, 257, 3164, 2848, 11, 293, 291, 393, 2010, 264, 1315, 295, 257, 2445, 11], "temperature": 0.0, "avg_logprob": -0.2091760340425157, "compression_ratio": 1.9396984924623115, "no_speech_prob": 0.00018107840151060373}, {"id": 14, "seek": 9612, "start": 103.16000000000001, "end": 109.52000000000001, "text": " and Google will give you a link to the documentation of that function in the package. If you don't", "tokens": [293, 3329, 486, 976, 291, 257, 2113, 281, 264, 14333, 295, 300, 2445, 294, 264, 7372, 13, 759, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.2091760340425157, "compression_ratio": 1.9396984924623115, "no_speech_prob": 0.00018107840151060373}, {"id": 15, "seek": 9612, "start": 109.52000000000001, "end": 115.48, "text": " know the name of the function, you can also type, write the type of the function, and Google", "tokens": [458, 264, 1315, 295, 264, 2445, 11, 291, 393, 611, 2010, 11, 2464, 264, 2010, 295, 264, 2445, 11, 293, 3329], "temperature": 0.0, "avg_logprob": -0.2091760340425157, "compression_ratio": 1.9396984924623115, "no_speech_prob": 0.00018107840151060373}, {"id": 16, "seek": 9612, "start": 115.48, "end": 121.4, "text": " try to find a function that matches that type, so you can see its documentation on the package,", "tokens": [853, 281, 915, 257, 2445, 300, 10676, 300, 2010, 11, 370, 291, 393, 536, 1080, 14333, 322, 264, 7372, 11], "temperature": 0.0, "avg_logprob": -0.2091760340425157, "compression_ratio": 1.9396984924623115, "no_speech_prob": 0.00018107840151060373}, {"id": 17, "seek": 12140, "start": 121.4, "end": 129.28, "text": " and you can see if it's the function you are looking for. To work on a Haskell project,", "tokens": [293, 291, 393, 536, 498, 309, 311, 264, 2445, 291, 366, 1237, 337, 13, 1407, 589, 322, 257, 8646, 43723, 1716, 11], "temperature": 0.0, "avg_logprob": -0.16724423144726044, "compression_ratio": 1.732394366197183, "no_speech_prob": 0.00020454828336369246}, {"id": 18, "seek": 12140, "start": 129.28, "end": 138.12, "text": " you can use cabal, which is a tool for building and packaging projects. To use cabal, we have", "tokens": [291, 393, 764, 5487, 304, 11, 597, 307, 257, 2290, 337, 2390, 293, 16836, 4455, 13, 1407, 764, 5487, 304, 11, 321, 362], "temperature": 0.0, "avg_logprob": -0.16724423144726044, "compression_ratio": 1.732394366197183, "no_speech_prob": 0.00020454828336369246}, {"id": 19, "seek": 12140, "start": 138.12, "end": 145.20000000000002, "text": " to write a cabal file, which is a configuration file, where you can specify some information", "tokens": [281, 2464, 257, 5487, 304, 3991, 11, 597, 307, 257, 11694, 3991, 11, 689, 291, 393, 16500, 512, 1589], "temperature": 0.0, "avg_logprob": -0.16724423144726044, "compression_ratio": 1.732394366197183, "no_speech_prob": 0.00020454828336369246}, {"id": 20, "seek": 12140, "start": 145.20000000000002, "end": 150.92000000000002, "text": " about your project, and also define the target you want to build in your project. For example,", "tokens": [466, 428, 1716, 11, 293, 611, 6964, 264, 3779, 291, 528, 281, 1322, 294, 428, 1716, 13, 1171, 1365, 11], "temperature": 0.0, "avg_logprob": -0.16724423144726044, "compression_ratio": 1.732394366197183, "no_speech_prob": 0.00020454828336369246}, {"id": 21, "seek": 15092, "start": 150.92, "end": 156.04, "text": " if you have a library or executables, you can write them here. You can also add some", "tokens": [498, 291, 362, 257, 6405, 420, 7568, 2965, 11, 291, 393, 2464, 552, 510, 13, 509, 393, 611, 909, 512], "temperature": 0.0, "avg_logprob": -0.22623023166451403, "compression_ratio": 1.726829268292683, "no_speech_prob": 0.00013741983275394887}, {"id": 22, "seek": 15092, "start": 156.04, "end": 163.23999999999998, "text": " dependencies, for example, libraries available on Ackage. Then you can use the cabal tool", "tokens": [36606, 11, 337, 1365, 11, 15148, 2435, 322, 316, 547, 609, 13, 1396, 291, 393, 764, 264, 5487, 304, 2290], "temperature": 0.0, "avg_logprob": -0.22623023166451403, "compression_ratio": 1.726829268292683, "no_speech_prob": 0.00013741983275394887}, {"id": 23, "seek": 15092, "start": 163.23999999999998, "end": 171.35999999999999, "text": " once we have this file, so we can run cabal build to build our targets. When you do that,", "tokens": [1564, 321, 362, 341, 3991, 11, 370, 321, 393, 1190, 5487, 304, 1322, 281, 1322, 527, 12911, 13, 1133, 291, 360, 300, 11], "temperature": 0.0, "avg_logprob": -0.22623023166451403, "compression_ratio": 1.726829268292683, "no_speech_prob": 0.00013741983275394887}, {"id": 24, "seek": 15092, "start": 171.35999999999999, "end": 178.23999999999998, "text": " cabal will get the dependencies from Ackage and run the compiler to build all your files.", "tokens": [5487, 304, 486, 483, 264, 36606, 490, 316, 547, 609, 293, 1190, 264, 31958, 281, 1322, 439, 428, 7098, 13], "temperature": 0.0, "avg_logprob": -0.22623023166451403, "compression_ratio": 1.726829268292683, "no_speech_prob": 0.00013741983275394887}, {"id": 25, "seek": 17824, "start": 178.24, "end": 184.36, "text": " We also have the cabal run command to run specific targets, and you can also give command", "tokens": [492, 611, 362, 264, 5487, 304, 1190, 5622, 281, 1190, 2685, 12911, 11, 293, 291, 393, 611, 976, 5622], "temperature": 0.0, "avg_logprob": -0.17668588771376498, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00020896254864055663}, {"id": 26, "seek": 17824, "start": 184.36, "end": 191.4, "text": " line arguments if your program requires that. We have a repo, which is a read-eval-print", "tokens": [1622, 12869, 498, 428, 1461, 7029, 300, 13, 492, 362, 257, 49040, 11, 597, 307, 257, 1401, 12, 68, 3337, 12, 14030], "temperature": 0.0, "avg_logprob": -0.17668588771376498, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00020896254864055663}, {"id": 27, "seek": 17824, "start": 191.4, "end": 197.44, "text": " loop. This runs the compiler in interpreter mode, so you can write some Haskell expressions,", "tokens": [6367, 13, 639, 6676, 264, 31958, 294, 34132, 4391, 11, 370, 291, 393, 2464, 512, 8646, 43723, 15277, 11], "temperature": 0.0, "avg_logprob": -0.17668588771376498, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00020896254864055663}, {"id": 28, "seek": 17824, "start": 197.44, "end": 203.76000000000002, "text": " and the compiler will evaluate these expressions and print the results. It's very interesting", "tokens": [293, 264, 31958, 486, 13059, 613, 15277, 293, 4482, 264, 3542, 13, 467, 311, 588, 1880], "temperature": 0.0, "avg_logprob": -0.17668588771376498, "compression_ratio": 1.6441441441441442, "no_speech_prob": 0.00020896254864055663}, {"id": 29, "seek": 20376, "start": 203.76, "end": 210.28, "text": " for testing some code, and you have also more specific commands. For example, here,", "tokens": [337, 4997, 512, 3089, 11, 293, 291, 362, 611, 544, 2685, 16901, 13, 1171, 1365, 11, 510, 11], "temperature": 0.0, "avg_logprob": -0.24702535673629405, "compression_ratio": 1.4724770642201834, "no_speech_prob": 0.0001835907023632899}, {"id": 30, "seek": 20376, "start": 210.28, "end": 214.95999999999998, "text": " you can ask some information about a type, a function, or anything.", "tokens": [291, 393, 1029, 512, 1589, 466, 257, 2010, 11, 257, 2445, 11, 420, 1340, 13], "temperature": 0.0, "avg_logprob": -0.24702535673629405, "compression_ratio": 1.4724770642201834, "no_speech_prob": 0.0001835907023632899}, {"id": 31, "seek": 20376, "start": 214.95999999999998, "end": 221.28, "text": " Okay, so to work on a Haskell project, we can use editors like Visual Studio Code with", "tokens": [1033, 11, 370, 281, 589, 322, 257, 8646, 43723, 1716, 11, 321, 393, 764, 31446, 411, 23187, 13500, 15549, 365], "temperature": 0.0, "avg_logprob": -0.24702535673629405, "compression_ratio": 1.4724770642201834, "no_speech_prob": 0.0001835907023632899}, {"id": 32, "seek": 20376, "start": 221.28, "end": 227.79999999999998, "text": " HLS and the Haskell.haskell plugin. It's a very classic tool, so you have the file", "tokens": [389, 19198, 293, 264, 8646, 43723, 13, 12438, 43723, 23407, 13, 467, 311, 257, 588, 7230, 2290, 11, 370, 291, 362, 264, 3991], "temperature": 0.0, "avg_logprob": -0.24702535673629405, "compression_ratio": 1.4724770642201834, "no_speech_prob": 0.0001835907023632899}, {"id": 33, "seek": 22780, "start": 227.8, "end": 234.76000000000002, "text": " of your project. You can open them, edit them. You also have code navigation and documentation,", "tokens": [295, 428, 1716, 13, 509, 393, 1269, 552, 11, 8129, 552, 13, 509, 611, 362, 3089, 17346, 293, 14333, 11], "temperature": 0.0, "avg_logprob": -0.1376836053256331, "compression_ratio": 1.836734693877551, "no_speech_prob": 4.641450505005196e-05}, {"id": 34, "seek": 22780, "start": 234.76000000000002, "end": 244.04000000000002, "text": " so if I put the mouse pointer over a function, VS Code will show me the documentation of", "tokens": [370, 498, 286, 829, 264, 9719, 23918, 670, 257, 2445, 11, 25091, 15549, 486, 855, 385, 264, 14333, 295], "temperature": 0.0, "avg_logprob": -0.1376836053256331, "compression_ratio": 1.836734693877551, "no_speech_prob": 4.641450505005196e-05}, {"id": 35, "seek": 22780, "start": 244.04000000000002, "end": 249.04000000000002, "text": " that function, and if I control-click on the function, VS Code goes to the definition", "tokens": [300, 2445, 11, 293, 498, 286, 1969, 12, 18548, 322, 264, 2445, 11, 25091, 15549, 1709, 281, 264, 7123], "temperature": 0.0, "avg_logprob": -0.1376836053256331, "compression_ratio": 1.836734693877551, "no_speech_prob": 4.641450505005196e-05}, {"id": 36, "seek": 22780, "start": 249.04000000000002, "end": 255.20000000000002, "text": " of the function. We also have code compression, so VS Code tries to complete the code you", "tokens": [295, 264, 2445, 13, 492, 611, 362, 3089, 19355, 11, 370, 25091, 15549, 9898, 281, 3566, 264, 3089, 291], "temperature": 0.0, "avg_logprob": -0.1376836053256331, "compression_ratio": 1.836734693877551, "no_speech_prob": 4.641450505005196e-05}, {"id": 37, "seek": 25520, "start": 255.2, "end": 264.36, "text": " are typing. We have integration of the compiler, so if there is an error in your code, VS", "tokens": [366, 18444, 13, 492, 362, 10980, 295, 264, 31958, 11, 370, 498, 456, 307, 364, 6713, 294, 428, 3089, 11, 25091], "temperature": 0.0, "avg_logprob": -0.15612732095921295, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.0002082671708194539}, {"id": 38, "seek": 25520, "start": 264.36, "end": 271.12, "text": " Code will show you where is this error, and it can give you the message from the compiler.", "tokens": [15549, 486, 855, 291, 689, 307, 341, 6713, 11, 293, 309, 393, 976, 291, 264, 3636, 490, 264, 31958, 13], "temperature": 0.0, "avg_logprob": -0.15612732095921295, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.0002082671708194539}, {"id": 39, "seek": 25520, "start": 271.12, "end": 277.28, "text": " Even if your code is correct, Haskell, VS Code can help you improve your code. It can", "tokens": [2754, 498, 428, 3089, 307, 3006, 11, 8646, 43723, 11, 25091, 15549, 393, 854, 291, 3470, 428, 3089, 13, 467, 393], "temperature": 0.0, "avg_logprob": -0.15612732095921295, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.0002082671708194539}, {"id": 40, "seek": 25520, "start": 277.28, "end": 284.76, "text": " give some hints to refactor it. For example, here, it says that my code is correct, but", "tokens": [976, 512, 27271, 281, 1895, 15104, 309, 13, 1171, 1365, 11, 510, 11, 309, 1619, 300, 452, 3089, 307, 3006, 11, 457], "temperature": 0.0, "avg_logprob": -0.15612732095921295, "compression_ratio": 1.669811320754717, "no_speech_prob": 0.0002082671708194539}, {"id": 41, "seek": 28476, "start": 284.76, "end": 291.24, "text": " it would be better if I use the FMAP operator instead of the FMAP function. We also have", "tokens": [309, 576, 312, 1101, 498, 286, 764, 264, 29614, 4715, 12973, 2602, 295, 264, 29614, 4715, 2445, 13, 492, 611, 362], "temperature": 0.0, "avg_logprob": -0.1832734777572307, "compression_ratio": 1.5213675213675213, "no_speech_prob": 0.00021255579486023635}, {"id": 42, "seek": 28476, "start": 291.24, "end": 297.12, "text": " HLS, which is, let's say you are writing some code, and you don't know what to write at", "tokens": [389, 19198, 11, 597, 307, 11, 718, 311, 584, 291, 366, 3579, 512, 3089, 11, 293, 291, 500, 380, 458, 437, 281, 2464, 412], "temperature": 0.0, "avg_logprob": -0.1832734777572307, "compression_ratio": 1.5213675213675213, "no_speech_prob": 0.00021255579486023635}, {"id": 43, "seek": 28476, "start": 297.12, "end": 303.28, "text": " a specific pace. You can put this underscore character, and the compiler will tell you what", "tokens": [257, 2685, 11638, 13, 509, 393, 829, 341, 37556, 2517, 11, 293, 264, 31958, 486, 980, 291, 437], "temperature": 0.0, "avg_logprob": -0.1832734777572307, "compression_ratio": 1.5213675213675213, "no_speech_prob": 0.00021255579486023635}, {"id": 44, "seek": 28476, "start": 303.28, "end": 308.36, "text": " you'd expect at this pace. For example, here, it says that it waits for a function that", "tokens": [291, 1116, 2066, 412, 341, 11638, 13, 1171, 1365, 11, 510, 11, 309, 1619, 300, 309, 40597, 337, 257, 2445, 300], "temperature": 0.0, "avg_logprob": -0.1832734777572307, "compression_ratio": 1.5213675213675213, "no_speech_prob": 0.00021255579486023635}, {"id": 45, "seek": 30836, "start": 308.36, "end": 317.40000000000003, "text": " takes a string and returns an int. We have an inline ripple, so you can type some Haskell", "tokens": [2516, 257, 6798, 293, 11247, 364, 560, 13, 492, 362, 364, 294, 1889, 40688, 11, 370, 291, 393, 2010, 512, 8646, 43723], "temperature": 0.0, "avg_logprob": -0.23295934012766634, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00013543968088924885}, {"id": 46, "seek": 30836, "start": 317.40000000000003, "end": 323.8, "text": " expressions as commands in your code with a specific prefix. When you do that, VS Code", "tokens": [15277, 382, 16901, 294, 428, 3089, 365, 257, 2685, 46969, 13, 1133, 291, 360, 300, 11, 25091, 15549], "temperature": 0.0, "avg_logprob": -0.23295934012766634, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00013543968088924885}, {"id": 47, "seek": 30836, "start": 323.8, "end": 329.16, "text": " will print a button, it will show a button, and if you click on this button, it will evaluate", "tokens": [486, 4482, 257, 2960, 11, 309, 486, 855, 257, 2960, 11, 293, 498, 291, 2052, 322, 341, 2960, 11, 309, 486, 13059], "temperature": 0.0, "avg_logprob": -0.23295934012766634, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00013543968088924885}, {"id": 48, "seek": 30836, "start": 329.16, "end": 336.8, "text": " your expressions and add the result of these expressions in the comments below. It can be", "tokens": [428, 15277, 293, 909, 264, 1874, 295, 613, 15277, 294, 264, 3053, 2507, 13, 467, 393, 312], "temperature": 0.0, "avg_logprob": -0.23295934012766634, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00013543968088924885}, {"id": 49, "seek": 33680, "start": 336.8, "end": 344.84000000000003, "text": " very useful for adding some examples as commands in your code for documenting the code.", "tokens": [588, 4420, 337, 5127, 512, 5110, 382, 16901, 294, 428, 3089, 337, 42360, 264, 3089, 13], "temperature": 0.0, "avg_logprob": -0.25519868697243175, "compression_ratio": 1.6857142857142857, "no_speech_prob": 0.00011800638458225876}, {"id": 50, "seek": 33680, "start": 344.84000000000003, "end": 348.64, "text": " Speaking of documentation, we have Hadock, which is a classic tool where we write the", "tokens": [13069, 295, 14333, 11, 321, 362, 389, 1573, 547, 11, 597, 307, 257, 7230, 2290, 689, 321, 2464, 264], "temperature": 0.0, "avg_logprob": -0.25519868697243175, "compression_ratio": 1.6857142857142857, "no_speech_prob": 0.00011800638458225876}, {"id": 51, "seek": 33680, "start": 348.64, "end": 356.84000000000003, "text": " documentation of our project as commands inside the code, and then we can run kbalhadock,", "tokens": [14333, 295, 527, 1716, 382, 16901, 1854, 264, 3089, 11, 293, 550, 321, 393, 1190, 350, 2645, 71, 1573, 547, 11], "temperature": 0.0, "avg_logprob": -0.25519868697243175, "compression_ratio": 1.6857142857142857, "no_speech_prob": 0.00011800638458225876}, {"id": 52, "seek": 33680, "start": 356.84000000000003, "end": 362.6, "text": " and this generates the documentation as HTML5, which looks like this. As you can see, it's", "tokens": [293, 341, 23815, 264, 14333, 382, 17995, 20, 11, 597, 1542, 411, 341, 13, 1018, 291, 393, 536, 11, 309, 311], "temperature": 0.0, "avg_logprob": -0.25519868697243175, "compression_ratio": 1.6857142857142857, "no_speech_prob": 0.00011800638458225876}, {"id": 53, "seek": 36260, "start": 362.6, "end": 370.0, "text": " a tool that is used for generating the documentation on the package. Finally, we have some tools", "tokens": [257, 2290, 300, 307, 1143, 337, 17746, 264, 14333, 322, 264, 7372, 13, 6288, 11, 321, 362, 512, 3873], "temperature": 0.0, "avg_logprob": -0.1593735376993815, "compression_ratio": 1.5811965811965811, "no_speech_prob": 7.3757313657552e-05}, {"id": 54, "seek": 36260, "start": 370.0, "end": 377.64000000000004, "text": " for testing our project. First of all, Haskell has a quite powerful type system, so it already", "tokens": [337, 4997, 527, 1716, 13, 2386, 295, 439, 11, 8646, 43723, 575, 257, 1596, 4005, 2010, 1185, 11, 370, 309, 1217], "temperature": 0.0, "avg_logprob": -0.1593735376993815, "compression_ratio": 1.5811965811965811, "no_speech_prob": 7.3757313657552e-05}, {"id": 55, "seek": 36260, "start": 377.64000000000004, "end": 383.28000000000003, "text": " prevents us from writing many errors, but we still need to test our code. We can do that", "tokens": [22367, 505, 490, 3579, 867, 13603, 11, 457, 321, 920, 643, 281, 1500, 527, 3089, 13, 492, 393, 360, 300], "temperature": 0.0, "avg_logprob": -0.1593735376993815, "compression_ratio": 1.5811965811965811, "no_speech_prob": 7.3757313657552e-05}, {"id": 56, "seek": 36260, "start": 383.28000000000003, "end": 388.0, "text": " with a very classic unit test. For example, here, we just write a Haskell expression with", "tokens": [365, 257, 588, 7230, 4985, 1500, 13, 1171, 1365, 11, 510, 11, 321, 445, 2464, 257, 8646, 43723, 6114, 365], "temperature": 0.0, "avg_logprob": -0.1593735376993815, "compression_ratio": 1.5811965811965811, "no_speech_prob": 7.3757313657552e-05}, {"id": 57, "seek": 38800, "start": 388.0, "end": 394.92, "text": " a specific input, and we call a function on that input, and we can write the value that", "tokens": [257, 2685, 4846, 11, 293, 321, 818, 257, 2445, 322, 300, 4846, 11, 293, 321, 393, 2464, 264, 2158, 300], "temperature": 0.0, "avg_logprob": -0.16214056448502975, "compression_ratio": 1.8121827411167513, "no_speech_prob": 0.0001199043108499609}, {"id": 58, "seek": 38800, "start": 394.92, "end": 402.92, "text": " we expect for this input. So we can write many inputs to test and test many functions,", "tokens": [321, 2066, 337, 341, 4846, 13, 407, 321, 393, 2464, 867, 15743, 281, 1500, 293, 1500, 867, 6828, 11], "temperature": 0.0, "avg_logprob": -0.16214056448502975, "compression_ratio": 1.8121827411167513, "no_speech_prob": 0.0001199043108499609}, {"id": 59, "seek": 38800, "start": 402.92, "end": 409.52, "text": " and when we run a kbalh test, this will compile our testing program and run it, and it checks", "tokens": [293, 562, 321, 1190, 257, 350, 2645, 71, 1500, 11, 341, 486, 31413, 527, 4997, 1461, 293, 1190, 309, 11, 293, 309, 13834], "temperature": 0.0, "avg_logprob": -0.16214056448502975, "compression_ratio": 1.8121827411167513, "no_speech_prob": 0.0001199043108499609}, {"id": 60, "seek": 38800, "start": 409.52, "end": 417.28, "text": " that every expression is evaluated and returns the expected value. If there is a problem", "tokens": [300, 633, 6114, 307, 25509, 293, 11247, 264, 5176, 2158, 13, 759, 456, 307, 257, 1154], "temperature": 0.0, "avg_logprob": -0.16214056448502975, "compression_ratio": 1.8121827411167513, "no_speech_prob": 0.0001199043108499609}, {"id": 61, "seek": 41728, "start": 417.28, "end": 426.71999999999997, "text": " in one of the tests, a kbalh test will tell us which function fails. We have more than", "tokens": [294, 472, 295, 264, 6921, 11, 257, 350, 2645, 71, 1500, 486, 980, 505, 597, 2445, 18199, 13, 492, 362, 544, 813], "temperature": 0.0, "avg_logprob": -0.2094106674194336, "compression_ratio": 1.5874439461883407, "no_speech_prob": 8.406378037761897e-05}, {"id": 62, "seek": 41728, "start": 426.71999999999997, "end": 433.4, "text": " that. We can use property-based testing. Instead of giving a specific input, we can write a", "tokens": [300, 13, 492, 393, 764, 4707, 12, 6032, 4997, 13, 7156, 295, 2902, 257, 2685, 4846, 11, 321, 393, 2464, 257], "temperature": 0.0, "avg_logprob": -0.2094106674194336, "compression_ratio": 1.5874439461883407, "no_speech_prob": 8.406378037761897e-05}, {"id": 63, "seek": 41728, "start": 433.4, "end": 437.47999999999996, "text": " property, which is a function that takes an argument, and return a Boolean. This Boolean", "tokens": [4707, 11, 597, 307, 257, 2445, 300, 2516, 364, 6770, 11, 293, 2736, 257, 23351, 28499, 13, 639, 23351, 28499], "temperature": 0.0, "avg_logprob": -0.2094106674194336, "compression_ratio": 1.5874439461883407, "no_speech_prob": 8.406378037761897e-05}, {"id": 64, "seek": 41728, "start": 437.47999999999996, "end": 443.47999999999996, "text": " says if the property is satisfied or not. And when we do that, QuickChat will generate", "tokens": [1619, 498, 264, 4707, 307, 11239, 420, 406, 13, 400, 562, 321, 360, 300, 11, 12101, 41683, 486, 8460], "temperature": 0.0, "avg_logprob": -0.2094106674194336, "compression_ratio": 1.5874439461883407, "no_speech_prob": 8.406378037761897e-05}, {"id": 65, "seek": 44348, "start": 443.48, "end": 450.48, "text": " random inputs. Here, it says that it has generated 100 inputs, and it tests the properties on", "tokens": [4974, 15743, 13, 1692, 11, 309, 1619, 300, 309, 575, 10833, 2319, 15743, 11, 293, 309, 6921, 264, 7221, 322], "temperature": 0.0, "avg_logprob": -0.2221173197031021, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.00025766403996385634}, {"id": 66, "seek": 44348, "start": 450.48, "end": 459.48, "text": " each input. If one input makes the test fail, QuickChat will try to shrink the input to the", "tokens": [1184, 4846, 13, 759, 472, 4846, 1669, 264, 1500, 3061, 11, 12101, 41683, 486, 853, 281, 23060, 264, 4846, 281, 264], "temperature": 0.0, "avg_logprob": -0.2221173197031021, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.00025766403996385634}, {"id": 67, "seek": 44348, "start": 459.48, "end": 467.48, "text": " smallest value, such that it's simpler for us to debug our program.", "tokens": [16998, 2158, 11, 1270, 300, 309, 311, 18587, 337, 505, 281, 24083, 527, 1461, 13], "temperature": 0.0, "avg_logprob": -0.2221173197031021, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.00025766403996385634}, {"id": 68, "seek": 46748, "start": 467.48, "end": 473.48, "text": " To conclude, Haskell has done some nice tools for many years. All these tools, kbalh, Ripple,", "tokens": [1407, 16886, 11, 8646, 43723, 575, 1096, 512, 1481, 3873, 337, 867, 924, 13, 1057, 613, 3873, 11, 350, 2645, 71, 11, 497, 23476, 11], "temperature": 0.0, "avg_logprob": -0.33719906983552156, "compression_ratio": 1.5726495726495726, "no_speech_prob": 0.000286117778159678}, {"id": 69, "seek": 46748, "start": 473.48, "end": 480.08000000000004, "text": " QuickChat are quite old and now very mature. Since more recently, we have very nice integrations", "tokens": [12101, 41683, 366, 1596, 1331, 293, 586, 588, 14442, 13, 4162, 544, 3938, 11, 321, 362, 588, 1481, 3572, 763], "temperature": 0.0, "avg_logprob": -0.33719906983552156, "compression_ratio": 1.5726495726495726, "no_speech_prob": 0.000286117778159678}, {"id": 70, "seek": 46748, "start": 480.08000000000004, "end": 488.08000000000004, "text": " in editors like VSCode or other editors. This is quite easy to install, at least on Linux.", "tokens": [294, 31446, 411, 691, 20839, 1429, 420, 661, 31446, 13, 639, 307, 1596, 1858, 281, 3625, 11, 412, 1935, 322, 18734, 13], "temperature": 0.0, "avg_logprob": -0.33719906983552156, "compression_ratio": 1.5726495726495726, "no_speech_prob": 0.000286117778159678}, {"id": 71, "seek": 46748, "start": 488.08000000000004, "end": 493.32, "text": " You just have to install VSCode, VSCode, and Haskell.Haskell.Pagin, and that's it. You", "tokens": [509, 445, 362, 281, 3625, 691, 20839, 1429, 11, 691, 20839, 1429, 11, 293, 8646, 43723, 13, 39, 296, 43723, 13, 47, 559, 259, 11, 293, 300, 311, 309, 13, 509], "temperature": 0.0, "avg_logprob": -0.33719906983552156, "compression_ratio": 1.5726495726495726, "no_speech_prob": 0.000286117778159678}, {"id": 72, "seek": 49332, "start": 493.32, "end": 500.32, "text": " have a nice Haskell environment for developing your project. This slide and the culture here", "tokens": [362, 257, 1481, 8646, 43723, 2823, 337, 6416, 428, 1716, 13, 639, 4137, 293, 264, 3713, 510], "temperature": 0.0, "avg_logprob": -0.2792618989944458, "compression_ratio": 1.483568075117371, "no_speech_prob": 0.0005137475091032684}, {"id": 73, "seek": 49332, "start": 500.32, "end": 508.32, "text": " are available at this link. You can also see the tooling below, which presents other alternatives.", "tokens": [366, 2435, 412, 341, 2113, 13, 509, 393, 611, 536, 264, 46593, 2507, 11, 597, 13533, 661, 20478, 13], "temperature": 0.0, "avg_logprob": -0.2792618989944458, "compression_ratio": 1.483568075117371, "no_speech_prob": 0.0005137475091032684}, {"id": 74, "seek": 49332, "start": 508.32, "end": 516.3199999999999, "text": " If you prefer to use VIM or MX, there is a tool you can use to do that. And that's all", "tokens": [759, 291, 4382, 281, 764, 691, 6324, 420, 47509, 11, 456, 307, 257, 2290, 291, 393, 764, 281, 360, 300, 13, 400, 300, 311, 439], "temperature": 0.0, "avg_logprob": -0.2792618989944458, "compression_ratio": 1.483568075117371, "no_speech_prob": 0.0005137475091032684}, {"id": 75, "seek": 49332, "start": 516.3199999999999, "end": 518.3199999999999, "text": " for me. Thank you for your attention.", "tokens": [337, 385, 13, 1044, 291, 337, 428, 3202, 13], "temperature": 0.0, "avg_logprob": -0.2792618989944458, "compression_ratio": 1.483568075117371, "no_speech_prob": 0.0005137475091032684}, {"id": 76, "seek": 51832, "start": 518.32, "end": 533.32, "text": " Thank you very much, Julia. There is time for questions. Five minutes. Just shout it out", "tokens": [1044, 291, 588, 709, 11, 18551, 13, 821, 307, 565, 337, 1651, 13, 9436, 2077, 13, 1449, 8043, 309, 484], "temperature": 0.0, "avg_logprob": -0.19593013416637073, "compression_ratio": 1.1764705882352942, "no_speech_prob": 0.0017459321534261107}, {"id": 77, "seek": 51832, "start": 533.32, "end": 535.32, "text": " and we can repeat the question.", "tokens": [293, 321, 393, 7149, 264, 1168, 13], "temperature": 0.0, "avg_logprob": -0.19593013416637073, "compression_ratio": 1.1764705882352942, "no_speech_prob": 0.0017459321534261107}, {"id": 78, "seek": 53532, "start": 535.32, "end": 550.32, "text": " Can you please repeat the question?", "tokens": [1664, 291, 1767, 7149, 264, 1168, 30], "temperature": 0.0, "avg_logprob": -0.19433631002902985, "compression_ratio": 1.4304635761589404, "no_speech_prob": 0.005825233180075884}, {"id": 79, "seek": 53532, "start": 550.32, "end": 555.32, "text": " What is the difference between the kbalh Ripple and the GHTI, which is the Ripple from the", "tokens": [708, 307, 264, 2649, 1296, 264, 350, 2645, 71, 497, 23476, 293, 264, 40690, 5422, 11, 597, 307, 264, 497, 23476, 490, 264], "temperature": 0.0, "avg_logprob": -0.19433631002902985, "compression_ratio": 1.4304635761589404, "no_speech_prob": 0.005825233180075884}, {"id": 80, "seek": 53532, "start": 555.32, "end": 562.32, "text": " compiler? In fact, I think it's quite the same tool. Kbalh will call the GHTI, the Ripple", "tokens": [31958, 30, 682, 1186, 11, 286, 519, 309, 311, 1596, 264, 912, 2290, 13, 591, 2645, 71, 486, 818, 264, 40690, 5422, 11, 264, 497, 23476], "temperature": 0.0, "avg_logprob": -0.19433631002902985, "compression_ratio": 1.4304635761589404, "no_speech_prob": 0.005825233180075884}, {"id": 81, "seek": 56232, "start": 562.32, "end": 569.32, "text": " from the compiler. But if you project some specific dependencies or some modules, the", "tokens": [490, 264, 31958, 13, 583, 498, 291, 1716, 512, 2685, 36606, 420, 512, 16679, 11, 264], "temperature": 0.0, "avg_logprob": -0.15048079559768457, "compression_ratio": 1.46524064171123, "no_speech_prob": 0.0008374426979571581}, {"id": 82, "seek": 56232, "start": 569.32, "end": 574.32, "text": " kbalh Ripple will take all of that into account so you can inspect that code and quite more", "tokens": [350, 2645, 71, 497, 23476, 486, 747, 439, 295, 300, 666, 2696, 370, 291, 393, 15018, 300, 3089, 293, 1596, 544], "temperature": 0.0, "avg_logprob": -0.15048079559768457, "compression_ratio": 1.46524064171123, "no_speech_prob": 0.0008374426979571581}, {"id": 83, "seek": 56232, "start": 574.32, "end": 585.32, "text": " powerful. But it's the same tool at the end.", "tokens": [4005, 13, 583, 309, 311, 264, 912, 2290, 412, 264, 917, 13], "temperature": 0.0, "avg_logprob": -0.15048079559768457, "compression_ratio": 1.46524064171123, "no_speech_prob": 0.0008374426979571581}, {"id": 84, "seek": 56232, "start": 585.32, "end": 590.32, "text": " Which tools do you recommend for debugging Haskell?", "tokens": [3013, 3873, 360, 291, 2748, 337, 45592, 8646, 43723, 30], "temperature": 0.0, "avg_logprob": -0.15048079559768457, "compression_ratio": 1.46524064171123, "no_speech_prob": 0.0008374426979571581}, {"id": 85, "seek": 59032, "start": 590.32, "end": 596.32, "text": " I don't use very much the Askell debugger. The debugging in Haskell is quite different", "tokens": [286, 500, 380, 764, 588, 709, 264, 1018, 43723, 24083, 1321, 13, 440, 45592, 294, 8646, 43723, 307, 1596, 819], "temperature": 0.0, "avg_logprob": -0.20067813579852764, "compression_ratio": 1.4739884393063585, "no_speech_prob": 0.0005508160684257746}, {"id": 86, "seek": 59032, "start": 596.32, "end": 605.32, "text": " from other languages, I think. So there is a debugger where you can inspect memory or", "tokens": [490, 661, 8650, 11, 286, 519, 13, 407, 456, 307, 257, 24083, 1321, 689, 291, 393, 15018, 4675, 420], "temperature": 0.0, "avg_logprob": -0.20067813579852764, "compression_ratio": 1.4739884393063585, "no_speech_prob": 0.0005508160684257746}, {"id": 87, "seek": 59032, "start": 605.32, "end": 615.32, "text": " the runtime system using the compiler. It's not something that I can do very well.", "tokens": [264, 34474, 1185, 1228, 264, 31958, 13, 467, 311, 406, 746, 300, 286, 393, 360, 588, 731, 13], "temperature": 0.0, "avg_logprob": -0.20067813579852764, "compression_ratio": 1.4739884393063585, "no_speech_prob": 0.0005508160684257746}, {"id": 88, "seek": 61532, "start": 615.32, "end": 625.32, "text": " So I won't recommend anything.", "tokens": [407, 286, 1582, 380, 2748, 1340, 13], "temperature": 0.0, "avg_logprob": -0.3006984194119771, "compression_ratio": 1.4225352112676057, "no_speech_prob": 0.004321451764553785}, {"id": 89, "seek": 61532, "start": 625.32, "end": 634.32, "text": " In your examples, you showed that you can have comments evaluated as a Ripple.", "tokens": [682, 428, 5110, 11, 291, 4712, 300, 291, 393, 362, 3053, 25509, 382, 257, 497, 23476, 13], "temperature": 0.0, "avg_logprob": -0.3006984194119771, "compression_ratio": 1.4225352112676057, "no_speech_prob": 0.004321451764553785}, {"id": 90, "seek": 61532, "start": 634.32, "end": 640.32, "text": " I know Rust has something quite similar and it made sure that examples in your documentation", "tokens": [286, 458, 34952, 575, 746, 1596, 2531, 293, 309, 1027, 988, 300, 5110, 294, 428, 14333], "temperature": 0.0, "avg_logprob": -0.3006984194119771, "compression_ratio": 1.4225352112676057, "no_speech_prob": 0.004321451764553785}, {"id": 91, "seek": 64032, "start": 640.32, "end": 646.32, "text": " have tests. Can you do similar sorts of things?", "tokens": [362, 6921, 13, 1664, 291, 360, 2531, 7527, 295, 721, 30], "temperature": 0.0, "avg_logprob": -0.2297480765809404, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.0010156681528314948}, {"id": 92, "seek": 64032, "start": 646.32, "end": 655.32, "text": " You had an example of a Ripple evaluated in comments in your code.", "tokens": [509, 632, 364, 1365, 295, 257, 497, 23476, 25509, 294, 3053, 294, 428, 3089, 13], "temperature": 0.0, "avg_logprob": -0.2297480765809404, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.0010156681528314948}, {"id": 93, "seek": 64032, "start": 655.32, "end": 656.32, "text": " This one.", "tokens": [639, 472, 13], "temperature": 0.0, "avg_logprob": -0.2297480765809404, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.0010156681528314948}, {"id": 94, "seek": 64032, "start": 656.32, "end": 661.32, "text": " Is that specifically the VS Code extension?", "tokens": [1119, 300, 4682, 264, 25091, 15549, 10320, 30], "temperature": 0.0, "avg_logprob": -0.2297480765809404, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.0010156681528314948}, {"id": 95, "seek": 66132, "start": 661.32, "end": 671.32, "text": " I think so. It's provided by Visual Studio Code with the Askell extension and it's automatic.", "tokens": [286, 519, 370, 13, 467, 311, 5649, 538, 23187, 13500, 15549, 365, 264, 1018, 43723, 10320, 293, 309, 311, 12509, 13], "temperature": 0.0, "avg_logprob": -0.3729656826366078, "compression_ratio": 1.2348484848484849, "no_speech_prob": 0.006634070537984371}, {"id": 96, "seek": 66132, "start": 671.32, "end": 681.32, "text": " Yeah, Rust has this feature. The evaluator is doing the test for you.", "tokens": [865, 11, 34952, 575, 341, 4111, 13, 440, 6133, 1639, 307, 884, 264, 1500, 337, 291, 13], "temperature": 0.0, "avg_logprob": -0.3729656826366078, "compression_ratio": 1.2348484848484849, "no_speech_prob": 0.006634070537984371}, {"id": 97, "seek": 68132, "start": 681.32, "end": 695.32, "text": " Yeah, so what is very confusing for beginners sometimes, if you come from another language", "tokens": [865, 11, 370, 437, 307, 588, 13181, 337, 26992, 2171, 11, 498, 291, 808, 490, 1071, 2856], "temperature": 0.0, "avg_logprob": -0.2298855852724901, "compression_ratio": 1.4036144578313252, "no_speech_prob": 0.0007715920219197869}, {"id": 98, "seek": 68132, "start": 695.32, "end": 699.32, "text": " like Rust or so, then it's one way to build a project.", "tokens": [411, 34952, 420, 370, 11, 550, 309, 311, 472, 636, 281, 1322, 257, 1716, 13], "temperature": 0.0, "avg_logprob": -0.2298855852724901, "compression_ratio": 1.4036144578313252, "no_speech_prob": 0.0007715920219197869}, {"id": 99, "seek": 68132, "start": 699.32, "end": 708.32, "text": " In Haskell, you have like Carbal and Nix together and then you have Carbal v1, v2, new.", "tokens": [682, 8646, 43723, 11, 291, 362, 411, 2741, 2645, 293, 426, 970, 1214, 293, 550, 291, 362, 2741, 2645, 371, 16, 11, 371, 17, 11, 777, 13], "temperature": 0.0, "avg_logprob": -0.2298855852724901, "compression_ratio": 1.4036144578313252, "no_speech_prob": 0.0007715920219197869}, {"id": 100, "seek": 70832, "start": 708.32, "end": 720.32, "text": " Is there some plan to clean this up someday to give a simple way to build a Haskell project?", "tokens": [1119, 456, 512, 1393, 281, 2541, 341, 493, 19412, 281, 976, 257, 2199, 636, 281, 1322, 257, 8646, 43723, 1716, 30], "temperature": 0.0, "avg_logprob": -0.14840151658698694, "compression_ratio": 1.4619883040935673, "no_speech_prob": 0.0010750845540314913}, {"id": 101, "seek": 70832, "start": 720.32, "end": 724.32, "text": " In fact, Carbal and Stack doesn't do exactly the same.", "tokens": [682, 1186, 11, 2741, 2645, 293, 37649, 1177, 380, 360, 2293, 264, 912, 13], "temperature": 0.0, "avg_logprob": -0.14840151658698694, "compression_ratio": 1.4619883040935673, "no_speech_prob": 0.0010750845540314913}, {"id": 102, "seek": 70832, "start": 724.32, "end": 731.32, "text": " Stack is based on snapshots, so it's more secure if you want to have the same build for every project.", "tokens": [37649, 307, 2361, 322, 19206, 27495, 11, 370, 309, 311, 544, 7144, 498, 291, 528, 281, 362, 264, 912, 1322, 337, 633, 1716, 13], "temperature": 0.0, "avg_logprob": -0.14840151658698694, "compression_ratio": 1.4619883040935673, "no_speech_prob": 0.0010750845540314913}, {"id": 103, "seek": 73132, "start": 731.32, "end": 738.32, "text": " But both tools are compatible, so Stack can use the Carbal file, so you can just write a Carbal file,", "tokens": [583, 1293, 3873, 366, 18218, 11, 370, 37649, 393, 764, 264, 2741, 2645, 3991, 11, 370, 291, 393, 445, 2464, 257, 2741, 2645, 3991, 11], "temperature": 0.0, "avg_logprob": -0.1871643520536877, "compression_ratio": 1.4933333333333334, "no_speech_prob": 0.0018404097063466907}, {"id": 104, "seek": 73132, "start": 738.32, "end": 744.32, "text": " then add the version of the snapshots you want to use for Stack and that's it.", "tokens": [550, 909, 264, 3037, 295, 264, 19206, 27495, 291, 528, 281, 764, 337, 37649, 293, 300, 311, 309, 13], "temperature": 0.0, "avg_logprob": -0.1871643520536877, "compression_ratio": 1.4933333333333334, "no_speech_prob": 0.0018404097063466907}, {"id": 105, "seek": 73132, "start": 744.32, "end": 757.32, "text": " But I agree with you, there are many tools.", "tokens": [583, 286, 3986, 365, 291, 11, 456, 366, 867, 3873, 13], "temperature": 0.0, "avg_logprob": -0.1871643520536877, "compression_ratio": 1.4933333333333334, "no_speech_prob": 0.0018404097063466907}, {"id": 106, "seek": 75732, "start": 757.32, "end": 763.32, "text": " I'm not familiar with Stack, but I thought that Carbal has something like log file nowadays, like a freeze.", "tokens": [286, 478, 406, 4963, 365, 37649, 11, 457, 286, 1194, 300, 2741, 2645, 575, 746, 411, 3565, 3991, 13434, 11, 411, 257, 15959, 13], "temperature": 0.0, "avg_logprob": -0.23798112466301716, "compression_ratio": 1.5163398692810457, "no_speech_prob": 0.00431669969111681}, {"id": 107, "seek": 75732, "start": 763.32, "end": 765.32, "text": " Is that similar to that?", "tokens": [1119, 300, 2531, 281, 300, 30], "temperature": 0.0, "avg_logprob": -0.23798112466301716, "compression_ratio": 1.5163398692810457, "no_speech_prob": 0.00431669969111681}, {"id": 108, "seek": 75732, "start": 765.32, "end": 769.32, "text": " Carbal, a freeze.", "tokens": [2741, 2645, 11, 257, 15959, 13], "temperature": 0.0, "avg_logprob": -0.23798112466301716, "compression_ratio": 1.5163398692810457, "no_speech_prob": 0.00431669969111681}, {"id": 109, "seek": 75732, "start": 769.32, "end": 784.32, "text": " Nix with Carbal, so there is a freeze with Nix, but I don't use Carbal very much.", "tokens": [426, 970, 365, 2741, 2645, 11, 370, 456, 307, 257, 15959, 365, 426, 970, 11, 457, 286, 500, 380, 764, 2741, 2645, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.23798112466301716, "compression_ratio": 1.5163398692810457, "no_speech_prob": 0.00431669969111681}, {"id": 110, "seek": 78432, "start": 784.32, "end": 788.32, "text": " Okay, we're out of time, so please once again thank Julio.", "tokens": [50364, 1033, 11, 321, 434, 484, 295, 565, 11, 370, 1767, 1564, 797, 1309, 7174, 1004, 13, 50564], "temperature": 0.0, "avg_logprob": -0.29946357325503703, "compression_ratio": 0.8923076923076924, "no_speech_prob": 0.0010211620246991515}], "language": "en"}