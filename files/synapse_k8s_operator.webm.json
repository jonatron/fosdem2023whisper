{"text": " Hello everyone, good morning, good afternoon. Today we'll talk about a Kubernetes operator for Synapse, which allows you to deploy and manage a Synapse on server as well as a couple of bridges on top of Kubernetes. This operator is written in Go, and if you don't know what Kubernetes operators are or what they do, don't worry because that's the first thing we will talk about. In this talk, we will not assume any prior knowledge of Kubernetes. My name is Mathias Gohens. I'm a senior software engineer at Red Hat, and I've been working with operators daily since I started a bit less than two years ago. I was looking for a way to learn and experiment with operators, and that's how this project started as a playground for me. So let's get started. As promised, the first thing we'll do is discuss some ground concepts of Kubernetes and introduce what Kubernetes operators are and what they do. And in the second part of this talk, we'll talk more specifically about the Synapse operator and do a demo of its main capabilities. And finally, we'll talk about the future of this project and the long list of improvements and features which could be added to it. So Kubernetes, what is it? Some ground concepts first. Kubernetes is a container orchestration engine. That means that it helps with managing containers at scale. Among its main features, Kubernetes helps with load balancing, high availability, and self-healing of your containerized application. There's this notion of pods in Kubernetes. A pod is wrapper for your containers. The pod runs one of multiple containers and you never run container directly on Kubernetes. You always go through this abstraction layer, which is a pod. And finally, your resources are described in YAML. The Kubernetes resources, such as a pod, can be described in YAML. And as a user, you often write something called manifest files to create or update your resources. You have also Kubernetes CLI called kubectl or kubectl, which allows you to interact with the Kubernetes API. And you can do things like kubectl get pods or create new resources with kubectl create. Talking about resources, that's what they look like for the most part. First, you have something called the type meta. This is where you identify the type of resource that you describe. In this case here, we're talking about a replica set. Other examples of Kubernetes resources are pods, we already mentioned this, deployment, jobs, service account, PVC, the persistent volume claims, config map, and so on. Then you have the so-called object meta, that's the part which allows you to uniquely identify an instance of a resource type. So here, we're dealing with an instance of a replica set called frontend. And finally, you have the spec and status section. And the spec or specification represents the desired configuration. It's the desired state of this resource. Finally, the status provides the user with information about the last known state of the resource. And so what is a replica set, by the way? It is a way to encapsulate a pod definition. So that's one here in the template. That's a template of a pod, right? And the pod runs containers. And it adds a replica count to it. So here, it expresses that there should be three replica, three copy of this pod running. And if for whatever reason, a pod comes to fail, then the replica set is there to ensure that a new copy of this pod is being created. Let's see a replica set in actions to illustrate what we just said. I'm on a Kubernetes cluster here. And I already have a replica set running on this pod, on this cluster. On the bottom right, you see the list of pods currently running on the cluster. So here, you have three pods, three engineering pods. And well, that makes actually sense because we have on this replica set configured that we would like to have a three pod running three copy of the engineering pod running. Let me take one pod and delete it. kubectl, delete pod, and the name of my pod. So what's going to happen? A new copy of a pod is recreated almost instantly. Well, that's the job of the replica set. That's exactly what it does. It ensures that three copies are running. All right, but where is this logic of recreating pods, recreating copy of my pod actually implemented? Well, that's the job of controllers. So let's think about this. What is a controller? A controller in Kubernetes? It's a process. It's a process that runs usually within the cluster as a pod. It's responsible for managing a type of resource in the cluster. So there is a job controller for managing jobs. There's a deployment controllers for managing the lifecycle of deployments. And there is of course a replica set controller, which we're going to see in a second. Behind the scene, how it works is that it watches the Kubernetes API. Each time it is an event, like a creation, the update of the deletion event, which is related to the type of resource that it manages, then it starts something called its control loop. And the control loop, it's an id input and function, which role is to resolve the difference between the current state of the resource and its desired state. And it's also, by the way, responsible for writing the status of the resource. So let's see an example real quick. This is the replica set controller or at least the simplified version of it. It implements a control loop. And this control loop here in the middle is triggered every time a replica set is either created, updated or deleted in the cluster. The main aspects of this control loop is to first read the desired number of replicas from the replica set. That's the desired state, right? This here. Second, it's to read the current state of the resource. How many replicas of the NGNX pod currently exist on the cluster? That's this here. And third, it will reconcile the resource state. That means that it calculates the difference between the desired and current number of replicas. And it creates or deletes replicas or even it can do nothing if the current and desired number of replicas already match. And finally, its last responsibility is to write the resources status. So this provides the end user or other controllers in the cluster information on the last known state of this resource. And they are similar built-in controllers, as we mentioned, running for the deployment, for the jobs, for the PVCs, etc. For all native Kubernetes resources, there is built-in controller for managing them. And, well, now you must wonder, wait, you keep talking about built-in controllers and native Kubernetes resources. Why is that? Does that mean that there is such an external controller in the non-native resource? Well, yes, precisely that's exactly what there is, and that's exactly what operators are all about. Operators are about reusing these concepts of Kubernetes resource and Kubernetes controller and create our own. So first, we're going to create new resource types. Let's say, for example, we're going to create a resource type called Synapse. In a second, we're going to create a custom controller to manage our brand new resource type. So let's say we're going to create a Synapse controller responsible for all the business logic of creating and managing a Synapse home server. So first, a new resource type. A new resource type. How are we going to do that? Well, we're using something called custom resource definition in Kubernetes. And this is a truly amazing feature of Kubernetes because CRDs, the short name for custom resource definition, they provide a way to extend the Kubernetes API using the Kubernetes API. That means that there is a resource type in Kubernetes natively, which is called custom resource definition. And we can write our CRD as a manifest file and create and query it with kubectl. So the CRD manifest will contain information about the new resource, the custom resource, and such as its kind and its open API v3 schema. Open API v3 schema is a set of definitions and rules that will describe the structure of our Kubernetes resource. So let's have a look. Let's have a look at custom resource definitions. As a matter of fact, on my Kubernetes cluster, there are already some CRDs installed and specifically CRDs for Synapse. And I can't dig into it. So here you see I did the kubectl get custom resource definition because this type is natively present on Kubernetes. And I can also do things like get, this is the command I run, get custom resource definition, the name of my Synapse CRD, that show YAML, that's to have it in a YAML output. And what I see here is how a CRD looks like. So there is a kind Kubernetes, kind, sorry, custom resource definition, this is the type meta. Here we have the object meta on this meta data section with the name of this CRD. And then we have the spec. And what is the spec of a CRD? Well, it is describing a new resource. We are creating a new resource type in Kubernetes, a custom resource. So how does this custom resource looks like? You have things, for example, such as the new kind that you want to have created. You have information, for example, this is a namespaced resource or not. You could also have cluster wide resources. And you have, you see here that it's available in the v1, alpha one version. And you have the schema, open API v3 schema for this new custom resource, this new Synapse custom resource. And on the top level, you have, you find things again, like API version on kind. So this is our beloved type meta, then the meta data section, the object meta that are common to all Kubernetes resources. And then you have the spec section and status section. Again, we again find the second status. And here you see the descriptions of what is contained into the spec. So here, for example, you have a Boolean called create new Postgres QL, by default, it's false. They have a section called home server. And with some information how to configure your Synapse instance. So this CRD is there to describe our new Synapse resource type. We're jumping a little bit ahead here. We'll come back to the Synapse CRD later. We're actually going to use it and create a Synapse instance. I just wanted to show you an example of a CRD manifest file. And because this, because this CRD is installed in the cluster, I can now do things like kubectl get Synapse. What do I get back from the cluster from the API? No resources found in default namespace. Okay. And just to compare, if I would run this here, kubectl get not exist. This is a type which does not exist. I get a different message. This one, it's an error message. So the server doesn't have a resource type not exist, right? Synapse, we have created CRD. So the resource type Synapse is known. And now that we talked about custom resources, we can talk about building a custom controller. So that's where we need to write some code and implement the actual logic of managing a simple Synapse instance, the business logic. Unfortunately, we have some SDKs available, which will help us with all the boilerplate code come on to all operators, such as watching the API, cashing some requests, building work queues, and so on. They also help with actually creating this CRD manifest that we just saw, because as you see, creating the open API with free schema by hand can be a little bit cumbersome. So we also have tools in the SDK to help us bootstrap, generate actually those CRD manifest files. So using an SDK really allows us to focus on writing the business logic and how to manage our application. And yeah, so with that, we have it. We have seen the main concepts behind Kubernetes operator. We talked about Kubernetes resources, how they are structured. We saw how we can extend the Kubernetes API with custom resource definitions. We talked about the controller pattern in Kubernetes and how controllers are responsible for reconciling the state of the resource they manage. And we saw that we can write our own controller with Operator SDK, for example. And hopefully by now, you have a good understanding of what operators are and do. Of course, there would be tons of other interesting details to mention on Operator SDKs and CRDs and so on. But yeah, we have a limited amount of time today. So this talk is actually about the Synapse operator. So let's move on to that part, finally. We have, so I made the choice to, of dividing this project into three CRDs. One for the Synapse home server and one for each bridges. So right now, this operator is able to manage two bridges, the Heisen bridge, so this is for IRC and matrix signal, which as the name suggests is for signal. That means that you can manage each component individually and independently. That's a model which would scale also better if and when additional components are added to the project. So let's have a look at the CRDs individually. First, the Synapse CRD. So we saw this already before and as the name suggests, it allows us to deploy a Synapse home server. By default, it will use the SQLite database, which is shipped within the Synapse Docker image. But there are also ways to work with Postgres. We'll talk about that a little bit later. In order to deploy Synapse, we need to provide some configuration options. To do that, we need a configuration file, which is called home server.yaml. And as you know, if you've dealt with Synapse before, this is a very long file. There are lots of configuration options. So therefore, I made the choice of providing users of the Synapse operator with two options for configuring their Synapse instance. As a user, you can either provide the two mandatory configuration options directly in the Synapse manifest. These two mandatory options are the name of your server and whether or not to report statistics. The Synapse operator then uses the default values and the rest of the home server.yaml with default values. Actually, it uses a default home server.yaml template and feeds those values into it. And this is especially useful if you don't have a home server.yaml at hand or just want to quick start in a project, quickly test the capability of this operator and just want to get a Synapse instance running. However, if you need more control over the configuration of Synapse, which is totally understandable, or if you already have a home server.yaml, then you want to go with the second option. And that is creating a config map containing the home server.yaml and feeding it to the Synapse resource. We're going to see this in a second with examples. The Synapse operator automatically will use your custom home server yaml. Actually, it will make a copy of it and it will use it to configure Synapse. Let's see a little demo of this. So, we're back on our Kubernetes cluster. On the top right, you see the logs of the three controllers, the Synapse controller, the Heisenbridge controller and the Motrix signal controller, which are running in the cluster. All the logs of those three controllers are here on the top right of your screen. On the bottom right, you again have the list of pod running in the cluster and the default namespace. Currently, there are none. And on the left side, that's where we're going to issue some commands. Let's go ahead and create our first Synapse instance. This one is going to use, so this one you see, it's a kind Synapse. And with the name called MySynapse. And this one is going to use values. We're going to use, provide some values in the spec section of our manifest file, the name of the server, which is called myserver.com. And whether or not to report that here, true, because we are a good citizen. And we are going to go ahead and create this Synapse instance. What we see here on the right side is the Synapse controller getting to work. And that's business logic, right, which is in the Synapse instance. It compares the desired state of this resource. So please have a home server running with this configuration values. And the current state, what do I currently have in a cluster? Nothing. I don't have a Synapse instance running. I don't have a pod for my Synapse instance. So this is what then creates all the necessary objects, a deployment, a config map, a PDC, and so on and so on. And now I can check that my Synapse is being created. So as you see, get Synapse, right? This time I have one. I get this one back in. I can check my Synapse status. And I see that some information on the home server configuration has been populated. Well, in this case, it's pretty straightforward. It's basically a copy of the values. And you can see that this Synapse instance is running. In fact, yes, you check a bit the logs of this Synapse pod here. You see that, well, the usual have been created, the usual have been displayed here with some info on this Synapse instance is running. Now we're going to move to the second example. Now that we have seen how to create a Synapse using values, we're going to see how you can do that with a custom home server, the YAML. Let's say you have your custom home server YAML. This time, you have configured a server name, my matrix host. And you want to use this for configuring Synapse. What you do here is create a config map for this home server YAML. So here I did kubectl create config map. This is the name of my config map, my custom home server. I'm using from file to say I want to use this file as an input for the data of this config map. And in fact, now I have this config map created here, my custom home server 15 seconds ago. Now I have the Synapse instance, a new Synapse called my custom Synapse. And in the configuration options, this time, I'm not using values, I'm using here config map, and I'm giving the name of the config map containing the home server YAML that I want to use for configuring this instance of Synapse. So let's go ahead and create it. And again, the Synapse controller gets to work. And a new pod is going to come up for this instance of Synapse. And if I'm checking this time the status of my custom Synapse, in the status here, I see again some information on the home server configuration has been populated by the Synapse controller. And especially the name of the server and whether or not to report stats, this has been fetched from my custom home server YAML. Behind the scene, what it does also, if I'm running this command again, is that it actually creates a copy of your input config map. So it makes a copy of the config map you provide, and it works on this copy, because sometimes the Synapse controller might have to do some modification to make sure that this instance of Synapse can actually run. So it makes a copy, doesn't touch your input config map, it makes a copy of it and edit it in place if needed. Let's go back to the presentation and move on to the next CRD that we have, the next resource type that we have installed, which is Heisenbridge. So Heisenbridge, as the name suggests, again deploys an instance of the IRC bridge called Heisenbridge. And then it also automatically adds this bridge as an application service to the Synapse home server YAML. And similarly to Synapse, you can again provide your custom Heisenbridge configuration file if you want. You can also decide to use some default values. And in that case, you don't have to provide anything because there is no mandatory configuration options for Heisenbridge. So if I'm going back to the terminal, I see that here I have an example manifest file for Heisenbridge, where I specify in the spec section simply the name of the Synapse instance that I want to be connected to. And that's okay because I have, my Synapse is an existing Synapse instance, right, we created it a few minutes ago. So I can go ahead and create this. And what's happening here now, we have two controllers now doing some work. First, the Heisenbridge controller, which runs here this part, the Heisenbridge part. And second, we have the Synapse controller, which you see has terminated one part, the one which was created four minutes ago, and has run a new part about 20 seconds ago now when we first created our Heisenbridge. Why is that? Well, the business logic of the Synapse controller is so that when it sees a Heisenbridge being created for an existing Synapse instance, well, it reconfigures it. So it adds it, it adds the Heisenbridge as an application service in Home Server YAML. And then he has to restart, not actually restart, recreate the part using this new configuration. So that's what it does. I can also check the logs of my Synapse pod, a grab for Heisenbridge. And we see that indeed Heisenbridge has been added as an application service. There is a user Heisenbridge, which has been created, which has been logged in. And there were some initial requests made for configuring it. All right, so I have now a Heisenbridge instance, and I have two Synapse instances running. By the way, this reconfiguration of the Home Server YAML would also work if you would have provided your own Home Server YAML with a config map, because I mentioned before that the controller makes a copy of this Home Server YAML. And so it works on this copy and it also modifies it if needed. All right, and just to mention here, we have also the possibility to configure Heisenbridge with a config map that would work in the same way as for Synapse. That means that we would need to create a config map first and then feed it here to the Heisenbridge resource. And in this config map, we would need to have the Heisenbridge configuration file. So similarly to what we had with Synapse. Finally, we have the MatrixSignal bridge. This works exactly in the same way, creating the Matrix Bridge, creating a signal D, which is required for this bridge to run, and reconfiguring the Home Server YAML and add MatrixSignal as a bridge there, as an app service there. Again, you can either use a custom configuration file or work with default if you want a quick start. Finally, there's a way to provision a PostgreSQL instance. The first thing you could do is have your custom Home Server YAML and if you already have a PostgreSQL instance running, you could provide your own Home Server YAML and configure the database connection information there. Or you can automatically spin up a PostgreSQL instance. We saw that there is a create PostgreSQL Boolean a little bit earlier. By default, it's false. But if you put it to true, it will attempt to create a PostgreSQL cluster or PostgreSQL instance using the PostgreSQL operator. So that's an external dependency on the Synapse operator. Let's finish very quick with the next steps. As you know, MatrixSignal is a very large ecosystem with tons of projects. Many are obviously missing from the Synapse operator today. First, bridges, of course. We could add more bridges. Web clients, we currently don't have any, but we could have Element or Hydrogen, for instance, as a web client. We could have some additional infrastructure components, such as a turn server for WebRTC, audio-video call, SSL certificates, or email server. And, of course, why not also have alternative Home Servers, right? Right now, we only have the Synapse Home Server, but we could also have a provided possibility to deploy. You maybe can do it on the Android and turn this Synapse operator into a Matrix operator, actually. Yeah, that would be for the long term. All right, so that's it for me today. Thanks for listening. Today, we hear some information on how to contact me, the link to the GitHub. Don't hesitate to go ahead and grab the code and try it out, provide feedbacks, write me also in the Synapse operator room. Right now, it's a very quiet room, but please just come and have a chat if you have any questions or if you're interested in working on this project. Thank you very much for your attention, and I wish you a good rest of the conference. Bye. you you", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.0, "text": " Hello everyone, good morning, good afternoon. Today we'll talk about a Kubernetes operator", "tokens": [50364, 2425, 1518, 11, 665, 2446, 11, 665, 6499, 13, 2692, 321, 603, 751, 466, 257, 23145, 12973, 50864], "temperature": 0.0, "avg_logprob": -0.17560920049977857, "compression_ratio": 1.634703196347032, "no_speech_prob": 0.07528790086507797}, {"id": 1, "seek": 0, "start": 10.0, "end": 15.040000000000001, "text": " for Synapse, which allows you to deploy and manage a Synapse on server as well as a couple", "tokens": [50864, 337, 26155, 11145, 11, 597, 4045, 291, 281, 7274, 293, 3067, 257, 26155, 11145, 322, 7154, 382, 731, 382, 257, 1916, 51116], "temperature": 0.0, "avg_logprob": -0.17560920049977857, "compression_ratio": 1.634703196347032, "no_speech_prob": 0.07528790086507797}, {"id": 2, "seek": 0, "start": 15.040000000000001, "end": 20.240000000000002, "text": " of bridges on top of Kubernetes. This operator is written in Go, and if you don't know what", "tokens": [51116, 295, 21114, 322, 1192, 295, 23145, 13, 639, 12973, 307, 3720, 294, 1037, 11, 293, 498, 291, 500, 380, 458, 437, 51376], "temperature": 0.0, "avg_logprob": -0.17560920049977857, "compression_ratio": 1.634703196347032, "no_speech_prob": 0.07528790086507797}, {"id": 3, "seek": 0, "start": 20.240000000000002, "end": 24.64, "text": " Kubernetes operators are or what they do, don't worry because that's the first thing", "tokens": [51376, 23145, 19077, 366, 420, 437, 436, 360, 11, 500, 380, 3292, 570, 300, 311, 264, 700, 551, 51596], "temperature": 0.0, "avg_logprob": -0.17560920049977857, "compression_ratio": 1.634703196347032, "no_speech_prob": 0.07528790086507797}, {"id": 4, "seek": 2464, "start": 24.64, "end": 29.6, "text": " we will talk about. In this talk, we will not assume any prior knowledge of Kubernetes.", "tokens": [50364, 321, 486, 751, 466, 13, 682, 341, 751, 11, 321, 486, 406, 6552, 604, 4059, 3601, 295, 23145, 13, 50612], "temperature": 0.0, "avg_logprob": -0.14707305867184875, "compression_ratio": 1.5720338983050848, "no_speech_prob": 0.04426146298646927}, {"id": 5, "seek": 2464, "start": 30.64, "end": 35.6, "text": " My name is Mathias Gohens. I'm a senior software engineer at Red Hat, and I've been working with", "tokens": [50664, 1222, 1315, 307, 15776, 4609, 1037, 71, 694, 13, 286, 478, 257, 7965, 4722, 11403, 412, 4477, 15867, 11, 293, 286, 600, 668, 1364, 365, 50912], "temperature": 0.0, "avg_logprob": -0.14707305867184875, "compression_ratio": 1.5720338983050848, "no_speech_prob": 0.04426146298646927}, {"id": 6, "seek": 2464, "start": 35.6, "end": 42.16, "text": " operators daily since I started a bit less than two years ago. I was looking for a way to learn", "tokens": [50912, 19077, 5212, 1670, 286, 1409, 257, 857, 1570, 813, 732, 924, 2057, 13, 286, 390, 1237, 337, 257, 636, 281, 1466, 51240], "temperature": 0.0, "avg_logprob": -0.14707305867184875, "compression_ratio": 1.5720338983050848, "no_speech_prob": 0.04426146298646927}, {"id": 7, "seek": 2464, "start": 42.16, "end": 48.56, "text": " and experiment with operators, and that's how this project started as a playground for me.", "tokens": [51240, 293, 5120, 365, 19077, 11, 293, 300, 311, 577, 341, 1716, 1409, 382, 257, 24646, 337, 385, 13, 51560], "temperature": 0.0, "avg_logprob": -0.14707305867184875, "compression_ratio": 1.5720338983050848, "no_speech_prob": 0.04426146298646927}, {"id": 8, "seek": 4856, "start": 49.28, "end": 56.88, "text": " So let's get started. As promised, the first thing we'll do is discuss some ground concepts", "tokens": [50400, 407, 718, 311, 483, 1409, 13, 1018, 10768, 11, 264, 700, 551, 321, 603, 360, 307, 2248, 512, 2727, 10392, 50780], "temperature": 0.0, "avg_logprob": -0.06574278528040106, "compression_ratio": 1.695067264573991, "no_speech_prob": 0.0018672127043828368}, {"id": 9, "seek": 4856, "start": 56.88, "end": 62.96, "text": " of Kubernetes and introduce what Kubernetes operators are and what they do. And in the second", "tokens": [50780, 295, 23145, 293, 5366, 437, 23145, 19077, 366, 293, 437, 436, 360, 13, 400, 294, 264, 1150, 51084], "temperature": 0.0, "avg_logprob": -0.06574278528040106, "compression_ratio": 1.695067264573991, "no_speech_prob": 0.0018672127043828368}, {"id": 10, "seek": 4856, "start": 62.96, "end": 67.68, "text": " part of this talk, we'll talk more specifically about the Synapse operator and do a demo of its", "tokens": [51084, 644, 295, 341, 751, 11, 321, 603, 751, 544, 4682, 466, 264, 26155, 11145, 12973, 293, 360, 257, 10723, 295, 1080, 51320], "temperature": 0.0, "avg_logprob": -0.06574278528040106, "compression_ratio": 1.695067264573991, "no_speech_prob": 0.0018672127043828368}, {"id": 11, "seek": 4856, "start": 67.68, "end": 73.76, "text": " main capabilities. And finally, we'll talk about the future of this project and the long list of", "tokens": [51320, 2135, 10862, 13, 400, 2721, 11, 321, 603, 751, 466, 264, 2027, 295, 341, 1716, 293, 264, 938, 1329, 295, 51624], "temperature": 0.0, "avg_logprob": -0.06574278528040106, "compression_ratio": 1.695067264573991, "no_speech_prob": 0.0018672127043828368}, {"id": 12, "seek": 7376, "start": 73.76, "end": 80.64, "text": " improvements and features which could be added to it. So Kubernetes, what is it? Some ground", "tokens": [50364, 13797, 293, 4122, 597, 727, 312, 3869, 281, 309, 13, 407, 23145, 11, 437, 307, 309, 30, 2188, 2727, 50708], "temperature": 0.0, "avg_logprob": -0.08773106336593628, "compression_ratio": 1.6517857142857142, "no_speech_prob": 0.0017542961286380887}, {"id": 13, "seek": 7376, "start": 80.64, "end": 86.16000000000001, "text": " concepts first. Kubernetes is a container orchestration engine. That means that it helps", "tokens": [50708, 10392, 700, 13, 23145, 307, 257, 10129, 14161, 2405, 2848, 13, 663, 1355, 300, 309, 3665, 50984], "temperature": 0.0, "avg_logprob": -0.08773106336593628, "compression_ratio": 1.6517857142857142, "no_speech_prob": 0.0017542961286380887}, {"id": 14, "seek": 7376, "start": 86.16000000000001, "end": 93.68, "text": " with managing containers at scale. Among its main features, Kubernetes helps with load balancing,", "tokens": [50984, 365, 11642, 17089, 412, 4373, 13, 16119, 1080, 2135, 4122, 11, 23145, 3665, 365, 3677, 22495, 11, 51360], "temperature": 0.0, "avg_logprob": -0.08773106336593628, "compression_ratio": 1.6517857142857142, "no_speech_prob": 0.0017542961286380887}, {"id": 15, "seek": 7376, "start": 93.68, "end": 99.60000000000001, "text": " high availability, and self-healing of your containerized application. There's this notion", "tokens": [51360, 1090, 17945, 11, 293, 2698, 12, 675, 4270, 295, 428, 10129, 1602, 3861, 13, 821, 311, 341, 10710, 51656], "temperature": 0.0, "avg_logprob": -0.08773106336593628, "compression_ratio": 1.6517857142857142, "no_speech_prob": 0.0017542961286380887}, {"id": 16, "seek": 9960, "start": 99.67999999999999, "end": 107.44, "text": " of pods in Kubernetes. A pod is wrapper for your containers. The pod runs one of multiple containers", "tokens": [50368, 295, 31925, 294, 23145, 13, 316, 2497, 307, 46906, 337, 428, 17089, 13, 440, 2497, 6676, 472, 295, 3866, 17089, 50756], "temperature": 0.0, "avg_logprob": -0.09095052014226498, "compression_ratio": 1.7212389380530972, "no_speech_prob": 0.0027571599930524826}, {"id": 17, "seek": 9960, "start": 107.44, "end": 113.36, "text": " and you never run container directly on Kubernetes. You always go through this abstraction layer,", "tokens": [50756, 293, 291, 1128, 1190, 10129, 3838, 322, 23145, 13, 509, 1009, 352, 807, 341, 37765, 4583, 11, 51052], "temperature": 0.0, "avg_logprob": -0.09095052014226498, "compression_ratio": 1.7212389380530972, "no_speech_prob": 0.0027571599930524826}, {"id": 18, "seek": 9960, "start": 113.36, "end": 121.52, "text": " which is a pod. And finally, your resources are described in YAML. The Kubernetes resources,", "tokens": [51052, 597, 307, 257, 2497, 13, 400, 2721, 11, 428, 3593, 366, 7619, 294, 398, 2865, 43, 13, 440, 23145, 3593, 11, 51460], "temperature": 0.0, "avg_logprob": -0.09095052014226498, "compression_ratio": 1.7212389380530972, "no_speech_prob": 0.0027571599930524826}, {"id": 19, "seek": 9960, "start": 121.52, "end": 127.67999999999999, "text": " such as a pod, can be described in YAML. And as a user, you often write something called manifest", "tokens": [51460, 1270, 382, 257, 2497, 11, 393, 312, 7619, 294, 398, 2865, 43, 13, 400, 382, 257, 4195, 11, 291, 2049, 2464, 746, 1219, 10067, 51768], "temperature": 0.0, "avg_logprob": -0.09095052014226498, "compression_ratio": 1.7212389380530972, "no_speech_prob": 0.0027571599930524826}, {"id": 20, "seek": 12768, "start": 127.68, "end": 136.08, "text": " files to create or update your resources. You have also Kubernetes CLI called kubectl or kubectl,", "tokens": [50364, 7098, 281, 1884, 420, 5623, 428, 3593, 13, 509, 362, 611, 23145, 12855, 40, 1219, 350, 836, 557, 75, 420, 350, 836, 557, 75, 11, 50784], "temperature": 0.0, "avg_logprob": -0.09926900085137814, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.0019256522646173835}, {"id": 21, "seek": 12768, "start": 136.08, "end": 143.12, "text": " which allows you to interact with the Kubernetes API. And you can do things like kubectl get pods", "tokens": [50784, 597, 4045, 291, 281, 4648, 365, 264, 23145, 9362, 13, 400, 291, 393, 360, 721, 411, 350, 836, 557, 75, 483, 31925, 51136], "temperature": 0.0, "avg_logprob": -0.09926900085137814, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.0019256522646173835}, {"id": 22, "seek": 12768, "start": 143.12, "end": 149.36, "text": " or create new resources with kubectl create. Talking about resources, that's what they look", "tokens": [51136, 420, 1884, 777, 3593, 365, 350, 836, 557, 75, 1884, 13, 22445, 466, 3593, 11, 300, 311, 437, 436, 574, 51448], "temperature": 0.0, "avg_logprob": -0.09926900085137814, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.0019256522646173835}, {"id": 23, "seek": 12768, "start": 149.36, "end": 156.16, "text": " like for the most part. First, you have something called the type meta. This is where you identify", "tokens": [51448, 411, 337, 264, 881, 644, 13, 2386, 11, 291, 362, 746, 1219, 264, 2010, 19616, 13, 639, 307, 689, 291, 5876, 51788], "temperature": 0.0, "avg_logprob": -0.09926900085137814, "compression_ratio": 1.6637931034482758, "no_speech_prob": 0.0019256522646173835}, {"id": 24, "seek": 15616, "start": 156.16, "end": 162.24, "text": " the type of resource that you describe. In this case here, we're talking about a replica set.", "tokens": [50364, 264, 2010, 295, 7684, 300, 291, 6786, 13, 682, 341, 1389, 510, 11, 321, 434, 1417, 466, 257, 35456, 992, 13, 50668], "temperature": 0.0, "avg_logprob": -0.13762301067973293, "compression_ratio": 1.4937759336099585, "no_speech_prob": 0.0004801962641067803}, {"id": 25, "seek": 15616, "start": 162.24, "end": 168.88, "text": " Other examples of Kubernetes resources are pods, we already mentioned this, deployment,", "tokens": [50668, 5358, 5110, 295, 23145, 3593, 366, 31925, 11, 321, 1217, 2835, 341, 11, 19317, 11, 51000], "temperature": 0.0, "avg_logprob": -0.13762301067973293, "compression_ratio": 1.4937759336099585, "no_speech_prob": 0.0004801962641067803}, {"id": 26, "seek": 15616, "start": 168.88, "end": 174.56, "text": " jobs, service account, PVC, the persistent volume claims, config map, and so on.", "tokens": [51000, 4782, 11, 2643, 2696, 11, 46700, 11, 264, 24315, 5523, 9441, 11, 6662, 4471, 11, 293, 370, 322, 13, 51284], "temperature": 0.0, "avg_logprob": -0.13762301067973293, "compression_ratio": 1.4937759336099585, "no_speech_prob": 0.0004801962641067803}, {"id": 27, "seek": 15616, "start": 176.07999999999998, "end": 180.8, "text": " Then you have the so-called object meta, that's the part which allows you to uniquely identify an", "tokens": [51360, 1396, 291, 362, 264, 370, 12, 11880, 2657, 19616, 11, 300, 311, 264, 644, 597, 4045, 291, 281, 31474, 5876, 364, 51596], "temperature": 0.0, "avg_logprob": -0.13762301067973293, "compression_ratio": 1.4937759336099585, "no_speech_prob": 0.0004801962641067803}, {"id": 28, "seek": 18080, "start": 180.8, "end": 186.16000000000003, "text": " instance of a resource type. So here, we're dealing with an instance of a replica set called", "tokens": [50364, 5197, 295, 257, 7684, 2010, 13, 407, 510, 11, 321, 434, 6260, 365, 364, 5197, 295, 257, 35456, 992, 1219, 50632], "temperature": 0.0, "avg_logprob": -0.13727627524846717, "compression_ratio": 1.7376237623762376, "no_speech_prob": 0.0013244336005300283}, {"id": 29, "seek": 18080, "start": 186.16000000000003, "end": 192.96, "text": " frontend. And finally, you have the spec and status section. And the spec or specification", "tokens": [50632, 1868, 521, 13, 400, 2721, 11, 291, 362, 264, 1608, 293, 6558, 3541, 13, 400, 264, 1608, 420, 31256, 50972], "temperature": 0.0, "avg_logprob": -0.13727627524846717, "compression_ratio": 1.7376237623762376, "no_speech_prob": 0.0013244336005300283}, {"id": 30, "seek": 18080, "start": 193.76000000000002, "end": 198.88000000000002, "text": " represents the desired configuration. It's the desired state of this resource.", "tokens": [51012, 8855, 264, 14721, 11694, 13, 467, 311, 264, 14721, 1785, 295, 341, 7684, 13, 51268], "temperature": 0.0, "avg_logprob": -0.13727627524846717, "compression_ratio": 1.7376237623762376, "no_speech_prob": 0.0013244336005300283}, {"id": 31, "seek": 18080, "start": 200.32000000000002, "end": 205.92000000000002, "text": " Finally, the status provides the user with information about the last known state of the", "tokens": [51340, 6288, 11, 264, 6558, 6417, 264, 4195, 365, 1589, 466, 264, 1036, 2570, 1785, 295, 264, 51620], "temperature": 0.0, "avg_logprob": -0.13727627524846717, "compression_ratio": 1.7376237623762376, "no_speech_prob": 0.0013244336005300283}, {"id": 32, "seek": 20592, "start": 205.92, "end": 215.2, "text": " resource. And so what is a replica set, by the way? It is a way to encapsulate a pod definition.", "tokens": [50364, 7684, 13, 400, 370, 437, 307, 257, 35456, 992, 11, 538, 264, 636, 30, 467, 307, 257, 636, 281, 38745, 5256, 257, 2497, 7123, 13, 50828], "temperature": 0.0, "avg_logprob": -0.17068522489523585, "compression_ratio": 1.5966850828729282, "no_speech_prob": 0.001303454744629562}, {"id": 33, "seek": 20592, "start": 215.2, "end": 219.83999999999997, "text": " So that's one here in the template. That's a template of a pod, right? And the pod runs containers.", "tokens": [50828, 407, 300, 311, 472, 510, 294, 264, 12379, 13, 663, 311, 257, 12379, 295, 257, 2497, 11, 558, 30, 400, 264, 2497, 6676, 17089, 13, 51060], "temperature": 0.0, "avg_logprob": -0.17068522489523585, "compression_ratio": 1.5966850828729282, "no_speech_prob": 0.001303454744629562}, {"id": 34, "seek": 20592, "start": 220.72, "end": 226.88, "text": " And it adds a replica count to it. So here, it expresses that there should be three replica,", "tokens": [51104, 400, 309, 10860, 257, 35456, 1207, 281, 309, 13, 407, 510, 11, 309, 39204, 300, 456, 820, 312, 1045, 35456, 11, 51412], "temperature": 0.0, "avg_logprob": -0.17068522489523585, "compression_ratio": 1.5966850828729282, "no_speech_prob": 0.001303454744629562}, {"id": 35, "seek": 22688, "start": 226.96, "end": 234.64, "text": " three copy of this pod running. And if for whatever reason, a pod comes to fail,", "tokens": [50368, 1045, 5055, 295, 341, 2497, 2614, 13, 400, 498, 337, 2035, 1778, 11, 257, 2497, 1487, 281, 3061, 11, 50752], "temperature": 0.0, "avg_logprob": -0.09830428733200323, "compression_ratio": 1.5496688741721854, "no_speech_prob": 0.009550577960908413}, {"id": 36, "seek": 22688, "start": 236.32, "end": 242.79999999999998, "text": " then the replica set is there to ensure that a new copy of this pod is being created.", "tokens": [50836, 550, 264, 35456, 992, 307, 456, 281, 5586, 300, 257, 777, 5055, 295, 341, 2497, 307, 885, 2942, 13, 51160], "temperature": 0.0, "avg_logprob": -0.09830428733200323, "compression_ratio": 1.5496688741721854, "no_speech_prob": 0.009550577960908413}, {"id": 37, "seek": 22688, "start": 244.32, "end": 248.56, "text": " Let's see a replica set in actions to illustrate what we just said.", "tokens": [51236, 961, 311, 536, 257, 35456, 992, 294, 5909, 281, 23221, 437, 321, 445, 848, 13, 51448], "temperature": 0.0, "avg_logprob": -0.09830428733200323, "compression_ratio": 1.5496688741721854, "no_speech_prob": 0.009550577960908413}, {"id": 38, "seek": 24856, "start": 248.56, "end": 259.44, "text": " I'm on a Kubernetes cluster here. And I already have a replica set running on this pod, on this", "tokens": [50364, 286, 478, 322, 257, 23145, 13630, 510, 13, 400, 286, 1217, 362, 257, 35456, 992, 2614, 322, 341, 2497, 11, 322, 341, 50908], "temperature": 0.0, "avg_logprob": -0.1355422159259239, "compression_ratio": 1.755868544600939, "no_speech_prob": 0.002550415927544236}, {"id": 39, "seek": 24856, "start": 259.44, "end": 265.44, "text": " cluster. On the bottom right, you see the list of pods currently running on the cluster. So here,", "tokens": [50908, 13630, 13, 1282, 264, 2767, 558, 11, 291, 536, 264, 1329, 295, 31925, 4362, 2614, 322, 264, 13630, 13, 407, 510, 11, 51208], "temperature": 0.0, "avg_logprob": -0.1355422159259239, "compression_ratio": 1.755868544600939, "no_speech_prob": 0.002550415927544236}, {"id": 40, "seek": 24856, "start": 265.44, "end": 270.96, "text": " you have three pods, three engineering pods. And well, that makes actually sense because", "tokens": [51208, 291, 362, 1045, 31925, 11, 1045, 7043, 31925, 13, 400, 731, 11, 300, 1669, 767, 2020, 570, 51484], "temperature": 0.0, "avg_logprob": -0.1355422159259239, "compression_ratio": 1.755868544600939, "no_speech_prob": 0.002550415927544236}, {"id": 41, "seek": 24856, "start": 270.96, "end": 277.6, "text": " we have on this replica set configured that we would like to have a three pod running three", "tokens": [51484, 321, 362, 322, 341, 35456, 992, 30538, 300, 321, 576, 411, 281, 362, 257, 1045, 2497, 2614, 1045, 51816], "temperature": 0.0, "avg_logprob": -0.1355422159259239, "compression_ratio": 1.755868544600939, "no_speech_prob": 0.002550415927544236}, {"id": 42, "seek": 27760, "start": 277.6, "end": 284.08000000000004, "text": " copy of the engineering pod running. Let me take one pod and delete it.", "tokens": [50364, 5055, 295, 264, 7043, 2497, 2614, 13, 961, 385, 747, 472, 2497, 293, 12097, 309, 13, 50688], "temperature": 0.0, "avg_logprob": -0.14476669462103592, "compression_ratio": 1.4915254237288136, "no_speech_prob": 0.0005975367967039347}, {"id": 43, "seek": 27760, "start": 286.0, "end": 295.28000000000003, "text": " kubectl, delete pod, and the name of my pod. So what's going to happen? A new copy of a pod is", "tokens": [50784, 350, 836, 557, 75, 11, 12097, 2497, 11, 293, 264, 1315, 295, 452, 2497, 13, 407, 437, 311, 516, 281, 1051, 30, 316, 777, 5055, 295, 257, 2497, 307, 51248], "temperature": 0.0, "avg_logprob": -0.14476669462103592, "compression_ratio": 1.4915254237288136, "no_speech_prob": 0.0005975367967039347}, {"id": 44, "seek": 27760, "start": 295.28000000000003, "end": 300.40000000000003, "text": " recreated almost instantly. Well, that's the job of the replica set. That's exactly what it does.", "tokens": [51248, 850, 26559, 1920, 13518, 13, 1042, 11, 300, 311, 264, 1691, 295, 264, 35456, 992, 13, 663, 311, 2293, 437, 309, 775, 13, 51504], "temperature": 0.0, "avg_logprob": -0.14476669462103592, "compression_ratio": 1.4915254237288136, "no_speech_prob": 0.0005975367967039347}, {"id": 45, "seek": 30040, "start": 300.79999999999995, "end": 310.23999999999995, "text": " It ensures that three copies are running. All right, but where is this logic of recreating pods,", "tokens": [50384, 467, 28111, 300, 1045, 14341, 366, 2614, 13, 1057, 558, 11, 457, 689, 307, 341, 9952, 295, 850, 44613, 31925, 11, 50856], "temperature": 0.0, "avg_logprob": -0.1978560599727907, "compression_ratio": 1.5307262569832403, "no_speech_prob": 0.0016733893426135182}, {"id": 46, "seek": 30040, "start": 310.88, "end": 320.32, "text": " recreating copy of my pod actually implemented? Well, that's the job of controllers. So let's", "tokens": [50888, 850, 44613, 5055, 295, 452, 2497, 767, 12270, 30, 1042, 11, 300, 311, 264, 1691, 295, 26903, 13, 407, 718, 311, 51360], "temperature": 0.0, "avg_logprob": -0.1978560599727907, "compression_ratio": 1.5307262569832403, "no_speech_prob": 0.0016733893426135182}, {"id": 47, "seek": 30040, "start": 320.32, "end": 325.35999999999996, "text": " think about this. What is a controller? A controller in Kubernetes? It's a process.", "tokens": [51360, 519, 466, 341, 13, 708, 307, 257, 10561, 30, 316, 10561, 294, 23145, 30, 467, 311, 257, 1399, 13, 51612], "temperature": 0.0, "avg_logprob": -0.1978560599727907, "compression_ratio": 1.5307262569832403, "no_speech_prob": 0.0016733893426135182}, {"id": 48, "seek": 32536, "start": 326.32, "end": 332.72, "text": " It's a process that runs usually within the cluster as a pod. It's responsible for managing", "tokens": [50412, 467, 311, 257, 1399, 300, 6676, 2673, 1951, 264, 13630, 382, 257, 2497, 13, 467, 311, 6250, 337, 11642, 50732], "temperature": 0.0, "avg_logprob": -0.11079140995325668, "compression_ratio": 1.7735849056603774, "no_speech_prob": 0.0013883357169106603}, {"id": 49, "seek": 32536, "start": 332.72, "end": 340.24, "text": " a type of resource in the cluster. So there is a job controller for managing jobs. There's a", "tokens": [50732, 257, 2010, 295, 7684, 294, 264, 13630, 13, 407, 456, 307, 257, 1691, 10561, 337, 11642, 4782, 13, 821, 311, 257, 51108], "temperature": 0.0, "avg_logprob": -0.11079140995325668, "compression_ratio": 1.7735849056603774, "no_speech_prob": 0.0013883357169106603}, {"id": 50, "seek": 32536, "start": 340.24, "end": 346.56, "text": " deployment controllers for managing the lifecycle of deployments. And there is of course a replica", "tokens": [51108, 19317, 26903, 337, 11642, 264, 45722, 295, 7274, 1117, 13, 400, 456, 307, 295, 1164, 257, 35456, 51424], "temperature": 0.0, "avg_logprob": -0.11079140995325668, "compression_ratio": 1.7735849056603774, "no_speech_prob": 0.0013883357169106603}, {"id": 51, "seek": 32536, "start": 346.56, "end": 352.0, "text": " set controller, which we're going to see in a second. Behind the scene, how it works is that", "tokens": [51424, 992, 10561, 11, 597, 321, 434, 516, 281, 536, 294, 257, 1150, 13, 20475, 264, 4145, 11, 577, 309, 1985, 307, 300, 51696], "temperature": 0.0, "avg_logprob": -0.11079140995325668, "compression_ratio": 1.7735849056603774, "no_speech_prob": 0.0013883357169106603}, {"id": 52, "seek": 35200, "start": 352.0, "end": 359.76, "text": " it watches the Kubernetes API. Each time it is an event, like a creation, the update of the deletion", "tokens": [50364, 309, 17062, 264, 23145, 9362, 13, 6947, 565, 309, 307, 364, 2280, 11, 411, 257, 8016, 11, 264, 5623, 295, 264, 1103, 302, 313, 50752], "temperature": 0.0, "avg_logprob": -0.12427307697052652, "compression_ratio": 1.7017543859649122, "no_speech_prob": 0.000910972710698843}, {"id": 53, "seek": 35200, "start": 359.76, "end": 366.16, "text": " event, which is related to the type of resource that it manages, then it starts something called", "tokens": [50752, 2280, 11, 597, 307, 4077, 281, 264, 2010, 295, 7684, 300, 309, 22489, 11, 550, 309, 3719, 746, 1219, 51072], "temperature": 0.0, "avg_logprob": -0.12427307697052652, "compression_ratio": 1.7017543859649122, "no_speech_prob": 0.000910972710698843}, {"id": 54, "seek": 35200, "start": 366.16, "end": 372.72, "text": " its control loop. And the control loop, it's an id input and function, which role is to resolve the", "tokens": [51072, 1080, 1969, 6367, 13, 400, 264, 1969, 6367, 11, 309, 311, 364, 4496, 4846, 293, 2445, 11, 597, 3090, 307, 281, 14151, 264, 51400], "temperature": 0.0, "avg_logprob": -0.12427307697052652, "compression_ratio": 1.7017543859649122, "no_speech_prob": 0.000910972710698843}, {"id": 55, "seek": 35200, "start": 372.72, "end": 378.72, "text": " difference between the current state of the resource and its desired state. And it's also,", "tokens": [51400, 2649, 1296, 264, 2190, 1785, 295, 264, 7684, 293, 1080, 14721, 1785, 13, 400, 309, 311, 611, 11, 51700], "temperature": 0.0, "avg_logprob": -0.12427307697052652, "compression_ratio": 1.7017543859649122, "no_speech_prob": 0.000910972710698843}, {"id": 56, "seek": 37872, "start": 378.72, "end": 384.96000000000004, "text": " by the way, responsible for writing the status of the resource. So let's see an example real quick.", "tokens": [50364, 538, 264, 636, 11, 6250, 337, 3579, 264, 6558, 295, 264, 7684, 13, 407, 718, 311, 536, 364, 1365, 957, 1702, 13, 50676], "temperature": 0.0, "avg_logprob": -0.1045745892471142, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.00031502265483140945}, {"id": 57, "seek": 37872, "start": 384.96000000000004, "end": 391.52000000000004, "text": " This is the replica set controller or at least the simplified version of it. It implements a control", "tokens": [50676, 639, 307, 264, 35456, 992, 10561, 420, 412, 1935, 264, 26335, 3037, 295, 309, 13, 467, 704, 17988, 257, 1969, 51004], "temperature": 0.0, "avg_logprob": -0.1045745892471142, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.00031502265483140945}, {"id": 58, "seek": 37872, "start": 391.52000000000004, "end": 398.24, "text": " loop. And this control loop here in the middle is triggered every time a replica set is either", "tokens": [51004, 6367, 13, 400, 341, 1969, 6367, 510, 294, 264, 2808, 307, 21710, 633, 565, 257, 35456, 992, 307, 2139, 51340], "temperature": 0.0, "avg_logprob": -0.1045745892471142, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.00031502265483140945}, {"id": 59, "seek": 37872, "start": 398.24, "end": 406.8, "text": " created, updated or deleted in the cluster. The main aspects of this control loop is to", "tokens": [51340, 2942, 11, 10588, 420, 22981, 294, 264, 13630, 13, 440, 2135, 7270, 295, 341, 1969, 6367, 307, 281, 51768], "temperature": 0.0, "avg_logprob": -0.1045745892471142, "compression_ratio": 1.6872246696035242, "no_speech_prob": 0.00031502265483140945}, {"id": 60, "seek": 40680, "start": 406.88, "end": 415.68, "text": " first read the desired number of replicas from the replica set. That's the desired state, right?", "tokens": [50368, 700, 1401, 264, 14721, 1230, 295, 3248, 9150, 490, 264, 35456, 992, 13, 663, 311, 264, 14721, 1785, 11, 558, 30, 50808], "temperature": 0.0, "avg_logprob": -0.16927520751953126, "compression_ratio": 1.6900584795321638, "no_speech_prob": 0.000828410149551928}, {"id": 61, "seek": 40680, "start": 415.68, "end": 423.28000000000003, "text": " This here. Second, it's to read the current state of the resource. How many replicas of the", "tokens": [50808, 639, 510, 13, 5736, 11, 309, 311, 281, 1401, 264, 2190, 1785, 295, 264, 7684, 13, 1012, 867, 3248, 9150, 295, 264, 51188], "temperature": 0.0, "avg_logprob": -0.16927520751953126, "compression_ratio": 1.6900584795321638, "no_speech_prob": 0.000828410149551928}, {"id": 62, "seek": 40680, "start": 423.28000000000003, "end": 432.56, "text": " NGNX pod currently exist on the cluster? That's this here. And third, it will reconcile the resource", "tokens": [51188, 426, 38, 45, 55, 2497, 4362, 2514, 322, 264, 13630, 30, 663, 311, 341, 510, 13, 400, 2636, 11, 309, 486, 41059, 264, 7684, 51652], "temperature": 0.0, "avg_logprob": -0.16927520751953126, "compression_ratio": 1.6900584795321638, "no_speech_prob": 0.000828410149551928}, {"id": 63, "seek": 43256, "start": 432.64, "end": 437.76, "text": " state. That means that it calculates the difference between the desired and current", "tokens": [50368, 1785, 13, 663, 1355, 300, 309, 4322, 1024, 264, 2649, 1296, 264, 14721, 293, 2190, 50624], "temperature": 0.0, "avg_logprob": -0.1639051286001054, "compression_ratio": 1.6506024096385543, "no_speech_prob": 0.0012441665166988969}, {"id": 64, "seek": 43256, "start": 437.76, "end": 447.6, "text": " number of replicas. And it creates or deletes replicas or even it can do nothing if the current", "tokens": [50624, 1230, 295, 3248, 9150, 13, 400, 309, 7829, 420, 1103, 37996, 3248, 9150, 420, 754, 309, 393, 360, 1825, 498, 264, 2190, 51116], "temperature": 0.0, "avg_logprob": -0.1639051286001054, "compression_ratio": 1.6506024096385543, "no_speech_prob": 0.0012441665166988969}, {"id": 65, "seek": 43256, "start": 447.6, "end": 456.72, "text": " and desired number of replicas already match. And finally, its last responsibility is to write", "tokens": [51116, 293, 14721, 1230, 295, 3248, 9150, 1217, 2995, 13, 400, 2721, 11, 1080, 1036, 6357, 307, 281, 2464, 51572], "temperature": 0.0, "avg_logprob": -0.1639051286001054, "compression_ratio": 1.6506024096385543, "no_speech_prob": 0.0012441665166988969}, {"id": 66, "seek": 45672, "start": 456.8, "end": 464.32000000000005, "text": " the resources status. So this provides the end user or other controllers in the cluster", "tokens": [50368, 264, 3593, 6558, 13, 407, 341, 6417, 264, 917, 4195, 420, 661, 26903, 294, 264, 13630, 50744], "temperature": 0.0, "avg_logprob": -0.16092466425012658, "compression_ratio": 1.6682692307692308, "no_speech_prob": 0.0035926224663853645}, {"id": 67, "seek": 45672, "start": 464.32000000000005, "end": 470.72, "text": " information on the last known state of this resource. And they are similar built-in controllers,", "tokens": [50744, 1589, 322, 264, 1036, 2570, 1785, 295, 341, 7684, 13, 400, 436, 366, 2531, 3094, 12, 259, 26903, 11, 51064], "temperature": 0.0, "avg_logprob": -0.16092466425012658, "compression_ratio": 1.6682692307692308, "no_speech_prob": 0.0035926224663853645}, {"id": 68, "seek": 45672, "start": 470.72, "end": 476.48, "text": " as we mentioned, running for the deployment, for the jobs, for the PVCs, etc. For all", "tokens": [51064, 382, 321, 2835, 11, 2614, 337, 264, 19317, 11, 337, 264, 4782, 11, 337, 264, 46700, 82, 11, 5183, 13, 1171, 439, 51352], "temperature": 0.0, "avg_logprob": -0.16092466425012658, "compression_ratio": 1.6682692307692308, "no_speech_prob": 0.0035926224663853645}, {"id": 69, "seek": 45672, "start": 477.52000000000004, "end": 483.84000000000003, "text": " native Kubernetes resources, there is built-in controller for managing them.", "tokens": [51404, 8470, 23145, 3593, 11, 456, 307, 3094, 12, 259, 10561, 337, 11642, 552, 13, 51720], "temperature": 0.0, "avg_logprob": -0.16092466425012658, "compression_ratio": 1.6682692307692308, "no_speech_prob": 0.0035926224663853645}, {"id": 70, "seek": 48384, "start": 484.4, "end": 492.4, "text": " And, well, now you must wonder, wait, you keep talking about built-in controllers", "tokens": [50392, 400, 11, 731, 11, 586, 291, 1633, 2441, 11, 1699, 11, 291, 1066, 1417, 466, 3094, 12, 259, 26903, 50792], "temperature": 0.0, "avg_logprob": -0.22376441955566406, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0006665835389867425}, {"id": 71, "seek": 48384, "start": 492.4, "end": 498.71999999999997, "text": " and native Kubernetes resources. Why is that? Does that mean that there is such an external", "tokens": [50792, 293, 8470, 23145, 3593, 13, 1545, 307, 300, 30, 4402, 300, 914, 300, 456, 307, 1270, 364, 8320, 51108], "temperature": 0.0, "avg_logprob": -0.22376441955566406, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0006665835389867425}, {"id": 72, "seek": 48384, "start": 498.71999999999997, "end": 506.08, "text": " controller in the non-native resource? Well, yes, precisely that's exactly what there is,", "tokens": [51108, 10561, 294, 264, 2107, 12, 77, 1166, 7684, 30, 1042, 11, 2086, 11, 13402, 300, 311, 2293, 437, 456, 307, 11, 51476], "temperature": 0.0, "avg_logprob": -0.22376441955566406, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0006665835389867425}, {"id": 73, "seek": 48384, "start": 506.08, "end": 512.72, "text": " and that's exactly what operators are all about. Operators are about reusing these concepts", "tokens": [51476, 293, 300, 311, 2293, 437, 19077, 366, 439, 466, 13, 12480, 3391, 366, 466, 319, 7981, 613, 10392, 51808], "temperature": 0.0, "avg_logprob": -0.22376441955566406, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0006665835389867425}, {"id": 74, "seek": 51272, "start": 512.72, "end": 519.12, "text": " of Kubernetes resource and Kubernetes controller and create our own. So first, we're going to create", "tokens": [50364, 295, 23145, 7684, 293, 23145, 10561, 293, 1884, 527, 1065, 13, 407, 700, 11, 321, 434, 516, 281, 1884, 50684], "temperature": 0.0, "avg_logprob": -0.19911479949951172, "compression_ratio": 2.1049723756906076, "no_speech_prob": 0.004898745100945234}, {"id": 75, "seek": 51272, "start": 519.12, "end": 524.96, "text": " new resource types. Let's say, for example, we're going to create a resource type called Synapse.", "tokens": [50684, 777, 7684, 3467, 13, 961, 311, 584, 11, 337, 1365, 11, 321, 434, 516, 281, 1884, 257, 7684, 2010, 1219, 26155, 11145, 13, 50976], "temperature": 0.0, "avg_logprob": -0.19911479949951172, "compression_ratio": 2.1049723756906076, "no_speech_prob": 0.004898745100945234}, {"id": 76, "seek": 51272, "start": 524.96, "end": 530.72, "text": " In a second, we're going to create a custom controller to manage our brand new resource type.", "tokens": [50976, 682, 257, 1150, 11, 321, 434, 516, 281, 1884, 257, 2375, 10561, 281, 3067, 527, 3360, 777, 7684, 2010, 13, 51264], "temperature": 0.0, "avg_logprob": -0.19911479949951172, "compression_ratio": 2.1049723756906076, "no_speech_prob": 0.004898745100945234}, {"id": 77, "seek": 51272, "start": 530.72, "end": 536.72, "text": " So let's say we're going to create a Synapse controller responsible for all the business", "tokens": [51264, 407, 718, 311, 584, 321, 434, 516, 281, 1884, 257, 26155, 11145, 10561, 6250, 337, 439, 264, 1606, 51564], "temperature": 0.0, "avg_logprob": -0.19911479949951172, "compression_ratio": 2.1049723756906076, "no_speech_prob": 0.004898745100945234}, {"id": 78, "seek": 53672, "start": 537.6800000000001, "end": 547.36, "text": " logic of creating and managing a Synapse home server. So first, a new resource type.", "tokens": [50412, 9952, 295, 4084, 293, 11642, 257, 26155, 11145, 1280, 7154, 13, 407, 700, 11, 257, 777, 7684, 2010, 13, 50896], "temperature": 0.0, "avg_logprob": -0.15677114742905346, "compression_ratio": 1.4864864864864864, "no_speech_prob": 0.0012615913292393088}, {"id": 79, "seek": 53672, "start": 548.88, "end": 556.5600000000001, "text": " A new resource type. How are we going to do that? Well, we're using something called custom resource", "tokens": [50972, 316, 777, 7684, 2010, 13, 1012, 366, 321, 516, 281, 360, 300, 30, 1042, 11, 321, 434, 1228, 746, 1219, 2375, 7684, 51356], "temperature": 0.0, "avg_logprob": -0.15677114742905346, "compression_ratio": 1.4864864864864864, "no_speech_prob": 0.0012615913292393088}, {"id": 80, "seek": 53672, "start": 556.5600000000001, "end": 562.64, "text": " definition in Kubernetes. And this is a truly amazing feature of Kubernetes because CRDs,", "tokens": [51356, 7123, 294, 23145, 13, 400, 341, 307, 257, 4908, 2243, 4111, 295, 23145, 570, 14123, 35, 82, 11, 51660], "temperature": 0.0, "avg_logprob": -0.15677114742905346, "compression_ratio": 1.4864864864864864, "no_speech_prob": 0.0012615913292393088}, {"id": 81, "seek": 56264, "start": 562.72, "end": 568.64, "text": " the short name for custom resource definition, they provide a way to extend the Kubernetes API", "tokens": [50368, 264, 2099, 1315, 337, 2375, 7684, 7123, 11, 436, 2893, 257, 636, 281, 10101, 264, 23145, 9362, 50664], "temperature": 0.0, "avg_logprob": -0.08993520736694335, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.002014081459492445}, {"id": 82, "seek": 56264, "start": 569.36, "end": 576.0, "text": " using the Kubernetes API. That means that there is a resource type in Kubernetes natively,", "tokens": [50700, 1228, 264, 23145, 9362, 13, 663, 1355, 300, 456, 307, 257, 7684, 2010, 294, 23145, 8470, 356, 11, 51032], "temperature": 0.0, "avg_logprob": -0.08993520736694335, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.002014081459492445}, {"id": 83, "seek": 56264, "start": 576.0, "end": 584.3199999999999, "text": " which is called custom resource definition. And we can write our CRD as a manifest file", "tokens": [51032, 597, 307, 1219, 2375, 7684, 7123, 13, 400, 321, 393, 2464, 527, 14123, 35, 382, 257, 10067, 3991, 51448], "temperature": 0.0, "avg_logprob": -0.08993520736694335, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.002014081459492445}, {"id": 84, "seek": 56264, "start": 584.3199999999999, "end": 591.52, "text": " and create and query it with kubectl. So the CRD manifest will contain information about the new", "tokens": [51448, 293, 1884, 293, 14581, 309, 365, 350, 836, 557, 75, 13, 407, 264, 14123, 35, 10067, 486, 5304, 1589, 466, 264, 777, 51808], "temperature": 0.0, "avg_logprob": -0.08993520736694335, "compression_ratio": 1.6894977168949772, "no_speech_prob": 0.002014081459492445}, {"id": 85, "seek": 59152, "start": 591.52, "end": 600.64, "text": " resource, the custom resource, and such as its kind and its open API v3 schema. Open API v3 schema", "tokens": [50364, 7684, 11, 264, 2375, 7684, 11, 293, 1270, 382, 1080, 733, 293, 1080, 1269, 9362, 371, 18, 34078, 13, 7238, 9362, 371, 18, 34078, 50820], "temperature": 0.0, "avg_logprob": -0.12716992696126303, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0010035807499662042}, {"id": 86, "seek": 59152, "start": 600.64, "end": 605.84, "text": " is a set of definitions and rules that will describe the structure of our Kubernetes resource.", "tokens": [50820, 307, 257, 992, 295, 21988, 293, 4474, 300, 486, 6786, 264, 3877, 295, 527, 23145, 7684, 13, 51080], "temperature": 0.0, "avg_logprob": -0.12716992696126303, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0010035807499662042}, {"id": 87, "seek": 59152, "start": 607.6, "end": 614.96, "text": " So let's have a look. Let's have a look at custom resource definitions.", "tokens": [51168, 407, 718, 311, 362, 257, 574, 13, 961, 311, 362, 257, 574, 412, 2375, 7684, 21988, 13, 51536], "temperature": 0.0, "avg_logprob": -0.12716992696126303, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.0010035807499662042}, {"id": 88, "seek": 61496, "start": 615.84, "end": 622.08, "text": " As a matter of fact, on my Kubernetes cluster, there are already", "tokens": [50408, 1018, 257, 1871, 295, 1186, 11, 322, 452, 23145, 13630, 11, 456, 366, 1217, 50720], "temperature": 0.0, "avg_logprob": -0.1772905847300654, "compression_ratio": 1.423913043478261, "no_speech_prob": 0.004395646508783102}, {"id": 89, "seek": 61496, "start": 623.6, "end": 630.08, "text": " some CRDs installed and specifically CRDs for Synapse. And I can't dig into it. So here you see", "tokens": [50796, 512, 14123, 35, 82, 8899, 293, 4682, 14123, 35, 82, 337, 26155, 11145, 13, 400, 286, 393, 380, 2528, 666, 309, 13, 407, 510, 291, 536, 51120], "temperature": 0.0, "avg_logprob": -0.1772905847300654, "compression_ratio": 1.423913043478261, "no_speech_prob": 0.004395646508783102}, {"id": 90, "seek": 61496, "start": 630.08, "end": 637.44, "text": " I did the kubectl get custom resource definition because this type is natively present on Kubernetes.", "tokens": [51120, 286, 630, 264, 350, 836, 557, 75, 483, 2375, 7684, 7123, 570, 341, 2010, 307, 8470, 356, 1974, 322, 23145, 13, 51488], "temperature": 0.0, "avg_logprob": -0.1772905847300654, "compression_ratio": 1.423913043478261, "no_speech_prob": 0.004395646508783102}, {"id": 91, "seek": 63744, "start": 638.24, "end": 648.24, "text": " And I can also do things like get, this is the command I run, get custom resource definition,", "tokens": [50404, 400, 286, 393, 611, 360, 721, 411, 483, 11, 341, 307, 264, 5622, 286, 1190, 11, 483, 2375, 7684, 7123, 11, 50904], "temperature": 0.0, "avg_logprob": -0.2181172143845331, "compression_ratio": 1.5675675675675675, "no_speech_prob": 0.003998639993369579}, {"id": 92, "seek": 63744, "start": 648.24, "end": 656.48, "text": " the name of my Synapse CRD, that show YAML, that's to have it in a YAML output. And what I see here", "tokens": [50904, 264, 1315, 295, 452, 26155, 11145, 14123, 35, 11, 300, 855, 398, 2865, 43, 11, 300, 311, 281, 362, 309, 294, 257, 398, 2865, 43, 5598, 13, 400, 437, 286, 536, 510, 51316], "temperature": 0.0, "avg_logprob": -0.2181172143845331, "compression_ratio": 1.5675675675675675, "no_speech_prob": 0.003998639993369579}, {"id": 93, "seek": 63744, "start": 656.48, "end": 665.12, "text": " is how a CRD looks like. So there is a kind Kubernetes, kind, sorry, custom resource definition,", "tokens": [51316, 307, 577, 257, 14123, 35, 1542, 411, 13, 407, 456, 307, 257, 733, 23145, 11, 733, 11, 2597, 11, 2375, 7684, 7123, 11, 51748], "temperature": 0.0, "avg_logprob": -0.2181172143845331, "compression_ratio": 1.5675675675675675, "no_speech_prob": 0.003998639993369579}, {"id": 94, "seek": 66512, "start": 665.36, "end": 672.24, "text": " this is the type meta. Here we have the object meta on this meta data section", "tokens": [50376, 341, 307, 264, 2010, 19616, 13, 1692, 321, 362, 264, 2657, 19616, 322, 341, 19616, 1412, 3541, 50720], "temperature": 0.0, "avg_logprob": -0.0983058655098693, "compression_ratio": 1.6424242424242423, "no_speech_prob": 0.0011334437876939774}, {"id": 95, "seek": 66512, "start": 673.04, "end": 678.8, "text": " with the name of this CRD. And then we have the spec. And what is the spec of a CRD? Well,", "tokens": [50760, 365, 264, 1315, 295, 341, 14123, 35, 13, 400, 550, 321, 362, 264, 1608, 13, 400, 437, 307, 264, 1608, 295, 257, 14123, 35, 30, 1042, 11, 51048], "temperature": 0.0, "avg_logprob": -0.0983058655098693, "compression_ratio": 1.6424242424242423, "no_speech_prob": 0.0011334437876939774}, {"id": 96, "seek": 66512, "start": 678.8, "end": 687.2, "text": " it is describing a new resource. We are creating a new resource type in Kubernetes, a custom resource.", "tokens": [51048, 309, 307, 16141, 257, 777, 7684, 13, 492, 366, 4084, 257, 777, 7684, 2010, 294, 23145, 11, 257, 2375, 7684, 13, 51468], "temperature": 0.0, "avg_logprob": -0.0983058655098693, "compression_ratio": 1.6424242424242423, "no_speech_prob": 0.0011334437876939774}, {"id": 97, "seek": 68720, "start": 687.76, "end": 695.76, "text": " So how does this custom resource looks like? You have things, for example, such as the new kind", "tokens": [50392, 407, 577, 775, 341, 2375, 7684, 1542, 411, 30, 509, 362, 721, 11, 337, 1365, 11, 1270, 382, 264, 777, 733, 50792], "temperature": 0.0, "avg_logprob": -0.1631107852883535, "compression_ratio": 1.6054054054054054, "no_speech_prob": 0.002511310623958707}, {"id": 98, "seek": 68720, "start": 695.76, "end": 701.44, "text": " that you want to have created. You have information, for example, this is a namespaced resource or not.", "tokens": [50792, 300, 291, 528, 281, 362, 2942, 13, 509, 362, 1589, 11, 337, 1365, 11, 341, 307, 257, 5288, 47038, 7684, 420, 406, 13, 51076], "temperature": 0.0, "avg_logprob": -0.1631107852883535, "compression_ratio": 1.6054054054054054, "no_speech_prob": 0.002511310623958707}, {"id": 99, "seek": 68720, "start": 702.48, "end": 708.32, "text": " You could also have cluster wide resources. And you have, you see here that it's available in the", "tokens": [51128, 509, 727, 611, 362, 13630, 4874, 3593, 13, 400, 291, 362, 11, 291, 536, 510, 300, 309, 311, 2435, 294, 264, 51420], "temperature": 0.0, "avg_logprob": -0.1631107852883535, "compression_ratio": 1.6054054054054054, "no_speech_prob": 0.002511310623958707}, {"id": 100, "seek": 70832, "start": 708.32, "end": 717.84, "text": " v1, alpha one version. And you have the schema, open API v3 schema for this new custom resource,", "tokens": [50364, 371, 16, 11, 8961, 472, 3037, 13, 400, 291, 362, 264, 34078, 11, 1269, 9362, 371, 18, 34078, 337, 341, 777, 2375, 7684, 11, 50840], "temperature": 0.0, "avg_logprob": -0.2004487737019857, "compression_ratio": 1.595505617977528, "no_speech_prob": 0.0034827720373868942}, {"id": 101, "seek": 70832, "start": 717.84, "end": 724.0, "text": " this new Synapse custom resource. And on the top level, you have, you find things again,", "tokens": [50840, 341, 777, 26155, 11145, 2375, 7684, 13, 400, 322, 264, 1192, 1496, 11, 291, 362, 11, 291, 915, 721, 797, 11, 51148], "temperature": 0.0, "avg_logprob": -0.2004487737019857, "compression_ratio": 1.595505617977528, "no_speech_prob": 0.0034827720373868942}, {"id": 102, "seek": 70832, "start": 724.0, "end": 731.12, "text": " like API version on kind. So this is our beloved type meta, then the meta data section, the object", "tokens": [51148, 411, 9362, 3037, 322, 733, 13, 407, 341, 307, 527, 14553, 2010, 19616, 11, 550, 264, 19616, 1412, 3541, 11, 264, 2657, 51504], "temperature": 0.0, "avg_logprob": -0.2004487737019857, "compression_ratio": 1.595505617977528, "no_speech_prob": 0.0034827720373868942}, {"id": 103, "seek": 73112, "start": 731.12, "end": 740.0, "text": " meta that are common to all Kubernetes resources. And then you have the spec section and status", "tokens": [50364, 19616, 300, 366, 2689, 281, 439, 23145, 3593, 13, 400, 550, 291, 362, 264, 1608, 3541, 293, 6558, 50808], "temperature": 0.0, "avg_logprob": -0.17533679675030453, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.0043305871076881886}, {"id": 104, "seek": 73112, "start": 740.0, "end": 747.76, "text": " section. Again, we again find the second status. And here you see the descriptions of what is", "tokens": [50808, 3541, 13, 3764, 11, 321, 797, 915, 264, 1150, 6558, 13, 400, 510, 291, 536, 264, 24406, 295, 437, 307, 51196], "temperature": 0.0, "avg_logprob": -0.17533679675030453, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.0043305871076881886}, {"id": 105, "seek": 73112, "start": 747.76, "end": 754.08, "text": " contained into the spec. So here, for example, you have a Boolean called create new Postgres QL,", "tokens": [51196, 16212, 666, 264, 1608, 13, 407, 510, 11, 337, 1365, 11, 291, 362, 257, 23351, 28499, 1219, 1884, 777, 10223, 45189, 1249, 43, 11, 51512], "temperature": 0.0, "avg_logprob": -0.17533679675030453, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.0043305871076881886}, {"id": 106, "seek": 73112, "start": 754.08, "end": 760.0, "text": " by default, it's false. They have a section called home server. And with some information how to", "tokens": [51512, 538, 7576, 11, 309, 311, 7908, 13, 814, 362, 257, 3541, 1219, 1280, 7154, 13, 400, 365, 512, 1589, 577, 281, 51808], "temperature": 0.0, "avg_logprob": -0.17533679675030453, "compression_ratio": 1.658008658008658, "no_speech_prob": 0.0043305871076881886}, {"id": 107, "seek": 76000, "start": 760.0, "end": 769.04, "text": " configure your Synapse instance. So this CRD is there to describe our new Synapse resource type.", "tokens": [50364, 22162, 428, 26155, 11145, 5197, 13, 407, 341, 14123, 35, 307, 456, 281, 6786, 527, 777, 26155, 11145, 7684, 2010, 13, 50816], "temperature": 0.0, "avg_logprob": -0.11889172855176423, "compression_ratio": 1.565934065934066, "no_speech_prob": 0.002757261972874403}, {"id": 108, "seek": 76000, "start": 770.32, "end": 774.88, "text": " We're jumping a little bit ahead here. We'll come back to the Synapse CRD later. We're actually", "tokens": [50880, 492, 434, 11233, 257, 707, 857, 2286, 510, 13, 492, 603, 808, 646, 281, 264, 26155, 11145, 14123, 35, 1780, 13, 492, 434, 767, 51108], "temperature": 0.0, "avg_logprob": -0.11889172855176423, "compression_ratio": 1.565934065934066, "no_speech_prob": 0.002757261972874403}, {"id": 109, "seek": 76000, "start": 774.88, "end": 781.68, "text": " going to use it and create a Synapse instance. I just wanted to show you an example of a CRD", "tokens": [51108, 516, 281, 764, 309, 293, 1884, 257, 26155, 11145, 5197, 13, 286, 445, 1415, 281, 855, 291, 364, 1365, 295, 257, 14123, 35, 51448], "temperature": 0.0, "avg_logprob": -0.11889172855176423, "compression_ratio": 1.565934065934066, "no_speech_prob": 0.002757261972874403}, {"id": 110, "seek": 78168, "start": 781.68, "end": 790.88, "text": " manifest file. And because this, because this CRD is installed in the cluster,", "tokens": [50364, 10067, 3991, 13, 400, 570, 341, 11, 570, 341, 14123, 35, 307, 8899, 294, 264, 13630, 11, 50824], "temperature": 0.0, "avg_logprob": -0.1793142641094369, "compression_ratio": 1.4475138121546962, "no_speech_prob": 0.00817487295717001}, {"id": 111, "seek": 78168, "start": 790.88, "end": 799.28, "text": " I can now do things like kubectl get Synapse. What do I get back from the cluster from the", "tokens": [50824, 286, 393, 586, 360, 721, 411, 350, 836, 557, 75, 483, 26155, 11145, 13, 708, 360, 286, 483, 646, 490, 264, 13630, 490, 264, 51244], "temperature": 0.0, "avg_logprob": -0.1793142641094369, "compression_ratio": 1.4475138121546962, "no_speech_prob": 0.00817487295717001}, {"id": 112, "seek": 78168, "start": 799.28, "end": 806.88, "text": " API? No resources found in default namespace. Okay. And just to compare, if I would run this", "tokens": [51244, 9362, 30, 883, 3593, 1352, 294, 7576, 5288, 17940, 13, 1033, 13, 400, 445, 281, 6794, 11, 498, 286, 576, 1190, 341, 51624], "temperature": 0.0, "avg_logprob": -0.1793142641094369, "compression_ratio": 1.4475138121546962, "no_speech_prob": 0.00817487295717001}, {"id": 113, "seek": 80688, "start": 806.88, "end": 812.32, "text": " here, kubectl get not exist. This is a type which does not exist. I get a different message. This", "tokens": [50364, 510, 11, 350, 836, 557, 75, 483, 406, 2514, 13, 639, 307, 257, 2010, 597, 775, 406, 2514, 13, 286, 483, 257, 819, 3636, 13, 639, 50636], "temperature": 0.0, "avg_logprob": -0.11795883552700866, "compression_ratio": 1.7174887892376682, "no_speech_prob": 0.0008558640256524086}, {"id": 114, "seek": 80688, "start": 812.32, "end": 817.52, "text": " one, it's an error message. So the server doesn't have a resource type not exist, right? Synapse,", "tokens": [50636, 472, 11, 309, 311, 364, 6713, 3636, 13, 407, 264, 7154, 1177, 380, 362, 257, 7684, 2010, 406, 2514, 11, 558, 30, 26155, 11145, 11, 50896], "temperature": 0.0, "avg_logprob": -0.11795883552700866, "compression_ratio": 1.7174887892376682, "no_speech_prob": 0.0008558640256524086}, {"id": 115, "seek": 80688, "start": 817.52, "end": 826.56, "text": " we have created CRD. So the resource type Synapse is known. And now that we talked about custom", "tokens": [50896, 321, 362, 2942, 14123, 35, 13, 407, 264, 7684, 2010, 26155, 11145, 307, 2570, 13, 400, 586, 300, 321, 2825, 466, 2375, 51348], "temperature": 0.0, "avg_logprob": -0.11795883552700866, "compression_ratio": 1.7174887892376682, "no_speech_prob": 0.0008558640256524086}, {"id": 116, "seek": 80688, "start": 826.56, "end": 833.52, "text": " resources, we can talk about building a custom controller. So that's where we need to write", "tokens": [51348, 3593, 11, 321, 393, 751, 466, 2390, 257, 2375, 10561, 13, 407, 300, 311, 689, 321, 643, 281, 2464, 51696], "temperature": 0.0, "avg_logprob": -0.11795883552700866, "compression_ratio": 1.7174887892376682, "no_speech_prob": 0.0008558640256524086}, {"id": 117, "seek": 83352, "start": 833.52, "end": 839.36, "text": " some code and implement the actual logic of managing a simple Synapse instance, the business", "tokens": [50364, 512, 3089, 293, 4445, 264, 3539, 9952, 295, 11642, 257, 2199, 26155, 11145, 5197, 11, 264, 1606, 50656], "temperature": 0.0, "avg_logprob": -0.1311517565437917, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.008060364052653313}, {"id": 118, "seek": 83352, "start": 839.36, "end": 848.16, "text": " logic. Unfortunately, we have some SDKs available, which will help us with all the boilerplate code", "tokens": [50656, 9952, 13, 8590, 11, 321, 362, 512, 37135, 82, 2435, 11, 597, 486, 854, 505, 365, 439, 264, 39228, 37008, 3089, 51096], "temperature": 0.0, "avg_logprob": -0.1311517565437917, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.008060364052653313}, {"id": 119, "seek": 83352, "start": 848.16, "end": 854.56, "text": " come on to all operators, such as watching the API, cashing some requests, building work queues,", "tokens": [51096, 808, 322, 281, 439, 19077, 11, 1270, 382, 1976, 264, 9362, 11, 3058, 571, 512, 12475, 11, 2390, 589, 631, 1247, 11, 51416], "temperature": 0.0, "avg_logprob": -0.1311517565437917, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.008060364052653313}, {"id": 120, "seek": 83352, "start": 854.56, "end": 861.28, "text": " and so on. They also help with actually creating this CRD manifest that we just saw,", "tokens": [51416, 293, 370, 322, 13, 814, 611, 854, 365, 767, 4084, 341, 14123, 35, 10067, 300, 321, 445, 1866, 11, 51752], "temperature": 0.0, "avg_logprob": -0.1311517565437917, "compression_ratio": 1.5648535564853556, "no_speech_prob": 0.008060364052653313}, {"id": 121, "seek": 86128, "start": 861.28, "end": 867.68, "text": " because as you see, creating the open API with free schema by hand can be a little bit cumbersome.", "tokens": [50364, 570, 382, 291, 536, 11, 4084, 264, 1269, 9362, 365, 1737, 34078, 538, 1011, 393, 312, 257, 707, 857, 12713, 1616, 423, 13, 50684], "temperature": 0.0, "avg_logprob": -0.16904818310457118, "compression_ratio": 1.4385026737967914, "no_speech_prob": 0.00037394670653156936}, {"id": 122, "seek": 86128, "start": 867.68, "end": 875.1999999999999, "text": " So we also have tools in the SDK to help us bootstrap, generate actually those", "tokens": [50684, 407, 321, 611, 362, 3873, 294, 264, 37135, 281, 854, 505, 11450, 372, 4007, 11, 8460, 767, 729, 51060], "temperature": 0.0, "avg_logprob": -0.16904818310457118, "compression_ratio": 1.4385026737967914, "no_speech_prob": 0.00037394670653156936}, {"id": 123, "seek": 86128, "start": 876.24, "end": 884.16, "text": " CRD manifest files. So using an SDK really allows us to focus on writing the business logic", "tokens": [51112, 14123, 35, 10067, 7098, 13, 407, 1228, 364, 37135, 534, 4045, 505, 281, 1879, 322, 3579, 264, 1606, 9952, 51508], "temperature": 0.0, "avg_logprob": -0.16904818310457118, "compression_ratio": 1.4385026737967914, "no_speech_prob": 0.00037394670653156936}, {"id": 124, "seek": 88416, "start": 884.16, "end": 892.0, "text": " and how to manage our application. And yeah, so with that, we have it. We have seen", "tokens": [50364, 293, 577, 281, 3067, 527, 3861, 13, 400, 1338, 11, 370, 365, 300, 11, 321, 362, 309, 13, 492, 362, 1612, 50756], "temperature": 0.0, "avg_logprob": -0.09279731072877583, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.0024723915848881006}, {"id": 125, "seek": 88416, "start": 892.0, "end": 897.92, "text": " the main concepts behind Kubernetes operator. We talked about Kubernetes resources,", "tokens": [50756, 264, 2135, 10392, 2261, 23145, 12973, 13, 492, 2825, 466, 23145, 3593, 11, 51052], "temperature": 0.0, "avg_logprob": -0.09279731072877583, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.0024723915848881006}, {"id": 126, "seek": 88416, "start": 897.92, "end": 903.92, "text": " how they are structured. We saw how we can extend the Kubernetes API with custom resource definitions.", "tokens": [51052, 577, 436, 366, 18519, 13, 492, 1866, 577, 321, 393, 10101, 264, 23145, 9362, 365, 2375, 7684, 21988, 13, 51352], "temperature": 0.0, "avg_logprob": -0.09279731072877583, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.0024723915848881006}, {"id": 127, "seek": 88416, "start": 904.64, "end": 910.9599999999999, "text": " We talked about the controller pattern in Kubernetes and how controllers are responsible", "tokens": [51388, 492, 2825, 466, 264, 10561, 5102, 294, 23145, 293, 577, 26903, 366, 6250, 51704], "temperature": 0.0, "avg_logprob": -0.09279731072877583, "compression_ratio": 1.7259615384615385, "no_speech_prob": 0.0024723915848881006}, {"id": 128, "seek": 91096, "start": 910.96, "end": 918.4000000000001, "text": " for reconciling the state of the resource they manage. And we saw that we can write our own", "tokens": [50364, 337, 9993, 3208, 278, 264, 1785, 295, 264, 7684, 436, 3067, 13, 400, 321, 1866, 300, 321, 393, 2464, 527, 1065, 50736], "temperature": 0.0, "avg_logprob": -0.13124253352483115, "compression_ratio": 1.5774058577405858, "no_speech_prob": 0.0004044538945890963}, {"id": 129, "seek": 91096, "start": 918.4000000000001, "end": 924.72, "text": " controller with Operator SDK, for example. And hopefully by now, you have a good understanding", "tokens": [50736, 10561, 365, 12480, 1639, 37135, 11, 337, 1365, 13, 400, 4696, 538, 586, 11, 291, 362, 257, 665, 3701, 51052], "temperature": 0.0, "avg_logprob": -0.13124253352483115, "compression_ratio": 1.5774058577405858, "no_speech_prob": 0.0004044538945890963}, {"id": 130, "seek": 91096, "start": 924.72, "end": 929.12, "text": " of what operators are and do. Of course, there would be tons of other interesting details to", "tokens": [51052, 295, 437, 19077, 366, 293, 360, 13, 2720, 1164, 11, 456, 576, 312, 9131, 295, 661, 1880, 4365, 281, 51272], "temperature": 0.0, "avg_logprob": -0.13124253352483115, "compression_ratio": 1.5774058577405858, "no_speech_prob": 0.0004044538945890963}, {"id": 131, "seek": 91096, "start": 929.12, "end": 935.52, "text": " mention on Operator SDKs and CRDs and so on. But yeah, we have a limited amount of time today. So", "tokens": [51272, 2152, 322, 12480, 1639, 37135, 82, 293, 14123, 35, 82, 293, 370, 322, 13, 583, 1338, 11, 321, 362, 257, 5567, 2372, 295, 565, 965, 13, 407, 51592], "temperature": 0.0, "avg_logprob": -0.13124253352483115, "compression_ratio": 1.5774058577405858, "no_speech_prob": 0.0004044538945890963}, {"id": 132, "seek": 93552, "start": 935.52, "end": 941.36, "text": " this talk is actually about the Synapse operator. So let's move on to that part, finally.", "tokens": [50364, 341, 751, 307, 767, 466, 264, 26155, 11145, 12973, 13, 407, 718, 311, 1286, 322, 281, 300, 644, 11, 2721, 13, 50656], "temperature": 0.0, "avg_logprob": -0.16138718525568643, "compression_ratio": 1.5657894736842106, "no_speech_prob": 0.0017543263966217637}, {"id": 133, "seek": 93552, "start": 943.68, "end": 950.0799999999999, "text": " We have, so I made the choice to, of dividing this project into three CRDs.", "tokens": [50772, 492, 362, 11, 370, 286, 1027, 264, 3922, 281, 11, 295, 26764, 341, 1716, 666, 1045, 14123, 35, 82, 13, 51092], "temperature": 0.0, "avg_logprob": -0.16138718525568643, "compression_ratio": 1.5657894736842106, "no_speech_prob": 0.0017543263966217637}, {"id": 134, "seek": 93552, "start": 951.04, "end": 958.56, "text": " One for the Synapse home server and one for each bridges. So right now, this operator is able to", "tokens": [51140, 1485, 337, 264, 26155, 11145, 1280, 7154, 293, 472, 337, 1184, 21114, 13, 407, 558, 586, 11, 341, 12973, 307, 1075, 281, 51516], "temperature": 0.0, "avg_logprob": -0.16138718525568643, "compression_ratio": 1.5657894736842106, "no_speech_prob": 0.0017543263966217637}, {"id": 135, "seek": 93552, "start": 958.56, "end": 964.72, "text": " manage two bridges, the Heisen bridge, so this is for IRC and matrix signal, which as the name", "tokens": [51516, 3067, 732, 21114, 11, 264, 634, 11106, 7283, 11, 370, 341, 307, 337, 16486, 34, 293, 8141, 6358, 11, 597, 382, 264, 1315, 51824], "temperature": 0.0, "avg_logprob": -0.16138718525568643, "compression_ratio": 1.5657894736842106, "no_speech_prob": 0.0017543263966217637}, {"id": 136, "seek": 96472, "start": 964.72, "end": 973.12, "text": " suggests is for signal. That means that you can manage each component individually and", "tokens": [50364, 13409, 307, 337, 6358, 13, 663, 1355, 300, 291, 393, 3067, 1184, 6542, 16652, 293, 50784], "temperature": 0.0, "avg_logprob": -0.07210239497098056, "compression_ratio": 1.489247311827957, "no_speech_prob": 0.00032495983759872615}, {"id": 137, "seek": 96472, "start": 973.12, "end": 981.12, "text": " independently. That's a model which would scale also better if and when additional components", "tokens": [50784, 21761, 13, 663, 311, 257, 2316, 597, 576, 4373, 611, 1101, 498, 293, 562, 4497, 6677, 51184], "temperature": 0.0, "avg_logprob": -0.07210239497098056, "compression_ratio": 1.489247311827957, "no_speech_prob": 0.00032495983759872615}, {"id": 138, "seek": 96472, "start": 981.12, "end": 988.48, "text": " are added to the project. So let's have a look at the CRDs individually. First, the Synapse CRD.", "tokens": [51184, 366, 3869, 281, 264, 1716, 13, 407, 718, 311, 362, 257, 574, 412, 264, 14123, 35, 82, 16652, 13, 2386, 11, 264, 26155, 11145, 14123, 35, 13, 51552], "temperature": 0.0, "avg_logprob": -0.07210239497098056, "compression_ratio": 1.489247311827957, "no_speech_prob": 0.00032495983759872615}, {"id": 139, "seek": 98848, "start": 988.48, "end": 994.64, "text": " So we saw this already before and as the name suggests, it allows us to deploy a Synapse home", "tokens": [50364, 407, 321, 1866, 341, 1217, 949, 293, 382, 264, 1315, 13409, 11, 309, 4045, 505, 281, 7274, 257, 26155, 11145, 1280, 50672], "temperature": 0.0, "avg_logprob": -0.1039182980855306, "compression_ratio": 1.5319148936170213, "no_speech_prob": 0.0001313410175498575}, {"id": 140, "seek": 98848, "start": 994.64, "end": 1000.48, "text": " server. By default, it will use the SQLite database, which is shipped within the Synapse", "tokens": [50672, 7154, 13, 3146, 7576, 11, 309, 486, 764, 264, 19200, 642, 8149, 11, 597, 307, 25312, 1951, 264, 26155, 11145, 50964], "temperature": 0.0, "avg_logprob": -0.1039182980855306, "compression_ratio": 1.5319148936170213, "no_speech_prob": 0.0001313410175498575}, {"id": 141, "seek": 98848, "start": 1000.48, "end": 1005.12, "text": " Docker image. But there are also ways to work with Postgres. We'll talk about that a little bit later.", "tokens": [50964, 33772, 3256, 13, 583, 456, 366, 611, 2098, 281, 589, 365, 10223, 45189, 13, 492, 603, 751, 466, 300, 257, 707, 857, 1780, 13, 51196], "temperature": 0.0, "avg_logprob": -0.1039182980855306, "compression_ratio": 1.5319148936170213, "no_speech_prob": 0.0001313410175498575}, {"id": 142, "seek": 98848, "start": 1006.64, "end": 1009.9200000000001, "text": " In order to deploy Synapse, we need to provide some configuration options.", "tokens": [51272, 682, 1668, 281, 7274, 26155, 11145, 11, 321, 643, 281, 2893, 512, 11694, 3956, 13, 51436], "temperature": 0.0, "avg_logprob": -0.1039182980855306, "compression_ratio": 1.5319148936170213, "no_speech_prob": 0.0001313410175498575}, {"id": 143, "seek": 100992, "start": 1010.7199999999999, "end": 1017.12, "text": " To do that, we need a configuration file, which is called home server.yaml.", "tokens": [50404, 1407, 360, 300, 11, 321, 643, 257, 11694, 3991, 11, 597, 307, 1219, 1280, 7154, 13, 88, 335, 75, 13, 50724], "temperature": 0.0, "avg_logprob": -0.1049703870500837, "compression_ratio": 1.6388888888888888, "no_speech_prob": 0.00041082530515268445}, {"id": 144, "seek": 100992, "start": 1017.76, "end": 1023.1999999999999, "text": " And as you know, if you've dealt with Synapse before, this is a very long file. There are", "tokens": [50756, 400, 382, 291, 458, 11, 498, 291, 600, 15991, 365, 26155, 11145, 949, 11, 341, 307, 257, 588, 938, 3991, 13, 821, 366, 51028], "temperature": 0.0, "avg_logprob": -0.1049703870500837, "compression_ratio": 1.6388888888888888, "no_speech_prob": 0.00041082530515268445}, {"id": 145, "seek": 100992, "start": 1023.1999999999999, "end": 1028.1599999999999, "text": " lots of configuration options. So therefore, I made the choice of providing users of the", "tokens": [51028, 3195, 295, 11694, 3956, 13, 407, 4412, 11, 286, 1027, 264, 3922, 295, 6530, 5022, 295, 264, 51276], "temperature": 0.0, "avg_logprob": -0.1049703870500837, "compression_ratio": 1.6388888888888888, "no_speech_prob": 0.00041082530515268445}, {"id": 146, "seek": 100992, "start": 1028.1599999999999, "end": 1035.36, "text": " Synapse operator with two options for configuring their Synapse instance. As a user, you can either", "tokens": [51276, 26155, 11145, 12973, 365, 732, 3956, 337, 6662, 1345, 641, 26155, 11145, 5197, 13, 1018, 257, 4195, 11, 291, 393, 2139, 51636], "temperature": 0.0, "avg_logprob": -0.1049703870500837, "compression_ratio": 1.6388888888888888, "no_speech_prob": 0.00041082530515268445}, {"id": 147, "seek": 103536, "start": 1035.36, "end": 1040.32, "text": " provide the two mandatory configuration options directly in the Synapse manifest.", "tokens": [50364, 2893, 264, 732, 22173, 11694, 3956, 3838, 294, 264, 26155, 11145, 10067, 13, 50612], "temperature": 0.0, "avg_logprob": -0.17084037966844512, "compression_ratio": 1.815, "no_speech_prob": 0.000465417600935325}, {"id": 148, "seek": 103536, "start": 1040.32, "end": 1046.0, "text": " These two mandatory options are the name of your server and whether or not to report statistics.", "tokens": [50612, 1981, 732, 22173, 3956, 366, 264, 1315, 295, 428, 7154, 293, 1968, 420, 406, 281, 2275, 12523, 13, 50896], "temperature": 0.0, "avg_logprob": -0.17084037966844512, "compression_ratio": 1.815, "no_speech_prob": 0.000465417600935325}, {"id": 149, "seek": 103536, "start": 1046.6399999999999, "end": 1054.08, "text": " The Synapse operator then uses the default values and the rest of the home server.yaml", "tokens": [50928, 440, 26155, 11145, 12973, 550, 4960, 264, 7576, 4190, 293, 264, 1472, 295, 264, 1280, 7154, 13, 88, 335, 75, 51300], "temperature": 0.0, "avg_logprob": -0.17084037966844512, "compression_ratio": 1.815, "no_speech_prob": 0.000465417600935325}, {"id": 150, "seek": 103536, "start": 1054.08, "end": 1059.12, "text": " with default values. Actually, it uses a default home server.yaml template and feeds those values", "tokens": [51300, 365, 7576, 4190, 13, 5135, 11, 309, 4960, 257, 7576, 1280, 7154, 13, 88, 335, 75, 12379, 293, 23712, 729, 4190, 51552], "temperature": 0.0, "avg_logprob": -0.17084037966844512, "compression_ratio": 1.815, "no_speech_prob": 0.000465417600935325}, {"id": 151, "seek": 105912, "start": 1059.12, "end": 1064.9599999999998, "text": " into it. And this is especially useful if you don't have a home server.yaml at hand", "tokens": [50364, 666, 309, 13, 400, 341, 307, 2318, 4420, 498, 291, 500, 380, 362, 257, 1280, 7154, 13, 88, 335, 75, 412, 1011, 50656], "temperature": 0.0, "avg_logprob": -0.0879808919770377, "compression_ratio": 1.7423076923076923, "no_speech_prob": 0.004904487170279026}, {"id": 152, "seek": 105912, "start": 1065.6799999999998, "end": 1070.2399999999998, "text": " or just want to quick start in a project, quickly test the capability of this operator", "tokens": [50692, 420, 445, 528, 281, 1702, 722, 294, 257, 1716, 11, 2661, 1500, 264, 13759, 295, 341, 12973, 50920], "temperature": 0.0, "avg_logprob": -0.0879808919770377, "compression_ratio": 1.7423076923076923, "no_speech_prob": 0.004904487170279026}, {"id": 153, "seek": 105912, "start": 1070.2399999999998, "end": 1075.4399999999998, "text": " and just want to get a Synapse instance running. However, if you need more control over the", "tokens": [50920, 293, 445, 528, 281, 483, 257, 26155, 11145, 5197, 2614, 13, 2908, 11, 498, 291, 643, 544, 1969, 670, 264, 51180], "temperature": 0.0, "avg_logprob": -0.0879808919770377, "compression_ratio": 1.7423076923076923, "no_speech_prob": 0.004904487170279026}, {"id": 154, "seek": 105912, "start": 1075.4399999999998, "end": 1080.6399999999999, "text": " configuration of Synapse, which is totally understandable, or if you already have a home", "tokens": [51180, 11694, 295, 26155, 11145, 11, 597, 307, 3879, 25648, 11, 420, 498, 291, 1217, 362, 257, 1280, 51440], "temperature": 0.0, "avg_logprob": -0.0879808919770377, "compression_ratio": 1.7423076923076923, "no_speech_prob": 0.004904487170279026}, {"id": 155, "seek": 105912, "start": 1080.6399999999999, "end": 1087.4399999999998, "text": " server.yaml, then you want to go with the second option. And that is creating a config map containing", "tokens": [51440, 7154, 13, 88, 335, 75, 11, 550, 291, 528, 281, 352, 365, 264, 1150, 3614, 13, 400, 300, 307, 4084, 257, 6662, 4471, 19273, 51780], "temperature": 0.0, "avg_logprob": -0.0879808919770377, "compression_ratio": 1.7423076923076923, "no_speech_prob": 0.004904487170279026}, {"id": 156, "seek": 108744, "start": 1087.44, "end": 1092.96, "text": " the home server.yaml and feeding it to the Synapse resource. We're going to see this", "tokens": [50364, 264, 1280, 7154, 13, 88, 335, 75, 293, 12919, 309, 281, 264, 26155, 11145, 7684, 13, 492, 434, 516, 281, 536, 341, 50640], "temperature": 0.0, "avg_logprob": -0.08433890342712402, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.0008552010403946042}, {"id": 157, "seek": 108744, "start": 1093.76, "end": 1100.16, "text": " in a second with examples. The Synapse operator automatically will use your custom home server", "tokens": [50680, 294, 257, 1150, 365, 5110, 13, 440, 26155, 11145, 12973, 6772, 486, 764, 428, 2375, 1280, 7154, 51000], "temperature": 0.0, "avg_logprob": -0.08433890342712402, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.0008552010403946042}, {"id": 158, "seek": 108744, "start": 1100.16, "end": 1105.2, "text": " yaml. Actually, it will make a copy of it and it will use it to configure Synapse.", "tokens": [51000, 288, 335, 75, 13, 5135, 11, 309, 486, 652, 257, 5055, 295, 309, 293, 309, 486, 764, 309, 281, 22162, 26155, 11145, 13, 51252], "temperature": 0.0, "avg_logprob": -0.08433890342712402, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.0008552010403946042}, {"id": 159, "seek": 108744, "start": 1106.8, "end": 1113.44, "text": " Let's see a little demo of this. So, we're back on our Kubernetes cluster. On the top right,", "tokens": [51332, 961, 311, 536, 257, 707, 10723, 295, 341, 13, 407, 11, 321, 434, 646, 322, 527, 23145, 13630, 13, 1282, 264, 1192, 558, 11, 51664], "temperature": 0.0, "avg_logprob": -0.08433890342712402, "compression_ratio": 1.5848214285714286, "no_speech_prob": 0.0008552010403946042}, {"id": 160, "seek": 111344, "start": 1113.44, "end": 1119.8400000000001, "text": " you see the logs of the three controllers, the Synapse controller, the Heisenbridge controller", "tokens": [50364, 291, 536, 264, 20820, 295, 264, 1045, 26903, 11, 264, 26155, 11145, 10561, 11, 264, 634, 11106, 18249, 10561, 50684], "temperature": 0.0, "avg_logprob": -0.14026059887625955, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.001064642216078937}, {"id": 161, "seek": 111344, "start": 1119.8400000000001, "end": 1124.88, "text": " and the Motrix signal controller, which are running in the cluster. All the logs of those three", "tokens": [50684, 293, 264, 8956, 6579, 6358, 10561, 11, 597, 366, 2614, 294, 264, 13630, 13, 1057, 264, 20820, 295, 729, 1045, 50936], "temperature": 0.0, "avg_logprob": -0.14026059887625955, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.001064642216078937}, {"id": 162, "seek": 111344, "start": 1124.88, "end": 1130.72, "text": " controllers are here on the top right of your screen. On the bottom right, you again have the", "tokens": [50936, 26903, 366, 510, 322, 264, 1192, 558, 295, 428, 2568, 13, 1282, 264, 2767, 558, 11, 291, 797, 362, 264, 51228], "temperature": 0.0, "avg_logprob": -0.14026059887625955, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.001064642216078937}, {"id": 163, "seek": 111344, "start": 1130.72, "end": 1135.44, "text": " list of pod running in the cluster and the default namespace. Currently, there are none.", "tokens": [51228, 1329, 295, 2497, 2614, 294, 264, 13630, 293, 264, 7576, 5288, 17940, 13, 19964, 11, 456, 366, 6022, 13, 51464], "temperature": 0.0, "avg_logprob": -0.14026059887625955, "compression_ratio": 1.855721393034826, "no_speech_prob": 0.001064642216078937}, {"id": 164, "seek": 113544, "start": 1136.16, "end": 1143.28, "text": " And on the left side, that's where we're going to issue some commands. Let's go ahead and create", "tokens": [50400, 400, 322, 264, 1411, 1252, 11, 300, 311, 689, 321, 434, 516, 281, 2734, 512, 16901, 13, 961, 311, 352, 2286, 293, 1884, 50756], "temperature": 0.0, "avg_logprob": -0.157869395087747, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.021217383444309235}, {"id": 165, "seek": 113544, "start": 1143.28, "end": 1149.8400000000001, "text": " our first Synapse instance. This one is going to use, so this one you see, it's a kind Synapse.", "tokens": [50756, 527, 700, 26155, 11145, 5197, 13, 639, 472, 307, 516, 281, 764, 11, 370, 341, 472, 291, 536, 11, 309, 311, 257, 733, 26155, 11145, 13, 51084], "temperature": 0.0, "avg_logprob": -0.157869395087747, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.021217383444309235}, {"id": 166, "seek": 113544, "start": 1149.8400000000001, "end": 1155.52, "text": " And with the name called MySynapse. And this one is going to use values. We're going to use,", "tokens": [51084, 400, 365, 264, 1315, 1219, 1222, 50, 2534, 11145, 13, 400, 341, 472, 307, 516, 281, 764, 4190, 13, 492, 434, 516, 281, 764, 11, 51368], "temperature": 0.0, "avg_logprob": -0.157869395087747, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.021217383444309235}, {"id": 167, "seek": 113544, "start": 1155.52, "end": 1160.4, "text": " provide some values in the spec section of our manifest file, the name of the server,", "tokens": [51368, 2893, 512, 4190, 294, 264, 1608, 3541, 295, 527, 10067, 3991, 11, 264, 1315, 295, 264, 7154, 11, 51612], "temperature": 0.0, "avg_logprob": -0.157869395087747, "compression_ratio": 1.7175925925925926, "no_speech_prob": 0.021217383444309235}, {"id": 168, "seek": 116040, "start": 1160.4, "end": 1165.68, "text": " which is called myserver.com. And whether or not to report that here, true, because we are a good", "tokens": [50364, 597, 307, 1219, 452, 12484, 331, 13, 1112, 13, 400, 1968, 420, 406, 281, 2275, 300, 510, 11, 2074, 11, 570, 321, 366, 257, 665, 50628], "temperature": 0.0, "avg_logprob": -0.1355611525083843, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0033167048823088408}, {"id": 169, "seek": 116040, "start": 1165.68, "end": 1174.0800000000002, "text": " citizen. And we are going to go ahead and create this Synapse instance. What we see here on the", "tokens": [50628, 13326, 13, 400, 321, 366, 516, 281, 352, 2286, 293, 1884, 341, 26155, 11145, 5197, 13, 708, 321, 536, 510, 322, 264, 51048], "temperature": 0.0, "avg_logprob": -0.1355611525083843, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0033167048823088408}, {"id": 170, "seek": 116040, "start": 1174.0800000000002, "end": 1182.96, "text": " right side is the Synapse controller getting to work. And that's business logic, right, which is", "tokens": [51048, 558, 1252, 307, 264, 26155, 11145, 10561, 1242, 281, 589, 13, 400, 300, 311, 1606, 9952, 11, 558, 11, 597, 307, 51492], "temperature": 0.0, "avg_logprob": -0.1355611525083843, "compression_ratio": 1.5263157894736843, "no_speech_prob": 0.0033167048823088408}, {"id": 171, "seek": 118296, "start": 1182.96, "end": 1191.1200000000001, "text": " in the Synapse instance. It compares the desired state of this resource. So please have a home", "tokens": [50364, 294, 264, 26155, 11145, 5197, 13, 467, 38334, 264, 14721, 1785, 295, 341, 7684, 13, 407, 1767, 362, 257, 1280, 50772], "temperature": 0.0, "avg_logprob": -0.14731712931210234, "compression_ratio": 1.6943231441048034, "no_speech_prob": 0.0017004222609102726}, {"id": 172, "seek": 118296, "start": 1191.1200000000001, "end": 1196.96, "text": " server running with this configuration values. And the current state, what do I currently have in", "tokens": [50772, 7154, 2614, 365, 341, 11694, 4190, 13, 400, 264, 2190, 1785, 11, 437, 360, 286, 4362, 362, 294, 51064], "temperature": 0.0, "avg_logprob": -0.14731712931210234, "compression_ratio": 1.6943231441048034, "no_speech_prob": 0.0017004222609102726}, {"id": 173, "seek": 118296, "start": 1196.96, "end": 1203.2, "text": " a cluster? Nothing. I don't have a Synapse instance running. I don't have a pod for my Synapse instance.", "tokens": [51064, 257, 13630, 30, 6693, 13, 286, 500, 380, 362, 257, 26155, 11145, 5197, 2614, 13, 286, 500, 380, 362, 257, 2497, 337, 452, 26155, 11145, 5197, 13, 51376], "temperature": 0.0, "avg_logprob": -0.14731712931210234, "compression_ratio": 1.6943231441048034, "no_speech_prob": 0.0017004222609102726}, {"id": 174, "seek": 118296, "start": 1203.2, "end": 1211.76, "text": " So this is what then creates all the necessary objects, a deployment, a config map, a PDC,", "tokens": [51376, 407, 341, 307, 437, 550, 7829, 439, 264, 4818, 6565, 11, 257, 19317, 11, 257, 6662, 4471, 11, 257, 10464, 34, 11, 51804], "temperature": 0.0, "avg_logprob": -0.14731712931210234, "compression_ratio": 1.6943231441048034, "no_speech_prob": 0.0017004222609102726}, {"id": 175, "seek": 121176, "start": 1211.76, "end": 1226.48, "text": " and so on and so on. And now I can check that my Synapse is being created. So as you see,", "tokens": [50364, 293, 370, 322, 293, 370, 322, 13, 400, 586, 286, 393, 1520, 300, 452, 26155, 11145, 307, 885, 2942, 13, 407, 382, 291, 536, 11, 51100], "temperature": 0.0, "avg_logprob": -0.14149596009935653, "compression_ratio": 1.435483870967742, "no_speech_prob": 0.00460821483284235}, {"id": 176, "seek": 121176, "start": 1226.48, "end": 1236.24, "text": " get Synapse, right? This time I have one. I get this one back in. I can check my Synapse", "tokens": [51100, 483, 26155, 11145, 11, 558, 30, 639, 565, 286, 362, 472, 13, 286, 483, 341, 472, 646, 294, 13, 286, 393, 1520, 452, 26155, 11145, 51588], "temperature": 0.0, "avg_logprob": -0.14149596009935653, "compression_ratio": 1.435483870967742, "no_speech_prob": 0.00460821483284235}, {"id": 177, "seek": 123624, "start": 1236.72, "end": 1243.52, "text": " status. And I see that some information on the home server configuration has been populated.", "tokens": [50388, 6558, 13, 400, 286, 536, 300, 512, 1589, 322, 264, 1280, 7154, 11694, 575, 668, 32998, 13, 50728], "temperature": 0.0, "avg_logprob": -0.12905442374093193, "compression_ratio": 1.4973262032085561, "no_speech_prob": 0.005819234531372786}, {"id": 178, "seek": 123624, "start": 1243.52, "end": 1250.56, "text": " Well, in this case, it's pretty straightforward. It's basically a copy of the values. And you", "tokens": [50728, 1042, 11, 294, 341, 1389, 11, 309, 311, 1238, 15325, 13, 467, 311, 1936, 257, 5055, 295, 264, 4190, 13, 400, 291, 51080], "temperature": 0.0, "avg_logprob": -0.12905442374093193, "compression_ratio": 1.4973262032085561, "no_speech_prob": 0.005819234531372786}, {"id": 179, "seek": 123624, "start": 1250.56, "end": 1262.24, "text": " can see that this Synapse instance is running. In fact, yes, you check a bit the logs of this", "tokens": [51080, 393, 536, 300, 341, 26155, 11145, 5197, 307, 2614, 13, 682, 1186, 11, 2086, 11, 291, 1520, 257, 857, 264, 20820, 295, 341, 51664], "temperature": 0.0, "avg_logprob": -0.12905442374093193, "compression_ratio": 1.4973262032085561, "no_speech_prob": 0.005819234531372786}, {"id": 180, "seek": 126224, "start": 1262.32, "end": 1271.28, "text": " Synapse pod here. You see that, well, the usual have been created, the usual have been displayed", "tokens": [50368, 26155, 11145, 2497, 510, 13, 509, 536, 300, 11, 731, 11, 264, 7713, 362, 668, 2942, 11, 264, 7713, 362, 668, 16372, 50816], "temperature": 0.0, "avg_logprob": -0.14873020069019213, "compression_ratio": 1.6686046511627908, "no_speech_prob": 0.001454935292713344}, {"id": 181, "seek": 126224, "start": 1271.28, "end": 1280.0, "text": " here with some info on this Synapse instance is running. Now we're going to move to the second", "tokens": [50816, 510, 365, 512, 13614, 322, 341, 26155, 11145, 5197, 307, 2614, 13, 823, 321, 434, 516, 281, 1286, 281, 264, 1150, 51252], "temperature": 0.0, "avg_logprob": -0.14873020069019213, "compression_ratio": 1.6686046511627908, "no_speech_prob": 0.001454935292713344}, {"id": 182, "seek": 126224, "start": 1280.0, "end": 1288.16, "text": " example. Now that we have seen how to create a Synapse using values, we're going to see how you", "tokens": [51252, 1365, 13, 823, 300, 321, 362, 1612, 577, 281, 1884, 257, 26155, 11145, 1228, 4190, 11, 321, 434, 516, 281, 536, 577, 291, 51660], "temperature": 0.0, "avg_logprob": -0.14873020069019213, "compression_ratio": 1.6686046511627908, "no_speech_prob": 0.001454935292713344}, {"id": 183, "seek": 128816, "start": 1288.16, "end": 1292.48, "text": " can do that with a custom home server, the YAML. Let's say you have your custom home server YAML.", "tokens": [50364, 393, 360, 300, 365, 257, 2375, 1280, 7154, 11, 264, 398, 2865, 43, 13, 961, 311, 584, 291, 362, 428, 2375, 1280, 7154, 398, 2865, 43, 13, 50580], "temperature": 0.0, "avg_logprob": -0.13317916078387565, "compression_ratio": 1.829268292682927, "no_speech_prob": 0.006903356406837702}, {"id": 184, "seek": 128816, "start": 1292.48, "end": 1303.68, "text": " This time, you have configured a server name, my matrix host. And you want to use this for", "tokens": [50580, 639, 565, 11, 291, 362, 30538, 257, 7154, 1315, 11, 452, 8141, 3975, 13, 400, 291, 528, 281, 764, 341, 337, 51140], "temperature": 0.0, "avg_logprob": -0.13317916078387565, "compression_ratio": 1.829268292682927, "no_speech_prob": 0.006903356406837702}, {"id": 185, "seek": 128816, "start": 1303.68, "end": 1311.76, "text": " configuring Synapse. What you do here is create a config map for this home server YAML. So here", "tokens": [51140, 6662, 1345, 26155, 11145, 13, 708, 291, 360, 510, 307, 1884, 257, 6662, 4471, 337, 341, 1280, 7154, 398, 2865, 43, 13, 407, 510, 51544], "temperature": 0.0, "avg_logprob": -0.13317916078387565, "compression_ratio": 1.829268292682927, "no_speech_prob": 0.006903356406837702}, {"id": 186, "seek": 128816, "start": 1311.76, "end": 1317.44, "text": " I did kubectl create config map. This is the name of my config map, my custom home server.", "tokens": [51544, 286, 630, 350, 836, 557, 75, 1884, 6662, 4471, 13, 639, 307, 264, 1315, 295, 452, 6662, 4471, 11, 452, 2375, 1280, 7154, 13, 51828], "temperature": 0.0, "avg_logprob": -0.13317916078387565, "compression_ratio": 1.829268292682927, "no_speech_prob": 0.006903356406837702}, {"id": 187, "seek": 131744, "start": 1317.44, "end": 1323.28, "text": " I'm using from file to say I want to use this file as an input for the data of this config map.", "tokens": [50364, 286, 478, 1228, 490, 3991, 281, 584, 286, 528, 281, 764, 341, 3991, 382, 364, 4846, 337, 264, 1412, 295, 341, 6662, 4471, 13, 50656], "temperature": 0.0, "avg_logprob": -0.12609395886411762, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.001263994723558426}, {"id": 188, "seek": 131744, "start": 1324.56, "end": 1331.8400000000001, "text": " And in fact, now I have this config map created here, my custom home server 15 seconds ago.", "tokens": [50720, 400, 294, 1186, 11, 586, 286, 362, 341, 6662, 4471, 2942, 510, 11, 452, 2375, 1280, 7154, 2119, 3949, 2057, 13, 51084], "temperature": 0.0, "avg_logprob": -0.12609395886411762, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.001263994723558426}, {"id": 189, "seek": 131744, "start": 1333.3600000000001, "end": 1341.1200000000001, "text": " Now I have the Synapse instance, a new Synapse called my custom Synapse. And in the configuration", "tokens": [51160, 823, 286, 362, 264, 26155, 11145, 5197, 11, 257, 777, 26155, 11145, 1219, 452, 2375, 26155, 11145, 13, 400, 294, 264, 11694, 51548], "temperature": 0.0, "avg_logprob": -0.12609395886411762, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.001263994723558426}, {"id": 190, "seek": 131744, "start": 1341.1200000000001, "end": 1347.2, "text": " options, this time, I'm not using values, I'm using here config map, and I'm giving the name", "tokens": [51548, 3956, 11, 341, 565, 11, 286, 478, 406, 1228, 4190, 11, 286, 478, 1228, 510, 6662, 4471, 11, 293, 286, 478, 2902, 264, 1315, 51852], "temperature": 0.0, "avg_logprob": -0.12609395886411762, "compression_ratio": 1.726027397260274, "no_speech_prob": 0.001263994723558426}, {"id": 191, "seek": 134720, "start": 1347.28, "end": 1351.8400000000001, "text": " of the config map containing the home server YAML that I want to use for configuring this", "tokens": [50368, 295, 264, 6662, 4471, 19273, 264, 1280, 7154, 398, 2865, 43, 300, 286, 528, 281, 764, 337, 6662, 1345, 341, 50596], "temperature": 0.0, "avg_logprob": -0.08725056648254395, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00091099354904145}, {"id": 192, "seek": 134720, "start": 1351.8400000000001, "end": 1357.92, "text": " instance of Synapse. So let's go ahead and create it. And again, the Synapse controller gets to work.", "tokens": [50596, 5197, 295, 26155, 11145, 13, 407, 718, 311, 352, 2286, 293, 1884, 309, 13, 400, 797, 11, 264, 26155, 11145, 10561, 2170, 281, 589, 13, 50900], "temperature": 0.0, "avg_logprob": -0.08725056648254395, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00091099354904145}, {"id": 193, "seek": 134720, "start": 1358.48, "end": 1367.92, "text": " And a new pod is going to come up for this instance of Synapse. And if I'm checking this time the", "tokens": [50928, 400, 257, 777, 2497, 307, 516, 281, 808, 493, 337, 341, 5197, 295, 26155, 11145, 13, 400, 498, 286, 478, 8568, 341, 565, 264, 51400], "temperature": 0.0, "avg_logprob": -0.08725056648254395, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00091099354904145}, {"id": 194, "seek": 134720, "start": 1367.92, "end": 1374.64, "text": " status of my custom Synapse, in the status here, I see again some information on the home server", "tokens": [51400, 6558, 295, 452, 2375, 26155, 11145, 11, 294, 264, 6558, 510, 11, 286, 536, 797, 512, 1589, 322, 264, 1280, 7154, 51736], "temperature": 0.0, "avg_logprob": -0.08725056648254395, "compression_ratio": 1.7625570776255708, "no_speech_prob": 0.00091099354904145}, {"id": 195, "seek": 137464, "start": 1374.64, "end": 1381.2, "text": " configuration has been populated by the Synapse controller. And especially the name of the server", "tokens": [50364, 11694, 575, 668, 32998, 538, 264, 26155, 11145, 10561, 13, 400, 2318, 264, 1315, 295, 264, 7154, 50692], "temperature": 0.0, "avg_logprob": -0.1255783248733688, "compression_ratio": 1.5991379310344827, "no_speech_prob": 0.0003401466819923371}, {"id": 196, "seek": 137464, "start": 1381.2, "end": 1386.0, "text": " and whether or not to report stats, this has been fetched from my custom home server YAML.", "tokens": [50692, 293, 1968, 420, 406, 281, 2275, 18152, 11, 341, 575, 668, 23673, 292, 490, 452, 2375, 1280, 7154, 398, 2865, 43, 13, 50932], "temperature": 0.0, "avg_logprob": -0.1255783248733688, "compression_ratio": 1.5991379310344827, "no_speech_prob": 0.0003401466819923371}, {"id": 197, "seek": 137464, "start": 1387.92, "end": 1393.44, "text": " Behind the scene, what it does also, if I'm running this command again, is that it actually", "tokens": [51028, 20475, 264, 4145, 11, 437, 309, 775, 611, 11, 498, 286, 478, 2614, 341, 5622, 797, 11, 307, 300, 309, 767, 51304], "temperature": 0.0, "avg_logprob": -0.1255783248733688, "compression_ratio": 1.5991379310344827, "no_speech_prob": 0.0003401466819923371}, {"id": 198, "seek": 137464, "start": 1393.44, "end": 1400.0, "text": " creates a copy of your input config map. So it makes a copy of the config map you provide,", "tokens": [51304, 7829, 257, 5055, 295, 428, 4846, 6662, 4471, 13, 407, 309, 1669, 257, 5055, 295, 264, 6662, 4471, 291, 2893, 11, 51632], "temperature": 0.0, "avg_logprob": -0.1255783248733688, "compression_ratio": 1.5991379310344827, "no_speech_prob": 0.0003401466819923371}, {"id": 199, "seek": 140000, "start": 1400.0, "end": 1405.84, "text": " and it works on this copy, because sometimes the Synapse controller might have to do some", "tokens": [50364, 293, 309, 1985, 322, 341, 5055, 11, 570, 2171, 264, 26155, 11145, 10561, 1062, 362, 281, 360, 512, 50656], "temperature": 0.0, "avg_logprob": -0.10301236484361731, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.0010811366373673081}, {"id": 200, "seek": 140000, "start": 1405.84, "end": 1414.48, "text": " modification to make sure that this instance of Synapse can actually run. So it makes a copy,", "tokens": [50656, 26747, 281, 652, 988, 300, 341, 5197, 295, 26155, 11145, 393, 767, 1190, 13, 407, 309, 1669, 257, 5055, 11, 51088], "temperature": 0.0, "avg_logprob": -0.10301236484361731, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.0010811366373673081}, {"id": 201, "seek": 140000, "start": 1414.48, "end": 1420.96, "text": " doesn't touch your input config map, it makes a copy of it and edit it in place if needed.", "tokens": [51088, 1177, 380, 2557, 428, 4846, 6662, 4471, 11, 309, 1669, 257, 5055, 295, 309, 293, 8129, 309, 294, 1081, 498, 2978, 13, 51412], "temperature": 0.0, "avg_logprob": -0.10301236484361731, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.0010811366373673081}, {"id": 202, "seek": 140000, "start": 1423.2, "end": 1429.76, "text": " Let's go back to the presentation and move on to the next CRD that we have, the next resource", "tokens": [51524, 961, 311, 352, 646, 281, 264, 5860, 293, 1286, 322, 281, 264, 958, 14123, 35, 300, 321, 362, 11, 264, 958, 7684, 51852], "temperature": 0.0, "avg_logprob": -0.10301236484361731, "compression_ratio": 1.6211453744493391, "no_speech_prob": 0.0010811366373673081}, {"id": 203, "seek": 142976, "start": 1429.76, "end": 1434.4, "text": " type that we have installed, which is Heisenbridge. So Heisenbridge, as the name suggests, again", "tokens": [50364, 2010, 300, 321, 362, 8899, 11, 597, 307, 634, 11106, 18249, 13, 407, 634, 11106, 18249, 11, 382, 264, 1315, 13409, 11, 797, 50596], "temperature": 0.0, "avg_logprob": -0.10289646784464518, "compression_ratio": 1.6681818181818182, "no_speech_prob": 0.0009542296756990254}, {"id": 204, "seek": 142976, "start": 1434.4, "end": 1442.24, "text": " deploys an instance of the IRC bridge called Heisenbridge. And then it also automatically", "tokens": [50596, 368, 49522, 364, 5197, 295, 264, 16486, 34, 7283, 1219, 634, 11106, 18249, 13, 400, 550, 309, 611, 6772, 50988], "temperature": 0.0, "avg_logprob": -0.10289646784464518, "compression_ratio": 1.6681818181818182, "no_speech_prob": 0.0009542296756990254}, {"id": 205, "seek": 142976, "start": 1442.24, "end": 1450.16, "text": " adds this bridge as an application service to the Synapse home server YAML. And similarly to", "tokens": [50988, 10860, 341, 7283, 382, 364, 3861, 2643, 281, 264, 26155, 11145, 1280, 7154, 398, 2865, 43, 13, 400, 14138, 281, 51384], "temperature": 0.0, "avg_logprob": -0.10289646784464518, "compression_ratio": 1.6681818181818182, "no_speech_prob": 0.0009542296756990254}, {"id": 206, "seek": 142976, "start": 1450.16, "end": 1456.72, "text": " Synapse, you can again provide your custom Heisenbridge configuration file if you want.", "tokens": [51384, 26155, 11145, 11, 291, 393, 797, 2893, 428, 2375, 634, 11106, 18249, 11694, 3991, 498, 291, 528, 13, 51712], "temperature": 0.0, "avg_logprob": -0.10289646784464518, "compression_ratio": 1.6681818181818182, "no_speech_prob": 0.0009542296756990254}, {"id": 207, "seek": 145672, "start": 1456.72, "end": 1465.2, "text": " You can also decide to use some default values. And in that case, you don't have to provide anything", "tokens": [50364, 509, 393, 611, 4536, 281, 764, 512, 7576, 4190, 13, 400, 294, 300, 1389, 11, 291, 500, 380, 362, 281, 2893, 1340, 50788], "temperature": 0.0, "avg_logprob": -0.10827928951808384, "compression_ratio": 1.5025906735751295, "no_speech_prob": 0.00034045721986331046}, {"id": 208, "seek": 145672, "start": 1465.2, "end": 1472.48, "text": " because there is no mandatory configuration options for Heisenbridge. So if I'm going back to the", "tokens": [50788, 570, 456, 307, 572, 22173, 11694, 3956, 337, 634, 11106, 18249, 13, 407, 498, 286, 478, 516, 646, 281, 264, 51152], "temperature": 0.0, "avg_logprob": -0.10827928951808384, "compression_ratio": 1.5025906735751295, "no_speech_prob": 0.00034045721986331046}, {"id": 209, "seek": 145672, "start": 1473.76, "end": 1480.48, "text": " terminal, I see that here I have an example manifest file for Heisenbridge, where I specify", "tokens": [51216, 14709, 11, 286, 536, 300, 510, 286, 362, 364, 1365, 10067, 3991, 337, 634, 11106, 18249, 11, 689, 286, 16500, 51552], "temperature": 0.0, "avg_logprob": -0.10827928951808384, "compression_ratio": 1.5025906735751295, "no_speech_prob": 0.00034045721986331046}, {"id": 210, "seek": 148048, "start": 1480.48, "end": 1486.64, "text": " in the spec section simply the name of the Synapse instance that I want to be connected to.", "tokens": [50364, 294, 264, 1608, 3541, 2935, 264, 1315, 295, 264, 26155, 11145, 5197, 300, 286, 528, 281, 312, 4582, 281, 13, 50672], "temperature": 0.0, "avg_logprob": -0.11345390478769939, "compression_ratio": 1.56, "no_speech_prob": 0.004133032634854317}, {"id": 211, "seek": 148048, "start": 1487.52, "end": 1496.64, "text": " And that's okay because I have, my Synapse is an existing Synapse instance, right,", "tokens": [50716, 400, 300, 311, 1392, 570, 286, 362, 11, 452, 26155, 11145, 307, 364, 6741, 26155, 11145, 5197, 11, 558, 11, 51172], "temperature": 0.0, "avg_logprob": -0.11345390478769939, "compression_ratio": 1.56, "no_speech_prob": 0.004133032634854317}, {"id": 212, "seek": 148048, "start": 1496.64, "end": 1505.28, "text": " we created it a few minutes ago. So I can go ahead and create this. And what's happening here now,", "tokens": [51172, 321, 2942, 309, 257, 1326, 2077, 2057, 13, 407, 286, 393, 352, 2286, 293, 1884, 341, 13, 400, 437, 311, 2737, 510, 586, 11, 51604], "temperature": 0.0, "avg_logprob": -0.11345390478769939, "compression_ratio": 1.56, "no_speech_prob": 0.004133032634854317}, {"id": 213, "seek": 150528, "start": 1505.28, "end": 1511.52, "text": " we have two controllers now doing some work. First, the Heisenbridge controller,", "tokens": [50364, 321, 362, 732, 26903, 586, 884, 512, 589, 13, 2386, 11, 264, 634, 11106, 18249, 10561, 11, 50676], "temperature": 0.0, "avg_logprob": -0.11408228623239618, "compression_ratio": 1.7699530516431925, "no_speech_prob": 0.0005612894310615957}, {"id": 214, "seek": 150528, "start": 1511.52, "end": 1517.2, "text": " which runs here this part, the Heisenbridge part. And second, we have the Synapse controller, which", "tokens": [50676, 597, 6676, 510, 341, 644, 11, 264, 634, 11106, 18249, 644, 13, 400, 1150, 11, 321, 362, 264, 26155, 11145, 10561, 11, 597, 50960], "temperature": 0.0, "avg_logprob": -0.11408228623239618, "compression_ratio": 1.7699530516431925, "no_speech_prob": 0.0005612894310615957}, {"id": 215, "seek": 150528, "start": 1517.2, "end": 1525.12, "text": " you see has terminated one part, the one which was created four minutes ago, and has run a new part", "tokens": [50960, 291, 536, 575, 1433, 5410, 472, 644, 11, 264, 472, 597, 390, 2942, 1451, 2077, 2057, 11, 293, 575, 1190, 257, 777, 644, 51356], "temperature": 0.0, "avg_logprob": -0.11408228623239618, "compression_ratio": 1.7699530516431925, "no_speech_prob": 0.0005612894310615957}, {"id": 216, "seek": 150528, "start": 1525.84, "end": 1532.3999999999999, "text": " about 20 seconds ago now when we first created our Heisenbridge. Why is that? Well, the business", "tokens": [51392, 466, 945, 3949, 2057, 586, 562, 321, 700, 2942, 527, 634, 11106, 18249, 13, 1545, 307, 300, 30, 1042, 11, 264, 1606, 51720], "temperature": 0.0, "avg_logprob": -0.11408228623239618, "compression_ratio": 1.7699530516431925, "no_speech_prob": 0.0005612894310615957}, {"id": 217, "seek": 153240, "start": 1532.48, "end": 1540.88, "text": " logic of the Synapse controller is so that when it sees a Heisenbridge being created for an", "tokens": [50368, 9952, 295, 264, 26155, 11145, 10561, 307, 370, 300, 562, 309, 8194, 257, 634, 11106, 18249, 885, 2942, 337, 364, 50788], "temperature": 0.0, "avg_logprob": -0.138360121815475, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.002354963216930628}, {"id": 218, "seek": 153240, "start": 1540.88, "end": 1546.88, "text": " existing Synapse instance, well, it reconfigures it. So it adds it, it adds the Heisenbridge as", "tokens": [50788, 6741, 26155, 11145, 5197, 11, 731, 11, 309, 9993, 20646, 1303, 309, 13, 407, 309, 10860, 309, 11, 309, 10860, 264, 634, 11106, 18249, 382, 51088], "temperature": 0.0, "avg_logprob": -0.138360121815475, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.002354963216930628}, {"id": 219, "seek": 153240, "start": 1546.88, "end": 1552.5600000000002, "text": " an application service in Home Server YAML. And then he has to restart, not actually restart,", "tokens": [51088, 364, 3861, 2643, 294, 8719, 25684, 398, 2865, 43, 13, 400, 550, 415, 575, 281, 21022, 11, 406, 767, 21022, 11, 51372], "temperature": 0.0, "avg_logprob": -0.138360121815475, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.002354963216930628}, {"id": 220, "seek": 153240, "start": 1552.5600000000002, "end": 1562.0800000000002, "text": " recreate the part using this new configuration. So that's what it does. I can also check the logs", "tokens": [51372, 25833, 264, 644, 1228, 341, 777, 11694, 13, 407, 300, 311, 437, 309, 775, 13, 286, 393, 611, 1520, 264, 20820, 51848], "temperature": 0.0, "avg_logprob": -0.138360121815475, "compression_ratio": 1.6127659574468085, "no_speech_prob": 0.002354963216930628}, {"id": 221, "seek": 156208, "start": 1562.08, "end": 1574.32, "text": " of my Synapse pod, a grab for Heisenbridge. And we see that indeed Heisenbridge has been added", "tokens": [50364, 295, 452, 26155, 11145, 2497, 11, 257, 4444, 337, 634, 11106, 18249, 13, 400, 321, 536, 300, 6451, 634, 11106, 18249, 575, 668, 3869, 50976], "temperature": 0.0, "avg_logprob": -0.16241277775294344, "compression_ratio": 1.583815028901734, "no_speech_prob": 0.0005029602907598019}, {"id": 222, "seek": 156208, "start": 1574.32, "end": 1580.6399999999999, "text": " as an application service. There is a user Heisenbridge, which has been created, which has", "tokens": [50976, 382, 364, 3861, 2643, 13, 821, 307, 257, 4195, 634, 11106, 18249, 11, 597, 575, 668, 2942, 11, 597, 575, 51292], "temperature": 0.0, "avg_logprob": -0.16241277775294344, "compression_ratio": 1.583815028901734, "no_speech_prob": 0.0005029602907598019}, {"id": 223, "seek": 156208, "start": 1580.6399999999999, "end": 1586.96, "text": " been logged in. And there were some initial requests made for configuring it. All right,", "tokens": [51292, 668, 27231, 294, 13, 400, 456, 645, 512, 5883, 12475, 1027, 337, 6662, 1345, 309, 13, 1057, 558, 11, 51608], "temperature": 0.0, "avg_logprob": -0.16241277775294344, "compression_ratio": 1.583815028901734, "no_speech_prob": 0.0005029602907598019}, {"id": 224, "seek": 158696, "start": 1586.96, "end": 1596.16, "text": " so I have now a Heisenbridge instance, and I have two Synapse instances running.", "tokens": [50364, 370, 286, 362, 586, 257, 634, 11106, 18249, 5197, 11, 293, 286, 362, 732, 26155, 11145, 14519, 2614, 13, 50824], "temperature": 0.0, "avg_logprob": -0.10987125272336214, "compression_ratio": 1.6296296296296295, "no_speech_prob": 0.0007672121282666922}, {"id": 225, "seek": 158696, "start": 1597.6000000000001, "end": 1601.8400000000001, "text": " By the way, this reconfiguration of the Home Server YAML would also work if you would have", "tokens": [50896, 3146, 264, 636, 11, 341, 9993, 20646, 8167, 295, 264, 8719, 25684, 398, 2865, 43, 576, 611, 589, 498, 291, 576, 362, 51108], "temperature": 0.0, "avg_logprob": -0.10987125272336214, "compression_ratio": 1.6296296296296295, "no_speech_prob": 0.0007672121282666922}, {"id": 226, "seek": 158696, "start": 1601.8400000000001, "end": 1608.08, "text": " provided your own Home Server YAML with a config map, because I mentioned before that", "tokens": [51108, 5649, 428, 1065, 8719, 25684, 398, 2865, 43, 365, 257, 6662, 4471, 11, 570, 286, 2835, 949, 300, 51420], "temperature": 0.0, "avg_logprob": -0.10987125272336214, "compression_ratio": 1.6296296296296295, "no_speech_prob": 0.0007672121282666922}, {"id": 227, "seek": 158696, "start": 1608.08, "end": 1615.1200000000001, "text": " the controller makes a copy of this Home Server YAML. And so it works on this copy and it also", "tokens": [51420, 264, 10561, 1669, 257, 5055, 295, 341, 8719, 25684, 398, 2865, 43, 13, 400, 370, 309, 1985, 322, 341, 5055, 293, 309, 611, 51772], "temperature": 0.0, "avg_logprob": -0.10987125272336214, "compression_ratio": 1.6296296296296295, "no_speech_prob": 0.0007672121282666922}, {"id": 228, "seek": 161512, "start": 1615.12, "end": 1620.32, "text": " modifies it if needed. All right, and just to mention here, we have also the possibility to", "tokens": [50364, 1072, 11221, 309, 498, 2978, 13, 1057, 558, 11, 293, 445, 281, 2152, 510, 11, 321, 362, 611, 264, 7959, 281, 50624], "temperature": 0.0, "avg_logprob": -0.0861151175065474, "compression_ratio": 1.8595744680851063, "no_speech_prob": 0.0010816610883921385}, {"id": 229, "seek": 161512, "start": 1620.32, "end": 1626.56, "text": " configure Heisenbridge with a config map that would work in the same way as for Synapse.", "tokens": [50624, 22162, 634, 11106, 18249, 365, 257, 6662, 4471, 300, 576, 589, 294, 264, 912, 636, 382, 337, 26155, 11145, 13, 50936], "temperature": 0.0, "avg_logprob": -0.0861151175065474, "compression_ratio": 1.8595744680851063, "no_speech_prob": 0.0010816610883921385}, {"id": 230, "seek": 161512, "start": 1626.56, "end": 1630.9599999999998, "text": " That means that we would need to create a config map first and then feed it here", "tokens": [50936, 663, 1355, 300, 321, 576, 643, 281, 1884, 257, 6662, 4471, 700, 293, 550, 3154, 309, 510, 51156], "temperature": 0.0, "avg_logprob": -0.0861151175065474, "compression_ratio": 1.8595744680851063, "no_speech_prob": 0.0010816610883921385}, {"id": 231, "seek": 161512, "start": 1631.76, "end": 1636.8, "text": " to the Heisenbridge resource. And in this config map, we would need to have the Heisenbridge", "tokens": [51196, 281, 264, 634, 11106, 18249, 7684, 13, 400, 294, 341, 6662, 4471, 11, 321, 576, 643, 281, 362, 264, 634, 11106, 18249, 51448], "temperature": 0.0, "avg_logprob": -0.0861151175065474, "compression_ratio": 1.8595744680851063, "no_speech_prob": 0.0010816610883921385}, {"id": 232, "seek": 161512, "start": 1636.8, "end": 1643.52, "text": " configuration file. So similarly to what we had with Synapse. Finally, we have the", "tokens": [51448, 11694, 3991, 13, 407, 14138, 281, 437, 321, 632, 365, 26155, 11145, 13, 6288, 11, 321, 362, 264, 51784], "temperature": 0.0, "avg_logprob": -0.0861151175065474, "compression_ratio": 1.8595744680851063, "no_speech_prob": 0.0010816610883921385}, {"id": 233, "seek": 164352, "start": 1643.52, "end": 1649.04, "text": " MatrixSignal bridge. This works exactly in the same way, creating the Matrix Bridge,", "tokens": [50364, 36274, 50, 788, 304, 7283, 13, 639, 1985, 2293, 294, 264, 912, 636, 11, 4084, 264, 36274, 18917, 11, 50640], "temperature": 0.0, "avg_logprob": -0.20158298041230888, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.00030057449475862086}, {"id": 234, "seek": 164352, "start": 1649.04, "end": 1655.2, "text": " creating a signal D, which is required for this bridge to run, and reconfiguring the Home", "tokens": [50640, 4084, 257, 6358, 413, 11, 597, 307, 4739, 337, 341, 7283, 281, 1190, 11, 293, 9993, 20646, 1345, 264, 8719, 50948], "temperature": 0.0, "avg_logprob": -0.20158298041230888, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.00030057449475862086}, {"id": 235, "seek": 164352, "start": 1655.2, "end": 1662.08, "text": " Server YAML and add MatrixSignal as a bridge there, as an app service there. Again, you can either", "tokens": [50948, 25684, 398, 2865, 43, 293, 909, 36274, 50, 788, 304, 382, 257, 7283, 456, 11, 382, 364, 724, 2643, 456, 13, 3764, 11, 291, 393, 2139, 51292], "temperature": 0.0, "avg_logprob": -0.20158298041230888, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.00030057449475862086}, {"id": 236, "seek": 164352, "start": 1662.08, "end": 1667.28, "text": " use a custom configuration file or work with default if you want a quick start. Finally,", "tokens": [51292, 764, 257, 2375, 11694, 3991, 420, 589, 365, 7576, 498, 291, 528, 257, 1702, 722, 13, 6288, 11, 51552], "temperature": 0.0, "avg_logprob": -0.20158298041230888, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.00030057449475862086}, {"id": 237, "seek": 166728, "start": 1667.28, "end": 1674.96, "text": " there's a way to provision a PostgreSQL instance. The first thing you could do is have your", "tokens": [50364, 456, 311, 257, 636, 281, 17225, 257, 10223, 33248, 39934, 5197, 13, 440, 700, 551, 291, 727, 360, 307, 362, 428, 50748], "temperature": 0.0, "avg_logprob": -0.12449300417336084, "compression_ratio": 1.7579908675799087, "no_speech_prob": 0.005137718748301268}, {"id": 238, "seek": 166728, "start": 1674.96, "end": 1679.44, "text": " custom Home Server YAML and if you already have a PostgreSQL instance running, you could provide", "tokens": [50748, 2375, 8719, 25684, 398, 2865, 43, 293, 498, 291, 1217, 362, 257, 10223, 33248, 39934, 5197, 2614, 11, 291, 727, 2893, 50972], "temperature": 0.0, "avg_logprob": -0.12449300417336084, "compression_ratio": 1.7579908675799087, "no_speech_prob": 0.005137718748301268}, {"id": 239, "seek": 166728, "start": 1679.44, "end": 1686.0, "text": " your own Home Server YAML and configure the database connection information there. Or you can", "tokens": [50972, 428, 1065, 8719, 25684, 398, 2865, 43, 293, 22162, 264, 8149, 4984, 1589, 456, 13, 1610, 291, 393, 51300], "temperature": 0.0, "avg_logprob": -0.12449300417336084, "compression_ratio": 1.7579908675799087, "no_speech_prob": 0.005137718748301268}, {"id": 240, "seek": 166728, "start": 1686.0, "end": 1692.16, "text": " automatically spin up a PostgreSQL instance. We saw that there is a create PostgreSQL Boolean a little", "tokens": [51300, 6772, 6060, 493, 257, 10223, 33248, 39934, 5197, 13, 492, 1866, 300, 456, 307, 257, 1884, 10223, 33248, 39934, 23351, 28499, 257, 707, 51608], "temperature": 0.0, "avg_logprob": -0.12449300417336084, "compression_ratio": 1.7579908675799087, "no_speech_prob": 0.005137718748301268}, {"id": 241, "seek": 169216, "start": 1692.24, "end": 1700.8000000000002, "text": " bit earlier. By default, it's false. But if you put it to true, it will attempt to create a PostgreSQL", "tokens": [50368, 857, 3071, 13, 3146, 7576, 11, 309, 311, 7908, 13, 583, 498, 291, 829, 309, 281, 2074, 11, 309, 486, 5217, 281, 1884, 257, 10223, 33248, 39934, 50796], "temperature": 0.0, "avg_logprob": -0.11819278200467427, "compression_ratio": 1.5949367088607596, "no_speech_prob": 0.0013036644086241722}, {"id": 242, "seek": 169216, "start": 1700.8000000000002, "end": 1707.68, "text": " cluster or PostgreSQL instance using the PostgreSQL operator. So that's an external dependency", "tokens": [50796, 13630, 420, 10223, 33248, 39934, 5197, 1228, 264, 10223, 33248, 39934, 12973, 13, 407, 300, 311, 364, 8320, 33621, 51140], "temperature": 0.0, "avg_logprob": -0.11819278200467427, "compression_ratio": 1.5949367088607596, "no_speech_prob": 0.0013036644086241722}, {"id": 243, "seek": 169216, "start": 1707.68, "end": 1715.44, "text": " on the Synapse operator. Let's finish very quick with the next steps. As you know,", "tokens": [51140, 322, 264, 26155, 11145, 12973, 13, 961, 311, 2413, 588, 1702, 365, 264, 958, 4439, 13, 1018, 291, 458, 11, 51528], "temperature": 0.0, "avg_logprob": -0.11819278200467427, "compression_ratio": 1.5949367088607596, "no_speech_prob": 0.0013036644086241722}, {"id": 244, "seek": 169216, "start": 1715.44, "end": 1720.72, "text": " MatrixSignal is a very large ecosystem with tons of projects. Many are obviously missing from the", "tokens": [51528, 36274, 50, 788, 304, 307, 257, 588, 2416, 11311, 365, 9131, 295, 4455, 13, 5126, 366, 2745, 5361, 490, 264, 51792], "temperature": 0.0, "avg_logprob": -0.11819278200467427, "compression_ratio": 1.5949367088607596, "no_speech_prob": 0.0013036644086241722}, {"id": 245, "seek": 172072, "start": 1720.72, "end": 1727.2, "text": " Synapse operator today. First, bridges, of course. We could add more bridges. Web clients, we currently", "tokens": [50364, 26155, 11145, 12973, 965, 13, 2386, 11, 21114, 11, 295, 1164, 13, 492, 727, 909, 544, 21114, 13, 9573, 6982, 11, 321, 4362, 50688], "temperature": 0.0, "avg_logprob": -0.20939730834960937, "compression_ratio": 1.7291666666666667, "no_speech_prob": 0.0013238228857517242}, {"id": 246, "seek": 172072, "start": 1727.2, "end": 1732.48, "text": " don't have any, but we could have Element or Hydrogen, for instance, as a web client. We could", "tokens": [50688, 500, 380, 362, 604, 11, 457, 321, 727, 362, 20900, 420, 24231, 7747, 11, 337, 5197, 11, 382, 257, 3670, 6423, 13, 492, 727, 50952], "temperature": 0.0, "avg_logprob": -0.20939730834960937, "compression_ratio": 1.7291666666666667, "no_speech_prob": 0.0013238228857517242}, {"id": 247, "seek": 172072, "start": 1732.48, "end": 1739.3600000000001, "text": " have some additional infrastructure components, such as a turn server for WebRTC, audio-video call,", "tokens": [50952, 362, 512, 4497, 6896, 6677, 11, 1270, 382, 257, 1261, 7154, 337, 9573, 49, 18238, 11, 6278, 12, 40876, 818, 11, 51296], "temperature": 0.0, "avg_logprob": -0.20939730834960937, "compression_ratio": 1.7291666666666667, "no_speech_prob": 0.0013238228857517242}, {"id": 248, "seek": 172072, "start": 1739.3600000000001, "end": 1744.88, "text": " SSL certificates, or email server. And, of course, why not also have alternative Home Servers, right?", "tokens": [51296, 12238, 43, 32941, 11, 420, 3796, 7154, 13, 400, 11, 295, 1164, 11, 983, 406, 611, 362, 8535, 8719, 4210, 840, 11, 558, 30, 51572], "temperature": 0.0, "avg_logprob": -0.20939730834960937, "compression_ratio": 1.7291666666666667, "no_speech_prob": 0.0013238228857517242}, {"id": 249, "seek": 172072, "start": 1745.44, "end": 1749.84, "text": " Right now, we only have the Synapse Home Server, but we could also have a provided possibility to", "tokens": [51600, 1779, 586, 11, 321, 787, 362, 264, 26155, 11145, 8719, 25684, 11, 457, 321, 727, 611, 362, 257, 5649, 7959, 281, 51820], "temperature": 0.0, "avg_logprob": -0.20939730834960937, "compression_ratio": 1.7291666666666667, "no_speech_prob": 0.0013238228857517242}, {"id": 250, "seek": 174984, "start": 1749.84, "end": 1756.3999999999999, "text": " deploy. You maybe can do it on the Android and turn this Synapse operator into a Matrix operator,", "tokens": [50364, 7274, 13, 509, 1310, 393, 360, 309, 322, 264, 8853, 293, 1261, 341, 26155, 11145, 12973, 666, 257, 36274, 12973, 11, 50692], "temperature": 0.0, "avg_logprob": -0.18923925399780273, "compression_ratio": 1.5524193548387097, "no_speech_prob": 0.0009251646115444601}, {"id": 251, "seek": 174984, "start": 1756.3999999999999, "end": 1764.24, "text": " actually. Yeah, that would be for the long term. All right, so that's it for me today. Thanks for", "tokens": [50692, 767, 13, 865, 11, 300, 576, 312, 337, 264, 938, 1433, 13, 1057, 558, 11, 370, 300, 311, 309, 337, 385, 965, 13, 2561, 337, 51084], "temperature": 0.0, "avg_logprob": -0.18923925399780273, "compression_ratio": 1.5524193548387097, "no_speech_prob": 0.0009251646115444601}, {"id": 252, "seek": 174984, "start": 1764.24, "end": 1772.0, "text": " listening. Today, we hear some information on how to contact me, the link to the GitHub. Don't", "tokens": [51084, 4764, 13, 2692, 11, 321, 1568, 512, 1589, 322, 577, 281, 3385, 385, 11, 264, 2113, 281, 264, 23331, 13, 1468, 380, 51472], "temperature": 0.0, "avg_logprob": -0.18923925399780273, "compression_ratio": 1.5524193548387097, "no_speech_prob": 0.0009251646115444601}, {"id": 253, "seek": 174984, "start": 1772.0, "end": 1779.04, "text": " hesitate to go ahead and grab the code and try it out, provide feedbacks, write me also in the", "tokens": [51472, 20842, 281, 352, 2286, 293, 4444, 264, 3089, 293, 853, 309, 484, 11, 2893, 5824, 82, 11, 2464, 385, 611, 294, 264, 51824], "temperature": 0.0, "avg_logprob": -0.18923925399780273, "compression_ratio": 1.5524193548387097, "no_speech_prob": 0.0009251646115444601}, {"id": 254, "seek": 177904, "start": 1779.04, "end": 1785.52, "text": " Synapse operator room. Right now, it's a very quiet room, but please just come and have a chat", "tokens": [50364, 26155, 11145, 12973, 1808, 13, 1779, 586, 11, 309, 311, 257, 588, 5677, 1808, 11, 457, 1767, 445, 808, 293, 362, 257, 5081, 50688], "temperature": 0.0, "avg_logprob": -0.11017573057715573, "compression_ratio": 1.4530386740331491, "no_speech_prob": 0.001453020260669291}, {"id": 255, "seek": 177904, "start": 1785.52, "end": 1790.24, "text": " if you have any questions or if you're interested in working on this project. Thank you very much", "tokens": [50688, 498, 291, 362, 604, 1651, 420, 498, 291, 434, 3102, 294, 1364, 322, 341, 1716, 13, 1044, 291, 588, 709, 50924], "temperature": 0.0, "avg_logprob": -0.11017573057715573, "compression_ratio": 1.4530386740331491, "no_speech_prob": 0.001453020260669291}, {"id": 256, "seek": 177904, "start": 1790.24, "end": 1795.28, "text": " for your attention, and I wish you a good rest of the conference. Bye.", "tokens": [50924, 337, 428, 3202, 11, 293, 286, 3172, 291, 257, 665, 1472, 295, 264, 7586, 13, 4621, 13, 51176], "temperature": 0.0, "avg_logprob": -0.11017573057715573, "compression_ratio": 1.4530386740331491, "no_speech_prob": 0.001453020260669291}, {"id": 257, "seek": 183904, "start": 1839.04, "end": 1840.42, "text": " you", "tokens": [50404, 291, 50433], "temperature": 0.0, "avg_logprob": -0.8385329246520996, "compression_ratio": 0.2727272727272727, "no_speech_prob": 0.9460896849632263}, {"id": 258, "seek": 186904, "start": 1869.04, "end": 1870.42, "text": " you", "tokens": [50404, 291, 50433], "temperature": 0.0, "avg_logprob": -0.7678462266921997, "compression_ratio": 0.2727272727272727, "no_speech_prob": 0.6323882937431335}], "language": "en"}