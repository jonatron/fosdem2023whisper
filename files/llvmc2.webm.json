{"text": " Welcome. I am Bess Vandenberg. I have been working on a language called C2 for about 11 years now. I did two talks in FOSDEM in 2013 and 2015, I think. So this is the third one about the compiler, so it's slightly different. So the presentation roughly has three parts. First the language introduction, because you can't talk about a compiler without knowing the language. Then the evolution of the C2 compiler, which is called C2C, because CC was already taken, of course. And then the next steps, so three parts. The first part, the language. There's a lot of info here. My reason for starting C2 was I'm an embedded developer, so I work a lot with low level systems kernels and that sort of thing. And everyone was getting new programming languages except embedded programmers. So we are still writing kernels in C and no other programming language are really making it in that race. So I thought, well, we should be able to do something about that. So I love C, so let's try to keep the good parts and remove the parts that have become somewhat older with time, since C is, of course, 50 years old. So what I did was I looked at the anti-patterns in C. For example, the types you define like Uint, 32T, and lots of macros, lots of plumbing you have to do that everyone does in every project, like the size of an array macro. And that's tried to get those out. Also, the header files had to go, because header files you had to type, yeah, your definitions twice and it's a hassle with a lot of stuff, a lot of tooling. Macros as well. So the macros also went out. And the goal was to get better development speed. So execution speed in C is not a problem, of course, but yeah, development speed is. Then the speed of execution can be better than C. That's because full program optimization is easy in C2 and it's quite hard in C in a realistic program. So you can get better execution speed that way. It also has a built-in build system. So the scope of the C2 compiler is different than a C compiler. The C compiler, you feed it a single C file, it produces an O file, and then you do that a lot of times and the linker just collects everything and turns it into an executable. In C2, you run the C2 compiler, it takes a lot of source files and produces the binary. So it does use the linker, but the translation unit is the whole program. So it can do a lot of diagnostics that the C compiler can do. Like this field in this truck is never written in the whole program. So in C, that's not possible unless it's in the static part, in the C file for example. And I tried to get better tooling, like jump to definitions that are reliable and fast, analyzers that are often hindered in C by the macro use, and so on. What I'm not trying to do is make a completely new language, like Rust or Go, because it should be recognizable by C and because I like the things in C, the abstraction layer is just to do it yourself, and it fits the hardware we have now, so that's okay. And I also don't want to add higher level features like garbage collection or runtime, because it's not the domain I'm trying to use it for. So let's see an example. How many people ever looked at a piece of C2 code already? Probably a few. Well, every file... The dog did. Every file starts with a module definition where you define every file as part of a module, and a module is just a piece of code. Different files can belong to the same module. Then you get a bunch of definitions like a type and two functions. The order here doesn't matter. The ordering is for a compiler, not for humans. There are no forward declarations. In 50 years ago, when the compiler had memory problems, it was an issue. So the user, the programmer had to structure the program, so I first do the forward declaration, and then like this part, the element points to an element again in C. That's not possible. You have to do forward declaration of the struct, and then the definition, that's a computer problem, and it should be able to do that. A second thing you'll notice here is the public keyword. Types and functions can be public or not. Public means it can be called by other modules. Another one is this one. This is called a struct function. So we have a struct, and we can just add these functions to it, and you can, in the next slide, also, you can do element dot in it. You can add them arbitrarily. Not just in C++, but you have to add it in the class definition. Another change from C was the dot here. These are pointers. In C, you have to use the arrow, and a dot for the full body. In C2, we make no difference. It's all a dot, because it's better readable. Okay, so how do we use this part? This is just an example, of course. It would roughly look like this. So you import the list, the linked list module, use the element, and then do something with it. The thing to note here is that the import has no file name. So in C, you do includes, and includes has a file name. It has a path or a sub-directory. That's all very unhandy when you try to reuse stuff, and it's in the utils library directory, and in another project, in the lib directory, you have to change the header files and includes. That's not the case here. You can just put the files somewhere on your file system in your project, and I'll show that later, and in your recipe file, and then it will work. But otherwise, if you look at the body function body, it's pretty similar to C. So the plumbing, like the rest of it, looks different, but if you have a large function with four loops, it's just the same. It looks really the same. So because the scope of the C2 compiler is the whole program, you have to tell it what to do. So you just run C2C, and you can give it arguments, but you don't have to. It will look up the recipe file, and then do whatever you want. So you can turn it into an extra executable or a library. These are the files, so it will not dynamically look for files with some name. It will also not use directory structures as the module name or something, like some languages do, but it will do this. And also, this is the configuration part. There are only a few options. In CUF, I have given actually presentations about the warning flags in C. In C2, the only warnings you have is unused. The rest is just an error. So unused can be, of course, if you are refactoring, it can be annoying. You can temporarily silence them, but other stuff you can't ignore. You have to fix it. So, what other features does the language have? Modules, imports, with the recipe file. We have a lot of stuff like elements of, which is the built-in function, like size of, but then for array sizes. We have enum min, enum max, which is the first and the last element or the highest element in an enum, offset of to container, which are usually macros in C, but they are part of the language here. Also, the base types are all in there. We have opaque data types, which are types in C that you only use by pointer. So, like you have some component and you call a create function, you get a handle back, but you cannot, you can only use the handle by pointer. You cannot actually look into it, and that's opaque data types. That's made explicit here. Another thing you can do, because we have full program scope, is global incremental arrays, which are just array, global arrays, but you can define them in different files and you can have them behind the configuration sort of if-devs. So, if you have this feature, these elements are added to the array and otherwise they don't. But in the end, the compiler will put them all together and turn it into a single array. Another feature I've never seen in other languages is the build file. It's also another file, which is optional. The recipe and the code is made by the developer, but the other users of a program can be, for example, open embedded or Yocto systems, where you have to tell it how to build where the directories are, and that is specified in a build file. So, that's not created by the developer, but by the users or the package managers or those people. Another feature, which I haven't seen in other languages or compilers is plugins. So, the C2 compiler has a plugin system. You can write plugins for it to walk the ASD, do stuff with it, either before parsing the other stuff or after. I'll come back to that later. Let me check the time. Current state. We have 900 unit tests. It does run, so it's quite okay. It gives quite nice diagnostics. Weird cases are all covered. Doesn't mean there aren't more. There probably are a lot. Lipsy support, pthread support. I once supported the Vulkan library, the Graphics library to C2 that worked, well, written web server, web socket server event framework. There are plugins for VIM or Neo VIM to jump to definitions that are really fast and correct. We can generate dependency matrixes of the whole code to some format, also through plugins. This part, the embedded user is still in progress, so that's the bare metal case. You need linker scripts for that. Inline assembly is supported already, but you need more for that. You also need the bare assembly. And it's been used in some production code, web server client and customer service for customers I work for. I advise them to use C2. Okay. So the second part is about the evolution of the compiler itself. Started in 2012. Well, you started by Zonjak because you're doing something with parsers. I quickly found out that they're not really usable in real projects, really hard to use. So I started with a patch on Clang, 3.2 in 2013, when Clang was a bit more slimmer, to parse C2. After that, I created an own C++ code base using many components from Clang. The patched preprocessor, tokenizer, also the diagnostics engine and generic LLVM components. That went on for quite a long time. It went well. Always rebasing on the latest LLVM, like 3, 4, 5, 6, 7, 8. We're now at 11, I think, or 12. Well, the latest rebase. Added to own custom unit test framework. And last year, the plugins, which is quite nice because like for the, so I have another slide for that. So that's this one. Yeah, this one. So some, the C2 compiler shouldn't depend on a VIM plugin, of course, but there's some sort of dependency on it. So we put that in it. You can create a plugin that generates walks, the AST, gets information out, puts it in some binary file, and the plugin can look at the binary file. So that works really well. And there's also another fun stuff to do, like shell commands to symbol. So you can, in a YAML config file, you can pass to these plugins. You can specify, I want to run this command, like git version or ls, and then put it in this C symbol. So you get it in C, you can just use the symbol name in your scope. And yeah, you get the information. So that's quite nice. Git version works the same way, but it's just specialized for this. Also load file. So you can, you have a load file plugin. So you specify, I want to load this file, and this is the symbol name. And the symbol name is just straight with the data field and the length field. So you can just access the content. So you don't need to have macros or scripts that convert stuff to header files and import those. Other IDs are to code obfuscation stuff and additional checks you can implement in companies, like every name should be 13 bytes long, whatever you want. So continuing on the list. Last year I started on rewriting the C2 compiler in C2, because that's the domain it's also meant for. So it was a sort of graduation project. See if it's valid. It was also the biggest project. It's now, I think, 15,000 lines of code or something. So to do that, you need to bootstrap it. So that was done this year. So we now have a bootstrap way to, yeah, to start with a normal C compiler and bootstrap that into a C2 compiler. That's shown in this image. So it's quite a hassle sometimes. So we start with the C++ sources for C2C, compile those with Clang++. We get a C2 compiler. Then we take the C2 sources, the native version, the C2 version, compile that with this compiler, get a C file we can generate C, if you want. Compile that with Clang and then do that again to the bootstrap because we want to use this final compiler to do another step. So then we get a C2 compiler that's the final one. And the bootstrap actually starts here. So we save this file. That's easy. It's quite a big file, but Clang can handle it. And the bootstrap is just the last part. So, well, I had first ideas to use binaries, but if you lose the one binary you have, then you cannot compile again. That's not so handy. I think the project was a success with the graduation. I found quite a lot of bugs in the old C++ version of the compiler, but it's quite nice. I was afraid that C or C2 like languages might be too low level because Clang is, of course, written in C++, but in a compiler you can use memory pools and quite a lot for the AST, and that's also faster. So memory management is not really an issue here. It now parses roughly four million lines a second. And analysis is also quite fast. That's because we do the whole program at once. So when you do a C program, your make files kicks in. It takes the first while, puts it in GCC, get an O file, and does some parallelism with multi-course. But it does code generation as well here, and then the second one and the third. So if your file number 100 has an error, you only get an error after 99 files have been compiled. And in C2 you parse all the files, check all the files, so it's really fast. It takes milliseconds. So I can announce now the public repository. I open sourced it yesterday. Had to add some legal headers and stuff, of course. I get some open source license in there. So it's now on GitHub. You can download it and try it. It's not as functional as the C++ version, so that's still the main. So the next step will be to convert all the unit tests to the new, actually the compiler to fit all the unit tests we have. Sometimes the diagnostics differ a bit, so I have to change the unit test. Also, when I implemented the C2 compiler in C2, I had to run, I had to use a lot of vectors as data types for lists of stuff, and you have to retype them every time you see. So I started playing around with templates. The start is now in there, but it needs to be expanded because it's quite nice to have some form of templates. I'm trying to stay far away from the C++ hell, of course, but at least something. The recipe file format will be changed to YAML because the build file is also in YAML and all the other files also, so that's more consistent. Then currently there are three backends, so the code gets converted through the backend to something else. One is the C backend, which is quite easy, and then we also generate make files, and it just runs it and gets a binary. Another backend is QBE, which was presented here last year. It's a small backend that has no optimization, but it works, and it's quite easy to use. Then there's also beginning of the LLVM backend, which is quite hard because LLVM is like a client, it's a huge dragon, it's millions lines of code. That's more work, so this is the step up to LLVM. Last is the embedded words used, so it's using linker scripts and allowing bare metal. That would be nice. So that's the presentation. I tried to keep it quite short and not focus only on the language itself, so there's room for questions. If there are any. So how do you interact with C code in particular with C headers? From a C2 project, you can generate C headers for your C2 library, a library that's written in C2. So I meant if you want to use a library written in C. Yes, so that's one way. The other way is if you have a C library like the Vulkan library, you have to create a sort of C, C2 interface file, so it's like a header file in C. It's quite straightforward, but it's manual work. There's no way to automate that currently. But the rest is the ABI is the same for the libc. You just have to define like printf, this is the function. So the question was how do you interact between C and C2? So you said that with your C2 compiler, the whole program will be compiled in one step. Do you have provisions for building shared libraries or other things that cannot be compiled into one step? What if the program is so large that we cannot compile and link it in one step? This is the case with many C++ projects if you do not have enough memory. If you take a really large program, it will probably take a tenth of the size of your browser. Loading a standard web page takes so many megabytes. Like a huge program like the Linux kernel, it fits in a few megabytes ASD in C2. That is true, but I'm working with a lot of software packages I'm doing packaging. And these days it's very frequent that some C++ software no longer compiles in 32 bits because the Clang process exceeds the 40-bit virtual average base. And that is because even if the ASD is just a couple megabytes, the internal data structures to represent all the things the optimizer is looking for are a hundred-fold of the size, a thousand-fold maybe. So that's an interesting question maybe for the future when C2 programs grow very big. Yeah, I looked at that. When I was working on the Linux kernel, I created a program to see how many lines of code the compiler actually had to parse, like a thousand files of C and how lots of files get included many times recursively also again. So the factor was roughly a factor of a hundred. So every thousand lines of code you create the compiler to parse like a hundred thousand lines and also analyze and stuff to stuff with it. But I think the biggest part will be probably the representation in LLVM and we can do that step by step because the modules are directed as cyclic graph. So they have a structure, one at the bottom and one at the top. So we can do them one by one. In the first slide you've shown that you can define methods and structures. So the question is do you have some kind of name mangling? Yes, you need to do some mangling but let's see here. It's really simple. In effect what we do we take the linked list, put the underscore at this one and this one is turned into an underscore so that's it. No, because it needs to be recognizable. So it's a really simple forward scheme. You can go both two ways, it's really easy. No, we start with the name of the module. So it's linked list underscore element underscore init. So how do you handle the case where you're linking with a C library that has that name which is a value? It's simple. Well, that gives you an error. It's like if you define a function printf in your C program you get an error. Yeah, so you get an error. In C you have a single namespace so this is a two-dimensional namespace so it's a linked list, a module name and that already solves so many problems that your namespace will be much cleaner. So he says that the symbols started with double underscore and underscore but the uppercase are on the implementation domain. So if you prepanded double underscore to all the symbols then you would know that you would never... Okay, I didn't know that so... Okay, that's easy to fix then. So double underscore and then capital. You could also use a scheme like the go-to channel and put a symbol into the linked symbols which cannot be used in C like you can put a bot in the symbol. For example, you could name the symbol element bot in it. I would never come out of anything. It's a smiley face. If you compile a NIC at the same time, can you actually parallelize the process? Like if you have like a one million files and you have eight cores do you use only one core to compile everything? No, we use many threads so we parse everything at once. We analyze it single thread because we don't do the locking and... Yes? So the modules we have an import like here. So this module depends on this module so we can build a graph. We sort all the modules and analyze the bottom up. And we also generate code that way but the generation of the code and the optimization is 90 something percent of the work. So that's done in threads. The other part is just milliseconds really. So in the thread when the symbol is not resolved because it's another module you just put some temporary hook that whenever it's resolved by the other thread then you update the symbol. No, the analysis is done over the whole program first. Bottom up. So everything is resolved. So the generation of codes just... it doesn't change the AST. Yes? So you were mentioning generics templates. Do you already have plans on how to handle separate compilations for that? Well we don't have to. I mean in C++ every time you use a vector in FAC file it has to generate the whole code for the vector and then in the end you have like 600 implementation and the linker has to remove them. That's why C++ is so slow. So here you don't have to do that. You have one implementation per instance of per use. If you have... So you have your say standard library module that defines the vector of t then you have two modules that both use vector of t that are compiled separately for some reason. Oh, no, you can... But they're not. They're never, yeah. It's quite easy, yeah. Can you reimplement the Linux kernel in C to C without macros? I wouldn't want to because Linux kernel is not a really good example. It's one of the worst pieces of open source there is. If you try to map to dependencies you get a fully connected graph. Everything depends on everything. It's horrible, no? Yeah. Yes? Do you have a C to C? You also have a C++ version. Yes? The C to version is much smaller. But there are also... Because some clang components we use are quite heavy. So it will require a lot of code. And clang is, of course, the components we use can do more than what we need. So they're a bit fat. But otherwise, yeah, the C to code is quite slim. That's also what we do with the name stuff. Here, like list, it doesn't need any prefix. In C, if you would use C, you would probably call it linked list underscore init. So you would have to type that all here. And then pass the list as an argument. Like if you have some component in C that's called foo. You already see foo underscore this, foo underscore that. And all that stuff is just reduced to a single name at the top and that's it. So your code gets a lot smaller in column size. Time's up. I see. Alright, thank you, Bas.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.64, "text": " Welcome. I am Bess Vandenberg. I have been working on a language called C2 for about", "tokens": [50364, 4027, 13, 286, 669, 363, 442, 691, 28762, 6873, 13, 286, 362, 668, 1364, 322, 257, 2856, 1219, 383, 17, 337, 466, 50946], "temperature": 0.0, "avg_logprob": -0.2776190948486328, "compression_ratio": 1.3724489795918366, "no_speech_prob": 0.20313844084739685}, {"id": 1, "seek": 0, "start": 11.64, "end": 20.72, "text": " 11 years now. I did two talks in FOSDEM in 2013 and 2015, I think. So this is the third", "tokens": [50946, 2975, 924, 586, 13, 286, 630, 732, 6686, 294, 479, 4367, 35, 6683, 294, 9012, 293, 7546, 11, 286, 519, 13, 407, 341, 307, 264, 2636, 51400], "temperature": 0.0, "avg_logprob": -0.2776190948486328, "compression_ratio": 1.3724489795918366, "no_speech_prob": 0.20313844084739685}, {"id": 2, "seek": 0, "start": 20.72, "end": 29.8, "text": " one about the compiler, so it's slightly different. So the presentation roughly has three parts.", "tokens": [51400, 472, 466, 264, 31958, 11, 370, 309, 311, 4748, 819, 13, 407, 264, 5860, 9810, 575, 1045, 3166, 13, 51854], "temperature": 0.0, "avg_logprob": -0.2776190948486328, "compression_ratio": 1.3724489795918366, "no_speech_prob": 0.20313844084739685}, {"id": 3, "seek": 2980, "start": 29.8, "end": 32.84, "text": " First the language introduction, because you can't talk about a compiler without knowing", "tokens": [50364, 2386, 264, 2856, 9339, 11, 570, 291, 393, 380, 751, 466, 257, 31958, 1553, 5276, 50516], "temperature": 0.0, "avg_logprob": -0.18677814355057276, "compression_ratio": 1.6036866359447004, "no_speech_prob": 0.01042341347783804}, {"id": 4, "seek": 2980, "start": 32.84, "end": 40.44, "text": " the language. Then the evolution of the C2 compiler, which is called C2C, because CC", "tokens": [50516, 264, 2856, 13, 1396, 264, 9303, 295, 264, 383, 17, 31958, 11, 597, 307, 1219, 383, 17, 34, 11, 570, 12630, 50896], "temperature": 0.0, "avg_logprob": -0.18677814355057276, "compression_ratio": 1.6036866359447004, "no_speech_prob": 0.01042341347783804}, {"id": 5, "seek": 2980, "start": 40.44, "end": 48.760000000000005, "text": " was already taken, of course. And then the next steps, so three parts. The first part,", "tokens": [50896, 390, 1217, 2726, 11, 295, 1164, 13, 400, 550, 264, 958, 4439, 11, 370, 1045, 3166, 13, 440, 700, 644, 11, 51312], "temperature": 0.0, "avg_logprob": -0.18677814355057276, "compression_ratio": 1.6036866359447004, "no_speech_prob": 0.01042341347783804}, {"id": 6, "seek": 2980, "start": 48.760000000000005, "end": 58.32, "text": " the language. There's a lot of info here. My reason for starting C2 was I'm an embedded", "tokens": [51312, 264, 2856, 13, 821, 311, 257, 688, 295, 13614, 510, 13, 1222, 1778, 337, 2891, 383, 17, 390, 286, 478, 364, 16741, 51790], "temperature": 0.0, "avg_logprob": -0.18677814355057276, "compression_ratio": 1.6036866359447004, "no_speech_prob": 0.01042341347783804}, {"id": 7, "seek": 5832, "start": 59.04, "end": 63.52, "text": " developer, so I work a lot with low level systems kernels and that sort of thing. And", "tokens": [50400, 10754, 11, 370, 286, 589, 257, 688, 365, 2295, 1496, 3652, 23434, 1625, 293, 300, 1333, 295, 551, 13, 400, 50624], "temperature": 0.0, "avg_logprob": -0.2176915545796239, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.024668937548995018}, {"id": 8, "seek": 5832, "start": 63.52, "end": 68.92, "text": " everyone was getting new programming languages except embedded programmers. So we are still", "tokens": [50624, 1518, 390, 1242, 777, 9410, 8650, 3993, 16741, 41504, 13, 407, 321, 366, 920, 50894], "temperature": 0.0, "avg_logprob": -0.2176915545796239, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.024668937548995018}, {"id": 9, "seek": 5832, "start": 68.92, "end": 79.8, "text": " writing kernels in C and no other programming language are really making it in that race.", "tokens": [50894, 3579, 23434, 1625, 294, 383, 293, 572, 661, 9410, 2856, 366, 534, 1455, 309, 294, 300, 4569, 13, 51438], "temperature": 0.0, "avg_logprob": -0.2176915545796239, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.024668937548995018}, {"id": 10, "seek": 5832, "start": 79.8, "end": 85.36, "text": " So I thought, well, we should be able to do something about that. So I love C, so let's", "tokens": [51438, 407, 286, 1194, 11, 731, 11, 321, 820, 312, 1075, 281, 360, 746, 466, 300, 13, 407, 286, 959, 383, 11, 370, 718, 311, 51716], "temperature": 0.0, "avg_logprob": -0.2176915545796239, "compression_ratio": 1.6511627906976745, "no_speech_prob": 0.024668937548995018}, {"id": 11, "seek": 8536, "start": 85.4, "end": 91.36, "text": " try to keep the good parts and remove the parts that have become somewhat older with", "tokens": [50366, 853, 281, 1066, 264, 665, 3166, 293, 4159, 264, 3166, 300, 362, 1813, 8344, 4906, 365, 50664], "temperature": 0.0, "avg_logprob": -0.1641099112374442, "compression_ratio": 1.5281385281385282, "no_speech_prob": 0.008824723772704601}, {"id": 12, "seek": 8536, "start": 91.36, "end": 98.16, "text": " time, since C is, of course, 50 years old. So what I did was I looked at the anti-patterns", "tokens": [50664, 565, 11, 1670, 383, 307, 11, 295, 1164, 11, 2625, 924, 1331, 13, 407, 437, 286, 630, 390, 286, 2956, 412, 264, 6061, 12, 79, 1161, 3695, 51004], "temperature": 0.0, "avg_logprob": -0.1641099112374442, "compression_ratio": 1.5281385281385282, "no_speech_prob": 0.008824723772704601}, {"id": 13, "seek": 8536, "start": 98.16, "end": 107.24, "text": " in C. For example, the types you define like Uint, 32T, and lots of macros, lots of plumbing", "tokens": [51004, 294, 383, 13, 1171, 1365, 11, 264, 3467, 291, 6964, 411, 624, 686, 11, 8858, 51, 11, 293, 3195, 295, 7912, 2635, 11, 3195, 295, 39993, 51458], "temperature": 0.0, "avg_logprob": -0.1641099112374442, "compression_ratio": 1.5281385281385282, "no_speech_prob": 0.008824723772704601}, {"id": 14, "seek": 8536, "start": 107.24, "end": 113.88, "text": " you have to do that everyone does in every project, like the size of an array macro.", "tokens": [51458, 291, 362, 281, 360, 300, 1518, 775, 294, 633, 1716, 11, 411, 264, 2744, 295, 364, 10225, 18887, 13, 51790], "temperature": 0.0, "avg_logprob": -0.1641099112374442, "compression_ratio": 1.5281385281385282, "no_speech_prob": 0.008824723772704601}, {"id": 15, "seek": 11388, "start": 113.88, "end": 120.08, "text": " And that's tried to get those out. Also, the header files had to go, because header files", "tokens": [50364, 400, 300, 311, 3031, 281, 483, 729, 484, 13, 2743, 11, 264, 23117, 7098, 632, 281, 352, 11, 570, 23117, 7098, 50674], "temperature": 0.0, "avg_logprob": -0.23334031252516912, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.008489918895065784}, {"id": 16, "seek": 11388, "start": 120.08, "end": 125.47999999999999, "text": " you had to type, yeah, your definitions twice and it's a hassle with a lot of stuff, a lot", "tokens": [50674, 291, 632, 281, 2010, 11, 1338, 11, 428, 21988, 6091, 293, 309, 311, 257, 39526, 365, 257, 688, 295, 1507, 11, 257, 688, 50944], "temperature": 0.0, "avg_logprob": -0.23334031252516912, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.008489918895065784}, {"id": 17, "seek": 11388, "start": 125.47999999999999, "end": 133.07999999999998, "text": " of tooling. Macros as well. So the macros also went out. And the goal was to get better", "tokens": [50944, 295, 46593, 13, 5707, 2635, 382, 731, 13, 407, 264, 7912, 2635, 611, 1437, 484, 13, 400, 264, 3387, 390, 281, 483, 1101, 51324], "temperature": 0.0, "avg_logprob": -0.23334031252516912, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.008489918895065784}, {"id": 18, "seek": 11388, "start": 133.07999999999998, "end": 139.44, "text": " development speed. So execution speed in C is not a problem, of course, but yeah, development", "tokens": [51324, 3250, 3073, 13, 407, 15058, 3073, 294, 383, 307, 406, 257, 1154, 11, 295, 1164, 11, 457, 1338, 11, 3250, 51642], "temperature": 0.0, "avg_logprob": -0.23334031252516912, "compression_ratio": 1.691588785046729, "no_speech_prob": 0.008489918895065784}, {"id": 19, "seek": 13944, "start": 139.44, "end": 149.56, "text": " speed is. Then the speed of execution can be better than C. That's because full program", "tokens": [50364, 3073, 307, 13, 1396, 264, 3073, 295, 15058, 393, 312, 1101, 813, 383, 13, 663, 311, 570, 1577, 1461, 50870], "temperature": 0.0, "avg_logprob": -0.1799639533547794, "compression_ratio": 1.5174418604651163, "no_speech_prob": 0.007173008285462856}, {"id": 20, "seek": 13944, "start": 149.56, "end": 156.88, "text": " optimization is easy in C2 and it's quite hard in C in a realistic program. So you can", "tokens": [50870, 19618, 307, 1858, 294, 383, 17, 293, 309, 311, 1596, 1152, 294, 383, 294, 257, 12465, 1461, 13, 407, 291, 393, 51236], "temperature": 0.0, "avg_logprob": -0.1799639533547794, "compression_ratio": 1.5174418604651163, "no_speech_prob": 0.007173008285462856}, {"id": 21, "seek": 13944, "start": 156.88, "end": 165.07999999999998, "text": " get better execution speed that way. It also has a built-in build system. So the scope", "tokens": [51236, 483, 1101, 15058, 3073, 300, 636, 13, 467, 611, 575, 257, 3094, 12, 259, 1322, 1185, 13, 407, 264, 11923, 51646], "temperature": 0.0, "avg_logprob": -0.1799639533547794, "compression_ratio": 1.5174418604651163, "no_speech_prob": 0.007173008285462856}, {"id": 22, "seek": 16508, "start": 165.08, "end": 170.52, "text": " of the C2 compiler is different than a C compiler. The C compiler, you feed it a single", "tokens": [50364, 295, 264, 383, 17, 31958, 307, 819, 813, 257, 383, 31958, 13, 440, 383, 31958, 11, 291, 3154, 309, 257, 2167, 50636], "temperature": 0.0, "avg_logprob": -0.16360045452507174, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.08384505659341812}, {"id": 23, "seek": 16508, "start": 170.52, "end": 175.08, "text": " C file, it produces an O file, and then you do that a lot of times and the linker just", "tokens": [50636, 383, 3991, 11, 309, 14725, 364, 422, 3991, 11, 293, 550, 291, 360, 300, 257, 688, 295, 1413, 293, 264, 2113, 260, 445, 50864], "temperature": 0.0, "avg_logprob": -0.16360045452507174, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.08384505659341812}, {"id": 24, "seek": 16508, "start": 175.08, "end": 183.08, "text": " collects everything and turns it into an executable. In C2, you run the C2 compiler, it takes a", "tokens": [50864, 39897, 1203, 293, 4523, 309, 666, 364, 7568, 712, 13, 682, 383, 17, 11, 291, 1190, 264, 383, 17, 31958, 11, 309, 2516, 257, 51264], "temperature": 0.0, "avg_logprob": -0.16360045452507174, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.08384505659341812}, {"id": 25, "seek": 16508, "start": 183.08, "end": 192.08, "text": " lot of source files and produces the binary. So it does use the linker, but the translation", "tokens": [51264, 688, 295, 4009, 7098, 293, 14725, 264, 17434, 13, 407, 309, 775, 764, 264, 2113, 260, 11, 457, 264, 12853, 51714], "temperature": 0.0, "avg_logprob": -0.16360045452507174, "compression_ratio": 1.7403846153846154, "no_speech_prob": 0.08384505659341812}, {"id": 26, "seek": 19208, "start": 192.08, "end": 198.76000000000002, "text": " unit is the whole program. So it can do a lot of diagnostics that the C compiler can", "tokens": [50364, 4985, 307, 264, 1379, 1461, 13, 407, 309, 393, 360, 257, 688, 295, 43215, 1167, 300, 264, 383, 31958, 393, 50698], "temperature": 0.0, "avg_logprob": -0.17693782860124616, "compression_ratio": 1.5568862275449102, "no_speech_prob": 0.018976114690303802}, {"id": 27, "seek": 19208, "start": 198.76000000000002, "end": 205.08, "text": " do. Like this field in this truck is never written in the whole program. So in C, that's", "tokens": [50698, 360, 13, 1743, 341, 2519, 294, 341, 5898, 307, 1128, 3720, 294, 264, 1379, 1461, 13, 407, 294, 383, 11, 300, 311, 51014], "temperature": 0.0, "avg_logprob": -0.17693782860124616, "compression_ratio": 1.5568862275449102, "no_speech_prob": 0.018976114690303802}, {"id": 28, "seek": 19208, "start": 205.08, "end": 212.96, "text": " not possible unless it's in the static part, in the C file for example. And I tried to", "tokens": [51014, 406, 1944, 5969, 309, 311, 294, 264, 13437, 644, 11, 294, 264, 383, 3991, 337, 1365, 13, 400, 286, 3031, 281, 51408], "temperature": 0.0, "avg_logprob": -0.17693782860124616, "compression_ratio": 1.5568862275449102, "no_speech_prob": 0.018976114690303802}, {"id": 29, "seek": 21296, "start": 212.96, "end": 222.12, "text": " get better tooling, like jump to definitions that are reliable and fast, analyzers that", "tokens": [50364, 483, 1101, 46593, 11, 411, 3012, 281, 21988, 300, 366, 12924, 293, 2370, 11, 6459, 41698, 300, 50822], "temperature": 0.0, "avg_logprob": -0.1996596322130801, "compression_ratio": 1.434065934065934, "no_speech_prob": 0.3848242163658142}, {"id": 30, "seek": 21296, "start": 222.12, "end": 231.92000000000002, "text": " are often hindered in C by the macro use, and so on. What I'm not trying to do is make", "tokens": [50822, 366, 2049, 20138, 4073, 294, 383, 538, 264, 18887, 764, 11, 293, 370, 322, 13, 708, 286, 478, 406, 1382, 281, 360, 307, 652, 51312], "temperature": 0.0, "avg_logprob": -0.1996596322130801, "compression_ratio": 1.434065934065934, "no_speech_prob": 0.3848242163658142}, {"id": 31, "seek": 21296, "start": 231.92000000000002, "end": 238.8, "text": " a completely new language, like Rust or Go, because it should be recognizable by C and", "tokens": [51312, 257, 2584, 777, 2856, 11, 411, 34952, 420, 1037, 11, 570, 309, 820, 312, 40757, 538, 383, 293, 51656], "temperature": 0.0, "avg_logprob": -0.1996596322130801, "compression_ratio": 1.434065934065934, "no_speech_prob": 0.3848242163658142}, {"id": 32, "seek": 23880, "start": 238.8, "end": 243.92000000000002, "text": " because I like the things in C, the abstraction layer is just to do it yourself, and it fits", "tokens": [50364, 570, 286, 411, 264, 721, 294, 383, 11, 264, 37765, 4583, 307, 445, 281, 360, 309, 1803, 11, 293, 309, 9001, 50620], "temperature": 0.0, "avg_logprob": -0.17411384176700673, "compression_ratio": 1.5084033613445378, "no_speech_prob": 0.14557847380638123}, {"id": 33, "seek": 23880, "start": 243.92000000000002, "end": 250.68, "text": " the hardware we have now, so that's okay. And I also don't want to add higher level", "tokens": [50620, 264, 8837, 321, 362, 586, 11, 370, 300, 311, 1392, 13, 400, 286, 611, 500, 380, 528, 281, 909, 2946, 1496, 50958], "temperature": 0.0, "avg_logprob": -0.17411384176700673, "compression_ratio": 1.5084033613445378, "no_speech_prob": 0.14557847380638123}, {"id": 34, "seek": 23880, "start": 250.68, "end": 257.12, "text": " features like garbage collection or runtime, because it's not the domain I'm trying to", "tokens": [50958, 4122, 411, 14150, 5765, 420, 34474, 11, 570, 309, 311, 406, 264, 9274, 286, 478, 1382, 281, 51280], "temperature": 0.0, "avg_logprob": -0.17411384176700673, "compression_ratio": 1.5084033613445378, "no_speech_prob": 0.14557847380638123}, {"id": 35, "seek": 23880, "start": 257.12, "end": 268.2, "text": " use it for. So let's see an example. How many people ever looked at a piece of C2 code already?", "tokens": [51280, 764, 309, 337, 13, 407, 718, 311, 536, 364, 1365, 13, 1012, 867, 561, 1562, 2956, 412, 257, 2522, 295, 383, 17, 3089, 1217, 30, 51834], "temperature": 0.0, "avg_logprob": -0.17411384176700673, "compression_ratio": 1.5084033613445378, "no_speech_prob": 0.14557847380638123}, {"id": 36, "seek": 26820, "start": 268.59999999999997, "end": 285.28, "text": " Probably a few. Well, every file... The dog did. Every file starts with a module definition", "tokens": [50384, 9210, 257, 1326, 13, 1042, 11, 633, 3991, 485, 440, 3000, 630, 13, 2048, 3991, 3719, 365, 257, 10088, 7123, 51218], "temperature": 0.0, "avg_logprob": -0.23691943112541647, "compression_ratio": 1.6058823529411765, "no_speech_prob": 0.044368959963321686}, {"id": 37, "seek": 26820, "start": 285.28, "end": 290.52, "text": " where you define every file as part of a module, and a module is just a piece of code. Different", "tokens": [51218, 689, 291, 6964, 633, 3991, 382, 644, 295, 257, 10088, 11, 293, 257, 10088, 307, 445, 257, 2522, 295, 3089, 13, 20825, 51480], "temperature": 0.0, "avg_logprob": -0.23691943112541647, "compression_ratio": 1.6058823529411765, "no_speech_prob": 0.044368959963321686}, {"id": 38, "seek": 26820, "start": 290.52, "end": 295.91999999999996, "text": " files can belong to the same module. Then you get a bunch of definitions like a type", "tokens": [51480, 7098, 393, 5784, 281, 264, 912, 10088, 13, 1396, 291, 483, 257, 3840, 295, 21988, 411, 257, 2010, 51750], "temperature": 0.0, "avg_logprob": -0.23691943112541647, "compression_ratio": 1.6058823529411765, "no_speech_prob": 0.044368959963321686}, {"id": 39, "seek": 29592, "start": 296.0, "end": 302.64000000000004, "text": " and two functions. The order here doesn't matter. The ordering is for a compiler, not", "tokens": [50368, 293, 732, 6828, 13, 440, 1668, 510, 1177, 380, 1871, 13, 440, 21739, 307, 337, 257, 31958, 11, 406, 50700], "temperature": 0.0, "avg_logprob": -0.1911561445756392, "compression_ratio": 1.7738095238095237, "no_speech_prob": 0.04837304726243019}, {"id": 40, "seek": 29592, "start": 302.64000000000004, "end": 308.84000000000003, "text": " for humans. There are no forward declarations. In 50 years ago, when the compiler had memory", "tokens": [50700, 337, 6255, 13, 821, 366, 572, 2128, 16694, 763, 13, 682, 2625, 924, 2057, 11, 562, 264, 31958, 632, 4675, 51010], "temperature": 0.0, "avg_logprob": -0.1911561445756392, "compression_ratio": 1.7738095238095237, "no_speech_prob": 0.04837304726243019}, {"id": 41, "seek": 29592, "start": 308.84000000000003, "end": 314.08000000000004, "text": " problems, it was an issue. So the user, the programmer had to structure the program, so", "tokens": [51010, 2740, 11, 309, 390, 364, 2734, 13, 407, 264, 4195, 11, 264, 32116, 632, 281, 3877, 264, 1461, 11, 370, 51272], "temperature": 0.0, "avg_logprob": -0.1911561445756392, "compression_ratio": 1.7738095238095237, "no_speech_prob": 0.04837304726243019}, {"id": 42, "seek": 29592, "start": 314.08000000000004, "end": 320.52000000000004, "text": " I first do the forward declaration, and then like this part, the element points to an element", "tokens": [51272, 286, 700, 360, 264, 2128, 27606, 11, 293, 550, 411, 341, 644, 11, 264, 4478, 2793, 281, 364, 4478, 51594], "temperature": 0.0, "avg_logprob": -0.1911561445756392, "compression_ratio": 1.7738095238095237, "no_speech_prob": 0.04837304726243019}, {"id": 43, "seek": 29592, "start": 320.52000000000004, "end": 324.20000000000005, "text": " again in C. That's not possible. You have to do forward declaration of the struct, and", "tokens": [51594, 797, 294, 383, 13, 663, 311, 406, 1944, 13, 509, 362, 281, 360, 2128, 27606, 295, 264, 6594, 11, 293, 51778], "temperature": 0.0, "avg_logprob": -0.1911561445756392, "compression_ratio": 1.7738095238095237, "no_speech_prob": 0.04837304726243019}, {"id": 44, "seek": 32420, "start": 324.2, "end": 330.2, "text": " then the definition, that's a computer problem, and it should be able to do that.", "tokens": [50364, 550, 264, 7123, 11, 300, 311, 257, 3820, 1154, 11, 293, 309, 820, 312, 1075, 281, 360, 300, 13, 50664], "temperature": 0.0, "avg_logprob": -0.174032563748567, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.0013915090821683407}, {"id": 45, "seek": 32420, "start": 332.2, "end": 338.0, "text": " A second thing you'll notice here is the public keyword. Types and functions can be public", "tokens": [50764, 316, 1150, 551, 291, 603, 3449, 510, 307, 264, 1908, 20428, 13, 5569, 5190, 293, 6828, 393, 312, 1908, 51054], "temperature": 0.0, "avg_logprob": -0.174032563748567, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.0013915090821683407}, {"id": 46, "seek": 32420, "start": 338.0, "end": 349.0, "text": " or not. Public means it can be called by other modules. Another one is this one. This is called", "tokens": [51054, 420, 406, 13, 9489, 1355, 309, 393, 312, 1219, 538, 661, 16679, 13, 3996, 472, 307, 341, 472, 13, 639, 307, 1219, 51604], "temperature": 0.0, "avg_logprob": -0.174032563748567, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.0013915090821683407}, {"id": 47, "seek": 32420, "start": 349.0, "end": 353.76, "text": " a struct function. So we have a struct, and we can just add these functions to it, and you", "tokens": [51604, 257, 6594, 2445, 13, 407, 321, 362, 257, 6594, 11, 293, 321, 393, 445, 909, 613, 6828, 281, 309, 11, 293, 291, 51842], "temperature": 0.0, "avg_logprob": -0.174032563748567, "compression_ratio": 1.662037037037037, "no_speech_prob": 0.0013915090821683407}, {"id": 48, "seek": 35376, "start": 353.8, "end": 360.8, "text": " can, in the next slide, also, you can do element dot in it. You can add them arbitrarily. Not", "tokens": [50366, 393, 11, 294, 264, 958, 4137, 11, 611, 11, 291, 393, 360, 4478, 5893, 294, 309, 13, 509, 393, 909, 552, 19071, 3289, 13, 1726, 50716], "temperature": 0.0, "avg_logprob": -0.1969008539237228, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0015781862894073129}, {"id": 49, "seek": 35376, "start": 360.8, "end": 369.3, "text": " just in C++, but you have to add it in the class definition. Another change from C was", "tokens": [50716, 445, 294, 383, 25472, 11, 457, 291, 362, 281, 909, 309, 294, 264, 1508, 7123, 13, 3996, 1319, 490, 383, 390, 51141], "temperature": 0.0, "avg_logprob": -0.1969008539237228, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0015781862894073129}, {"id": 50, "seek": 35376, "start": 369.3, "end": 374.59999999999997, "text": " the dot here. These are pointers. In C, you have to use the arrow, and a dot for the full", "tokens": [51141, 264, 5893, 510, 13, 1981, 366, 44548, 13, 682, 383, 11, 291, 362, 281, 764, 264, 11610, 11, 293, 257, 5893, 337, 264, 1577, 51406], "temperature": 0.0, "avg_logprob": -0.1969008539237228, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0015781862894073129}, {"id": 51, "seek": 35376, "start": 374.59999999999997, "end": 381.59999999999997, "text": " body. In C2, we make no difference. It's all a dot, because it's better readable.", "tokens": [51406, 1772, 13, 682, 383, 17, 11, 321, 652, 572, 2649, 13, 467, 311, 439, 257, 5893, 11, 570, 309, 311, 1101, 49857, 13, 51756], "temperature": 0.0, "avg_logprob": -0.1969008539237228, "compression_ratio": 1.550660792951542, "no_speech_prob": 0.0015781862894073129}, {"id": 52, "seek": 38376, "start": 384.12, "end": 389.08, "text": " Okay, so how do we use this part? This is just an example, of course. It would roughly", "tokens": [50382, 1033, 11, 370, 577, 360, 321, 764, 341, 644, 30, 639, 307, 445, 364, 1365, 11, 295, 1164, 13, 467, 576, 9810, 50630], "temperature": 0.0, "avg_logprob": -0.19123432159423828, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.0018180612241849303}, {"id": 53, "seek": 38376, "start": 389.08, "end": 396.08, "text": " look like this. So you import the list, the linked list module, use the element, and then", "tokens": [50630, 574, 411, 341, 13, 407, 291, 974, 264, 1329, 11, 264, 9408, 1329, 10088, 11, 764, 264, 4478, 11, 293, 550, 50980], "temperature": 0.0, "avg_logprob": -0.19123432159423828, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.0018180612241849303}, {"id": 54, "seek": 38376, "start": 396.59999999999997, "end": 402.8, "text": " do something with it. The thing to note here is that the import has no file name. So in", "tokens": [51006, 360, 746, 365, 309, 13, 440, 551, 281, 3637, 510, 307, 300, 264, 974, 575, 572, 3991, 1315, 13, 407, 294, 51316], "temperature": 0.0, "avg_logprob": -0.19123432159423828, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.0018180612241849303}, {"id": 55, "seek": 38376, "start": 402.8, "end": 408.15999999999997, "text": " C, you do includes, and includes has a file name. It has a path or a sub-directory. That's", "tokens": [51316, 383, 11, 291, 360, 5974, 11, 293, 5974, 575, 257, 3991, 1315, 13, 467, 575, 257, 3100, 420, 257, 1422, 12, 44868, 827, 13, 663, 311, 51584], "temperature": 0.0, "avg_logprob": -0.19123432159423828, "compression_ratio": 1.6210045662100456, "no_speech_prob": 0.0018180612241849303}, {"id": 56, "seek": 40816, "start": 408.20000000000005, "end": 414.56, "text": " all very unhandy when you try to reuse stuff, and it's in the utils library directory, and", "tokens": [50366, 439, 588, 517, 5543, 88, 562, 291, 853, 281, 26225, 1507, 11, 293, 309, 311, 294, 264, 2839, 4174, 6405, 21120, 11, 293, 50684], "temperature": 0.0, "avg_logprob": -0.22151453741665544, "compression_ratio": 1.7237354085603114, "no_speech_prob": 0.022207390516996384}, {"id": 57, "seek": 40816, "start": 414.56, "end": 419.28000000000003, "text": " in another project, in the lib directory, you have to change the header files and includes.", "tokens": [50684, 294, 1071, 1716, 11, 294, 264, 22854, 21120, 11, 291, 362, 281, 1319, 264, 23117, 7098, 293, 5974, 13, 50920], "temperature": 0.0, "avg_logprob": -0.22151453741665544, "compression_ratio": 1.7237354085603114, "no_speech_prob": 0.022207390516996384}, {"id": 58, "seek": 40816, "start": 419.28000000000003, "end": 424.20000000000005, "text": " That's not the case here. You can just put the files somewhere on your file system in", "tokens": [50920, 663, 311, 406, 264, 1389, 510, 13, 509, 393, 445, 829, 264, 7098, 4079, 322, 428, 3991, 1185, 294, 51166], "temperature": 0.0, "avg_logprob": -0.22151453741665544, "compression_ratio": 1.7237354085603114, "no_speech_prob": 0.022207390516996384}, {"id": 59, "seek": 40816, "start": 424.20000000000005, "end": 431.20000000000005, "text": " your project, and I'll show that later, and in your recipe file, and then it will work.", "tokens": [51166, 428, 1716, 11, 293, 286, 603, 855, 300, 1780, 11, 293, 294, 428, 6782, 3991, 11, 293, 550, 309, 486, 589, 13, 51516], "temperature": 0.0, "avg_logprob": -0.22151453741665544, "compression_ratio": 1.7237354085603114, "no_speech_prob": 0.022207390516996384}, {"id": 60, "seek": 40816, "start": 432.28000000000003, "end": 438.04, "text": " But otherwise, if you look at the body function body, it's pretty similar to C. So the", "tokens": [51570, 583, 5911, 11, 498, 291, 574, 412, 264, 1772, 2445, 1772, 11, 309, 311, 1238, 2531, 281, 383, 13, 407, 264, 51858], "temperature": 0.0, "avg_logprob": -0.22151453741665544, "compression_ratio": 1.7237354085603114, "no_speech_prob": 0.022207390516996384}, {"id": 61, "seek": 43804, "start": 438.08000000000004, "end": 443.24, "text": " plumbing, like the rest of it, looks different, but if you have a large function with four", "tokens": [50366, 39993, 11, 411, 264, 1472, 295, 309, 11, 1542, 819, 11, 457, 498, 291, 362, 257, 2416, 2445, 365, 1451, 50624], "temperature": 0.0, "avg_logprob": -0.16114007380970738, "compression_ratio": 1.6762295081967213, "no_speech_prob": 0.0008292485726997256}, {"id": 62, "seek": 43804, "start": 443.24, "end": 446.24, "text": " loops, it's just the same. It looks really the same.", "tokens": [50624, 16121, 11, 309, 311, 445, 264, 912, 13, 467, 1542, 534, 264, 912, 13, 50774], "temperature": 0.0, "avg_logprob": -0.16114007380970738, "compression_ratio": 1.6762295081967213, "no_speech_prob": 0.0008292485726997256}, {"id": 63, "seek": 43804, "start": 450.84000000000003, "end": 455.16, "text": " So because the scope of the C2 compiler is the whole program, you have to tell it what", "tokens": [51004, 407, 570, 264, 11923, 295, 264, 383, 17, 31958, 307, 264, 1379, 1461, 11, 291, 362, 281, 980, 309, 437, 51220], "temperature": 0.0, "avg_logprob": -0.16114007380970738, "compression_ratio": 1.6762295081967213, "no_speech_prob": 0.0008292485726997256}, {"id": 64, "seek": 43804, "start": 455.16, "end": 461.24, "text": " to do. So you just run C2C, and you can give it arguments, but you don't have to. It will", "tokens": [51220, 281, 360, 13, 407, 291, 445, 1190, 383, 17, 34, 11, 293, 291, 393, 976, 309, 12869, 11, 457, 291, 500, 380, 362, 281, 13, 467, 486, 51524], "temperature": 0.0, "avg_logprob": -0.16114007380970738, "compression_ratio": 1.6762295081967213, "no_speech_prob": 0.0008292485726997256}, {"id": 65, "seek": 43804, "start": 461.24, "end": 467.76, "text": " look up the recipe file, and then do whatever you want. So you can turn it into an extra", "tokens": [51524, 574, 493, 264, 6782, 3991, 11, 293, 550, 360, 2035, 291, 528, 13, 407, 291, 393, 1261, 309, 666, 364, 2857, 51850], "temperature": 0.0, "avg_logprob": -0.16114007380970738, "compression_ratio": 1.6762295081967213, "no_speech_prob": 0.0008292485726997256}, {"id": 66, "seek": 46776, "start": 467.8, "end": 473.88, "text": " executable or a library. These are the files, so it will not dynamically look for files", "tokens": [50366, 7568, 712, 420, 257, 6405, 13, 1981, 366, 264, 7098, 11, 370, 309, 486, 406, 43492, 574, 337, 7098, 50670], "temperature": 0.0, "avg_logprob": -0.18226422819980356, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.0018496670527383685}, {"id": 67, "seek": 46776, "start": 473.88, "end": 480.56, "text": " with some name. It will also not use directory structures as the module name or something,", "tokens": [50670, 365, 512, 1315, 13, 467, 486, 611, 406, 764, 21120, 9227, 382, 264, 10088, 1315, 420, 746, 11, 51004], "temperature": 0.0, "avg_logprob": -0.18226422819980356, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.0018496670527383685}, {"id": 68, "seek": 46776, "start": 480.56, "end": 487.56, "text": " like some languages do, but it will do this. And also, this is the configuration part.", "tokens": [51004, 411, 512, 8650, 360, 11, 457, 309, 486, 360, 341, 13, 400, 611, 11, 341, 307, 264, 11694, 644, 13, 51354], "temperature": 0.0, "avg_logprob": -0.18226422819980356, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.0018496670527383685}, {"id": 69, "seek": 46776, "start": 490.68, "end": 497.2, "text": " There are only a few options. In CUF, I have given actually presentations about the warning", "tokens": [51510, 821, 366, 787, 257, 1326, 3956, 13, 682, 29777, 37, 11, 286, 362, 2212, 767, 18964, 466, 264, 9164, 51836], "temperature": 0.0, "avg_logprob": -0.18226422819980356, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.0018496670527383685}, {"id": 70, "seek": 49720, "start": 497.24, "end": 502.24, "text": " flags in C. In C2, the only warnings you have is unused. The rest is just an error.", "tokens": [50366, 23265, 294, 383, 13, 682, 383, 17, 11, 264, 787, 30009, 291, 362, 307, 44383, 13, 440, 1472, 307, 445, 364, 6713, 13, 50616], "temperature": 0.0, "avg_logprob": -0.20256928994622028, "compression_ratio": 1.4610778443113772, "no_speech_prob": 0.0021332355681806803}, {"id": 71, "seek": 49720, "start": 506.64, "end": 512.24, "text": " So unused can be, of course, if you are refactoring, it can be annoying. You can temporarily", "tokens": [50836, 407, 44383, 393, 312, 11, 295, 1164, 11, 498, 291, 366, 1895, 578, 3662, 11, 309, 393, 312, 11304, 13, 509, 393, 23750, 51116], "temperature": 0.0, "avg_logprob": -0.20256928994622028, "compression_ratio": 1.4610778443113772, "no_speech_prob": 0.0021332355681806803}, {"id": 72, "seek": 49720, "start": 512.24, "end": 518.24, "text": " silence them, but other stuff you can't ignore. You have to fix it.", "tokens": [51116, 12239, 552, 11, 457, 661, 1507, 291, 393, 380, 11200, 13, 509, 362, 281, 3191, 309, 13, 51416], "temperature": 0.0, "avg_logprob": -0.20256928994622028, "compression_ratio": 1.4610778443113772, "no_speech_prob": 0.0021332355681806803}, {"id": 73, "seek": 51824, "start": 518.5600000000001, "end": 525.5600000000001, "text": " So, what other features does the language have? Modules, imports, with the recipe file. We", "tokens": [50380, 407, 11, 437, 661, 4122, 775, 264, 2856, 362, 30, 6583, 3473, 11, 41596, 11, 365, 264, 6782, 3991, 13, 492, 50730], "temperature": 0.0, "avg_logprob": -0.24201959371566772, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0034733363427221775}, {"id": 74, "seek": 51824, "start": 527.6800000000001, "end": 533.2, "text": " have a lot of stuff like elements of, which is the built-in function, like size of, but", "tokens": [50836, 362, 257, 688, 295, 1507, 411, 4959, 295, 11, 597, 307, 264, 3094, 12, 259, 2445, 11, 411, 2744, 295, 11, 457, 51112], "temperature": 0.0, "avg_logprob": -0.24201959371566772, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0034733363427221775}, {"id": 75, "seek": 51824, "start": 533.2, "end": 538.8, "text": " then for array sizes. We have enum min, enum max, which is the first and the last element", "tokens": [51112, 550, 337, 10225, 11602, 13, 492, 362, 465, 449, 923, 11, 465, 449, 11469, 11, 597, 307, 264, 700, 293, 264, 1036, 4478, 51392], "temperature": 0.0, "avg_logprob": -0.24201959371566772, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0034733363427221775}, {"id": 76, "seek": 51824, "start": 538.8, "end": 544.92, "text": " or the highest element in an enum, offset of to container, which are usually macros in", "tokens": [51392, 420, 264, 6343, 4478, 294, 364, 465, 449, 11, 18687, 295, 281, 10129, 11, 597, 366, 2673, 7912, 2635, 294, 51698], "temperature": 0.0, "avg_logprob": -0.24201959371566772, "compression_ratio": 1.6824644549763033, "no_speech_prob": 0.0034733363427221775}, {"id": 77, "seek": 54492, "start": 545.04, "end": 552.04, "text": " C, but they are part of the language here. Also, the base types are all in there. We have", "tokens": [50370, 383, 11, 457, 436, 366, 644, 295, 264, 2856, 510, 13, 2743, 11, 264, 3096, 3467, 366, 439, 294, 456, 13, 492, 362, 50720], "temperature": 0.0, "avg_logprob": -0.1968528057666535, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.006625988520681858}, {"id": 78, "seek": 54492, "start": 553.12, "end": 559.64, "text": " opaque data types, which are types in C that you only use by pointer. So, like you have", "tokens": [50774, 42687, 1412, 3467, 11, 597, 366, 3467, 294, 383, 300, 291, 787, 764, 538, 23918, 13, 407, 11, 411, 291, 362, 51100], "temperature": 0.0, "avg_logprob": -0.1968528057666535, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.006625988520681858}, {"id": 79, "seek": 54492, "start": 559.64, "end": 565.04, "text": " some component and you call a create function, you get a handle back, but you cannot, you", "tokens": [51100, 512, 6542, 293, 291, 818, 257, 1884, 2445, 11, 291, 483, 257, 4813, 646, 11, 457, 291, 2644, 11, 291, 51370], "temperature": 0.0, "avg_logprob": -0.1968528057666535, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.006625988520681858}, {"id": 80, "seek": 54492, "start": 565.04, "end": 569.8399999999999, "text": " can only use the handle by pointer. You cannot actually look into it, and that's opaque data", "tokens": [51370, 393, 787, 764, 264, 4813, 538, 23918, 13, 509, 2644, 767, 574, 666, 309, 11, 293, 300, 311, 42687, 1412, 51610], "temperature": 0.0, "avg_logprob": -0.1968528057666535, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.006625988520681858}, {"id": 81, "seek": 56984, "start": 569.84, "end": 576.84, "text": " types. That's made explicit here. Another thing you can do, because we have full program", "tokens": [50364, 3467, 13, 663, 311, 1027, 13691, 510, 13, 3996, 551, 291, 393, 360, 11, 570, 321, 362, 1577, 1461, 50714], "temperature": 0.0, "avg_logprob": -0.20887236368088496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.019957149401307106}, {"id": 82, "seek": 56984, "start": 578.36, "end": 585.12, "text": " scope, is global incremental arrays, which are just array, global arrays, but you can", "tokens": [50790, 11923, 11, 307, 4338, 35759, 41011, 11, 597, 366, 445, 10225, 11, 4338, 41011, 11, 457, 291, 393, 51128], "temperature": 0.0, "avg_logprob": -0.20887236368088496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.019957149401307106}, {"id": 83, "seek": 56984, "start": 585.12, "end": 590.24, "text": " define them in different files and you can have them behind the configuration sort of", "tokens": [51128, 6964, 552, 294, 819, 7098, 293, 291, 393, 362, 552, 2261, 264, 11694, 1333, 295, 51384], "temperature": 0.0, "avg_logprob": -0.20887236368088496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.019957149401307106}, {"id": 84, "seek": 56984, "start": 590.24, "end": 595.24, "text": " if-devs. So, if you have this feature, these elements are added to the array and otherwise", "tokens": [51384, 498, 12, 40343, 82, 13, 407, 11, 498, 291, 362, 341, 4111, 11, 613, 4959, 366, 3869, 281, 264, 10225, 293, 5911, 51634], "temperature": 0.0, "avg_logprob": -0.20887236368088496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.019957149401307106}, {"id": 85, "seek": 59524, "start": 595.36, "end": 600.12, "text": " they don't. But in the end, the compiler will put them all together and turn it into a single", "tokens": [50370, 436, 500, 380, 13, 583, 294, 264, 917, 11, 264, 31958, 486, 829, 552, 439, 1214, 293, 1261, 309, 666, 257, 2167, 50608], "temperature": 0.0, "avg_logprob": -0.20127424986466116, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.003679018234834075}, {"id": 86, "seek": 59524, "start": 600.12, "end": 607.12, "text": " array. Another feature I've never seen in other languages is the build file. It's also", "tokens": [50608, 10225, 13, 3996, 4111, 286, 600, 1128, 1612, 294, 661, 8650, 307, 264, 1322, 3991, 13, 467, 311, 611, 50958], "temperature": 0.0, "avg_logprob": -0.20127424986466116, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.003679018234834075}, {"id": 87, "seek": 59524, "start": 610.08, "end": 617.08, "text": " another file, which is optional. The recipe and the code is made by the developer, but", "tokens": [51106, 1071, 3991, 11, 597, 307, 17312, 13, 440, 6782, 293, 264, 3089, 307, 1027, 538, 264, 10754, 11, 457, 51456], "temperature": 0.0, "avg_logprob": -0.20127424986466116, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.003679018234834075}, {"id": 88, "seek": 59524, "start": 617.24, "end": 622.28, "text": " the other users of a program can be, for example, open embedded or Yocto systems, where you", "tokens": [51464, 264, 661, 5022, 295, 257, 1461, 393, 312, 11, 337, 1365, 11, 1269, 16741, 420, 7616, 349, 78, 3652, 11, 689, 291, 51716], "temperature": 0.0, "avg_logprob": -0.20127424986466116, "compression_ratio": 1.5676855895196506, "no_speech_prob": 0.003679018234834075}, {"id": 89, "seek": 62228, "start": 622.3199999999999, "end": 628.8199999999999, "text": " have to tell it how to build where the directories are, and that is specified in a build file.", "tokens": [50366, 362, 281, 980, 309, 577, 281, 1322, 689, 264, 5391, 530, 366, 11, 293, 300, 307, 22206, 294, 257, 1322, 3991, 13, 50691], "temperature": 0.0, "avg_logprob": -0.20690331710012336, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.0013781930319964886}, {"id": 90, "seek": 62228, "start": 628.8199999999999, "end": 635.8199999999999, "text": " So, that's not created by the developer, but by the users or the package managers or those", "tokens": [50691, 407, 11, 300, 311, 406, 2942, 538, 264, 10754, 11, 457, 538, 264, 5022, 420, 264, 7372, 14084, 420, 729, 51041], "temperature": 0.0, "avg_logprob": -0.20690331710012336, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.0013781930319964886}, {"id": 91, "seek": 62228, "start": 636.04, "end": 642.04, "text": " people. Another feature, which I haven't seen in other languages or compilers is plugins.", "tokens": [51052, 561, 13, 3996, 4111, 11, 597, 286, 2378, 380, 1612, 294, 661, 8650, 420, 715, 388, 433, 307, 33759, 13, 51352], "temperature": 0.0, "avg_logprob": -0.20690331710012336, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.0013781930319964886}, {"id": 92, "seek": 62228, "start": 642.04, "end": 648.0, "text": " So, the C2 compiler has a plugin system. You can write plugins for it to walk the ASD,", "tokens": [51352, 407, 11, 264, 383, 17, 31958, 575, 257, 23407, 1185, 13, 509, 393, 2464, 33759, 337, 309, 281, 1792, 264, 7469, 35, 11, 51650], "temperature": 0.0, "avg_logprob": -0.20690331710012336, "compression_ratio": 1.6017699115044248, "no_speech_prob": 0.0013781930319964886}, {"id": 93, "seek": 64800, "start": 648.0, "end": 654.44, "text": " do stuff with it, either before parsing the other stuff or after. I'll come back to that", "tokens": [50364, 360, 1507, 365, 309, 11, 2139, 949, 21156, 278, 264, 661, 1507, 420, 934, 13, 286, 603, 808, 646, 281, 300, 50686], "temperature": 0.0, "avg_logprob": -0.20967296759287515, "compression_ratio": 1.4480874316939891, "no_speech_prob": 0.024374568834900856}, {"id": 94, "seek": 64800, "start": 654.44, "end": 661.44, "text": " later. Let me check the time. Current state. We have 900 unit tests. It does run, so it's", "tokens": [50686, 1780, 13, 961, 385, 1520, 264, 565, 13, 15629, 1785, 13, 492, 362, 22016, 4985, 6921, 13, 467, 775, 1190, 11, 370, 309, 311, 51036], "temperature": 0.0, "avg_logprob": -0.20967296759287515, "compression_ratio": 1.4480874316939891, "no_speech_prob": 0.024374568834900856}, {"id": 95, "seek": 64800, "start": 665.76, "end": 672.76, "text": " quite okay. It gives quite nice diagnostics. Weird cases are all covered. Doesn't mean", "tokens": [51252, 1596, 1392, 13, 467, 2709, 1596, 1481, 43215, 1167, 13, 32033, 3331, 366, 439, 5343, 13, 12955, 380, 914, 51602], "temperature": 0.0, "avg_logprob": -0.20967296759287515, "compression_ratio": 1.4480874316939891, "no_speech_prob": 0.024374568834900856}, {"id": 96, "seek": 67276, "start": 673.76, "end": 680.76, "text": " there aren't more. There probably are a lot. Lipsy support, pthread support. I once supported", "tokens": [50414, 456, 3212, 380, 544, 13, 821, 1391, 366, 257, 688, 13, 441, 2600, 88, 1406, 11, 280, 392, 2538, 1406, 13, 286, 1564, 8104, 50764], "temperature": 0.0, "avg_logprob": -0.28658190081196444, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.0040407502092421055}, {"id": 97, "seek": 67276, "start": 681.56, "end": 688.56, "text": " the Vulkan library, the Graphics library to C2 that worked, well, written web server,", "tokens": [50804, 264, 41434, 5225, 6405, 11, 264, 21884, 1167, 6405, 281, 383, 17, 300, 2732, 11, 731, 11, 3720, 3670, 7154, 11, 51154], "temperature": 0.0, "avg_logprob": -0.28658190081196444, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.0040407502092421055}, {"id": 98, "seek": 67276, "start": 688.56, "end": 693.28, "text": " web socket server event framework. There are plugins for VIM or Neo VIM to jump to definitions", "tokens": [51154, 3670, 19741, 7154, 2280, 8388, 13, 821, 366, 33759, 337, 691, 6324, 420, 24458, 691, 6324, 281, 3012, 281, 21988, 51390], "temperature": 0.0, "avg_logprob": -0.28658190081196444, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.0040407502092421055}, {"id": 99, "seek": 67276, "start": 693.28, "end": 700.28, "text": " that are really fast and correct. We can generate dependency matrixes of the whole code to some", "tokens": [51390, 300, 366, 534, 2370, 293, 3006, 13, 492, 393, 8460, 33621, 8141, 279, 295, 264, 1379, 3089, 281, 512, 51740], "temperature": 0.0, "avg_logprob": -0.28658190081196444, "compression_ratio": 1.5611814345991561, "no_speech_prob": 0.0040407502092421055}, {"id": 100, "seek": 70276, "start": 702.76, "end": 709.76, "text": " format, also through plugins. This part, the embedded user is still in progress, so that's", "tokens": [50364, 7877, 11, 611, 807, 33759, 13, 639, 644, 11, 264, 16741, 4195, 307, 920, 294, 4205, 11, 370, 300, 311, 50714], "temperature": 0.0, "avg_logprob": -0.19790274446660822, "compression_ratio": 1.6380090497737556, "no_speech_prob": 0.0023962855339050293}, {"id": 101, "seek": 70276, "start": 710.16, "end": 716.12, "text": " the bare metal case. You need linker scripts for that. Inline assembly is supported already,", "tokens": [50734, 264, 6949, 5760, 1389, 13, 509, 643, 2113, 260, 23294, 337, 300, 13, 682, 1889, 12103, 307, 8104, 1217, 11, 51032], "temperature": 0.0, "avg_logprob": -0.19790274446660822, "compression_ratio": 1.6380090497737556, "no_speech_prob": 0.0023962855339050293}, {"id": 102, "seek": 70276, "start": 716.12, "end": 722.8, "text": " but you need more for that. You also need the bare assembly. And it's been used in some", "tokens": [51032, 457, 291, 643, 544, 337, 300, 13, 509, 611, 643, 264, 6949, 12103, 13, 400, 309, 311, 668, 1143, 294, 512, 51366], "temperature": 0.0, "avg_logprob": -0.19790274446660822, "compression_ratio": 1.6380090497737556, "no_speech_prob": 0.0023962855339050293}, {"id": 103, "seek": 70276, "start": 722.8, "end": 729.8, "text": " production code, web server client and customer service for customers I work for. I advise", "tokens": [51366, 4265, 3089, 11, 3670, 7154, 6423, 293, 5474, 2643, 337, 4581, 286, 589, 337, 13, 286, 18312, 51716], "temperature": 0.0, "avg_logprob": -0.19790274446660822, "compression_ratio": 1.6380090497737556, "no_speech_prob": 0.0023962855339050293}, {"id": 104, "seek": 72980, "start": 729.88, "end": 736.88, "text": " them to use C2. Okay. So the second part is about the evolution of the compiler itself.", "tokens": [50368, 552, 281, 764, 383, 17, 13, 1033, 13, 407, 264, 1150, 644, 307, 466, 264, 9303, 295, 264, 31958, 2564, 13, 50718], "temperature": 0.0, "avg_logprob": -0.329730434694152, "compression_ratio": 1.4224598930481283, "no_speech_prob": 0.017180614173412323}, {"id": 105, "seek": 72980, "start": 742.4399999999999, "end": 747.16, "text": " Started in 2012. Well, you started by Zonjak because you're doing something with parsers.", "tokens": [50996, 39715, 294, 9125, 13, 1042, 11, 291, 1409, 538, 1176, 266, 36230, 570, 291, 434, 884, 746, 365, 21156, 433, 13, 51232], "temperature": 0.0, "avg_logprob": -0.329730434694152, "compression_ratio": 1.4224598930481283, "no_speech_prob": 0.017180614173412323}, {"id": 106, "seek": 72980, "start": 747.16, "end": 753.28, "text": " I quickly found out that they're not really usable in real projects, really hard to use.", "tokens": [51232, 286, 2661, 1352, 484, 300, 436, 434, 406, 534, 29975, 294, 957, 4455, 11, 534, 1152, 281, 764, 13, 51538], "temperature": 0.0, "avg_logprob": -0.329730434694152, "compression_ratio": 1.4224598930481283, "no_speech_prob": 0.017180614173412323}, {"id": 107, "seek": 75328, "start": 753.28, "end": 760.28, "text": " So I started with a patch on Clang, 3.2 in 2013, when Clang was a bit more slimmer, to", "tokens": [50364, 407, 286, 1409, 365, 257, 9972, 322, 2033, 656, 11, 805, 13, 17, 294, 9012, 11, 562, 2033, 656, 390, 257, 857, 544, 1061, 14477, 11, 281, 50714], "temperature": 0.0, "avg_logprob": -0.2517712116241455, "compression_ratio": 1.4052631578947368, "no_speech_prob": 0.0036080784630030394}, {"id": 108, "seek": 75328, "start": 763.8, "end": 770.8, "text": " parse C2. After that, I created an own C++ code base using many components from Clang.", "tokens": [50890, 48377, 383, 17, 13, 2381, 300, 11, 286, 2942, 364, 1065, 383, 25472, 3089, 3096, 1228, 867, 6677, 490, 2033, 656, 13, 51240], "temperature": 0.0, "avg_logprob": -0.2517712116241455, "compression_ratio": 1.4052631578947368, "no_speech_prob": 0.0036080784630030394}, {"id": 109, "seek": 75328, "start": 772.0799999999999, "end": 779.0799999999999, "text": " The patched preprocessor, tokenizer, also the diagnostics engine and generic LLVM components.", "tokens": [51304, 440, 9972, 292, 2666, 340, 25432, 11, 14862, 6545, 11, 611, 264, 43215, 1167, 2848, 293, 19577, 441, 43, 53, 44, 6677, 13, 51654], "temperature": 0.0, "avg_logprob": -0.2517712116241455, "compression_ratio": 1.4052631578947368, "no_speech_prob": 0.0036080784630030394}, {"id": 110, "seek": 77908, "start": 779.88, "end": 784.88, "text": " That went on for quite a long time. It went well. Always rebasing on the latest LLVM,", "tokens": [50404, 663, 1437, 322, 337, 1596, 257, 938, 565, 13, 467, 1437, 731, 13, 11270, 12970, 3349, 322, 264, 6792, 441, 43, 53, 44, 11, 50654], "temperature": 0.0, "avg_logprob": -0.25800913030450995, "compression_ratio": 1.4956896551724137, "no_speech_prob": 0.01522754691541195}, {"id": 111, "seek": 77908, "start": 784.88, "end": 790.88, "text": " like 3, 4, 5, 6, 7, 8. We're now at 11, I think, or 12. Well, the latest rebase.", "tokens": [50654, 411, 805, 11, 1017, 11, 1025, 11, 1386, 11, 1614, 11, 1649, 13, 492, 434, 586, 412, 2975, 11, 286, 519, 11, 420, 2272, 13, 1042, 11, 264, 6792, 12970, 651, 13, 50954], "temperature": 0.0, "avg_logprob": -0.25800913030450995, "compression_ratio": 1.4956896551724137, "no_speech_prob": 0.01522754691541195}, {"id": 112, "seek": 77908, "start": 790.88, "end": 797.88, "text": " Added to own custom unit test framework. And last year, the plugins, which is quite nice", "tokens": [50954, 5349, 292, 281, 1065, 2375, 4985, 1500, 8388, 13, 400, 1036, 1064, 11, 264, 33759, 11, 597, 307, 1596, 1481, 51304], "temperature": 0.0, "avg_logprob": -0.25800913030450995, "compression_ratio": 1.4956896551724137, "no_speech_prob": 0.01522754691541195}, {"id": 113, "seek": 77908, "start": 800.0400000000001, "end": 807.0400000000001, "text": " because like for the, so I have another slide for that. So that's this one. Yeah, this one.", "tokens": [51412, 570, 411, 337, 264, 11, 370, 286, 362, 1071, 4137, 337, 300, 13, 407, 300, 311, 341, 472, 13, 865, 11, 341, 472, 13, 51762], "temperature": 0.0, "avg_logprob": -0.25800913030450995, "compression_ratio": 1.4956896551724137, "no_speech_prob": 0.01522754691541195}, {"id": 114, "seek": 80704, "start": 808.04, "end": 815.04, "text": " So some, the C2 compiler shouldn't depend on a VIM plugin, of course, but there's some", "tokens": [50414, 407, 512, 11, 264, 383, 17, 31958, 4659, 380, 5672, 322, 257, 691, 6324, 23407, 11, 295, 1164, 11, 457, 456, 311, 512, 50764], "temperature": 0.0, "avg_logprob": -0.24625920234842502, "compression_ratio": 1.5863636363636364, "no_speech_prob": 0.0019627378787845373}, {"id": 115, "seek": 80704, "start": 815.56, "end": 820.52, "text": " sort of dependency on it. So we put that in it. You can create a plugin that generates", "tokens": [50790, 1333, 295, 33621, 322, 309, 13, 407, 321, 829, 300, 294, 309, 13, 509, 393, 1884, 257, 23407, 300, 23815, 51038], "temperature": 0.0, "avg_logprob": -0.24625920234842502, "compression_ratio": 1.5863636363636364, "no_speech_prob": 0.0019627378787845373}, {"id": 116, "seek": 80704, "start": 820.52, "end": 825.92, "text": " walks, the AST, gets information out, puts it in some binary file, and the plugin can", "tokens": [51038, 12896, 11, 264, 316, 6840, 11, 2170, 1589, 484, 11, 8137, 309, 294, 512, 17434, 3991, 11, 293, 264, 23407, 393, 51308], "temperature": 0.0, "avg_logprob": -0.24625920234842502, "compression_ratio": 1.5863636363636364, "no_speech_prob": 0.0019627378787845373}, {"id": 117, "seek": 80704, "start": 825.92, "end": 831.7199999999999, "text": " look at the binary file. So that works really well. And there's also another fun stuff to", "tokens": [51308, 574, 412, 264, 17434, 3991, 13, 407, 300, 1985, 534, 731, 13, 400, 456, 311, 611, 1071, 1019, 1507, 281, 51598], "temperature": 0.0, "avg_logprob": -0.24625920234842502, "compression_ratio": 1.5863636363636364, "no_speech_prob": 0.0019627378787845373}, {"id": 118, "seek": 83172, "start": 831.72, "end": 837.2, "text": " do, like shell commands to symbol. So you can, in a YAML config file, you can pass to", "tokens": [50364, 360, 11, 411, 8720, 16901, 281, 5986, 13, 407, 291, 393, 11, 294, 257, 398, 2865, 43, 6662, 3991, 11, 291, 393, 1320, 281, 50638], "temperature": 0.0, "avg_logprob": -0.2101249542236328, "compression_ratio": 1.752988047808765, "no_speech_prob": 0.1672017127275467}, {"id": 119, "seek": 83172, "start": 837.2, "end": 843.0400000000001, "text": " these plugins. You can specify, I want to run this command, like git version or ls,", "tokens": [50638, 613, 33759, 13, 509, 393, 16500, 11, 286, 528, 281, 1190, 341, 5622, 11, 411, 18331, 3037, 420, 287, 82, 11, 50930], "temperature": 0.0, "avg_logprob": -0.2101249542236328, "compression_ratio": 1.752988047808765, "no_speech_prob": 0.1672017127275467}, {"id": 120, "seek": 83172, "start": 843.0400000000001, "end": 848.0400000000001, "text": " and then put it in this C symbol. So you get it in C, you can just use the symbol name", "tokens": [50930, 293, 550, 829, 309, 294, 341, 383, 5986, 13, 407, 291, 483, 309, 294, 383, 11, 291, 393, 445, 764, 264, 5986, 1315, 51180], "temperature": 0.0, "avg_logprob": -0.2101249542236328, "compression_ratio": 1.752988047808765, "no_speech_prob": 0.1672017127275467}, {"id": 121, "seek": 83172, "start": 848.0400000000001, "end": 855.0400000000001, "text": " in your scope. And yeah, you get the information. So that's quite nice. Git version works the", "tokens": [51180, 294, 428, 11923, 13, 400, 1338, 11, 291, 483, 264, 1589, 13, 407, 300, 311, 1596, 1481, 13, 16939, 3037, 1985, 264, 51530], "temperature": 0.0, "avg_logprob": -0.2101249542236328, "compression_ratio": 1.752988047808765, "no_speech_prob": 0.1672017127275467}, {"id": 122, "seek": 83172, "start": 855.84, "end": 860.8000000000001, "text": " same way, but it's just specialized for this. Also load file. So you can, you have a load", "tokens": [51570, 912, 636, 11, 457, 309, 311, 445, 19813, 337, 341, 13, 2743, 3677, 3991, 13, 407, 291, 393, 11, 291, 362, 257, 3677, 51818], "temperature": 0.0, "avg_logprob": -0.2101249542236328, "compression_ratio": 1.752988047808765, "no_speech_prob": 0.1672017127275467}, {"id": 123, "seek": 86080, "start": 860.8, "end": 865.3199999999999, "text": " file plugin. So you specify, I want to load this file, and this is the symbol name. And", "tokens": [50364, 3991, 23407, 13, 407, 291, 16500, 11, 286, 528, 281, 3677, 341, 3991, 11, 293, 341, 307, 264, 5986, 1315, 13, 400, 50590], "temperature": 0.0, "avg_logprob": -0.22717743276435637, "compression_ratio": 1.6566037735849057, "no_speech_prob": 0.0031761890277266502}, {"id": 124, "seek": 86080, "start": 865.3199999999999, "end": 868.88, "text": " the symbol name is just straight with the data field and the length field. So you can", "tokens": [50590, 264, 5986, 1315, 307, 445, 2997, 365, 264, 1412, 2519, 293, 264, 4641, 2519, 13, 407, 291, 393, 50768], "temperature": 0.0, "avg_logprob": -0.22717743276435637, "compression_ratio": 1.6566037735849057, "no_speech_prob": 0.0031761890277266502}, {"id": 125, "seek": 86080, "start": 868.88, "end": 875.38, "text": " just access the content. So you don't need to have macros or scripts that convert stuff", "tokens": [50768, 445, 2105, 264, 2701, 13, 407, 291, 500, 380, 643, 281, 362, 7912, 2635, 420, 23294, 300, 7620, 1507, 51093], "temperature": 0.0, "avg_logprob": -0.22717743276435637, "compression_ratio": 1.6566037735849057, "no_speech_prob": 0.0031761890277266502}, {"id": 126, "seek": 86080, "start": 875.38, "end": 882.14, "text": " to header files and import those. Other IDs are to code obfuscation stuff and additional", "tokens": [51093, 281, 23117, 7098, 293, 974, 729, 13, 5358, 48212, 366, 281, 3089, 1111, 69, 32601, 399, 1507, 293, 4497, 51431], "temperature": 0.0, "avg_logprob": -0.22717743276435637, "compression_ratio": 1.6566037735849057, "no_speech_prob": 0.0031761890277266502}, {"id": 127, "seek": 86080, "start": 882.14, "end": 888.64, "text": " checks you can implement in companies, like every name should be 13 bytes long, whatever", "tokens": [51431, 13834, 291, 393, 4445, 294, 3431, 11, 411, 633, 1315, 820, 312, 3705, 36088, 938, 11, 2035, 51756], "temperature": 0.0, "avg_logprob": -0.22717743276435637, "compression_ratio": 1.6566037735849057, "no_speech_prob": 0.0031761890277266502}, {"id": 128, "seek": 88864, "start": 888.76, "end": 895.76, "text": " you want. So continuing on the list. Last year I started on rewriting the C2 compiler in C2,", "tokens": [50370, 291, 528, 13, 407, 9289, 322, 264, 1329, 13, 5264, 1064, 286, 1409, 322, 319, 19868, 264, 383, 17, 31958, 294, 383, 17, 11, 50720], "temperature": 0.0, "avg_logprob": -0.2049442142635197, "compression_ratio": 1.4378378378378378, "no_speech_prob": 0.0037690254393965006}, {"id": 129, "seek": 88864, "start": 903.6, "end": 909.1999999999999, "text": " because that's the domain it's also meant for. So it was a sort of graduation project.", "tokens": [51112, 570, 300, 311, 264, 9274, 309, 311, 611, 4140, 337, 13, 407, 309, 390, 257, 1333, 295, 15652, 1716, 13, 51392], "temperature": 0.0, "avg_logprob": -0.2049442142635197, "compression_ratio": 1.4378378378378378, "no_speech_prob": 0.0037690254393965006}, {"id": 130, "seek": 88864, "start": 909.1999999999999, "end": 914.76, "text": " See if it's valid. It was also the biggest project. It's now, I think, 15,000 lines of", "tokens": [51392, 3008, 498, 309, 311, 7363, 13, 467, 390, 611, 264, 3880, 1716, 13, 467, 311, 586, 11, 286, 519, 11, 2119, 11, 1360, 3876, 295, 51670], "temperature": 0.0, "avg_logprob": -0.2049442142635197, "compression_ratio": 1.4378378378378378, "no_speech_prob": 0.0037690254393965006}, {"id": 131, "seek": 91476, "start": 914.8, "end": 921.8, "text": " code or something. So to do that, you need to bootstrap it. So that was done this year.", "tokens": [50366, 3089, 420, 746, 13, 407, 281, 360, 300, 11, 291, 643, 281, 11450, 372, 4007, 309, 13, 407, 300, 390, 1096, 341, 1064, 13, 50716], "temperature": 0.0, "avg_logprob": -0.14147191169934395, "compression_ratio": 1.5562130177514792, "no_speech_prob": 0.002935876837000251}, {"id": 132, "seek": 91476, "start": 923.2, "end": 930.2, "text": " So we now have a bootstrap way to, yeah, to start with a normal C compiler and bootstrap", "tokens": [50786, 407, 321, 586, 362, 257, 11450, 372, 4007, 636, 281, 11, 1338, 11, 281, 722, 365, 257, 2710, 383, 31958, 293, 11450, 372, 4007, 51136], "temperature": 0.0, "avg_logprob": -0.14147191169934395, "compression_ratio": 1.5562130177514792, "no_speech_prob": 0.002935876837000251}, {"id": 133, "seek": 91476, "start": 930.2, "end": 937.2, "text": " that into a C2 compiler. That's shown in this image. So it's quite a hassle sometimes.", "tokens": [51136, 300, 666, 257, 383, 17, 31958, 13, 663, 311, 4898, 294, 341, 3256, 13, 407, 309, 311, 1596, 257, 39526, 2171, 13, 51486], "temperature": 0.0, "avg_logprob": -0.14147191169934395, "compression_ratio": 1.5562130177514792, "no_speech_prob": 0.002935876837000251}, {"id": 134, "seek": 93720, "start": 937.6400000000001, "end": 944.6400000000001, "text": " So we start with the C++ sources for C2C, compile those with Clang++. We get a C2 compiler.", "tokens": [50386, 407, 321, 722, 365, 264, 383, 25472, 7139, 337, 383, 17, 34, 11, 31413, 729, 365, 2033, 656, 25472, 13, 492, 483, 257, 383, 17, 31958, 13, 50736], "temperature": 0.0, "avg_logprob": -0.2114120079920842, "compression_ratio": 1.8267326732673268, "no_speech_prob": 0.003462613793089986}, {"id": 135, "seek": 93720, "start": 948.2800000000001, "end": 953.8000000000001, "text": " Then we take the C2 sources, the native version, the C2 version, compile that with this compiler,", "tokens": [50918, 1396, 321, 747, 264, 383, 17, 7139, 11, 264, 8470, 3037, 11, 264, 383, 17, 3037, 11, 31413, 300, 365, 341, 31958, 11, 51194], "temperature": 0.0, "avg_logprob": -0.2114120079920842, "compression_ratio": 1.8267326732673268, "no_speech_prob": 0.003462613793089986}, {"id": 136, "seek": 93720, "start": 953.8000000000001, "end": 960.72, "text": " get a C file we can generate C, if you want. Compile that with Clang and then do that again", "tokens": [51194, 483, 257, 383, 3991, 321, 393, 8460, 383, 11, 498, 291, 528, 13, 6620, 794, 300, 365, 2033, 656, 293, 550, 360, 300, 797, 51540], "temperature": 0.0, "avg_logprob": -0.2114120079920842, "compression_ratio": 1.8267326732673268, "no_speech_prob": 0.003462613793089986}, {"id": 137, "seek": 93720, "start": 960.72, "end": 966.2, "text": " to the bootstrap because we want to use this final compiler to do another step. So then", "tokens": [51540, 281, 264, 11450, 372, 4007, 570, 321, 528, 281, 764, 341, 2572, 31958, 281, 360, 1071, 1823, 13, 407, 550, 51814], "temperature": 0.0, "avg_logprob": -0.2114120079920842, "compression_ratio": 1.8267326732673268, "no_speech_prob": 0.003462613793089986}, {"id": 138, "seek": 96620, "start": 966.2, "end": 973.2, "text": " we get a C2 compiler that's the final one. And the bootstrap actually starts here. So", "tokens": [50364, 321, 483, 257, 383, 17, 31958, 300, 311, 264, 2572, 472, 13, 400, 264, 11450, 372, 4007, 767, 3719, 510, 13, 407, 50714], "temperature": 0.0, "avg_logprob": -0.208795982071116, "compression_ratio": 1.5, "no_speech_prob": 0.0015666964463889599}, {"id": 139, "seek": 96620, "start": 975.2800000000001, "end": 982.2800000000001, "text": " we save this file. That's easy. It's quite a big file, but Clang can handle it. And the", "tokens": [50818, 321, 3155, 341, 3991, 13, 663, 311, 1858, 13, 467, 311, 1596, 257, 955, 3991, 11, 457, 2033, 656, 393, 4813, 309, 13, 400, 264, 51168], "temperature": 0.0, "avg_logprob": -0.208795982071116, "compression_ratio": 1.5, "no_speech_prob": 0.0015666964463889599}, {"id": 140, "seek": 96620, "start": 983.24, "end": 990.24, "text": " bootstrap is just the last part. So, well, I had first ideas to use binaries, but if", "tokens": [51216, 11450, 372, 4007, 307, 445, 264, 1036, 644, 13, 407, 11, 731, 11, 286, 632, 700, 3487, 281, 764, 5171, 4889, 11, 457, 498, 51566], "temperature": 0.0, "avg_logprob": -0.208795982071116, "compression_ratio": 1.5, "no_speech_prob": 0.0015666964463889599}, {"id": 141, "seek": 99024, "start": 990.24, "end": 997.24, "text": " you lose the one binary you have, then you cannot compile again. That's not so handy.", "tokens": [50364, 291, 3624, 264, 472, 17434, 291, 362, 11, 550, 291, 2644, 31413, 797, 13, 663, 311, 406, 370, 13239, 13, 50714], "temperature": 0.0, "avg_logprob": -0.2000108772600201, "compression_ratio": 1.4857142857142858, "no_speech_prob": 0.0013629378518089652}, {"id": 142, "seek": 99024, "start": 1002.4, "end": 1007.48, "text": " I think the project was a success with the graduation. I found quite a lot of bugs in", "tokens": [50972, 286, 519, 264, 1716, 390, 257, 2245, 365, 264, 15652, 13, 286, 1352, 1596, 257, 688, 295, 15120, 294, 51226], "temperature": 0.0, "avg_logprob": -0.2000108772600201, "compression_ratio": 1.4857142857142858, "no_speech_prob": 0.0013629378518089652}, {"id": 143, "seek": 99024, "start": 1007.48, "end": 1014.48, "text": " the old C++ version of the compiler, but it's quite nice. I was afraid that C or C2 like", "tokens": [51226, 264, 1331, 383, 25472, 3037, 295, 264, 31958, 11, 457, 309, 311, 1596, 1481, 13, 286, 390, 4638, 300, 383, 420, 383, 17, 411, 51576], "temperature": 0.0, "avg_logprob": -0.2000108772600201, "compression_ratio": 1.4857142857142858, "no_speech_prob": 0.0013629378518089652}, {"id": 144, "seek": 101448, "start": 1015.48, "end": 1021.48, "text": " languages might be too low level because Clang is, of course, written in C++, but in a compiler", "tokens": [50414, 8650, 1062, 312, 886, 2295, 1496, 570, 2033, 656, 307, 11, 295, 1164, 11, 3720, 294, 383, 25472, 11, 457, 294, 257, 31958, 50714], "temperature": 0.0, "avg_logprob": -0.1908934944554379, "compression_ratio": 1.5420168067226891, "no_speech_prob": 0.008052251301705837}, {"id": 145, "seek": 101448, "start": 1022.4, "end": 1029.4, "text": " you can use memory pools and quite a lot for the AST, and that's also faster. So memory", "tokens": [50760, 291, 393, 764, 4675, 28688, 293, 1596, 257, 688, 337, 264, 316, 6840, 11, 293, 300, 311, 611, 4663, 13, 407, 4675, 51110], "temperature": 0.0, "avg_logprob": -0.1908934944554379, "compression_ratio": 1.5420168067226891, "no_speech_prob": 0.008052251301705837}, {"id": 146, "seek": 101448, "start": 1029.96, "end": 1036.96, "text": " management is not really an issue here. It now parses roughly four million lines a second.", "tokens": [51138, 4592, 307, 406, 534, 364, 2734, 510, 13, 467, 586, 21156, 279, 9810, 1451, 2459, 3876, 257, 1150, 13, 51488], "temperature": 0.0, "avg_logprob": -0.1908934944554379, "compression_ratio": 1.5420168067226891, "no_speech_prob": 0.008052251301705837}, {"id": 147, "seek": 101448, "start": 1037.3600000000001, "end": 1043.92, "text": " And analysis is also quite fast. That's because we do the whole program at once. So when you", "tokens": [51508, 400, 5215, 307, 611, 1596, 2370, 13, 663, 311, 570, 321, 360, 264, 1379, 1461, 412, 1564, 13, 407, 562, 291, 51836], "temperature": 0.0, "avg_logprob": -0.1908934944554379, "compression_ratio": 1.5420168067226891, "no_speech_prob": 0.008052251301705837}, {"id": 148, "seek": 104392, "start": 1043.92, "end": 1048.92, "text": " do a C program, your make files kicks in. It takes the first while, puts it in GCC,", "tokens": [50364, 360, 257, 383, 1461, 11, 428, 652, 7098, 21293, 294, 13, 467, 2516, 264, 700, 1339, 11, 8137, 309, 294, 460, 11717, 11, 50614], "temperature": 0.0, "avg_logprob": -0.23922665244654606, "compression_ratio": 1.524229074889868, "no_speech_prob": 0.0035203697625547647}, {"id": 149, "seek": 104392, "start": 1048.92, "end": 1054.1200000000001, "text": " get an O file, and does some parallelism with multi-course. But it does code generation", "tokens": [50614, 483, 364, 422, 3991, 11, 293, 775, 512, 8952, 1434, 365, 4825, 12, 31913, 13, 583, 309, 775, 3089, 5125, 50874], "temperature": 0.0, "avg_logprob": -0.23922665244654606, "compression_ratio": 1.524229074889868, "no_speech_prob": 0.0035203697625547647}, {"id": 150, "seek": 104392, "start": 1054.1200000000001, "end": 1061.1200000000001, "text": " as well here, and then the second one and the third. So if your file number 100 has", "tokens": [50874, 382, 731, 510, 11, 293, 550, 264, 1150, 472, 293, 264, 2636, 13, 407, 498, 428, 3991, 1230, 2319, 575, 51224], "temperature": 0.0, "avg_logprob": -0.23922665244654606, "compression_ratio": 1.524229074889868, "no_speech_prob": 0.0035203697625547647}, {"id": 151, "seek": 104392, "start": 1061.6000000000001, "end": 1067.52, "text": " an error, you only get an error after 99 files have been compiled. And in C2 you parse all", "tokens": [51248, 364, 6713, 11, 291, 787, 483, 364, 6713, 934, 11803, 7098, 362, 668, 36548, 13, 400, 294, 383, 17, 291, 48377, 439, 51544], "temperature": 0.0, "avg_logprob": -0.23922665244654606, "compression_ratio": 1.524229074889868, "no_speech_prob": 0.0035203697625547647}, {"id": 152, "seek": 106752, "start": 1067.52, "end": 1074.52, "text": " the files, check all the files, so it's really fast. It takes milliseconds. So I can announce", "tokens": [50364, 264, 7098, 11, 1520, 439, 264, 7098, 11, 370, 309, 311, 534, 2370, 13, 467, 2516, 34184, 13, 407, 286, 393, 7478, 50714], "temperature": 0.0, "avg_logprob": -0.1698926030373087, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.017446834594011307}, {"id": 153, "seek": 106752, "start": 1078.72, "end": 1084.48, "text": " now the public repository. I open sourced it yesterday. Had to add some legal headers", "tokens": [50924, 586, 264, 1908, 25841, 13, 286, 1269, 11006, 1232, 309, 5186, 13, 12298, 281, 909, 512, 5089, 45101, 51212], "temperature": 0.0, "avg_logprob": -0.1698926030373087, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.017446834594011307}, {"id": 154, "seek": 106752, "start": 1084.48, "end": 1091.48, "text": " and stuff, of course. I get some open source license in there. So it's now on GitHub. You", "tokens": [51212, 293, 1507, 11, 295, 1164, 13, 286, 483, 512, 1269, 4009, 10476, 294, 456, 13, 407, 309, 311, 586, 322, 23331, 13, 509, 51562], "temperature": 0.0, "avg_logprob": -0.1698926030373087, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.017446834594011307}, {"id": 155, "seek": 106752, "start": 1091.48, "end": 1097.44, "text": " can download it and try it. It's not as functional as the C++ version, so that's still the main.", "tokens": [51562, 393, 5484, 309, 293, 853, 309, 13, 467, 311, 406, 382, 11745, 382, 264, 383, 25472, 3037, 11, 370, 300, 311, 920, 264, 2135, 13, 51860], "temperature": 0.0, "avg_logprob": -0.1698926030373087, "compression_ratio": 1.5844155844155845, "no_speech_prob": 0.017446834594011307}, {"id": 156, "seek": 109744, "start": 1098.1200000000001, "end": 1105.1200000000001, "text": " So the next step will be to convert all the unit tests to the new, actually the compiler", "tokens": [50398, 407, 264, 958, 1823, 486, 312, 281, 7620, 439, 264, 4985, 6921, 281, 264, 777, 11, 767, 264, 31958, 50748], "temperature": 0.0, "avg_logprob": -0.22117337788621041, "compression_ratio": 1.6219512195121952, "no_speech_prob": 0.000570963486097753}, {"id": 157, "seek": 109744, "start": 1105.8400000000001, "end": 1112.16, "text": " to fit all the unit tests we have. Sometimes the diagnostics differ a bit, so I have to", "tokens": [50784, 281, 3318, 439, 264, 4985, 6921, 321, 362, 13, 4803, 264, 43215, 1167, 743, 257, 857, 11, 370, 286, 362, 281, 51100], "temperature": 0.0, "avg_logprob": -0.22117337788621041, "compression_ratio": 1.6219512195121952, "no_speech_prob": 0.000570963486097753}, {"id": 158, "seek": 109744, "start": 1112.16, "end": 1119.16, "text": " change the unit test. Also, when I implemented the C2 compiler in C2, I had to run, I had", "tokens": [51100, 1319, 264, 4985, 1500, 13, 2743, 11, 562, 286, 12270, 264, 383, 17, 31958, 294, 383, 17, 11, 286, 632, 281, 1190, 11, 286, 632, 51450], "temperature": 0.0, "avg_logprob": -0.22117337788621041, "compression_ratio": 1.6219512195121952, "no_speech_prob": 0.000570963486097753}, {"id": 159, "seek": 111916, "start": 1120.16, "end": 1127.16, "text": " to use a lot of vectors as data types for lists of stuff, and you have to retype them", "tokens": [50414, 281, 764, 257, 688, 295, 18875, 382, 1412, 3467, 337, 14511, 295, 1507, 11, 293, 291, 362, 281, 319, 20467, 552, 50764], "temperature": 0.0, "avg_logprob": -0.19967758909184882, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.007747069466859102}, {"id": 160, "seek": 111916, "start": 1127.52, "end": 1133.88, "text": " every time you see. So I started playing around with templates. The start is now in there,", "tokens": [50782, 633, 565, 291, 536, 13, 407, 286, 1409, 2433, 926, 365, 21165, 13, 440, 722, 307, 586, 294, 456, 11, 51100], "temperature": 0.0, "avg_logprob": -0.19967758909184882, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.007747069466859102}, {"id": 161, "seek": 111916, "start": 1133.88, "end": 1139.2, "text": " but it needs to be expanded because it's quite nice to have some form of templates. I'm trying", "tokens": [51100, 457, 309, 2203, 281, 312, 14342, 570, 309, 311, 1596, 1481, 281, 362, 512, 1254, 295, 21165, 13, 286, 478, 1382, 51366], "temperature": 0.0, "avg_logprob": -0.19967758909184882, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.007747069466859102}, {"id": 162, "seek": 111916, "start": 1139.2, "end": 1146.2, "text": " to stay far away from the C++ hell, of course, but at least something. The recipe file format", "tokens": [51366, 281, 1754, 1400, 1314, 490, 264, 383, 25472, 4921, 11, 295, 1164, 11, 457, 412, 1935, 746, 13, 440, 6782, 3991, 7877, 51716], "temperature": 0.0, "avg_logprob": -0.19967758909184882, "compression_ratio": 1.5869565217391304, "no_speech_prob": 0.007747069466859102}, {"id": 163, "seek": 114620, "start": 1147.0800000000002, "end": 1150.8, "text": " will be changed to YAML because the build file is also in YAML and all the other files", "tokens": [50408, 486, 312, 3105, 281, 398, 2865, 43, 570, 264, 1322, 3991, 307, 611, 294, 398, 2865, 43, 293, 439, 264, 661, 7098, 50594], "temperature": 0.0, "avg_logprob": -0.22908524407280817, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.007326613180339336}, {"id": 164, "seek": 114620, "start": 1150.8, "end": 1157.8, "text": " also, so that's more consistent. Then currently there are three backends, so the code gets", "tokens": [50594, 611, 11, 370, 300, 311, 544, 8398, 13, 1396, 4362, 456, 366, 1045, 646, 2581, 11, 370, 264, 3089, 2170, 50944], "temperature": 0.0, "avg_logprob": -0.22908524407280817, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.007326613180339336}, {"id": 165, "seek": 114620, "start": 1158.44, "end": 1163.52, "text": " converted through the backend to something else. One is the C backend, which is quite", "tokens": [50976, 16424, 807, 264, 38087, 281, 746, 1646, 13, 1485, 307, 264, 383, 38087, 11, 597, 307, 1596, 51230], "temperature": 0.0, "avg_logprob": -0.22908524407280817, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.007326613180339336}, {"id": 166, "seek": 114620, "start": 1163.52, "end": 1170.52, "text": " easy, and then we also generate make files, and it just runs it and gets a binary. Another", "tokens": [51230, 1858, 11, 293, 550, 321, 611, 8460, 652, 7098, 11, 293, 309, 445, 6676, 309, 293, 2170, 257, 17434, 13, 3996, 51580], "temperature": 0.0, "avg_logprob": -0.22908524407280817, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.007326613180339336}, {"id": 167, "seek": 117052, "start": 1170.92, "end": 1177.56, "text": " backend is QBE, which was presented here last year. It's a small backend that has no optimization,", "tokens": [50384, 38087, 307, 1249, 10207, 11, 597, 390, 8212, 510, 1036, 1064, 13, 467, 311, 257, 1359, 38087, 300, 575, 572, 19618, 11, 50716], "temperature": 0.0, "avg_logprob": -0.17422934032621837, "compression_ratio": 1.5720524017467248, "no_speech_prob": 0.003978445660322905}, {"id": 168, "seek": 117052, "start": 1177.56, "end": 1183.32, "text": " but it works, and it's quite easy to use. Then there's also beginning of the LLVM backend,", "tokens": [50716, 457, 309, 1985, 11, 293, 309, 311, 1596, 1858, 281, 764, 13, 1396, 456, 311, 611, 2863, 295, 264, 441, 43, 53, 44, 38087, 11, 51004], "temperature": 0.0, "avg_logprob": -0.17422934032621837, "compression_ratio": 1.5720524017467248, "no_speech_prob": 0.003978445660322905}, {"id": 169, "seek": 117052, "start": 1183.32, "end": 1188.92, "text": " which is quite hard because LLVM is like a client, it's a huge dragon, it's millions", "tokens": [51004, 597, 307, 1596, 1152, 570, 441, 43, 53, 44, 307, 411, 257, 6423, 11, 309, 311, 257, 2603, 12165, 11, 309, 311, 6803, 51284], "temperature": 0.0, "avg_logprob": -0.17422934032621837, "compression_ratio": 1.5720524017467248, "no_speech_prob": 0.003978445660322905}, {"id": 170, "seek": 117052, "start": 1188.92, "end": 1195.92, "text": " lines of code. That's more work, so this is the step up to LLVM. Last is the embedded", "tokens": [51284, 3876, 295, 3089, 13, 663, 311, 544, 589, 11, 370, 341, 307, 264, 1823, 493, 281, 441, 43, 53, 44, 13, 5264, 307, 264, 16741, 51634], "temperature": 0.0, "avg_logprob": -0.17422934032621837, "compression_ratio": 1.5720524017467248, "no_speech_prob": 0.003978445660322905}, {"id": 171, "seek": 119592, "start": 1196.92, "end": 1203.92, "text": " words used, so it's using linker scripts and allowing bare metal. That would be nice.", "tokens": [50414, 2283, 1143, 11, 370, 309, 311, 1228, 2113, 260, 23294, 293, 8293, 6949, 5760, 13, 663, 576, 312, 1481, 13, 50764], "temperature": 0.0, "avg_logprob": -0.21065602537061348, "compression_ratio": 1.4390243902439024, "no_speech_prob": 0.002095405710861087}, {"id": 172, "seek": 119592, "start": 1210.5600000000002, "end": 1217.0600000000002, "text": " So that's the presentation. I tried to keep it quite short and not focus only on the language", "tokens": [51096, 407, 300, 311, 264, 5860, 13, 286, 3031, 281, 1066, 309, 1596, 2099, 293, 406, 1879, 787, 322, 264, 2856, 51421], "temperature": 0.0, "avg_logprob": -0.21065602537061348, "compression_ratio": 1.4390243902439024, "no_speech_prob": 0.002095405710861087}, {"id": 173, "seek": 119592, "start": 1217.0600000000002, "end": 1224.0600000000002, "text": " itself, so there's room for questions. If there are any.", "tokens": [51421, 2564, 11, 370, 456, 311, 1808, 337, 1651, 13, 759, 456, 366, 604, 13, 51771], "temperature": 0.0, "avg_logprob": -0.21065602537061348, "compression_ratio": 1.4390243902439024, "no_speech_prob": 0.002095405710861087}, {"id": 174, "seek": 122592, "start": 1225.92, "end": 1232.92, "text": " So how do you interact with C code in particular with C headers?", "tokens": [50364, 407, 577, 360, 291, 4648, 365, 383, 3089, 294, 1729, 365, 383, 45101, 30, 50714], "temperature": 0.0, "avg_logprob": -0.28101107279459636, "compression_ratio": 1.641711229946524, "no_speech_prob": 0.015469726175069809}, {"id": 175, "seek": 122592, "start": 1237.28, "end": 1242.72, "text": " From a C2 project, you can generate C headers for your C2 library, a library that's written", "tokens": [50932, 3358, 257, 383, 17, 1716, 11, 291, 393, 8460, 383, 45101, 337, 428, 383, 17, 6405, 11, 257, 6405, 300, 311, 3720, 51204], "temperature": 0.0, "avg_logprob": -0.28101107279459636, "compression_ratio": 1.641711229946524, "no_speech_prob": 0.015469726175069809}, {"id": 176, "seek": 122592, "start": 1242.72, "end": 1243.72, "text": " in C2.", "tokens": [51204, 294, 383, 17, 13, 51254], "temperature": 0.0, "avg_logprob": -0.28101107279459636, "compression_ratio": 1.641711229946524, "no_speech_prob": 0.015469726175069809}, {"id": 177, "seek": 122592, "start": 1243.72, "end": 1246.8000000000002, "text": " So I meant if you want to use a library written in C.", "tokens": [51254, 407, 286, 4140, 498, 291, 528, 281, 764, 257, 6405, 3720, 294, 383, 13, 51408], "temperature": 0.0, "avg_logprob": -0.28101107279459636, "compression_ratio": 1.641711229946524, "no_speech_prob": 0.015469726175069809}, {"id": 178, "seek": 122592, "start": 1246.8000000000002, "end": 1251.5600000000002, "text": " Yes, so that's one way. The other way is if you have a C library like the Vulkan library,", "tokens": [51408, 1079, 11, 370, 300, 311, 472, 636, 13, 440, 661, 636, 307, 498, 291, 362, 257, 383, 6405, 411, 264, 41434, 5225, 6405, 11, 51646], "temperature": 0.0, "avg_logprob": -0.28101107279459636, "compression_ratio": 1.641711229946524, "no_speech_prob": 0.015469726175069809}, {"id": 179, "seek": 125156, "start": 1251.56, "end": 1258.56, "text": " you have to create a sort of C, C2 interface file, so it's like a header file in C. It's", "tokens": [50364, 291, 362, 281, 1884, 257, 1333, 295, 383, 11, 383, 17, 9226, 3991, 11, 370, 309, 311, 411, 257, 23117, 3991, 294, 383, 13, 467, 311, 50714], "temperature": 0.0, "avg_logprob": -0.2220378644538648, "compression_ratio": 1.5176991150442478, "no_speech_prob": 0.0016654585488140583}, {"id": 180, "seek": 125156, "start": 1258.56, "end": 1265.76, "text": " quite straightforward, but it's manual work. There's no way to automate that currently.", "tokens": [50714, 1596, 15325, 11, 457, 309, 311, 9688, 589, 13, 821, 311, 572, 636, 281, 31605, 300, 4362, 13, 51074], "temperature": 0.0, "avg_logprob": -0.2220378644538648, "compression_ratio": 1.5176991150442478, "no_speech_prob": 0.0016654585488140583}, {"id": 181, "seek": 125156, "start": 1265.76, "end": 1270.8, "text": " But the rest is the ABI is the same for the libc. You just have to define like printf,", "tokens": [51074, 583, 264, 1472, 307, 264, 316, 11291, 307, 264, 912, 337, 264, 22854, 66, 13, 509, 445, 362, 281, 6964, 411, 4482, 69, 11, 51326], "temperature": 0.0, "avg_logprob": -0.2220378644538648, "compression_ratio": 1.5176991150442478, "no_speech_prob": 0.0016654585488140583}, {"id": 182, "seek": 125156, "start": 1270.8, "end": 1274.56, "text": " this is the function.", "tokens": [51326, 341, 307, 264, 2445, 13, 51514], "temperature": 0.0, "avg_logprob": -0.2220378644538648, "compression_ratio": 1.5176991150442478, "no_speech_prob": 0.0016654585488140583}, {"id": 183, "seek": 125156, "start": 1274.56, "end": 1279.56, "text": " So the question was how do you interact between C and C2?", "tokens": [51514, 407, 264, 1168, 390, 577, 360, 291, 4648, 1296, 383, 293, 383, 17, 30, 51764], "temperature": 0.0, "avg_logprob": -0.2220378644538648, "compression_ratio": 1.5176991150442478, "no_speech_prob": 0.0016654585488140583}, {"id": 184, "seek": 127956, "start": 1280.56, "end": 1287.56, "text": " So you said that with your C2 compiler, the whole program will be compiled in one step.", "tokens": [50414, 407, 291, 848, 300, 365, 428, 383, 17, 31958, 11, 264, 1379, 1461, 486, 312, 36548, 294, 472, 1823, 13, 50764], "temperature": 0.0, "avg_logprob": -0.16700167883010136, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.010476615279912949}, {"id": 185, "seek": 127956, "start": 1287.56, "end": 1292.56, "text": " Do you have provisions for building shared libraries or other things that cannot be compiled", "tokens": [50764, 1144, 291, 362, 25034, 337, 2390, 5507, 15148, 420, 661, 721, 300, 2644, 312, 36548, 51014], "temperature": 0.0, "avg_logprob": -0.16700167883010136, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.010476615279912949}, {"id": 186, "seek": 127956, "start": 1292.56, "end": 1297.56, "text": " into one step? What if the program is so large that we cannot compile and link it in one step?", "tokens": [51014, 666, 472, 1823, 30, 708, 498, 264, 1461, 307, 370, 2416, 300, 321, 2644, 31413, 293, 2113, 309, 294, 472, 1823, 30, 51264], "temperature": 0.0, "avg_logprob": -0.16700167883010136, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.010476615279912949}, {"id": 187, "seek": 127956, "start": 1297.56, "end": 1303.56, "text": " This is the case with many C++ projects if you do not have enough memory.", "tokens": [51264, 639, 307, 264, 1389, 365, 867, 383, 25472, 4455, 498, 291, 360, 406, 362, 1547, 4675, 13, 51564], "temperature": 0.0, "avg_logprob": -0.16700167883010136, "compression_ratio": 1.6778846153846154, "no_speech_prob": 0.010476615279912949}, {"id": 188, "seek": 130356, "start": 1303.56, "end": 1310.56, "text": " If you take a really large program, it will probably take a tenth of the size of your browser.", "tokens": [50364, 759, 291, 747, 257, 534, 2416, 1461, 11, 309, 486, 1391, 747, 257, 27269, 295, 264, 2744, 295, 428, 11185, 13, 50714], "temperature": 0.0, "avg_logprob": -0.16502958025251116, "compression_ratio": 1.54863813229572, "no_speech_prob": 0.049501050263643265}, {"id": 189, "seek": 130356, "start": 1310.56, "end": 1316.56, "text": " Loading a standard web page takes so many megabytes. Like a huge program like the Linux kernel,", "tokens": [50714, 6130, 8166, 257, 3832, 3670, 3028, 2516, 370, 867, 10816, 24538, 13, 1743, 257, 2603, 1461, 411, 264, 18734, 28256, 11, 51014], "temperature": 0.0, "avg_logprob": -0.16502958025251116, "compression_ratio": 1.54863813229572, "no_speech_prob": 0.049501050263643265}, {"id": 190, "seek": 130356, "start": 1316.56, "end": 1319.56, "text": " it fits in a few megabytes ASD in C2.", "tokens": [51014, 309, 9001, 294, 257, 1326, 10816, 24538, 7469, 35, 294, 383, 17, 13, 51164], "temperature": 0.0, "avg_logprob": -0.16502958025251116, "compression_ratio": 1.54863813229572, "no_speech_prob": 0.049501050263643265}, {"id": 191, "seek": 130356, "start": 1319.56, "end": 1324.56, "text": " That is true, but I'm working with a lot of software packages I'm doing packaging.", "tokens": [51164, 663, 307, 2074, 11, 457, 286, 478, 1364, 365, 257, 688, 295, 4722, 17401, 286, 478, 884, 16836, 13, 51414], "temperature": 0.0, "avg_logprob": -0.16502958025251116, "compression_ratio": 1.54863813229572, "no_speech_prob": 0.049501050263643265}, {"id": 192, "seek": 130356, "start": 1324.56, "end": 1329.56, "text": " And these days it's very frequent that some C++ software no longer compiles in 32 bits", "tokens": [51414, 400, 613, 1708, 309, 311, 588, 18004, 300, 512, 383, 25472, 4722, 572, 2854, 715, 4680, 294, 8858, 9239, 51664], "temperature": 0.0, "avg_logprob": -0.16502958025251116, "compression_ratio": 1.54863813229572, "no_speech_prob": 0.049501050263643265}, {"id": 193, "seek": 132956, "start": 1329.56, "end": 1333.56, "text": " because the Clang process exceeds the 40-bit virtual average base.", "tokens": [50364, 570, 264, 2033, 656, 1399, 43305, 264, 3356, 12, 5260, 6374, 4274, 3096, 13, 50564], "temperature": 0.0, "avg_logprob": -0.23497390747070312, "compression_ratio": 1.536480686695279, "no_speech_prob": 0.034097980707883835}, {"id": 194, "seek": 132956, "start": 1333.56, "end": 1338.56, "text": " And that is because even if the ASD is just a couple megabytes, the internal data structures", "tokens": [50564, 400, 300, 307, 570, 754, 498, 264, 7469, 35, 307, 445, 257, 1916, 10816, 24538, 11, 264, 6920, 1412, 9227, 50814], "temperature": 0.0, "avg_logprob": -0.23497390747070312, "compression_ratio": 1.536480686695279, "no_speech_prob": 0.034097980707883835}, {"id": 195, "seek": 132956, "start": 1338.56, "end": 1345.56, "text": " to represent all the things the optimizer is looking for are a hundred-fold of the size, a thousand-fold maybe.", "tokens": [50814, 281, 2906, 439, 264, 721, 264, 5028, 6545, 307, 1237, 337, 366, 257, 3262, 12, 18353, 295, 264, 2744, 11, 257, 4714, 12, 18353, 1310, 13, 51164], "temperature": 0.0, "avg_logprob": -0.23497390747070312, "compression_ratio": 1.536480686695279, "no_speech_prob": 0.034097980707883835}, {"id": 196, "seek": 132956, "start": 1345.56, "end": 1351.56, "text": " So that's an interesting question maybe for the future when C2 programs grow very big.", "tokens": [51164, 407, 300, 311, 364, 1880, 1168, 1310, 337, 264, 2027, 562, 383, 17, 4268, 1852, 588, 955, 13, 51464], "temperature": 0.0, "avg_logprob": -0.23497390747070312, "compression_ratio": 1.536480686695279, "no_speech_prob": 0.034097980707883835}, {"id": 197, "seek": 135156, "start": 1352.56, "end": 1359.56, "text": " Yeah, I looked at that. When I was working on the Linux kernel,", "tokens": [50414, 865, 11, 286, 2956, 412, 300, 13, 1133, 286, 390, 1364, 322, 264, 18734, 28256, 11, 50764], "temperature": 0.0, "avg_logprob": -0.12700453440348308, "compression_ratio": 1.5051020408163265, "no_speech_prob": 0.06546179205179214}, {"id": 198, "seek": 135156, "start": 1359.56, "end": 1364.56, "text": " I created a program to see how many lines of code the compiler actually had to parse,", "tokens": [50764, 286, 2942, 257, 1461, 281, 536, 577, 867, 3876, 295, 3089, 264, 31958, 767, 632, 281, 48377, 11, 51014], "temperature": 0.0, "avg_logprob": -0.12700453440348308, "compression_ratio": 1.5051020408163265, "no_speech_prob": 0.06546179205179214}, {"id": 199, "seek": 135156, "start": 1364.56, "end": 1372.56, "text": " like a thousand files of C and how lots of files get included many times recursively also again.", "tokens": [51014, 411, 257, 4714, 7098, 295, 383, 293, 577, 3195, 295, 7098, 483, 5556, 867, 1413, 20560, 3413, 611, 797, 13, 51414], "temperature": 0.0, "avg_logprob": -0.12700453440348308, "compression_ratio": 1.5051020408163265, "no_speech_prob": 0.06546179205179214}, {"id": 200, "seek": 135156, "start": 1372.56, "end": 1375.56, "text": " So the factor was roughly a factor of a hundred.", "tokens": [51414, 407, 264, 5952, 390, 9810, 257, 5952, 295, 257, 3262, 13, 51564], "temperature": 0.0, "avg_logprob": -0.12700453440348308, "compression_ratio": 1.5051020408163265, "no_speech_prob": 0.06546179205179214}, {"id": 201, "seek": 137556, "start": 1375.56, "end": 1381.56, "text": " So every thousand lines of code you create the compiler to parse like a hundred thousand lines", "tokens": [50364, 407, 633, 4714, 3876, 295, 3089, 291, 1884, 264, 31958, 281, 48377, 411, 257, 3262, 4714, 3876, 50664], "temperature": 0.0, "avg_logprob": -0.15538582331697706, "compression_ratio": 1.5233160621761659, "no_speech_prob": 0.024704718962311745}, {"id": 202, "seek": 137556, "start": 1381.56, "end": 1384.56, "text": " and also analyze and stuff to stuff with it.", "tokens": [50664, 293, 611, 12477, 293, 1507, 281, 1507, 365, 309, 13, 50814], "temperature": 0.0, "avg_logprob": -0.15538582331697706, "compression_ratio": 1.5233160621761659, "no_speech_prob": 0.024704718962311745}, {"id": 203, "seek": 137556, "start": 1390.56, "end": 1395.56, "text": " But I think the biggest part will be probably the representation in LLVM", "tokens": [51114, 583, 286, 519, 264, 3880, 644, 486, 312, 1391, 264, 10290, 294, 441, 43, 53, 44, 51364], "temperature": 0.0, "avg_logprob": -0.15538582331697706, "compression_ratio": 1.5233160621761659, "no_speech_prob": 0.024704718962311745}, {"id": 204, "seek": 137556, "start": 1395.56, "end": 1401.56, "text": " and we can do that step by step because the modules are directed as cyclic graph.", "tokens": [51364, 293, 321, 393, 360, 300, 1823, 538, 1823, 570, 264, 16679, 366, 12898, 382, 38154, 1050, 4295, 13, 51664], "temperature": 0.0, "avg_logprob": -0.15538582331697706, "compression_ratio": 1.5233160621761659, "no_speech_prob": 0.024704718962311745}, {"id": 205, "seek": 140156, "start": 1401.56, "end": 1406.56, "text": " So they have a structure, one at the bottom and one at the top.", "tokens": [50364, 407, 436, 362, 257, 3877, 11, 472, 412, 264, 2767, 293, 472, 412, 264, 1192, 13, 50614], "temperature": 0.0, "avg_logprob": -0.20661979913711548, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.053425323218107224}, {"id": 206, "seek": 140156, "start": 1406.56, "end": 1408.56, "text": " So we can do them one by one.", "tokens": [50614, 407, 321, 393, 360, 552, 472, 538, 472, 13, 50714], "temperature": 0.0, "avg_logprob": -0.20661979913711548, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.053425323218107224}, {"id": 207, "seek": 140156, "start": 1417.56, "end": 1422.56, "text": " In the first slide you've shown that you can define methods and structures.", "tokens": [51164, 682, 264, 700, 4137, 291, 600, 4898, 300, 291, 393, 6964, 7150, 293, 9227, 13, 51414], "temperature": 0.0, "avg_logprob": -0.20661979913711548, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.053425323218107224}, {"id": 208, "seek": 140156, "start": 1422.56, "end": 1426.56, "text": " So the question is do you have some kind of name mangling?", "tokens": [51414, 407, 264, 1168, 307, 360, 291, 362, 512, 733, 295, 1315, 32432, 1688, 30, 51614], "temperature": 0.0, "avg_logprob": -0.20661979913711548, "compression_ratio": 1.5405405405405406, "no_speech_prob": 0.053425323218107224}, {"id": 209, "seek": 142656, "start": 1426.56, "end": 1435.56, "text": " Yes, you need to do some mangling but let's see here. It's really simple.", "tokens": [50364, 1079, 11, 291, 643, 281, 360, 512, 32432, 1688, 457, 718, 311, 536, 510, 13, 467, 311, 534, 2199, 13, 50814], "temperature": 0.0, "avg_logprob": -0.2291344075963117, "compression_ratio": 1.496969696969697, "no_speech_prob": 0.008174904622137547}, {"id": 210, "seek": 142656, "start": 1435.56, "end": 1441.56, "text": " In effect what we do we take the linked list, put the underscore at this one", "tokens": [50814, 682, 1802, 437, 321, 360, 321, 747, 264, 9408, 1329, 11, 829, 264, 37556, 412, 341, 472, 51114], "temperature": 0.0, "avg_logprob": -0.2291344075963117, "compression_ratio": 1.496969696969697, "no_speech_prob": 0.008174904622137547}, {"id": 211, "seek": 142656, "start": 1441.56, "end": 1445.56, "text": " and this one is turned into an underscore so that's it.", "tokens": [51114, 293, 341, 472, 307, 3574, 666, 364, 37556, 370, 300, 311, 309, 13, 51314], "temperature": 0.0, "avg_logprob": -0.2291344075963117, "compression_ratio": 1.496969696969697, "no_speech_prob": 0.008174904622137547}, {"id": 212, "seek": 142656, "start": 1449.56, "end": 1452.56, "text": " No, because it needs to be recognizable.", "tokens": [51514, 883, 11, 570, 309, 2203, 281, 312, 40757, 13, 51664], "temperature": 0.0, "avg_logprob": -0.2291344075963117, "compression_ratio": 1.496969696969697, "no_speech_prob": 0.008174904622137547}, {"id": 213, "seek": 145256, "start": 1453.56, "end": 1458.56, "text": " So it's a really simple forward scheme. You can go both two ways, it's really easy.", "tokens": [50414, 407, 309, 311, 257, 534, 2199, 2128, 12232, 13, 509, 393, 352, 1293, 732, 2098, 11, 309, 311, 534, 1858, 13, 50664], "temperature": 0.0, "avg_logprob": -0.19271572113037108, "compression_ratio": 1.3923076923076922, "no_speech_prob": 0.0047209798358380795}, {"id": 214, "seek": 145256, "start": 1462.56, "end": 1466.56, "text": " No, we start with the name of the module.", "tokens": [50864, 883, 11, 321, 722, 365, 264, 1315, 295, 264, 10088, 13, 51064], "temperature": 0.0, "avg_logprob": -0.19271572113037108, "compression_ratio": 1.3923076923076922, "no_speech_prob": 0.0047209798358380795}, {"id": 215, "seek": 145256, "start": 1467.56, "end": 1471.56, "text": " So it's linked list underscore element underscore init.", "tokens": [51114, 407, 309, 311, 9408, 1329, 37556, 4478, 37556, 3157, 13, 51314], "temperature": 0.0, "avg_logprob": -0.19271572113037108, "compression_ratio": 1.3923076923076922, "no_speech_prob": 0.0047209798358380795}, {"id": 216, "seek": 147156, "start": 1471.56, "end": 1475.56, "text": " So how do you handle the case where you're linking with a C library", "tokens": [50364, 407, 577, 360, 291, 4813, 264, 1389, 689, 291, 434, 25775, 365, 257, 383, 6405, 50564], "temperature": 0.0, "avg_logprob": -0.238861083984375, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.006507311016321182}, {"id": 217, "seek": 147156, "start": 1475.56, "end": 1478.56, "text": " that has that name which is a value? It's simple.", "tokens": [50564, 300, 575, 300, 1315, 597, 307, 257, 2158, 30, 467, 311, 2199, 13, 50714], "temperature": 0.0, "avg_logprob": -0.238861083984375, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.006507311016321182}, {"id": 218, "seek": 147156, "start": 1480.56, "end": 1483.56, "text": " Well, that gives you an error.", "tokens": [50814, 1042, 11, 300, 2709, 291, 364, 6713, 13, 50964], "temperature": 0.0, "avg_logprob": -0.238861083984375, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.006507311016321182}, {"id": 219, "seek": 147156, "start": 1485.56, "end": 1489.56, "text": " It's like if you define a function printf in your C program you get an error.", "tokens": [51064, 467, 311, 411, 498, 291, 6964, 257, 2445, 4482, 69, 294, 428, 383, 1461, 291, 483, 364, 6713, 13, 51264], "temperature": 0.0, "avg_logprob": -0.238861083984375, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.006507311016321182}, {"id": 220, "seek": 147156, "start": 1496.56, "end": 1498.56, "text": " Yeah, so you get an error.", "tokens": [51614, 865, 11, 370, 291, 483, 364, 6713, 13, 51714], "temperature": 0.0, "avg_logprob": -0.238861083984375, "compression_ratio": 1.5149700598802396, "no_speech_prob": 0.006507311016321182}, {"id": 221, "seek": 149856, "start": 1498.56, "end": 1502.56, "text": " In C you have a single namespace so this is a two-dimensional namespace", "tokens": [50364, 682, 383, 291, 362, 257, 2167, 5288, 17940, 370, 341, 307, 257, 732, 12, 18759, 5288, 17940, 50564], "temperature": 0.0, "avg_logprob": -0.13732060264138615, "compression_ratio": 1.4253731343283582, "no_speech_prob": 0.012564964592456818}, {"id": 222, "seek": 149856, "start": 1502.56, "end": 1507.56, "text": " so it's a linked list, a module name and that already solves so many problems", "tokens": [50564, 370, 309, 311, 257, 9408, 1329, 11, 257, 10088, 1315, 293, 300, 1217, 39890, 370, 867, 2740, 50814], "temperature": 0.0, "avg_logprob": -0.13732060264138615, "compression_ratio": 1.4253731343283582, "no_speech_prob": 0.012564964592456818}, {"id": 223, "seek": 149856, "start": 1507.56, "end": 1510.56, "text": " that your namespace will be much cleaner.", "tokens": [50814, 300, 428, 5288, 17940, 486, 312, 709, 16532, 13, 50964], "temperature": 0.0, "avg_logprob": -0.13732060264138615, "compression_ratio": 1.4253731343283582, "no_speech_prob": 0.012564964592456818}, {"id": 224, "seek": 151056, "start": 1510.56, "end": 1515.56, "text": " So he says that the symbols started with double underscore and underscore", "tokens": [50364, 407, 415, 1619, 300, 264, 16944, 1409, 365, 3834, 37556, 293, 37556, 50614], "temperature": 0.0, "avg_logprob": -0.3051695036656648, "compression_ratio": 1.8296943231441047, "no_speech_prob": 0.2780340015888214}, {"id": 225, "seek": 151056, "start": 1515.56, "end": 1519.56, "text": " but the uppercase are on the implementation domain.", "tokens": [50614, 457, 264, 11775, 2869, 651, 366, 322, 264, 11420, 9274, 13, 50814], "temperature": 0.0, "avg_logprob": -0.3051695036656648, "compression_ratio": 1.8296943231441047, "no_speech_prob": 0.2780340015888214}, {"id": 226, "seek": 151056, "start": 1519.56, "end": 1525.56, "text": " So if you prepanded double underscore to all the symbols then you would know that you would never...", "tokens": [50814, 407, 498, 291, 2666, 474, 292, 3834, 37556, 281, 439, 264, 16944, 550, 291, 576, 458, 300, 291, 576, 1128, 485, 51114], "temperature": 0.0, "avg_logprob": -0.3051695036656648, "compression_ratio": 1.8296943231441047, "no_speech_prob": 0.2780340015888214}, {"id": 227, "seek": 151056, "start": 1525.56, "end": 1529.56, "text": " Okay, I didn't know that so... Okay, that's easy to fix then.", "tokens": [51114, 1033, 11, 286, 994, 380, 458, 300, 370, 485, 1033, 11, 300, 311, 1858, 281, 3191, 550, 13, 51314], "temperature": 0.0, "avg_logprob": -0.3051695036656648, "compression_ratio": 1.8296943231441047, "no_speech_prob": 0.2780340015888214}, {"id": 228, "seek": 151056, "start": 1529.56, "end": 1531.56, "text": " So double underscore and then capital.", "tokens": [51314, 407, 3834, 37556, 293, 550, 4238, 13, 51414], "temperature": 0.0, "avg_logprob": -0.3051695036656648, "compression_ratio": 1.8296943231441047, "no_speech_prob": 0.2780340015888214}, {"id": 229, "seek": 151056, "start": 1531.56, "end": 1536.56, "text": " You could also use a scheme like the go-to channel and put a symbol into the linked symbols", "tokens": [51414, 509, 727, 611, 764, 257, 12232, 411, 264, 352, 12, 1353, 2269, 293, 829, 257, 5986, 666, 264, 9408, 16944, 51664], "temperature": 0.0, "avg_logprob": -0.3051695036656648, "compression_ratio": 1.8296943231441047, "no_speech_prob": 0.2780340015888214}, {"id": 230, "seek": 153656, "start": 1536.56, "end": 1540.56, "text": " which cannot be used in C like you can put a bot in the symbol.", "tokens": [50364, 597, 2644, 312, 1143, 294, 383, 411, 291, 393, 829, 257, 10592, 294, 264, 5986, 13, 50564], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 231, "seek": 153656, "start": 1540.56, "end": 1543.56, "text": " For example, you could name the symbol element bot in it.", "tokens": [50564, 1171, 1365, 11, 291, 727, 1315, 264, 5986, 4478, 10592, 294, 309, 13, 50714], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 232, "seek": 153656, "start": 1543.56, "end": 1545.56, "text": " I would never come out of anything.", "tokens": [50714, 286, 576, 1128, 808, 484, 295, 1340, 13, 50814], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 233, "seek": 153656, "start": 1545.56, "end": 1547.56, "text": " It's a smiley face.", "tokens": [50814, 467, 311, 257, 7563, 88, 1851, 13, 50914], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 234, "seek": 153656, "start": 1547.56, "end": 1551.56, "text": " If you compile a NIC at the same time, can you actually parallelize the process?", "tokens": [50914, 759, 291, 31413, 257, 426, 2532, 412, 264, 912, 565, 11, 393, 291, 767, 8952, 1125, 264, 1399, 30, 51114], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 235, "seek": 153656, "start": 1551.56, "end": 1554.56, "text": " Like if you have like a one million files and you have eight cores", "tokens": [51114, 1743, 498, 291, 362, 411, 257, 472, 2459, 7098, 293, 291, 362, 3180, 24826, 51264], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 236, "seek": 153656, "start": 1554.56, "end": 1557.56, "text": " do you use only one core to compile everything?", "tokens": [51264, 360, 291, 764, 787, 472, 4965, 281, 31413, 1203, 30, 51414], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 237, "seek": 153656, "start": 1557.56, "end": 1561.56, "text": " No, we use many threads so we parse everything at once.", "tokens": [51414, 883, 11, 321, 764, 867, 19314, 370, 321, 48377, 1203, 412, 1564, 13, 51614], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 238, "seek": 153656, "start": 1561.56, "end": 1564.56, "text": " We analyze it single thread because we don't do the locking and...", "tokens": [51614, 492, 12477, 309, 2167, 7207, 570, 321, 500, 380, 360, 264, 23954, 293, 485, 51764], "temperature": 0.0, "avg_logprob": -0.21820757282314016, "compression_ratio": 1.7403508771929825, "no_speech_prob": 0.04868859797716141}, {"id": 239, "seek": 156456, "start": 1565.56, "end": 1567.56, "text": " Yes?", "tokens": [50414, 1079, 30, 50514], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 240, "seek": 156456, "start": 1567.56, "end": 1569.56, "text": " So the modules we have an import like here.", "tokens": [50514, 407, 264, 16679, 321, 362, 364, 974, 411, 510, 13, 50614], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 241, "seek": 156456, "start": 1569.56, "end": 1573.56, "text": " So this module depends on this module so we can build a graph.", "tokens": [50614, 407, 341, 10088, 5946, 322, 341, 10088, 370, 321, 393, 1322, 257, 4295, 13, 50814], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 242, "seek": 156456, "start": 1573.56, "end": 1576.56, "text": " We sort all the modules and analyze the bottom up.", "tokens": [50814, 492, 1333, 439, 264, 16679, 293, 12477, 264, 2767, 493, 13, 50964], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 243, "seek": 156456, "start": 1576.56, "end": 1583.56, "text": " And we also generate code that way but the generation of the code and the optimization is 90 something percent of the work.", "tokens": [50964, 400, 321, 611, 8460, 3089, 300, 636, 457, 264, 5125, 295, 264, 3089, 293, 264, 19618, 307, 4289, 746, 3043, 295, 264, 589, 13, 51314], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 244, "seek": 156456, "start": 1583.56, "end": 1585.56, "text": " So that's done in threads.", "tokens": [51314, 407, 300, 311, 1096, 294, 19314, 13, 51414], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 245, "seek": 156456, "start": 1585.56, "end": 1589.56, "text": " The other part is just milliseconds really.", "tokens": [51414, 440, 661, 644, 307, 445, 34184, 534, 13, 51614], "temperature": 0.0, "avg_logprob": -0.16222164941870648, "compression_ratio": 1.6376146788990826, "no_speech_prob": 0.021080898120999336}, {"id": 246, "seek": 158956, "start": 1589.56, "end": 1592.56, "text": " So in the thread when the symbol is not resolved because it's another module", "tokens": [50364, 407, 294, 264, 7207, 562, 264, 5986, 307, 406, 20772, 570, 309, 311, 1071, 10088, 50514], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 247, "seek": 158956, "start": 1592.56, "end": 1597.56, "text": " you just put some temporary hook that whenever it's resolved by the other thread then you update the symbol.", "tokens": [50514, 291, 445, 829, 512, 13413, 6328, 300, 5699, 309, 311, 20772, 538, 264, 661, 7207, 550, 291, 5623, 264, 5986, 13, 50764], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 248, "seek": 158956, "start": 1597.56, "end": 1601.56, "text": " No, the analysis is done over the whole program first.", "tokens": [50764, 883, 11, 264, 5215, 307, 1096, 670, 264, 1379, 1461, 700, 13, 50964], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 249, "seek": 158956, "start": 1601.56, "end": 1602.56, "text": " Bottom up.", "tokens": [50964, 38289, 493, 13, 51014], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 250, "seek": 158956, "start": 1602.56, "end": 1604.56, "text": " So everything is resolved.", "tokens": [51014, 407, 1203, 307, 20772, 13, 51114], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 251, "seek": 158956, "start": 1604.56, "end": 1607.56, "text": " So the generation of codes just...", "tokens": [51114, 407, 264, 5125, 295, 14211, 445, 485, 51264], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 252, "seek": 158956, "start": 1607.56, "end": 1609.56, "text": " it doesn't change the AST.", "tokens": [51264, 309, 1177, 380, 1319, 264, 316, 6840, 13, 51364], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 253, "seek": 158956, "start": 1612.56, "end": 1613.56, "text": " Yes?", "tokens": [51514, 1079, 30, 51564], "temperature": 0.0, "avg_logprob": -0.17988181900192093, "compression_ratio": 1.5972222222222223, "no_speech_prob": 0.006513158790767193}, {"id": 254, "seek": 161356, "start": 1613.56, "end": 1616.56, "text": " So you were mentioning generics templates.", "tokens": [50364, 407, 291, 645, 18315, 1337, 1167, 21165, 13, 50514], "temperature": 0.0, "avg_logprob": -0.17984758104596818, "compression_ratio": 1.584070796460177, "no_speech_prob": 0.010655477643013}, {"id": 255, "seek": 161356, "start": 1619.56, "end": 1624.56, "text": " Do you already have plans on how to handle separate compilations for that?", "tokens": [50664, 1144, 291, 1217, 362, 5482, 322, 577, 281, 4813, 4994, 715, 388, 763, 337, 300, 30, 50914], "temperature": 0.0, "avg_logprob": -0.17984758104596818, "compression_ratio": 1.584070796460177, "no_speech_prob": 0.010655477643013}, {"id": 256, "seek": 161356, "start": 1624.56, "end": 1626.56, "text": " Well we don't have to.", "tokens": [50914, 1042, 321, 500, 380, 362, 281, 13, 51014], "temperature": 0.0, "avg_logprob": -0.17984758104596818, "compression_ratio": 1.584070796460177, "no_speech_prob": 0.010655477643013}, {"id": 257, "seek": 161356, "start": 1626.56, "end": 1631.56, "text": " I mean in C++ every time you use a vector in FAC file it has to generate the whole code for the vector", "tokens": [51014, 286, 914, 294, 383, 25472, 633, 565, 291, 764, 257, 8062, 294, 479, 4378, 3991, 309, 575, 281, 8460, 264, 1379, 3089, 337, 264, 8062, 51264], "temperature": 0.0, "avg_logprob": -0.17984758104596818, "compression_ratio": 1.584070796460177, "no_speech_prob": 0.010655477643013}, {"id": 258, "seek": 161356, "start": 1631.56, "end": 1637.56, "text": " and then in the end you have like 600 implementation and the linker has to remove them.", "tokens": [51264, 293, 550, 294, 264, 917, 291, 362, 411, 11849, 11420, 293, 264, 2113, 260, 575, 281, 4159, 552, 13, 51564], "temperature": 0.0, "avg_logprob": -0.17984758104596818, "compression_ratio": 1.584070796460177, "no_speech_prob": 0.010655477643013}, {"id": 259, "seek": 161356, "start": 1637.56, "end": 1639.56, "text": " That's why C++ is so slow.", "tokens": [51564, 663, 311, 983, 383, 25472, 307, 370, 2964, 13, 51664], "temperature": 0.0, "avg_logprob": -0.17984758104596818, "compression_ratio": 1.584070796460177, "no_speech_prob": 0.010655477643013}, {"id": 260, "seek": 163956, "start": 1639.56, "end": 1641.56, "text": " So here you don't have to do that.", "tokens": [50364, 407, 510, 291, 500, 380, 362, 281, 360, 300, 13, 50464], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 261, "seek": 163956, "start": 1641.56, "end": 1646.56, "text": " You have one implementation per instance of per use.", "tokens": [50464, 509, 362, 472, 11420, 680, 5197, 295, 680, 764, 13, 50714], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 262, "seek": 163956, "start": 1646.56, "end": 1648.56, "text": " If you have...", "tokens": [50714, 759, 291, 362, 485, 50814], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 263, "seek": 163956, "start": 1648.56, "end": 1653.56, "text": " So you have your say standard library module that defines the vector of t", "tokens": [50814, 407, 291, 362, 428, 584, 3832, 6405, 10088, 300, 23122, 264, 8062, 295, 256, 51064], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 264, "seek": 163956, "start": 1653.56, "end": 1659.56, "text": " then you have two modules that both use vector of t that are compiled separately for some reason.", "tokens": [51064, 550, 291, 362, 732, 16679, 300, 1293, 764, 8062, 295, 256, 300, 366, 36548, 14759, 337, 512, 1778, 13, 51364], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 265, "seek": 163956, "start": 1659.56, "end": 1661.56, "text": " Oh, no, you can...", "tokens": [51364, 876, 11, 572, 11, 291, 393, 485, 51464], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 266, "seek": 163956, "start": 1661.56, "end": 1662.56, "text": " But they're not.", "tokens": [51464, 583, 436, 434, 406, 13, 51514], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 267, "seek": 163956, "start": 1662.56, "end": 1664.56, "text": " They're never, yeah.", "tokens": [51514, 814, 434, 1128, 11, 1338, 13, 51614], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 268, "seek": 163956, "start": 1664.56, "end": 1667.56, "text": " It's quite easy, yeah.", "tokens": [51614, 467, 311, 1596, 1858, 11, 1338, 13, 51764], "temperature": 0.0, "avg_logprob": -0.2318298115449793, "compression_ratio": 1.6465116279069767, "no_speech_prob": 0.004172551911324263}, {"id": 269, "seek": 166756, "start": 1667.56, "end": 1672.56, "text": " Can you reimplement the Linux kernel in C to C without macros?", "tokens": [50364, 1664, 291, 33433, 43704, 264, 18734, 28256, 294, 383, 281, 383, 1553, 7912, 2635, 30, 50614], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 270, "seek": 166756, "start": 1672.56, "end": 1677.56, "text": " I wouldn't want to because Linux kernel is not a really good example.", "tokens": [50614, 286, 2759, 380, 528, 281, 570, 18734, 28256, 307, 406, 257, 534, 665, 1365, 13, 50864], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 271, "seek": 166756, "start": 1677.56, "end": 1680.56, "text": " It's one of the worst pieces of open source there is.", "tokens": [50864, 467, 311, 472, 295, 264, 5855, 3755, 295, 1269, 4009, 456, 307, 13, 51014], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 272, "seek": 166756, "start": 1680.56, "end": 1683.56, "text": " If you try to map to dependencies you get a fully connected graph.", "tokens": [51014, 759, 291, 853, 281, 4471, 281, 36606, 291, 483, 257, 4498, 4582, 4295, 13, 51164], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 273, "seek": 166756, "start": 1683.56, "end": 1685.56, "text": " Everything depends on everything.", "tokens": [51164, 5471, 5946, 322, 1203, 13, 51264], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 274, "seek": 166756, "start": 1685.56, "end": 1687.56, "text": " It's horrible, no?", "tokens": [51264, 467, 311, 9263, 11, 572, 30, 51364], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 275, "seek": 166756, "start": 1687.56, "end": 1688.56, "text": " Yeah.", "tokens": [51364, 865, 13, 51414], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 276, "seek": 166756, "start": 1688.56, "end": 1689.56, "text": " Yes?", "tokens": [51414, 1079, 30, 51464], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 277, "seek": 166756, "start": 1689.56, "end": 1691.56, "text": " Do you have a C to C?", "tokens": [51464, 1144, 291, 362, 257, 383, 281, 383, 30, 51564], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 278, "seek": 166756, "start": 1691.56, "end": 1693.56, "text": " You also have a C++ version.", "tokens": [51564, 509, 611, 362, 257, 383, 25472, 3037, 13, 51664], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 279, "seek": 166756, "start": 1693.56, "end": 1694.56, "text": " Yes?", "tokens": [51664, 1079, 30, 51714], "temperature": 0.0, "avg_logprob": -0.1907075748108981, "compression_ratio": 1.5940170940170941, "no_speech_prob": 0.008362630382180214}, {"id": 280, "seek": 169456, "start": 1695.56, "end": 1700.56, "text": " The C to version is much smaller.", "tokens": [50414, 440, 383, 281, 3037, 307, 709, 4356, 13, 50664], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 281, "seek": 169456, "start": 1700.56, "end": 1702.56, "text": " But there are also...", "tokens": [50664, 583, 456, 366, 611, 485, 50764], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 282, "seek": 169456, "start": 1702.56, "end": 1706.56, "text": " Because some clang components we use are quite heavy.", "tokens": [50764, 1436, 512, 596, 656, 6677, 321, 764, 366, 1596, 4676, 13, 50964], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 283, "seek": 169456, "start": 1706.56, "end": 1708.56, "text": " So it will require a lot of code.", "tokens": [50964, 407, 309, 486, 3651, 257, 688, 295, 3089, 13, 51064], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 284, "seek": 169456, "start": 1708.56, "end": 1712.56, "text": " And clang is, of course, the components we use can do more than what we need.", "tokens": [51064, 400, 596, 656, 307, 11, 295, 1164, 11, 264, 6677, 321, 764, 393, 360, 544, 813, 437, 321, 643, 13, 51264], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 285, "seek": 169456, "start": 1712.56, "end": 1715.56, "text": " So they're a bit fat.", "tokens": [51264, 407, 436, 434, 257, 857, 4046, 13, 51414], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 286, "seek": 169456, "start": 1715.56, "end": 1719.56, "text": " But otherwise, yeah, the C to code is quite slim.", "tokens": [51414, 583, 5911, 11, 1338, 11, 264, 383, 281, 3089, 307, 1596, 25357, 13, 51614], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 287, "seek": 169456, "start": 1719.56, "end": 1722.56, "text": " That's also what we do with the name stuff.", "tokens": [51614, 663, 311, 611, 437, 321, 360, 365, 264, 1315, 1507, 13, 51764], "temperature": 0.0, "avg_logprob": -0.1625374251720952, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.005301253870129585}, {"id": 288, "seek": 172256, "start": 1722.56, "end": 1725.56, "text": " Here, like list, it doesn't need any prefix.", "tokens": [50364, 1692, 11, 411, 1329, 11, 309, 1177, 380, 643, 604, 46969, 13, 50514], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 289, "seek": 172256, "start": 1725.56, "end": 1730.56, "text": " In C, if you would use C, you would probably call it linked list underscore init.", "tokens": [50514, 682, 383, 11, 498, 291, 576, 764, 383, 11, 291, 576, 1391, 818, 309, 9408, 1329, 37556, 3157, 13, 50764], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 290, "seek": 172256, "start": 1730.56, "end": 1733.56, "text": " So you would have to type that all here.", "tokens": [50764, 407, 291, 576, 362, 281, 2010, 300, 439, 510, 13, 50914], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 291, "seek": 172256, "start": 1733.56, "end": 1736.56, "text": " And then pass the list as an argument.", "tokens": [50914, 400, 550, 1320, 264, 1329, 382, 364, 6770, 13, 51064], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 292, "seek": 172256, "start": 1736.56, "end": 1740.56, "text": " Like if you have some component in C that's called foo.", "tokens": [51064, 1743, 498, 291, 362, 512, 6542, 294, 383, 300, 311, 1219, 726, 78, 13, 51264], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 293, "seek": 172256, "start": 1740.56, "end": 1743.56, "text": " You already see foo underscore this, foo underscore that.", "tokens": [51264, 509, 1217, 536, 726, 78, 37556, 341, 11, 726, 78, 37556, 300, 13, 51414], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 294, "seek": 172256, "start": 1743.56, "end": 1748.56, "text": " And all that stuff is just reduced to a single name at the top and that's it.", "tokens": [51414, 400, 439, 300, 1507, 307, 445, 9212, 281, 257, 2167, 1315, 412, 264, 1192, 293, 300, 311, 309, 13, 51664], "temperature": 0.0, "avg_logprob": -0.16194195406777517, "compression_ratio": 1.6722689075630253, "no_speech_prob": 0.03721541538834572}, {"id": 295, "seek": 174856, "start": 1748.56, "end": 1752.56, "text": " So your code gets a lot smaller in column size.", "tokens": [50364, 407, 428, 3089, 2170, 257, 688, 4356, 294, 7738, 2744, 13, 50564], "temperature": 0.0, "avg_logprob": -0.2110559493303299, "compression_ratio": 1.0227272727272727, "no_speech_prob": 0.005007768515497446}, {"id": 296, "seek": 174856, "start": 1755.56, "end": 1757.56, "text": " Time's up. I see.", "tokens": [50714, 6161, 311, 493, 13, 286, 536, 13, 50814], "temperature": 0.0, "avg_logprob": -0.2110559493303299, "compression_ratio": 1.0227272727272727, "no_speech_prob": 0.005007768515497446}, {"id": 297, "seek": 174856, "start": 1757.56, "end": 1759.56, "text": " Alright, thank you, Bas.", "tokens": [50814, 2798, 11, 1309, 291, 11, 5859, 13, 50914], "temperature": 0.0, "avg_logprob": -0.2110559493303299, "compression_ratio": 1.0227272727272727, "no_speech_prob": 0.005007768515497446}], "language": "en"}