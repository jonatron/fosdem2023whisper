{"text": " Hello, Fozdom. I am Nandini Jomsanas. I am a software toolchain engineer at Ember Cozum. I lead the Core 5 GNU toolchain project. I am also a UK electronic scholar from UK ESF. UK ESF encourages young electronic scholars, students to study electronics and pursue a career in the sector. UK ESF also connects top UK universities with leading employees. In this talk, I will be giving you a tutorial on how to add a GCC built-in to the RISC-5 compiler. Okay, so what is a built-in? Well, in C++ and C, there are two types of functions. You've got your user defined functions and your built-in functions. User defined functions are functions that the programmer has defined within their code so they can use it. But a built-in function are functions that are already implemented in the compiler. So the programmer doesn't need to write specific code for it and can directly use these built-ins. Many low-level architectures in GCC use built-ins. Built-ins look superficially like any C function, but there are intrinsics to the compiler which are directly implemented within. These built-ins have specific patterns to be matched in the machine description file and have access to unique individual machine functionalities. Because they are integrated within GCC, they are more efficient than using just simple inline assembly. For RISC-5, this presents an excellent opportunity to expose the ISA extension to C and C++ programmers. This is an example of a simple built-in in GCC which takes the square root of a float. There are tons and tons of GCC built-ins, but I don't know if you know, but there's probably like two in RISC-5. And this is why I'm giving you a tutorial about it so we can add more. It is important to say that yes, we call it a built-in function, but it's not really a function. There are any corresponding entry or exit points and a just cannot be obtained. Here is the square root float built-in that is implemented in GCC. If you want to find it in GCC built-ins.dev, all of the source code will be linked at the end, so don't worry, I will give that to you. And if you want to make a specific RISC-5 built-in, then you would go into the link below, or the path at the below, which will be in RISC-5 built-ins.cc. Yes, I'm talking a lot about built-ins, we could simply just use inline assembly. But this is why we shouldn't be using inline assembly. If you want to use inline assembly, you have to annoyingly specify the pattern every single time you use inline assembly. Sometimes you can get it wrong. GCC does not know about this built-in, so there's a huge risk of data flow information being lost. Again, GCC does not know about this instruction that you're using with inline assembly, so optimization cannot be used. The reason we use built-in functions, well, all of your data flow information will be retained. Patterns can be recognized and used elsewhere by GCC. You only need to specify the pattern once, and that will be in the machine description file. And then, voila, you just need to use your built-ins, put in the arguments, and the programmer will be fine. And again, with built-in functions, they're implemented directly in the compiler. So GCC will know about it and can use their optimization flags. What do I talk about when I say optimization? Well, GCC has a bunch of optimization flags. Here are two that I'm currently using as an example. The first one is with the flag minus 0. I don't think that is. That's the basic level of optimization. In fact, I don't think that's any optimization at all. This is just hardcore assembly, which you will use for cv.er, which I'll explain later. And when you use an optimization flag, minus 02, that will increase performance, reduce compilation time. GCC optimizes those assembly instructions because it knows that it doesn't need to be used. You might have noticed that I'm using cv.erw, probably wondering what the hell that is. Well, cv.erw is part of cv3 to e4ep iso extensions, also core 5 iso extensions. The cv.erw is part of event load extension. We are currently implementing version 2 of this in Open Hardwares core 5 GCC and binutils. The first set of extensions, the first set of versioning has the first five extensions, and then version 2 has event load, SIMD and bit manipulation. I would like to emphasize that all of these extensions and instructions are in binutils, the assembly and the linker. But it's time to add built-ins in GCC. I am going to be using event load for this tutorial. This is because event load only has one instruction, so it's a very beginner-friendly task. That instruction is cv.erw, which will load a word and cause the cv3 to e4ep process cycle to go into sleep state. This is an instruction that GCC will not know about because it's very machine-specific. Thus, we need a built-in. Before we get into all of this, it is very important to call out the naming conventions of these built-ins. A general convention name for a built-in in GCC will just be built-in and then the instruction name. But if you want to make it a RISC-5 specific built-in, it will be built-in RISC-5, the vendor and the name. For a core-5 specific one, it will be built-in RISC-5, cv4 core-5, the extension name and then the instruction name. Yes, I understand it's a bit long-winded, but it is very important to emphasise which vendor, which architecture you want to use, what extension, what instruction. It just makes it a lot easier for the programmer to know which instructions they want to use. So for my built-in, and if you want to use it, it will be called underscore underscore built-in underscore RISC-5, underscore cv underscore aw underscore aw. Because there's only one instruction, I just call it the same thing. So this is an example of how to use this built-in. This built-in will take a void pointer. It will be loading it from a specific memory address and then loading it into a general-purpose register, which is an unsigned day-to-bit integer. From this example, yes, the only thing you'll have to do is just put in the pointer and it will return your unsigned day-to-bit integer value. Can you speak a little louder, please? Oh, okay, sorry. Now that I've spoken about what event load is, it's time to add an extension to GCC. So most of these implementation for adding an extension will be in RISC-5.common.cc. So we've called our extension xcv, which will be the main extension, and then you'll have a sub-extensions, which will be xcvew. There isn't any ISO-specific class, so I'll just use a macro none, and this will be the first version of it. Because I am implementing a sub-extension, we'll have to imply it here by putting the sub-extension first and then the main or parent extension. Next, we add the corresponding masks and targets. Before we do all of this, we need to go into RISC-5.opt to emphasize or add the target variable and the corresponding core five flags. This file is very sensitive, and so you'll have to, even though it's two lines, if you mess it up, then you've got GCC crashing everywhere. So you have to be very careful in this file, and then you use that flag for your corresponding target, but you also use it when you have to specify your GCC options. So I've done that in RISC-5.common.cc, which is here. Now it gets into the interesting stuff to actually define the built-in. RISC-5 has a function already made for us, so we can make these built-ins. That is in RISC-5's built-ins.cc. It takes in five arguments, and I'll be going through all of these in the following slides. That'll be the instruction name, the built-in name, built-in type, function type, and availability predicate. So using this function, I have created my own file, which is called corev.dev, and this is where all the corev-related built-ins will be in. My first built-in will be in corev.dev, and the name of the instruction name will be C-V-E-L-W-S-I for single integer. The name of the built-in that the programmers will be using will be C-V-E-L-W-E-L-W, but that will be expanded to built-in RISC-5. Then you've got the corresponding built-in types, function types, availability predicate, and I'll go into that more. So the instruction patterns, this is probably the most difficult part of the whole built-in implementation. So the insert name is the name of the associated instruction pattern in the machine description file. It uses, it takes in five operands, but the last operand is optional, but I recommend you putting in if you can. You've got the name, you've got the RTL template, conditions, output template, and instant attributes, and that will be all in RISC-5.md, but I will be creating my own md for corev-specific, so we don't merge it into RISC-5.md. So this is an example of RTL templates or register transfer language. It's a template that is very, very similar to intermediate representation that GCC uses. It's a template that GCC will take and then put in the corresponding registers or operands that it needs to do. So this is my instruction pattern that I will be using for this built-in. The name will be RISC-5 underscore CV as we've previously defined it. I am using the set pattern and this will take a destination register and a source register. The destination, I think, this will be the destination register, the first operand, and I've used the match operand pattern which will take m as machine mode and the index of this operand, the predicate and the constraint. The machine mode for this will be SI which is a single integer, it's 32 bits. It's zero for the index of this operand. We usually start with zero as the indexing. The predicate for this will be a register operand as we'll be loading it into a general purpose register and the constraint will be R emphasizing as register equals to meaning it's going to be written to. Next part of this is the source register which will be the memory specific address. So we're using mem to specify the size of the object being referenced. SI being single integer, 32 bits. Again, we're using match operand to match the register or the pointer to the specific address. The index number will be one because that's the next number. I am using an address operand and then p specifying as pointer. I am using an unspect volatile for this instruction because it's a volatile operation. It's very machine specific. It can get difficult and there are times where it could be trapped. We are referencing in this state that is fragile and vulnerable so that is why I've been using an unspect volatile. Now that I've talked about the RTL pattern, we talk about the condition. The condition is important to add so that the instruction can only be generated within these conditions. You can only generate this pattern if the target is to X call VELW and that it's not a 64 bit target. Next we talk about the orange bit which is the output template. The output template will be what you will see in the assembly. You define it with the instruction name so cv.el and then slash t for tad. This is where you use those index numbers to reference which operands you want to use. I will be referencing %0 and then %a1. %0 will be the destination register and %1 will be the source register. I am using %a to substitute as a memory reference. Lastly we talk about the optional operand but again this is something we should try to put in if you are going to add a built-in. We want to tell GCC that this is a load type of instruction and the mode is SI throughout the whole built-in. The reason I have added this optional operand is that the instruction can still be generated but GCC can now optimise it knowing that it is a load, knowing that it is in machine mode SI. That is now the big part of the built-in. We have discussed the instant name and the template name. Here it comes to the built-in types. In RISC-5 there are currently only two types of built-in types. Those built-in types can be found in RISC-5 built-ins.cc. This is RISC-5 built-in direct and RISC-5 built-in direct no target. RISC-5 built-in direct corresponds directly to a machine pattern we have just created whereas RISC-5 built-in direct no target does the same thing but the return type will be void. But we are returning a general register operand or theta bit unsigned integer. So we will be using RISC-5 built-in direct. Next comes the function types. And again, everything is in RISC-5 built-ins.cc. And currently there are only two types of prototypes for RISC-5. You can only return. You can only have a returning type. You can only have a return type and one argument. In coming presentations I will be talking about it a bit more because I only have 45 minutes to talk about this presentation. When it comes to defining which return types and argument types we are using that will be in RISC-5-f types.dev. So the comment says that it will expand to RISC-5 underscore unsigned integer and then avoid pointer because that's what I will be using for my built-in type. Lastly we have the availability predicate. This is very similar to the conditions we had in the RTL template. So we use this avail function that has been declared in RISC-5 built-ins.cc. It takes the name of your availability predicate and then the corresponding conditions. As you can see it's very similar to the condition we had in the RTL template which is a target reference and then it's not a 64-bit target. Now that we've added the extension and the instruction and the built-in it's time to test it. And this is a very simple test just to make sure that it works. It's a compilation test. It takes in a void pointer with an offset. It returns an unsigned 32-bit value. You can see there are comments on the side. These are deja vu comments. We are using deja vu because we want to use a simulator or it can be used on microcontrollers. It's a framework testing model that we use for our test scripts. The first comment we'll talk about telling it it can be an execution or a compilation test. So this will be a compilation test because we haven't got an executable target yet. The second line is to tell you the options for this built-in. If you don't specify the options then this test won't run because this instruction only works within X core VELW. And then the last line or the last comment will be for checking if our instruction has been generated in the assembly. And it should be generated once. There are dashes to escape. It's very sensitive because it's a regular expression type of framework. We've got a run script for this. It's very important to build GCC because I've been running tests without building GCC and wondering why it doesn't work. And it wasn't until our GCC experts told us, no, you've got a run build. You have to run GCC and then run it. So this shows the results from our run test scripts. Although it's just one test, there are 18 passes. That is because it goes through nine optimization levels. The optimization level goes through a scan assembly test and then a compilation test. Like I promised, I put up the slides for where all of this will be found. This will be found in GitHub's Open Hardware Core 5 Vinutils and Core 5 GCC. This is also part of the Open Hardware group. We are still looking for volunteers and people to contribute to this project. And it's very important to also mention the GCC internals manual. It's probably the guru of GCC. That's what I rely on the most now. Thank you for listening to my presentation. Do you have any questions? Yes? I have a question. So I know that these built-in functions are used by the code people, which I think is what came before the Core 5 project, right? I think they use it for various mathematical functions to speed them up. I was just wondering, what I'm interested in, what I'm working on, is using higher level compilers to compile into automatically generated kernels. What's not clear to me right now is that if I use a built-in, then I would need to compile to a C code, right? Is there any way that you can still reuse part of this work without having to use C code, or would you always need to go to C code? For now, I've just been using C code, so I'm not really sure. I don't know. If you've got a fault, I'm fine. There's the C API, so you can sort of wire it into it. This is in the compiler, so you just need to find your own code to reach to the client. So in this case, you would also use these things in Fortran code. You could, yeah. I have an amazing that myself, I've been working with the staff, so there's no reason for this not to work. It's expressed in terms of a C code, so it has to be expressed somehow. I was a bit confused more about the built-in concept in general, because I mean, usually people use C code to not be machine specific, but if you use it like a built-in, then you become machine specific, right? Yeah. Oh, yeah. It depends on the built-in. GCC has built-ins that are sort of general. I mean, like all the maths functions, for example, like a body of maths, it's not machine specific. And it says, obviously, compiler specific. It's not that specific in this case, yeah, but because you can have other kind of other mathematics. Yeah. Okay, at least architecture specific, right? Well, actually it is not architecture specific. It's a general. Yeah, but even for mathematics built-in functions, you always have, not always, but mostly, yeah, kind of architecture specific. Oh, yeah, there can be stuff like encoding of numbers or such like. Yeah. It's a sort of, you know, just because. So it should work, yeah. Actually, that's one way to avoid these architecture specific. Like, rather than encoding a non-pattern into your code, just by using a constant or bit pattern and then sort of casting to proper floating point type, you can use built-in non. It's a built-in function that produces the correct encoding of a non for your target. Okay, thank you for listening to my presentation. Thank you. For me. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 13.44, "text": " Hello, Fozdom. I am Nandini Jomsanas. I am a software toolchain engineer at Ember Cozum.", "tokens": [2425, 11, 8564, 89, 4121, 13, 286, 669, 426, 474, 3812, 508, 4785, 14292, 13, 286, 669, 257, 4722, 2290, 11509, 11403, 412, 3968, 607, 3066, 89, 449, 13], "temperature": 0.0, "avg_logprob": -0.34970267065640154, "compression_ratio": 1.2846715328467153, "no_speech_prob": 0.17409496009349823}, {"id": 1, "seek": 0, "start": 13.44, "end": 23.0, "text": " I lead the Core 5 GNU toolchain project. I am also a UK electronic scholar from UK ESF.", "tokens": [286, 1477, 264, 14798, 1025, 46411, 52, 2290, 11509, 1716, 13, 286, 669, 611, 257, 7051, 10092, 17912, 490, 7051, 12564, 37, 13], "temperature": 0.0, "avg_logprob": -0.34970267065640154, "compression_ratio": 1.2846715328467153, "no_speech_prob": 0.17409496009349823}, {"id": 2, "seek": 2300, "start": 23.0, "end": 34.0, "text": " UK ESF encourages young electronic scholars, students to study electronics and pursue a career in the sector.", "tokens": [7051, 12564, 37, 28071, 2037, 10092, 8553, 11, 1731, 281, 2979, 20611, 293, 12392, 257, 3988, 294, 264, 6977, 13], "temperature": 0.0, "avg_logprob": -0.15147611969395688, "compression_ratio": 1.3282442748091603, "no_speech_prob": 8.998046541819349e-05}, {"id": 3, "seek": 2300, "start": 34.0, "end": 45.0, "text": " UK ESF also connects top UK universities with leading employees.", "tokens": [7051, 12564, 37, 611, 16967, 1192, 7051, 11779, 365, 5775, 6619, 13], "temperature": 0.0, "avg_logprob": -0.15147611969395688, "compression_ratio": 1.3282442748091603, "no_speech_prob": 8.998046541819349e-05}, {"id": 4, "seek": 4500, "start": 45.0, "end": 61.0, "text": " In this talk, I will be giving you a tutorial on how to add a GCC built-in to the RISC-5 compiler.", "tokens": [682, 341, 751, 11, 286, 486, 312, 2902, 291, 257, 7073, 322, 577, 281, 909, 257, 460, 11717, 3094, 12, 259, 281, 264, 497, 2343, 34, 12, 20, 31958, 13], "temperature": 0.0, "avg_logprob": -0.13752558973969006, "compression_ratio": 1.2482758620689656, "no_speech_prob": 7.527987327193841e-05}, {"id": 5, "seek": 4500, "start": 61.0, "end": 68.0, "text": " Okay, so what is a built-in? Well, in C++ and C, there are two types of functions.", "tokens": [1033, 11, 370, 437, 307, 257, 3094, 12, 259, 30, 1042, 11, 294, 383, 25472, 293, 383, 11, 456, 366, 732, 3467, 295, 6828, 13], "temperature": 0.0, "avg_logprob": -0.13752558973969006, "compression_ratio": 1.2482758620689656, "no_speech_prob": 7.527987327193841e-05}, {"id": 6, "seek": 6800, "start": 68.0, "end": 81.0, "text": " You've got your user defined functions and your built-in functions. User defined functions are functions that the programmer has defined within their code so they can use it.", "tokens": [509, 600, 658, 428, 4195, 7642, 6828, 293, 428, 3094, 12, 259, 6828, 13, 32127, 7642, 6828, 366, 6828, 300, 264, 32116, 575, 7642, 1951, 641, 3089, 370, 436, 393, 764, 309, 13], "temperature": 0.0, "avg_logprob": -0.11085446675618489, "compression_ratio": 1.859375, "no_speech_prob": 7.287685730261728e-05}, {"id": 7, "seek": 6800, "start": 81.0, "end": 86.0, "text": " But a built-in function are functions that are already implemented in the compiler.", "tokens": [583, 257, 3094, 12, 259, 2445, 366, 6828, 300, 366, 1217, 12270, 294, 264, 31958, 13], "temperature": 0.0, "avg_logprob": -0.11085446675618489, "compression_ratio": 1.859375, "no_speech_prob": 7.287685730261728e-05}, {"id": 8, "seek": 6800, "start": 86.0, "end": 95.0, "text": " So the programmer doesn't need to write specific code for it and can directly use these built-ins.", "tokens": [407, 264, 32116, 1177, 380, 643, 281, 2464, 2685, 3089, 337, 309, 293, 393, 3838, 764, 613, 3094, 12, 1292, 13], "temperature": 0.0, "avg_logprob": -0.11085446675618489, "compression_ratio": 1.859375, "no_speech_prob": 7.287685730261728e-05}, {"id": 9, "seek": 9500, "start": 95.0, "end": 101.0, "text": " Many low-level architectures in GCC use built-ins.", "tokens": [5126, 2295, 12, 12418, 6331, 1303, 294, 460, 11717, 764, 3094, 12, 1292, 13], "temperature": 0.0, "avg_logprob": -0.09914908938937717, "compression_ratio": 1.3043478260869565, "no_speech_prob": 4.5109016355127096e-05}, {"id": 10, "seek": 9500, "start": 101.0, "end": 112.0, "text": " Built-ins look superficially like any C function, but there are intrinsics to the compiler which are directly implemented within.", "tokens": [49822, 12, 1292, 574, 23881, 2270, 411, 604, 383, 2445, 11, 457, 456, 366, 28621, 1167, 281, 264, 31958, 597, 366, 3838, 12270, 1951, 13], "temperature": 0.0, "avg_logprob": -0.09914908938937717, "compression_ratio": 1.3043478260869565, "no_speech_prob": 4.5109016355127096e-05}, {"id": 11, "seek": 11200, "start": 112.0, "end": 125.0, "text": " These built-ins have specific patterns to be matched in the machine description file and have access to unique individual machine functionalities.", "tokens": [1981, 3094, 12, 1292, 362, 2685, 8294, 281, 312, 21447, 294, 264, 3479, 3855, 3991, 293, 362, 2105, 281, 3845, 2609, 3479, 11745, 1088, 13], "temperature": 0.0, "avg_logprob": -0.046185993680766986, "compression_ratio": 1.4534883720930232, "no_speech_prob": 1.5037097909953445e-05}, {"id": 12, "seek": 11200, "start": 125.0, "end": 136.0, "text": " Because they are integrated within GCC, they are more efficient than using just simple inline assembly.", "tokens": [1436, 436, 366, 10919, 1951, 460, 11717, 11, 436, 366, 544, 7148, 813, 1228, 445, 2199, 294, 1889, 12103, 13], "temperature": 0.0, "avg_logprob": -0.046185993680766986, "compression_ratio": 1.4534883720930232, "no_speech_prob": 1.5037097909953445e-05}, {"id": 13, "seek": 13600, "start": 136.0, "end": 148.0, "text": " For RISC-5, this presents an excellent opportunity to expose the ISA extension to C and C++ programmers.", "tokens": [1171, 497, 2343, 34, 12, 20, 11, 341, 13533, 364, 7103, 2650, 281, 19219, 264, 6205, 32, 10320, 281, 383, 293, 383, 25472, 41504, 13], "temperature": 0.0, "avg_logprob": -0.08243442385384206, "compression_ratio": 1.4901960784313726, "no_speech_prob": 2.4934606699389406e-05}, {"id": 14, "seek": 13600, "start": 148.0, "end": 155.0, "text": " This is an example of a simple built-in in GCC which takes the square root of a float.", "tokens": [639, 307, 364, 1365, 295, 257, 2199, 3094, 12, 259, 294, 460, 11717, 597, 2516, 264, 3732, 5593, 295, 257, 15706, 13], "temperature": 0.0, "avg_logprob": -0.08243442385384206, "compression_ratio": 1.4901960784313726, "no_speech_prob": 2.4934606699389406e-05}, {"id": 15, "seek": 13600, "start": 155.0, "end": 165.0, "text": " There are tons and tons of GCC built-ins, but I don't know if you know, but there's probably like two in RISC-5.", "tokens": [821, 366, 9131, 293, 9131, 295, 460, 11717, 3094, 12, 1292, 11, 457, 286, 500, 380, 458, 498, 291, 458, 11, 457, 456, 311, 1391, 411, 732, 294, 497, 2343, 34, 12, 20, 13], "temperature": 0.0, "avg_logprob": -0.08243442385384206, "compression_ratio": 1.4901960784313726, "no_speech_prob": 2.4934606699389406e-05}, {"id": 16, "seek": 16500, "start": 165.0, "end": 170.0, "text": " And this is why I'm giving you a tutorial about it so we can add more.", "tokens": [400, 341, 307, 983, 286, 478, 2902, 291, 257, 7073, 466, 309, 370, 321, 393, 909, 544, 13], "temperature": 0.0, "avg_logprob": -0.08739855743589856, "compression_ratio": 1.5096153846153846, "no_speech_prob": 2.9604105293401517e-05}, {"id": 17, "seek": 16500, "start": 170.0, "end": 176.0, "text": " It is important to say that yes, we call it a built-in function, but it's not really a function.", "tokens": [467, 307, 1021, 281, 584, 300, 2086, 11, 321, 818, 309, 257, 3094, 12, 259, 2445, 11, 457, 309, 311, 406, 534, 257, 2445, 13], "temperature": 0.0, "avg_logprob": -0.08739855743589856, "compression_ratio": 1.5096153846153846, "no_speech_prob": 2.9604105293401517e-05}, {"id": 18, "seek": 16500, "start": 176.0, "end": 187.0, "text": " There are any corresponding entry or exit points and a just cannot be obtained.", "tokens": [821, 366, 604, 11760, 8729, 420, 11043, 2793, 293, 257, 445, 2644, 312, 14879, 13], "temperature": 0.0, "avg_logprob": -0.08739855743589856, "compression_ratio": 1.5096153846153846, "no_speech_prob": 2.9604105293401517e-05}, {"id": 19, "seek": 16500, "start": 187.0, "end": 192.0, "text": " Here is the square root float built-in that is implemented in GCC.", "tokens": [1692, 307, 264, 3732, 5593, 15706, 3094, 12, 259, 300, 307, 12270, 294, 460, 11717, 13], "temperature": 0.0, "avg_logprob": -0.08739855743589856, "compression_ratio": 1.5096153846153846, "no_speech_prob": 2.9604105293401517e-05}, {"id": 20, "seek": 19200, "start": 192.0, "end": 201.0, "text": " If you want to find it in GCC built-ins.dev, all of the source code will be linked at the end, so don't worry, I will give that to you.", "tokens": [759, 291, 528, 281, 915, 309, 294, 460, 11717, 3094, 12, 1292, 13, 40343, 11, 439, 295, 264, 4009, 3089, 486, 312, 9408, 412, 264, 917, 11, 370, 500, 380, 3292, 11, 286, 486, 976, 300, 281, 291, 13], "temperature": 0.0, "avg_logprob": -0.13823319506901566, "compression_ratio": 1.5934065934065933, "no_speech_prob": 0.0002596995036583394}, {"id": 21, "seek": 19200, "start": 201.0, "end": 218.0, "text": " And if you want to make a specific RISC-5 built-in, then you would go into the link below, or the path at the below, which will be in RISC-5 built-ins.cc.", "tokens": [400, 498, 291, 528, 281, 652, 257, 2685, 497, 2343, 34, 12, 20, 3094, 12, 259, 11, 550, 291, 576, 352, 666, 264, 2113, 2507, 11, 420, 264, 3100, 412, 264, 2507, 11, 597, 486, 312, 294, 497, 2343, 34, 12, 20, 3094, 12, 1292, 13, 1914, 13], "temperature": 0.0, "avg_logprob": -0.13823319506901566, "compression_ratio": 1.5934065934065933, "no_speech_prob": 0.0002596995036583394}, {"id": 22, "seek": 21800, "start": 218.0, "end": 223.0, "text": " Yes, I'm talking a lot about built-ins, we could simply just use inline assembly.", "tokens": [1079, 11, 286, 478, 1417, 257, 688, 466, 3094, 12, 1292, 11, 321, 727, 2935, 445, 764, 294, 1889, 12103, 13], "temperature": 0.0, "avg_logprob": -0.05019957810929678, "compression_ratio": 1.691304347826087, "no_speech_prob": 9.122617484536022e-06}, {"id": 23, "seek": 21800, "start": 223.0, "end": 229.0, "text": " But this is why we shouldn't be using inline assembly.", "tokens": [583, 341, 307, 983, 321, 4659, 380, 312, 1228, 294, 1889, 12103, 13], "temperature": 0.0, "avg_logprob": -0.05019957810929678, "compression_ratio": 1.691304347826087, "no_speech_prob": 9.122617484536022e-06}, {"id": 24, "seek": 21800, "start": 229.0, "end": 237.0, "text": " If you want to use inline assembly, you have to annoyingly specify the pattern every single time you use inline assembly.", "tokens": [759, 291, 528, 281, 764, 294, 1889, 12103, 11, 291, 362, 281, 11304, 356, 16500, 264, 5102, 633, 2167, 565, 291, 764, 294, 1889, 12103, 13], "temperature": 0.0, "avg_logprob": -0.05019957810929678, "compression_ratio": 1.691304347826087, "no_speech_prob": 9.122617484536022e-06}, {"id": 25, "seek": 21800, "start": 237.0, "end": 239.0, "text": " Sometimes you can get it wrong.", "tokens": [4803, 291, 393, 483, 309, 2085, 13], "temperature": 0.0, "avg_logprob": -0.05019957810929678, "compression_ratio": 1.691304347826087, "no_speech_prob": 9.122617484536022e-06}, {"id": 26, "seek": 21800, "start": 239.0, "end": 247.0, "text": " GCC does not know about this built-in, so there's a huge risk of data flow information being lost.", "tokens": [460, 11717, 775, 406, 458, 466, 341, 3094, 12, 259, 11, 370, 456, 311, 257, 2603, 3148, 295, 1412, 3095, 1589, 885, 2731, 13], "temperature": 0.0, "avg_logprob": -0.05019957810929678, "compression_ratio": 1.691304347826087, "no_speech_prob": 9.122617484536022e-06}, {"id": 27, "seek": 24700, "start": 247.0, "end": 256.0, "text": " Again, GCC does not know about this instruction that you're using with inline assembly, so optimization cannot be used.", "tokens": [3764, 11, 460, 11717, 775, 406, 458, 466, 341, 10951, 300, 291, 434, 1228, 365, 294, 1889, 12103, 11, 370, 19618, 2644, 312, 1143, 13], "temperature": 0.0, "avg_logprob": -0.06580095729608645, "compression_ratio": 1.5603448275862069, "no_speech_prob": 3.5325836506672204e-05}, {"id": 28, "seek": 24700, "start": 256.0, "end": 265.0, "text": " The reason we use built-in functions, well, all of your data flow information will be retained.", "tokens": [440, 1778, 321, 764, 3094, 12, 259, 6828, 11, 731, 11, 439, 295, 428, 1412, 3095, 1589, 486, 312, 33438, 13], "temperature": 0.0, "avg_logprob": -0.06580095729608645, "compression_ratio": 1.5603448275862069, "no_speech_prob": 3.5325836506672204e-05}, {"id": 29, "seek": 24700, "start": 265.0, "end": 268.0, "text": " Patterns can be recognized and used elsewhere by GCC.", "tokens": [34367, 3695, 393, 312, 9823, 293, 1143, 14517, 538, 460, 11717, 13], "temperature": 0.0, "avg_logprob": -0.06580095729608645, "compression_ratio": 1.5603448275862069, "no_speech_prob": 3.5325836506672204e-05}, {"id": 30, "seek": 24700, "start": 268.0, "end": 273.0, "text": " You only need to specify the pattern once, and that will be in the machine description file.", "tokens": [509, 787, 643, 281, 16500, 264, 5102, 1564, 11, 293, 300, 486, 312, 294, 264, 3479, 3855, 3991, 13], "temperature": 0.0, "avg_logprob": -0.06580095729608645, "compression_ratio": 1.5603448275862069, "no_speech_prob": 3.5325836506672204e-05}, {"id": 31, "seek": 27300, "start": 273.0, "end": 280.0, "text": " And then, voila, you just need to use your built-ins, put in the arguments, and the programmer will be fine.", "tokens": [400, 550, 11, 45565, 11, 291, 445, 643, 281, 764, 428, 3094, 12, 1292, 11, 829, 294, 264, 12869, 11, 293, 264, 32116, 486, 312, 2489, 13], "temperature": 0.0, "avg_logprob": -0.07341699146089099, "compression_ratio": 1.6048387096774193, "no_speech_prob": 2.963570659630932e-05}, {"id": 32, "seek": 27300, "start": 280.0, "end": 287.0, "text": " And again, with built-in functions, they're implemented directly in the compiler.", "tokens": [400, 797, 11, 365, 3094, 12, 259, 6828, 11, 436, 434, 12270, 3838, 294, 264, 31958, 13], "temperature": 0.0, "avg_logprob": -0.07341699146089099, "compression_ratio": 1.6048387096774193, "no_speech_prob": 2.963570659630932e-05}, {"id": 33, "seek": 27300, "start": 287.0, "end": 291.0, "text": " So GCC will know about it and can use their optimization flags.", "tokens": [407, 460, 11717, 486, 458, 466, 309, 293, 393, 764, 641, 19618, 23265, 13], "temperature": 0.0, "avg_logprob": -0.07341699146089099, "compression_ratio": 1.6048387096774193, "no_speech_prob": 2.963570659630932e-05}, {"id": 34, "seek": 27300, "start": 291.0, "end": 294.0, "text": " What do I talk about when I say optimization?", "tokens": [708, 360, 286, 751, 466, 562, 286, 584, 19618, 30], "temperature": 0.0, "avg_logprob": -0.07341699146089099, "compression_ratio": 1.6048387096774193, "no_speech_prob": 2.963570659630932e-05}, {"id": 35, "seek": 27300, "start": 294.0, "end": 299.0, "text": " Well, GCC has a bunch of optimization flags.", "tokens": [1042, 11, 460, 11717, 575, 257, 3840, 295, 19618, 23265, 13], "temperature": 0.0, "avg_logprob": -0.07341699146089099, "compression_ratio": 1.6048387096774193, "no_speech_prob": 2.963570659630932e-05}, {"id": 36, "seek": 27300, "start": 299.0, "end": 302.0, "text": " Here are two that I'm currently using as an example.", "tokens": [1692, 366, 732, 300, 286, 478, 4362, 1228, 382, 364, 1365, 13], "temperature": 0.0, "avg_logprob": -0.07341699146089099, "compression_ratio": 1.6048387096774193, "no_speech_prob": 2.963570659630932e-05}, {"id": 37, "seek": 30200, "start": 302.0, "end": 307.0, "text": " The first one is with the flag minus 0.", "tokens": [440, 700, 472, 307, 365, 264, 7166, 3175, 1958, 13], "temperature": 0.0, "avg_logprob": -0.10553196937807145, "compression_ratio": 1.6325581395348838, "no_speech_prob": 5.729284748667851e-05}, {"id": 38, "seek": 30200, "start": 307.0, "end": 310.0, "text": " I don't think that is. That's the basic level of optimization.", "tokens": [286, 500, 380, 519, 300, 307, 13, 663, 311, 264, 3875, 1496, 295, 19618, 13], "temperature": 0.0, "avg_logprob": -0.10553196937807145, "compression_ratio": 1.6325581395348838, "no_speech_prob": 5.729284748667851e-05}, {"id": 39, "seek": 30200, "start": 310.0, "end": 313.0, "text": " In fact, I don't think that's any optimization at all.", "tokens": [682, 1186, 11, 286, 500, 380, 519, 300, 311, 604, 19618, 412, 439, 13], "temperature": 0.0, "avg_logprob": -0.10553196937807145, "compression_ratio": 1.6325581395348838, "no_speech_prob": 5.729284748667851e-05}, {"id": 40, "seek": 30200, "start": 313.0, "end": 320.0, "text": " This is just hardcore assembly, which you will use for cv.er, which I'll explain later.", "tokens": [639, 307, 445, 28196, 12103, 11, 597, 291, 486, 764, 337, 269, 85, 13, 260, 11, 597, 286, 603, 2903, 1780, 13], "temperature": 0.0, "avg_logprob": -0.10553196937807145, "compression_ratio": 1.6325581395348838, "no_speech_prob": 5.729284748667851e-05}, {"id": 41, "seek": 30200, "start": 320.0, "end": 329.0, "text": " And when you use an optimization flag, minus 02, that will increase performance, reduce compilation time.", "tokens": [400, 562, 291, 764, 364, 19618, 7166, 11, 3175, 37202, 11, 300, 486, 3488, 3389, 11, 5407, 40261, 565, 13], "temperature": 0.0, "avg_logprob": -0.10553196937807145, "compression_ratio": 1.6325581395348838, "no_speech_prob": 5.729284748667851e-05}, {"id": 42, "seek": 32900, "start": 329.0, "end": 337.0, "text": " GCC optimizes those assembly instructions because it knows that it doesn't need to be used.", "tokens": [460, 11717, 5028, 5660, 729, 12103, 9415, 570, 309, 3255, 300, 309, 1177, 380, 643, 281, 312, 1143, 13], "temperature": 0.0, "avg_logprob": -0.09975427776188045, "compression_ratio": 1.4550561797752808, "no_speech_prob": 4.054597957292572e-05}, {"id": 43, "seek": 32900, "start": 337.0, "end": 344.0, "text": " You might have noticed that I'm using cv.erw, probably wondering what the hell that is.", "tokens": [509, 1062, 362, 5694, 300, 286, 478, 1228, 269, 85, 13, 260, 86, 11, 1391, 6359, 437, 264, 4921, 300, 307, 13], "temperature": 0.0, "avg_logprob": -0.09975427776188045, "compression_ratio": 1.4550561797752808, "no_speech_prob": 4.054597957292572e-05}, {"id": 44, "seek": 32900, "start": 344.0, "end": 354.0, "text": " Well, cv.erw is part of cv3 to e4ep iso extensions, also core 5 iso extensions.", "tokens": [1042, 11, 269, 85, 13, 260, 86, 307, 644, 295, 269, 85, 18, 281, 308, 19, 595, 307, 78, 25129, 11, 611, 4965, 1025, 307, 78, 25129, 13], "temperature": 0.0, "avg_logprob": -0.09975427776188045, "compression_ratio": 1.4550561797752808, "no_speech_prob": 4.054597957292572e-05}, {"id": 45, "seek": 35400, "start": 354.0, "end": 359.0, "text": " The cv.erw is part of event load extension.", "tokens": [440, 269, 85, 13, 260, 86, 307, 644, 295, 2280, 3677, 10320, 13], "temperature": 0.0, "avg_logprob": -0.15208075882552505, "compression_ratio": 1.6136363636363635, "no_speech_prob": 3.358968751854263e-05}, {"id": 46, "seek": 35400, "start": 359.0, "end": 366.0, "text": " We are currently implementing version 2 of this in Open Hardwares core 5 GCC and binutils.", "tokens": [492, 366, 4362, 18114, 3037, 568, 295, 341, 294, 7238, 11817, 4151, 495, 4965, 1025, 460, 11717, 293, 5171, 325, 4174, 13], "temperature": 0.0, "avg_logprob": -0.15208075882552505, "compression_ratio": 1.6136363636363635, "no_speech_prob": 3.358968751854263e-05}, {"id": 47, "seek": 35400, "start": 366.0, "end": 374.0, "text": " The first set of extensions, the first set of versioning has the first five extensions,", "tokens": [440, 700, 992, 295, 25129, 11, 264, 700, 992, 295, 3037, 278, 575, 264, 700, 1732, 25129, 11], "temperature": 0.0, "avg_logprob": -0.15208075882552505, "compression_ratio": 1.6136363636363635, "no_speech_prob": 3.358968751854263e-05}, {"id": 48, "seek": 35400, "start": 374.0, "end": 379.0, "text": " and then version 2 has event load, SIMD and bit manipulation.", "tokens": [293, 550, 3037, 568, 575, 2280, 3677, 11, 24738, 35, 293, 857, 26475, 13], "temperature": 0.0, "avg_logprob": -0.15208075882552505, "compression_ratio": 1.6136363636363635, "no_speech_prob": 3.358968751854263e-05}, {"id": 49, "seek": 37900, "start": 379.0, "end": 387.0, "text": " I would like to emphasize that all of these extensions and instructions are in binutils, the assembly and the linker.", "tokens": [286, 576, 411, 281, 16078, 300, 439, 295, 613, 25129, 293, 9415, 366, 294, 5171, 325, 4174, 11, 264, 12103, 293, 264, 2113, 260, 13], "temperature": 0.0, "avg_logprob": -0.07205612659454345, "compression_ratio": 1.52020202020202, "no_speech_prob": 1.420041371602565e-05}, {"id": 50, "seek": 37900, "start": 387.0, "end": 394.0, "text": " But it's time to add built-ins in GCC.", "tokens": [583, 309, 311, 565, 281, 909, 3094, 12, 1292, 294, 460, 11717, 13], "temperature": 0.0, "avg_logprob": -0.07205612659454345, "compression_ratio": 1.52020202020202, "no_speech_prob": 1.420041371602565e-05}, {"id": 51, "seek": 37900, "start": 394.0, "end": 397.0, "text": " I am going to be using event load for this tutorial.", "tokens": [286, 669, 516, 281, 312, 1228, 2280, 3677, 337, 341, 7073, 13], "temperature": 0.0, "avg_logprob": -0.07205612659454345, "compression_ratio": 1.52020202020202, "no_speech_prob": 1.420041371602565e-05}, {"id": 52, "seek": 37900, "start": 397.0, "end": 405.0, "text": " This is because event load only has one instruction, so it's a very beginner-friendly task.", "tokens": [639, 307, 570, 2280, 3677, 787, 575, 472, 10951, 11, 370, 309, 311, 257, 588, 22080, 12, 22864, 5633, 13], "temperature": 0.0, "avg_logprob": -0.07205612659454345, "compression_ratio": 1.52020202020202, "no_speech_prob": 1.420041371602565e-05}, {"id": 53, "seek": 40500, "start": 405.0, "end": 419.0, "text": " That instruction is cv.erw, which will load a word and cause the cv3 to e4ep process cycle to go into sleep state.", "tokens": [663, 10951, 307, 269, 85, 13, 260, 86, 11, 597, 486, 3677, 257, 1349, 293, 3082, 264, 269, 85, 18, 281, 308, 19, 595, 1399, 6586, 281, 352, 666, 2817, 1785, 13], "temperature": 0.0, "avg_logprob": -0.09838723435121424, "compression_ratio": 1.3902439024390243, "no_speech_prob": 3.024604666279629e-05}, {"id": 54, "seek": 40500, "start": 419.0, "end": 427.0, "text": " This is an instruction that GCC will not know about because it's very machine-specific.", "tokens": [639, 307, 364, 10951, 300, 460, 11717, 486, 406, 458, 466, 570, 309, 311, 588, 3479, 12, 29258, 13], "temperature": 0.0, "avg_logprob": -0.09838723435121424, "compression_ratio": 1.3902439024390243, "no_speech_prob": 3.024604666279629e-05}, {"id": 55, "seek": 40500, "start": 427.0, "end": 432.0, "text": " Thus, we need a built-in.", "tokens": [13827, 11, 321, 643, 257, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.09838723435121424, "compression_ratio": 1.3902439024390243, "no_speech_prob": 3.024604666279629e-05}, {"id": 56, "seek": 43200, "start": 432.0, "end": 440.0, "text": " Before we get into all of this, it is very important to call out the naming conventions of these built-ins.", "tokens": [4546, 321, 483, 666, 439, 295, 341, 11, 309, 307, 588, 1021, 281, 818, 484, 264, 25290, 33520, 295, 613, 3094, 12, 1292, 13], "temperature": 0.0, "avg_logprob": -0.11520172202068826, "compression_ratio": 1.6898395721925135, "no_speech_prob": 0.00012708910799119622}, {"id": 57, "seek": 43200, "start": 440.0, "end": 447.0, "text": " A general convention name for a built-in in GCC will just be built-in and then the instruction name.", "tokens": [316, 2674, 10286, 1315, 337, 257, 3094, 12, 259, 294, 460, 11717, 486, 445, 312, 3094, 12, 259, 293, 550, 264, 10951, 1315, 13], "temperature": 0.0, "avg_logprob": -0.11520172202068826, "compression_ratio": 1.6898395721925135, "no_speech_prob": 0.00012708910799119622}, {"id": 58, "seek": 43200, "start": 447.0, "end": 454.0, "text": " But if you want to make it a RISC-5 specific built-in, it will be built-in RISC-5, the vendor and the name.", "tokens": [583, 498, 291, 528, 281, 652, 309, 257, 497, 2343, 34, 12, 20, 2685, 3094, 12, 259, 11, 309, 486, 312, 3094, 12, 259, 497, 2343, 34, 12, 20, 11, 264, 24321, 293, 264, 1315, 13], "temperature": 0.0, "avg_logprob": -0.11520172202068826, "compression_ratio": 1.6898395721925135, "no_speech_prob": 0.00012708910799119622}, {"id": 59, "seek": 45400, "start": 454.0, "end": 463.0, "text": " For a core-5 specific one, it will be built-in RISC-5, cv4 core-5, the extension name and then the instruction name.", "tokens": [1171, 257, 4965, 12, 20, 2685, 472, 11, 309, 486, 312, 3094, 12, 259, 497, 2343, 34, 12, 20, 11, 269, 85, 19, 4965, 12, 20, 11, 264, 10320, 1315, 293, 550, 264, 10951, 1315, 13], "temperature": 0.0, "avg_logprob": -0.11357768376668294, "compression_ratio": 1.626086956521739, "no_speech_prob": 8.402413368457928e-05}, {"id": 60, "seek": 45400, "start": 463.0, "end": 472.0, "text": " Yes, I understand it's a bit long-winded, but it is very important to emphasise which vendor, which architecture you want to use,", "tokens": [1079, 11, 286, 1223, 309, 311, 257, 857, 938, 12, 12199, 292, 11, 457, 309, 307, 588, 1021, 281, 7896, 908, 597, 24321, 11, 597, 9482, 291, 528, 281, 764, 11], "temperature": 0.0, "avg_logprob": -0.11357768376668294, "compression_ratio": 1.626086956521739, "no_speech_prob": 8.402413368457928e-05}, {"id": 61, "seek": 45400, "start": 472.0, "end": 474.0, "text": " what extension, what instruction.", "tokens": [437, 10320, 11, 437, 10951, 13], "temperature": 0.0, "avg_logprob": -0.11357768376668294, "compression_ratio": 1.626086956521739, "no_speech_prob": 8.402413368457928e-05}, {"id": 62, "seek": 45400, "start": 474.0, "end": 480.0, "text": " It just makes it a lot easier for the programmer to know which instructions they want to use.", "tokens": [467, 445, 1669, 309, 257, 688, 3571, 337, 264, 32116, 281, 458, 597, 9415, 436, 528, 281, 764, 13], "temperature": 0.0, "avg_logprob": -0.11357768376668294, "compression_ratio": 1.626086956521739, "no_speech_prob": 8.402413368457928e-05}, {"id": 63, "seek": 48000, "start": 480.0, "end": 487.0, "text": " So for my built-in, and if you want to use it, it will be called underscore underscore built-in underscore RISC-5,", "tokens": [407, 337, 452, 3094, 12, 259, 11, 293, 498, 291, 528, 281, 764, 309, 11, 309, 486, 312, 1219, 37556, 37556, 3094, 12, 259, 37556, 497, 2343, 34, 12, 20, 11], "temperature": 0.0, "avg_logprob": -0.13205991321139865, "compression_ratio": 1.7043010752688172, "no_speech_prob": 6.567891978193074e-05}, {"id": 64, "seek": 48000, "start": 487.0, "end": 491.0, "text": " underscore cv underscore aw underscore aw.", "tokens": [37556, 269, 85, 37556, 1714, 37556, 1714, 13], "temperature": 0.0, "avg_logprob": -0.13205991321139865, "compression_ratio": 1.7043010752688172, "no_speech_prob": 6.567891978193074e-05}, {"id": 65, "seek": 48000, "start": 491.0, "end": 501.0, "text": " Because there's only one instruction, I just call it the same thing.", "tokens": [1436, 456, 311, 787, 472, 10951, 11, 286, 445, 818, 309, 264, 912, 551, 13], "temperature": 0.0, "avg_logprob": -0.13205991321139865, "compression_ratio": 1.7043010752688172, "no_speech_prob": 6.567891978193074e-05}, {"id": 66, "seek": 48000, "start": 501.0, "end": 505.0, "text": " So this is an example of how to use this built-in.", "tokens": [407, 341, 307, 364, 1365, 295, 577, 281, 764, 341, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.13205991321139865, "compression_ratio": 1.7043010752688172, "no_speech_prob": 6.567891978193074e-05}, {"id": 67, "seek": 48000, "start": 505.0, "end": 508.0, "text": " This built-in will take a void pointer.", "tokens": [639, 3094, 12, 259, 486, 747, 257, 22009, 23918, 13], "temperature": 0.0, "avg_logprob": -0.13205991321139865, "compression_ratio": 1.7043010752688172, "no_speech_prob": 6.567891978193074e-05}, {"id": 68, "seek": 50800, "start": 508.0, "end": 518.0, "text": " It will be loading it from a specific memory address and then loading it into a general-purpose register,", "tokens": [467, 486, 312, 15114, 309, 490, 257, 2685, 4675, 2985, 293, 550, 15114, 309, 666, 257, 2674, 12, 42601, 7280, 11], "temperature": 0.0, "avg_logprob": -0.1085904648429469, "compression_ratio": 1.6145251396648044, "no_speech_prob": 0.00012571773550007492}, {"id": 69, "seek": 50800, "start": 518.0, "end": 526.0, "text": " which is an unsigned day-to-bit integer.", "tokens": [597, 307, 364, 2693, 16690, 786, 12, 1353, 12, 5260, 24922, 13], "temperature": 0.0, "avg_logprob": -0.1085904648429469, "compression_ratio": 1.6145251396648044, "no_speech_prob": 0.00012571773550007492}, {"id": 70, "seek": 50800, "start": 526.0, "end": 537.0, "text": " From this example, yes, the only thing you'll have to do is just put in the pointer and it will return your unsigned day-to-bit integer value.", "tokens": [3358, 341, 1365, 11, 2086, 11, 264, 787, 551, 291, 603, 362, 281, 360, 307, 445, 829, 294, 264, 23918, 293, 309, 486, 2736, 428, 2693, 16690, 786, 12, 1353, 12, 5260, 24922, 2158, 13], "temperature": 0.0, "avg_logprob": -0.1085904648429469, "compression_ratio": 1.6145251396648044, "no_speech_prob": 0.00012571773550007492}, {"id": 71, "seek": 53700, "start": 537.0, "end": 544.0, "text": " Can you speak a little louder, please?", "tokens": [1664, 291, 1710, 257, 707, 22717, 11, 1767, 30], "temperature": 0.0, "avg_logprob": -0.15524492263793946, "compression_ratio": 1.1864406779661016, "no_speech_prob": 0.00011932257621083409}, {"id": 72, "seek": 53700, "start": 544.0, "end": 549.0, "text": " Oh, okay, sorry.", "tokens": [876, 11, 1392, 11, 2597, 13], "temperature": 0.0, "avg_logprob": -0.15524492263793946, "compression_ratio": 1.1864406779661016, "no_speech_prob": 0.00011932257621083409}, {"id": 73, "seek": 53700, "start": 549.0, "end": 558.0, "text": " Now that I've spoken about what event load is, it's time to add an extension to GCC.", "tokens": [823, 300, 286, 600, 10759, 466, 437, 2280, 3677, 307, 11, 309, 311, 565, 281, 909, 364, 10320, 281, 460, 11717, 13], "temperature": 0.0, "avg_logprob": -0.15524492263793946, "compression_ratio": 1.1864406779661016, "no_speech_prob": 0.00011932257621083409}, {"id": 74, "seek": 55800, "start": 558.0, "end": 574.0, "text": " So most of these implementation for adding an extension will be in RISC-5.common.cc.", "tokens": [407, 881, 295, 613, 11420, 337, 5127, 364, 10320, 486, 312, 294, 497, 2343, 34, 12, 20, 13, 1112, 3317, 13, 1914, 13], "temperature": 0.0, "avg_logprob": -0.16137431984517112, "compression_ratio": 1.5, "no_speech_prob": 6.1422060753102414e-06}, {"id": 75, "seek": 55800, "start": 574.0, "end": 580.0, "text": " So we've called our extension xcv, which will be the main extension,", "tokens": [407, 321, 600, 1219, 527, 10320, 2031, 66, 85, 11, 597, 486, 312, 264, 2135, 10320, 11], "temperature": 0.0, "avg_logprob": -0.16137431984517112, "compression_ratio": 1.5, "no_speech_prob": 6.1422060753102414e-06}, {"id": 76, "seek": 55800, "start": 580.0, "end": 585.0, "text": " and then you'll have a sub-extensions, which will be xcvew.", "tokens": [293, 550, 291, 603, 362, 257, 1422, 12, 3828, 8302, 11, 597, 486, 312, 2031, 66, 85, 1023, 13], "temperature": 0.0, "avg_logprob": -0.16137431984517112, "compression_ratio": 1.5, "no_speech_prob": 6.1422060753102414e-06}, {"id": 77, "seek": 58500, "start": 585.0, "end": 590.0, "text": " There isn't any ISO-specific class, so I'll just use a macro none,", "tokens": [821, 1943, 380, 604, 25042, 12, 29258, 1508, 11, 370, 286, 603, 445, 764, 257, 18887, 6022, 11], "temperature": 0.0, "avg_logprob": -0.0915881076329191, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.8293540051672608e-05}, {"id": 78, "seek": 58500, "start": 590.0, "end": 597.0, "text": " and this will be the first version of it.", "tokens": [293, 341, 486, 312, 264, 700, 3037, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.0915881076329191, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.8293540051672608e-05}, {"id": 79, "seek": 58500, "start": 597.0, "end": 605.0, "text": " Because I am implementing a sub-extension, we'll have to imply it here by putting the sub-extension first", "tokens": [1436, 286, 669, 18114, 257, 1422, 12, 3828, 3378, 11, 321, 603, 362, 281, 33616, 309, 510, 538, 3372, 264, 1422, 12, 3828, 3378, 700], "temperature": 0.0, "avg_logprob": -0.0915881076329191, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.8293540051672608e-05}, {"id": 80, "seek": 58500, "start": 605.0, "end": 613.0, "text": " and then the main or parent extension.", "tokens": [293, 550, 264, 2135, 420, 2596, 10320, 13], "temperature": 0.0, "avg_logprob": -0.0915881076329191, "compression_ratio": 1.4970414201183433, "no_speech_prob": 1.8293540051672608e-05}, {"id": 81, "seek": 61300, "start": 613.0, "end": 618.0, "text": " Next, we add the corresponding masks and targets.", "tokens": [3087, 11, 321, 909, 264, 11760, 11830, 293, 12911, 13], "temperature": 0.0, "avg_logprob": -0.1252216849216195, "compression_ratio": 1.5211267605633803, "no_speech_prob": 2.7520803996594623e-05}, {"id": 82, "seek": 61300, "start": 618.0, "end": 630.0, "text": " Before we do all of this, we need to go into RISC-5.opt to emphasize or add the target variable and the corresponding core five flags.", "tokens": [4546, 321, 360, 439, 295, 341, 11, 321, 643, 281, 352, 666, 497, 2343, 34, 12, 20, 13, 5747, 281, 16078, 420, 909, 264, 3779, 7006, 293, 264, 11760, 4965, 1732, 23265, 13], "temperature": 0.0, "avg_logprob": -0.1252216849216195, "compression_ratio": 1.5211267605633803, "no_speech_prob": 2.7520803996594623e-05}, {"id": 83, "seek": 61300, "start": 630.0, "end": 640.0, "text": " This file is very sensitive, and so you'll have to, even though it's two lines, if you mess it up, then you've got GCC crashing everywhere.", "tokens": [639, 3991, 307, 588, 9477, 11, 293, 370, 291, 603, 362, 281, 11, 754, 1673, 309, 311, 732, 3876, 11, 498, 291, 2082, 309, 493, 11, 550, 291, 600, 658, 460, 11717, 26900, 5315, 13], "temperature": 0.0, "avg_logprob": -0.1252216849216195, "compression_ratio": 1.5211267605633803, "no_speech_prob": 2.7520803996594623e-05}, {"id": 84, "seek": 64000, "start": 640.0, "end": 651.0, "text": " So you have to be very careful in this file, and then you use that flag for your corresponding target,", "tokens": [407, 291, 362, 281, 312, 588, 5026, 294, 341, 3991, 11, 293, 550, 291, 764, 300, 7166, 337, 428, 11760, 3779, 11], "temperature": 0.0, "avg_logprob": -0.0782871607578162, "compression_ratio": 1.3860759493670887, "no_speech_prob": 2.348411362618208e-05}, {"id": 85, "seek": 64000, "start": 651.0, "end": 658.0, "text": " but you also use it when you have to specify your GCC options.", "tokens": [457, 291, 611, 764, 309, 562, 291, 362, 281, 16500, 428, 460, 11717, 3956, 13], "temperature": 0.0, "avg_logprob": -0.0782871607578162, "compression_ratio": 1.3860759493670887, "no_speech_prob": 2.348411362618208e-05}, {"id": 86, "seek": 64000, "start": 658.0, "end": 669.0, "text": " So I've done that in RISC-5.common.cc, which is here.", "tokens": [407, 286, 600, 1096, 300, 294, 497, 2343, 34, 12, 20, 13, 1112, 3317, 13, 1914, 11, 597, 307, 510, 13], "temperature": 0.0, "avg_logprob": -0.0782871607578162, "compression_ratio": 1.3860759493670887, "no_speech_prob": 2.348411362618208e-05}, {"id": 87, "seek": 66900, "start": 669.0, "end": 677.0, "text": " Now it gets into the interesting stuff to actually define the built-in.", "tokens": [823, 309, 2170, 666, 264, 1880, 1507, 281, 767, 6964, 264, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.08194609386164968, "compression_ratio": 1.4702702702702704, "no_speech_prob": 2.6731173420557752e-05}, {"id": 88, "seek": 66900, "start": 677.0, "end": 683.0, "text": " RISC-5 has a function already made for us, so we can make these built-ins.", "tokens": [497, 2343, 34, 12, 20, 575, 257, 2445, 1217, 1027, 337, 505, 11, 370, 321, 393, 652, 613, 3094, 12, 1292, 13], "temperature": 0.0, "avg_logprob": -0.08194609386164968, "compression_ratio": 1.4702702702702704, "no_speech_prob": 2.6731173420557752e-05}, {"id": 89, "seek": 66900, "start": 683.0, "end": 687.0, "text": " That is in RISC-5's built-ins.cc.", "tokens": [663, 307, 294, 497, 2343, 34, 12, 20, 311, 3094, 12, 1292, 13, 1914, 13], "temperature": 0.0, "avg_logprob": -0.08194609386164968, "compression_ratio": 1.4702702702702704, "no_speech_prob": 2.6731173420557752e-05}, {"id": 90, "seek": 66900, "start": 687.0, "end": 693.0, "text": " It takes in five arguments, and I'll be going through all of these in the following slides.", "tokens": [467, 2516, 294, 1732, 12869, 11, 293, 286, 603, 312, 516, 807, 439, 295, 613, 294, 264, 3480, 9788, 13], "temperature": 0.0, "avg_logprob": -0.08194609386164968, "compression_ratio": 1.4702702702702704, "no_speech_prob": 2.6731173420557752e-05}, {"id": 91, "seek": 69300, "start": 693.0, "end": 706.0, "text": " That'll be the instruction name, the built-in name, built-in type, function type, and availability predicate.", "tokens": [663, 603, 312, 264, 10951, 1315, 11, 264, 3094, 12, 259, 1315, 11, 3094, 12, 259, 2010, 11, 2445, 2010, 11, 293, 17945, 3852, 8700, 13], "temperature": 0.0, "avg_logprob": -0.09953549882056008, "compression_ratio": 1.5822784810126582, "no_speech_prob": 1.8053300664178096e-05}, {"id": 92, "seek": 69300, "start": 706.0, "end": 714.0, "text": " So using this function, I have created my own file, which is called corev.dev,", "tokens": [407, 1228, 341, 2445, 11, 286, 362, 2942, 452, 1065, 3991, 11, 597, 307, 1219, 4965, 85, 13, 40343, 11], "temperature": 0.0, "avg_logprob": -0.09953549882056008, "compression_ratio": 1.5822784810126582, "no_speech_prob": 1.8053300664178096e-05}, {"id": 93, "seek": 69300, "start": 714.0, "end": 720.0, "text": " and this is where all the corev-related built-ins will be in.", "tokens": [293, 341, 307, 689, 439, 264, 4965, 85, 12, 12004, 3094, 12, 1292, 486, 312, 294, 13], "temperature": 0.0, "avg_logprob": -0.09953549882056008, "compression_ratio": 1.5822784810126582, "no_speech_prob": 1.8053300664178096e-05}, {"id": 94, "seek": 72000, "start": 720.0, "end": 731.0, "text": " My first built-in will be in corev.dev, and the name of the instruction name will be C-V-E-L-W-S-I for single integer.", "tokens": [1222, 700, 3094, 12, 259, 486, 312, 294, 4965, 85, 13, 40343, 11, 293, 264, 1315, 295, 264, 10951, 1315, 486, 312, 383, 12, 53, 12, 36, 12, 43, 12, 54, 12, 50, 12, 40, 337, 2167, 24922, 13], "temperature": 0.0, "avg_logprob": -0.0852306604385376, "compression_ratio": 1.6803652968036529, "no_speech_prob": 3.2023704989114776e-05}, {"id": 95, "seek": 72000, "start": 731.0, "end": 737.0, "text": " The name of the built-in that the programmers will be using will be C-V-E-L-W-E-L-W,", "tokens": [440, 1315, 295, 264, 3094, 12, 259, 300, 264, 41504, 486, 312, 1228, 486, 312, 383, 12, 53, 12, 36, 12, 43, 12, 54, 12, 36, 12, 43, 12, 54, 11], "temperature": 0.0, "avg_logprob": -0.0852306604385376, "compression_ratio": 1.6803652968036529, "no_speech_prob": 3.2023704989114776e-05}, {"id": 96, "seek": 72000, "start": 737.0, "end": 741.0, "text": " but that will be expanded to built-in RISC-5.", "tokens": [457, 300, 486, 312, 14342, 281, 3094, 12, 259, 497, 2343, 34, 12, 20, 13], "temperature": 0.0, "avg_logprob": -0.0852306604385376, "compression_ratio": 1.6803652968036529, "no_speech_prob": 3.2023704989114776e-05}, {"id": 97, "seek": 74100, "start": 741.0, "end": 752.0, "text": " Then you've got the corresponding built-in types, function types, availability predicate, and I'll go into that more.", "tokens": [1396, 291, 600, 658, 264, 11760, 3094, 12, 259, 3467, 11, 2445, 3467, 11, 17945, 3852, 8700, 11, 293, 286, 603, 352, 666, 300, 544, 13], "temperature": 0.0, "avg_logprob": -0.07926811112297906, "compression_ratio": 1.6515151515151516, "no_speech_prob": 1.3217826563050039e-05}, {"id": 98, "seek": 74100, "start": 752.0, "end": 761.0, "text": " So the instruction patterns, this is probably the most difficult part of the whole built-in implementation.", "tokens": [407, 264, 10951, 8294, 11, 341, 307, 1391, 264, 881, 2252, 644, 295, 264, 1379, 3094, 12, 259, 11420, 13], "temperature": 0.0, "avg_logprob": -0.07926811112297906, "compression_ratio": 1.6515151515151516, "no_speech_prob": 1.3217826563050039e-05}, {"id": 99, "seek": 74100, "start": 761.0, "end": 767.0, "text": " So the insert name is the name of the associated instruction pattern in the machine description file.", "tokens": [407, 264, 8969, 1315, 307, 264, 1315, 295, 264, 6615, 10951, 5102, 294, 264, 3479, 3855, 3991, 13], "temperature": 0.0, "avg_logprob": -0.07926811112297906, "compression_ratio": 1.6515151515151516, "no_speech_prob": 1.3217826563050039e-05}, {"id": 100, "seek": 76700, "start": 767.0, "end": 772.0, "text": " It uses, it takes in five operands, but the last operand is optional,", "tokens": [467, 4960, 11, 309, 2516, 294, 1732, 2208, 2967, 11, 457, 264, 1036, 2208, 474, 307, 17312, 11], "temperature": 0.0, "avg_logprob": -0.09786739978161486, "compression_ratio": 1.5459183673469388, "no_speech_prob": 4.61115560028702e-05}, {"id": 101, "seek": 76700, "start": 772.0, "end": 776.0, "text": " but I recommend you putting in if you can.", "tokens": [457, 286, 2748, 291, 3372, 294, 498, 291, 393, 13], "temperature": 0.0, "avg_logprob": -0.09786739978161486, "compression_ratio": 1.5459183673469388, "no_speech_prob": 4.61115560028702e-05}, {"id": 102, "seek": 76700, "start": 776.0, "end": 785.0, "text": " You've got the name, you've got the RTL template, conditions, output template, and instant attributes,", "tokens": [509, 600, 658, 264, 1315, 11, 291, 600, 658, 264, 21797, 43, 12379, 11, 4487, 11, 5598, 12379, 11, 293, 9836, 17212, 11], "temperature": 0.0, "avg_logprob": -0.09786739978161486, "compression_ratio": 1.5459183673469388, "no_speech_prob": 4.61115560028702e-05}, {"id": 103, "seek": 76700, "start": 785.0, "end": 793.0, "text": " and that will be all in RISC-5.md, but I will be creating my own md for corev-specific,", "tokens": [293, 300, 486, 312, 439, 294, 497, 2343, 34, 12, 20, 13, 76, 67, 11, 457, 286, 486, 312, 4084, 452, 1065, 275, 67, 337, 4965, 85, 12, 29258, 11], "temperature": 0.0, "avg_logprob": -0.09786739978161486, "compression_ratio": 1.5459183673469388, "no_speech_prob": 4.61115560028702e-05}, {"id": 104, "seek": 79300, "start": 793.0, "end": 800.0, "text": " so we don't merge it into RISC-5.md.", "tokens": [370, 321, 500, 380, 22183, 309, 666, 497, 2343, 34, 12, 20, 13, 76, 67, 13], "temperature": 0.0, "avg_logprob": -0.05596741710800723, "compression_ratio": 1.5583756345177664, "no_speech_prob": 2.3813732695998624e-05}, {"id": 105, "seek": 79300, "start": 800.0, "end": 805.0, "text": " So this is an example of RTL templates or register transfer language.", "tokens": [407, 341, 307, 364, 1365, 295, 21797, 43, 21165, 420, 7280, 5003, 2856, 13], "temperature": 0.0, "avg_logprob": -0.05596741710800723, "compression_ratio": 1.5583756345177664, "no_speech_prob": 2.3813732695998624e-05}, {"id": 106, "seek": 79300, "start": 805.0, "end": 813.0, "text": " It's a template that is very, very similar to intermediate representation that GCC uses.", "tokens": [467, 311, 257, 12379, 300, 307, 588, 11, 588, 2531, 281, 19376, 10290, 300, 460, 11717, 4960, 13], "temperature": 0.0, "avg_logprob": -0.05596741710800723, "compression_ratio": 1.5583756345177664, "no_speech_prob": 2.3813732695998624e-05}, {"id": 107, "seek": 79300, "start": 813.0, "end": 822.0, "text": " It's a template that GCC will take and then put in the corresponding registers or operands that it needs to do.", "tokens": [467, 311, 257, 12379, 300, 460, 11717, 486, 747, 293, 550, 829, 294, 264, 11760, 38351, 420, 2208, 2967, 300, 309, 2203, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.05596741710800723, "compression_ratio": 1.5583756345177664, "no_speech_prob": 2.3813732695998624e-05}, {"id": 108, "seek": 82200, "start": 822.0, "end": 828.0, "text": " So this is my instruction pattern that I will be using for this built-in.", "tokens": [407, 341, 307, 452, 10951, 5102, 300, 286, 486, 312, 1228, 337, 341, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.09885706667040216, "compression_ratio": 1.4873417721518987, "no_speech_prob": 5.098250767332502e-05}, {"id": 109, "seek": 82200, "start": 828.0, "end": 841.0, "text": " The name will be RISC-5 underscore CV as we've previously defined it.", "tokens": [440, 1315, 486, 312, 497, 2343, 34, 12, 20, 37556, 22995, 382, 321, 600, 8046, 7642, 309, 13], "temperature": 0.0, "avg_logprob": -0.09885706667040216, "compression_ratio": 1.4873417721518987, "no_speech_prob": 5.098250767332502e-05}, {"id": 110, "seek": 82200, "start": 841.0, "end": 850.0, "text": " I am using the set pattern and this will take a destination register and a source register.", "tokens": [286, 669, 1228, 264, 992, 5102, 293, 341, 486, 747, 257, 12236, 7280, 293, 257, 4009, 7280, 13], "temperature": 0.0, "avg_logprob": -0.09885706667040216, "compression_ratio": 1.4873417721518987, "no_speech_prob": 5.098250767332502e-05}, {"id": 111, "seek": 85000, "start": 850.0, "end": 858.0, "text": " The destination, I think, this will be the destination register, the first operand,", "tokens": [440, 12236, 11, 286, 519, 11, 341, 486, 312, 264, 12236, 7280, 11, 264, 700, 2208, 474, 11], "temperature": 0.0, "avg_logprob": -0.19329241702431127, "compression_ratio": 1.574468085106383, "no_speech_prob": 4.971758971805684e-05}, {"id": 112, "seek": 85000, "start": 858.0, "end": 868.0, "text": " and I've used the match operand pattern which will take m as machine mode and the index of this operand,", "tokens": [293, 286, 600, 1143, 264, 2995, 2208, 474, 5102, 597, 486, 747, 275, 382, 3479, 4391, 293, 264, 8186, 295, 341, 2208, 474, 11], "temperature": 0.0, "avg_logprob": -0.19329241702431127, "compression_ratio": 1.574468085106383, "no_speech_prob": 4.971758971805684e-05}, {"id": 113, "seek": 85000, "start": 868.0, "end": 873.0, "text": " the predicate and the constraint.", "tokens": [264, 3852, 8700, 293, 264, 25534, 13], "temperature": 0.0, "avg_logprob": -0.19329241702431127, "compression_ratio": 1.574468085106383, "no_speech_prob": 4.971758971805684e-05}, {"id": 114, "seek": 87300, "start": 873.0, "end": 880.0, "text": " The machine mode for this will be SI which is a single integer, it's 32 bits.", "tokens": [440, 3479, 4391, 337, 341, 486, 312, 29083, 597, 307, 257, 2167, 24922, 11, 309, 311, 8858, 9239, 13], "temperature": 0.0, "avg_logprob": -0.11878923575083415, "compression_ratio": 1.5798816568047338, "no_speech_prob": 1.6142586900969036e-05}, {"id": 115, "seek": 87300, "start": 880.0, "end": 883.0, "text": " It's zero for the index of this operand.", "tokens": [467, 311, 4018, 337, 264, 8186, 295, 341, 2208, 474, 13], "temperature": 0.0, "avg_logprob": -0.11878923575083415, "compression_ratio": 1.5798816568047338, "no_speech_prob": 1.6142586900969036e-05}, {"id": 116, "seek": 87300, "start": 883.0, "end": 888.0, "text": " We usually start with zero as the indexing.", "tokens": [492, 2673, 722, 365, 4018, 382, 264, 8186, 278, 13], "temperature": 0.0, "avg_logprob": -0.11878923575083415, "compression_ratio": 1.5798816568047338, "no_speech_prob": 1.6142586900969036e-05}, {"id": 117, "seek": 87300, "start": 888.0, "end": 897.0, "text": " The predicate for this will be a register operand as we'll be loading it into a general purpose register", "tokens": [440, 3852, 8700, 337, 341, 486, 312, 257, 7280, 2208, 474, 382, 321, 603, 312, 15114, 309, 666, 257, 2674, 4334, 7280], "temperature": 0.0, "avg_logprob": -0.11878923575083415, "compression_ratio": 1.5798816568047338, "no_speech_prob": 1.6142586900969036e-05}, {"id": 118, "seek": 89700, "start": 897.0, "end": 909.0, "text": " and the constraint will be R emphasizing as register equals to meaning it's going to be written to.", "tokens": [293, 264, 25534, 486, 312, 497, 45550, 382, 7280, 6915, 281, 3620, 309, 311, 516, 281, 312, 3720, 281, 13], "temperature": 0.0, "avg_logprob": -0.12410943791017694, "compression_ratio": 1.5209580838323353, "no_speech_prob": 1.7108075553551316e-05}, {"id": 119, "seek": 89700, "start": 909.0, "end": 920.0, "text": " Next part of this is the source register which will be the memory specific address.", "tokens": [3087, 644, 295, 341, 307, 264, 4009, 7280, 597, 486, 312, 264, 4675, 2685, 2985, 13], "temperature": 0.0, "avg_logprob": -0.12410943791017694, "compression_ratio": 1.5209580838323353, "no_speech_prob": 1.7108075553551316e-05}, {"id": 120, "seek": 89700, "start": 920.0, "end": 926.0, "text": " So we're using mem to specify the size of the object being referenced.", "tokens": [407, 321, 434, 1228, 1334, 281, 16500, 264, 2744, 295, 264, 2657, 885, 32734, 13], "temperature": 0.0, "avg_logprob": -0.12410943791017694, "compression_ratio": 1.5209580838323353, "no_speech_prob": 1.7108075553551316e-05}, {"id": 121, "seek": 92600, "start": 926.0, "end": 930.0, "text": " SI being single integer, 32 bits.", "tokens": [29083, 885, 2167, 24922, 11, 8858, 9239, 13], "temperature": 0.0, "avg_logprob": -0.09463733556319257, "compression_ratio": 1.35, "no_speech_prob": 2.0736510123242624e-05}, {"id": 122, "seek": 92600, "start": 930.0, "end": 942.0, "text": " Again, we're using match operand to match the register or the pointer to the specific address.", "tokens": [3764, 11, 321, 434, 1228, 2995, 2208, 474, 281, 2995, 264, 7280, 420, 264, 23918, 281, 264, 2685, 2985, 13], "temperature": 0.0, "avg_logprob": -0.09463733556319257, "compression_ratio": 1.35, "no_speech_prob": 2.0736510123242624e-05}, {"id": 123, "seek": 92600, "start": 942.0, "end": 948.0, "text": " The index number will be one because that's the next number.", "tokens": [440, 8186, 1230, 486, 312, 472, 570, 300, 311, 264, 958, 1230, 13], "temperature": 0.0, "avg_logprob": -0.09463733556319257, "compression_ratio": 1.35, "no_speech_prob": 2.0736510123242624e-05}, {"id": 124, "seek": 94800, "start": 948.0, "end": 959.0, "text": " I am using an address operand and then p specifying as pointer.", "tokens": [286, 669, 1228, 364, 2985, 2208, 474, 293, 550, 280, 1608, 5489, 382, 23918, 13], "temperature": 0.0, "avg_logprob": -0.09814129337187737, "compression_ratio": 1.5870967741935484, "no_speech_prob": 1.8886079487856477e-05}, {"id": 125, "seek": 94800, "start": 959.0, "end": 966.0, "text": " I am using an unspect volatile for this instruction because it's a volatile operation.", "tokens": [286, 669, 1228, 364, 2693, 1043, 34377, 337, 341, 10951, 570, 309, 311, 257, 34377, 6916, 13], "temperature": 0.0, "avg_logprob": -0.09814129337187737, "compression_ratio": 1.5870967741935484, "no_speech_prob": 1.8886079487856477e-05}, {"id": 126, "seek": 94800, "start": 966.0, "end": 968.0, "text": " It's very machine specific.", "tokens": [467, 311, 588, 3479, 2685, 13], "temperature": 0.0, "avg_logprob": -0.09814129337187737, "compression_ratio": 1.5870967741935484, "no_speech_prob": 1.8886079487856477e-05}, {"id": 127, "seek": 94800, "start": 968.0, "end": 973.0, "text": " It can get difficult and there are times where it could be trapped.", "tokens": [467, 393, 483, 2252, 293, 456, 366, 1413, 689, 309, 727, 312, 14994, 13], "temperature": 0.0, "avg_logprob": -0.09814129337187737, "compression_ratio": 1.5870967741935484, "no_speech_prob": 1.8886079487856477e-05}, {"id": 128, "seek": 97300, "start": 973.0, "end": 989.0, "text": " We are referencing in this state that is fragile and vulnerable so that is why I've been using an unspect volatile.", "tokens": [492, 366, 40582, 294, 341, 1785, 300, 307, 23847, 293, 10955, 370, 300, 307, 983, 286, 600, 668, 1228, 364, 2693, 1043, 34377, 13], "temperature": 0.0, "avg_logprob": -0.12486906254545171, "compression_ratio": 1.3925925925925926, "no_speech_prob": 1.8802702470566146e-05}, {"id": 129, "seek": 97300, "start": 989.0, "end": 998.0, "text": " Now that I've talked about the RTL pattern, we talk about the condition.", "tokens": [823, 300, 286, 600, 2825, 466, 264, 21797, 43, 5102, 11, 321, 751, 466, 264, 4188, 13], "temperature": 0.0, "avg_logprob": -0.12486906254545171, "compression_ratio": 1.3925925925925926, "no_speech_prob": 1.8802702470566146e-05}, {"id": 130, "seek": 99800, "start": 998.0, "end": 1006.0, "text": " The condition is important to add so that the instruction can only be generated within these conditions.", "tokens": [440, 4188, 307, 1021, 281, 909, 370, 300, 264, 10951, 393, 787, 312, 10833, 1951, 613, 4487, 13], "temperature": 0.0, "avg_logprob": -0.135396089553833, "compression_ratio": 1.4507042253521127, "no_speech_prob": 6.6308707573625725e-06}, {"id": 131, "seek": 99800, "start": 1006.0, "end": 1023.0, "text": " You can only generate this pattern if the target is to X call VELW and that it's not a 64 bit target.", "tokens": [509, 393, 787, 8460, 341, 5102, 498, 264, 3779, 307, 281, 1783, 818, 691, 3158, 54, 293, 300, 309, 311, 406, 257, 12145, 857, 3779, 13], "temperature": 0.0, "avg_logprob": -0.135396089553833, "compression_ratio": 1.4507042253521127, "no_speech_prob": 6.6308707573625725e-06}, {"id": 132, "seek": 102300, "start": 1023.0, "end": 1028.0, "text": " Next we talk about the orange bit which is the output template.", "tokens": [3087, 321, 751, 466, 264, 7671, 857, 597, 307, 264, 5598, 12379, 13], "temperature": 0.0, "avg_logprob": -0.17526715422329836, "compression_ratio": 1.5737704918032787, "no_speech_prob": 2.9595466912724078e-05}, {"id": 133, "seek": 102300, "start": 1028.0, "end": 1034.0, "text": " The output template will be what you will see in the assembly.", "tokens": [440, 5598, 12379, 486, 312, 437, 291, 486, 536, 294, 264, 12103, 13], "temperature": 0.0, "avg_logprob": -0.17526715422329836, "compression_ratio": 1.5737704918032787, "no_speech_prob": 2.9595466912724078e-05}, {"id": 134, "seek": 102300, "start": 1034.0, "end": 1041.0, "text": " You define it with the instruction name so cv.el and then slash t for tad.", "tokens": [509, 6964, 309, 365, 264, 10951, 1315, 370, 269, 85, 13, 338, 293, 550, 17330, 256, 337, 29622, 13], "temperature": 0.0, "avg_logprob": -0.17526715422329836, "compression_ratio": 1.5737704918032787, "no_speech_prob": 2.9595466912724078e-05}, {"id": 135, "seek": 102300, "start": 1041.0, "end": 1047.0, "text": " This is where you use those index numbers to reference which operands you want to use.", "tokens": [639, 307, 689, 291, 764, 729, 8186, 3547, 281, 6408, 597, 2208, 2967, 291, 528, 281, 764, 13], "temperature": 0.0, "avg_logprob": -0.17526715422329836, "compression_ratio": 1.5737704918032787, "no_speech_prob": 2.9595466912724078e-05}, {"id": 136, "seek": 104700, "start": 1047.0, "end": 1053.0, "text": " I will be referencing %0 and then %a1.", "tokens": [286, 486, 312, 40582, 14189, 15, 293, 550, 14189, 64, 16, 13], "temperature": 0.0, "avg_logprob": -0.09487438201904297, "compression_ratio": 1.4375, "no_speech_prob": 2.4819430109346285e-05}, {"id": 137, "seek": 104700, "start": 1053.0, "end": 1060.0, "text": " %0 will be the destination register and %1 will be the source register.", "tokens": [14189, 15, 486, 312, 264, 12236, 7280, 293, 14189, 16, 486, 312, 264, 4009, 7280, 13], "temperature": 0.0, "avg_logprob": -0.09487438201904297, "compression_ratio": 1.4375, "no_speech_prob": 2.4819430109346285e-05}, {"id": 138, "seek": 104700, "start": 1060.0, "end": 1070.0, "text": " I am using %a to substitute as a memory reference.", "tokens": [286, 669, 1228, 14189, 64, 281, 15802, 382, 257, 4675, 6408, 13], "temperature": 0.0, "avg_logprob": -0.09487438201904297, "compression_ratio": 1.4375, "no_speech_prob": 2.4819430109346285e-05}, {"id": 139, "seek": 107000, "start": 1070.0, "end": 1079.0, "text": " Lastly we talk about the optional operand but again this is something we should try to put in if you are going to add a built-in.", "tokens": [18072, 321, 751, 466, 264, 17312, 2208, 474, 457, 797, 341, 307, 746, 321, 820, 853, 281, 829, 294, 498, 291, 366, 516, 281, 909, 257, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.12698811869467458, "compression_ratio": 1.4753086419753085, "no_speech_prob": 1.610691106179729e-05}, {"id": 140, "seek": 107000, "start": 1079.0, "end": 1089.0, "text": " We want to tell GCC that this is a load type of instruction and the mode is SI throughout the whole built-in.", "tokens": [492, 528, 281, 980, 460, 11717, 300, 341, 307, 257, 3677, 2010, 295, 10951, 293, 264, 4391, 307, 29083, 3710, 264, 1379, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.12698811869467458, "compression_ratio": 1.4753086419753085, "no_speech_prob": 1.610691106179729e-05}, {"id": 141, "seek": 108900, "start": 1089.0, "end": 1108.0, "text": " The reason I have added this optional operand is that the instruction can still be generated but GCC can now optimise it knowing that it is a load, knowing that it is in machine mode SI.", "tokens": [440, 1778, 286, 362, 3869, 341, 17312, 2208, 474, 307, 300, 264, 10951, 393, 920, 312, 10833, 457, 460, 11717, 393, 586, 5028, 908, 309, 5276, 300, 309, 307, 257, 3677, 11, 5276, 300, 309, 307, 294, 3479, 4391, 29083, 13], "temperature": 0.0, "avg_logprob": -0.2099421289232042, "compression_ratio": 1.5977653631284916, "no_speech_prob": 1.7103498976211995e-05}, {"id": 142, "seek": 108900, "start": 1108.0, "end": 1112.0, "text": " That is now the big part of the built-in.", "tokens": [663, 307, 586, 264, 955, 644, 295, 264, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.2099421289232042, "compression_ratio": 1.5977653631284916, "no_speech_prob": 1.7103498976211995e-05}, {"id": 143, "seek": 108900, "start": 1112.0, "end": 1117.0, "text": " We have discussed the instant name and the template name.", "tokens": [492, 362, 7152, 264, 9836, 1315, 293, 264, 12379, 1315, 13], "temperature": 0.0, "avg_logprob": -0.2099421289232042, "compression_ratio": 1.5977653631284916, "no_speech_prob": 1.7103498976211995e-05}, {"id": 144, "seek": 111700, "start": 1117.0, "end": 1119.0, "text": " Here it comes to the built-in types.", "tokens": [1692, 309, 1487, 281, 264, 3094, 12, 259, 3467, 13], "temperature": 0.0, "avg_logprob": -0.1471114158630371, "compression_ratio": 1.7328244274809161, "no_speech_prob": 6.118301826063544e-05}, {"id": 145, "seek": 111700, "start": 1119.0, "end": 1126.0, "text": " In RISC-5 there are currently only two types of built-in types.", "tokens": [682, 497, 2343, 34, 12, 20, 456, 366, 4362, 787, 732, 3467, 295, 3094, 12, 259, 3467, 13], "temperature": 0.0, "avg_logprob": -0.1471114158630371, "compression_ratio": 1.7328244274809161, "no_speech_prob": 6.118301826063544e-05}, {"id": 146, "seek": 111700, "start": 1126.0, "end": 1132.0, "text": " Those built-in types can be found in RISC-5 built-ins.cc.", "tokens": [3950, 3094, 12, 259, 3467, 393, 312, 1352, 294, 497, 2343, 34, 12, 20, 3094, 12, 1292, 13, 1914, 13], "temperature": 0.0, "avg_logprob": -0.1471114158630371, "compression_ratio": 1.7328244274809161, "no_speech_prob": 6.118301826063544e-05}, {"id": 147, "seek": 111700, "start": 1132.0, "end": 1139.0, "text": " This is RISC-5 built-in direct and RISC-5 built-in direct no target.", "tokens": [639, 307, 497, 2343, 34, 12, 20, 3094, 12, 259, 2047, 293, 497, 2343, 34, 12, 20, 3094, 12, 259, 2047, 572, 3779, 13], "temperature": 0.0, "avg_logprob": -0.1471114158630371, "compression_ratio": 1.7328244274809161, "no_speech_prob": 6.118301826063544e-05}, {"id": 148, "seek": 113900, "start": 1139.0, "end": 1152.0, "text": " RISC-5 built-in direct corresponds directly to a machine pattern we have just created whereas RISC-5 built-in direct no target does the same thing but the return type will be void.", "tokens": [497, 2343, 34, 12, 20, 3094, 12, 259, 2047, 23249, 3838, 281, 257, 3479, 5102, 321, 362, 445, 2942, 9735, 497, 2343, 34, 12, 20, 3094, 12, 259, 2047, 572, 3779, 775, 264, 912, 551, 457, 264, 2736, 2010, 486, 312, 22009, 13], "temperature": 0.0, "avg_logprob": -0.1146741145994605, "compression_ratio": 1.6557377049180328, "no_speech_prob": 1.703143243503291e-05}, {"id": 149, "seek": 113900, "start": 1152.0, "end": 1158.0, "text": " But we are returning a general register operand or theta bit unsigned integer.", "tokens": [583, 321, 366, 12678, 257, 2674, 7280, 2208, 474, 420, 9725, 857, 2693, 16690, 24922, 13], "temperature": 0.0, "avg_logprob": -0.1146741145994605, "compression_ratio": 1.6557377049180328, "no_speech_prob": 1.703143243503291e-05}, {"id": 150, "seek": 113900, "start": 1158.0, "end": 1166.0, "text": " So we will be using RISC-5 built-in direct.", "tokens": [407, 321, 486, 312, 1228, 497, 2343, 34, 12, 20, 3094, 12, 259, 2047, 13], "temperature": 0.0, "avg_logprob": -0.1146741145994605, "compression_ratio": 1.6557377049180328, "no_speech_prob": 1.703143243503291e-05}, {"id": 151, "seek": 116600, "start": 1166.0, "end": 1169.0, "text": " Next comes the function types.", "tokens": [3087, 1487, 264, 2445, 3467, 13], "temperature": 0.0, "avg_logprob": -0.1341129649769176, "compression_ratio": 1.6193548387096774, "no_speech_prob": 1.581811193318572e-05}, {"id": 152, "seek": 116600, "start": 1169.0, "end": 1175.0, "text": " And again, everything is in RISC-5 built-ins.cc.", "tokens": [400, 797, 11, 1203, 307, 294, 497, 2343, 34, 12, 20, 3094, 12, 1292, 13, 1914, 13], "temperature": 0.0, "avg_logprob": -0.1341129649769176, "compression_ratio": 1.6193548387096774, "no_speech_prob": 1.581811193318572e-05}, {"id": 153, "seek": 116600, "start": 1175.0, "end": 1181.0, "text": " And currently there are only two types of prototypes for RISC-5.", "tokens": [400, 4362, 456, 366, 787, 732, 3467, 295, 42197, 337, 497, 2343, 34, 12, 20, 13], "temperature": 0.0, "avg_logprob": -0.1341129649769176, "compression_ratio": 1.6193548387096774, "no_speech_prob": 1.581811193318572e-05}, {"id": 154, "seek": 116600, "start": 1181.0, "end": 1185.0, "text": " You can only return.", "tokens": [509, 393, 787, 2736, 13], "temperature": 0.0, "avg_logprob": -0.1341129649769176, "compression_ratio": 1.6193548387096774, "no_speech_prob": 1.581811193318572e-05}, {"id": 155, "seek": 116600, "start": 1185.0, "end": 1187.0, "text": " You can only have a returning type.", "tokens": [509, 393, 787, 362, 257, 12678, 2010, 13], "temperature": 0.0, "avg_logprob": -0.1341129649769176, "compression_ratio": 1.6193548387096774, "no_speech_prob": 1.581811193318572e-05}, {"id": 156, "seek": 116600, "start": 1187.0, "end": 1191.0, "text": " You can only have a return type and one argument.", "tokens": [509, 393, 787, 362, 257, 2736, 2010, 293, 472, 6770, 13], "temperature": 0.0, "avg_logprob": -0.1341129649769176, "compression_ratio": 1.6193548387096774, "no_speech_prob": 1.581811193318572e-05}, {"id": 157, "seek": 119100, "start": 1191.0, "end": 1206.0, "text": " In coming presentations I will be talking about it a bit more because I only have 45 minutes to talk about this presentation.", "tokens": [682, 1348, 18964, 286, 486, 312, 1417, 466, 309, 257, 857, 544, 570, 286, 787, 362, 6905, 2077, 281, 751, 466, 341, 5860, 13], "temperature": 0.0, "avg_logprob": -0.13188055006124205, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.00016493526345584542}, {"id": 158, "seek": 119100, "start": 1206.0, "end": 1218.0, "text": " When it comes to defining which return types and argument types we are using that will be in RISC-5-f types.dev.", "tokens": [1133, 309, 1487, 281, 17827, 597, 2736, 3467, 293, 6770, 3467, 321, 366, 1228, 300, 486, 312, 294, 497, 2343, 34, 12, 20, 12, 69, 3467, 13, 40343, 13], "temperature": 0.0, "avg_logprob": -0.13188055006124205, "compression_ratio": 1.4782608695652173, "no_speech_prob": 0.00016493526345584542}, {"id": 159, "seek": 121800, "start": 1218.0, "end": 1236.0, "text": " So the comment says that it will expand to RISC-5 underscore unsigned integer and then avoid pointer because that's what I will be using for my built-in type.", "tokens": [407, 264, 2871, 1619, 300, 309, 486, 5268, 281, 497, 2343, 34, 12, 20, 37556, 2693, 16690, 24922, 293, 550, 5042, 23918, 570, 300, 311, 437, 286, 486, 312, 1228, 337, 452, 3094, 12, 259, 2010, 13], "temperature": 0.0, "avg_logprob": -0.11247465189765482, "compression_ratio": 1.425531914893617, "no_speech_prob": 2.9159609766793437e-05}, {"id": 160, "seek": 121800, "start": 1236.0, "end": 1239.0, "text": " Lastly we have the availability predicate.", "tokens": [18072, 321, 362, 264, 17945, 3852, 8700, 13], "temperature": 0.0, "avg_logprob": -0.11247465189765482, "compression_ratio": 1.425531914893617, "no_speech_prob": 2.9159609766793437e-05}, {"id": 161, "seek": 121800, "start": 1239.0, "end": 1245.0, "text": " This is very similar to the conditions we had in the RTL template.", "tokens": [639, 307, 588, 2531, 281, 264, 4487, 321, 632, 294, 264, 21797, 43, 12379, 13], "temperature": 0.0, "avg_logprob": -0.11247465189765482, "compression_ratio": 1.425531914893617, "no_speech_prob": 2.9159609766793437e-05}, {"id": 162, "seek": 124500, "start": 1245.0, "end": 1252.0, "text": " So we use this avail function that has been declared in RISC-5 built-ins.cc.", "tokens": [407, 321, 764, 341, 2327, 2445, 300, 575, 668, 15489, 294, 497, 2343, 34, 12, 20, 3094, 12, 1292, 13, 1914, 13], "temperature": 0.0, "avg_logprob": -0.08340120315551758, "compression_ratio": 1.4901960784313726, "no_speech_prob": 5.894249625271186e-05}, {"id": 163, "seek": 124500, "start": 1252.0, "end": 1257.0, "text": " It takes the name of your availability predicate and then the corresponding conditions.", "tokens": [467, 2516, 264, 1315, 295, 428, 17945, 3852, 8700, 293, 550, 264, 11760, 4487, 13], "temperature": 0.0, "avg_logprob": -0.08340120315551758, "compression_ratio": 1.4901960784313726, "no_speech_prob": 5.894249625271186e-05}, {"id": 164, "seek": 124500, "start": 1257.0, "end": 1273.0, "text": " As you can see it's very similar to the condition we had in the RTL template which is a target reference and then it's not a 64-bit target.", "tokens": [1018, 291, 393, 536, 309, 311, 588, 2531, 281, 264, 4188, 321, 632, 294, 264, 21797, 43, 12379, 597, 307, 257, 3779, 6408, 293, 550, 309, 311, 406, 257, 12145, 12, 5260, 3779, 13], "temperature": 0.0, "avg_logprob": -0.08340120315551758, "compression_ratio": 1.4901960784313726, "no_speech_prob": 5.894249625271186e-05}, {"id": 165, "seek": 127300, "start": 1273.0, "end": 1282.0, "text": " Now that we've added the extension and the instruction and the built-in it's time to test it.", "tokens": [823, 300, 321, 600, 3869, 264, 10320, 293, 264, 10951, 293, 264, 3094, 12, 259, 309, 311, 565, 281, 1500, 309, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 166, "seek": 127300, "start": 1282.0, "end": 1286.0, "text": " And this is a very simple test just to make sure that it works.", "tokens": [400, 341, 307, 257, 588, 2199, 1500, 445, 281, 652, 988, 300, 309, 1985, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 167, "seek": 127300, "start": 1286.0, "end": 1288.0, "text": " It's a compilation test.", "tokens": [467, 311, 257, 40261, 1500, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 168, "seek": 127300, "start": 1288.0, "end": 1292.0, "text": " It takes in a void pointer with an offset.", "tokens": [467, 2516, 294, 257, 22009, 23918, 365, 364, 18687, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 169, "seek": 127300, "start": 1292.0, "end": 1295.0, "text": " It returns an unsigned 32-bit value.", "tokens": [467, 11247, 364, 2693, 16690, 8858, 12, 5260, 2158, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 170, "seek": 127300, "start": 1295.0, "end": 1298.0, "text": " You can see there are comments on the side.", "tokens": [509, 393, 536, 456, 366, 3053, 322, 264, 1252, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 171, "seek": 127300, "start": 1298.0, "end": 1300.0, "text": " These are deja vu comments.", "tokens": [1981, 366, 38260, 9732, 3053, 13], "temperature": 0.0, "avg_logprob": -0.11820723884984066, "compression_ratio": 1.5754716981132075, "no_speech_prob": 5.751083153882064e-05}, {"id": 172, "seek": 130000, "start": 1300.0, "end": 1309.0, "text": " We are using deja vu because we want to use a simulator or it can be used on microcontrollers.", "tokens": [492, 366, 1228, 38260, 9732, 570, 321, 528, 281, 764, 257, 32974, 420, 309, 393, 312, 1143, 322, 4532, 9000, 3970, 433, 13], "temperature": 0.0, "avg_logprob": -0.12135820161728632, "compression_ratio": 1.642156862745098, "no_speech_prob": 1.974430779227987e-05}, {"id": 173, "seek": 130000, "start": 1309.0, "end": 1316.0, "text": " It's a framework testing model that we use for our test scripts.", "tokens": [467, 311, 257, 8388, 4997, 2316, 300, 321, 764, 337, 527, 1500, 23294, 13], "temperature": 0.0, "avg_logprob": -0.12135820161728632, "compression_ratio": 1.642156862745098, "no_speech_prob": 1.974430779227987e-05}, {"id": 174, "seek": 130000, "start": 1316.0, "end": 1324.0, "text": " The first comment we'll talk about telling it it can be an execution or a compilation test.", "tokens": [440, 700, 2871, 321, 603, 751, 466, 3585, 309, 309, 393, 312, 364, 15058, 420, 257, 40261, 1500, 13], "temperature": 0.0, "avg_logprob": -0.12135820161728632, "compression_ratio": 1.642156862745098, "no_speech_prob": 1.974430779227987e-05}, {"id": 175, "seek": 130000, "start": 1324.0, "end": 1329.0, "text": " So this will be a compilation test because we haven't got an executable target yet.", "tokens": [407, 341, 486, 312, 257, 40261, 1500, 570, 321, 2378, 380, 658, 364, 7568, 712, 3779, 1939, 13], "temperature": 0.0, "avg_logprob": -0.12135820161728632, "compression_ratio": 1.642156862745098, "no_speech_prob": 1.974430779227987e-05}, {"id": 176, "seek": 132900, "start": 1329.0, "end": 1333.0, "text": " The second line is to tell you the options for this built-in.", "tokens": [440, 1150, 1622, 307, 281, 980, 291, 264, 3956, 337, 341, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.11424526698152784, "compression_ratio": 1.5806451612903225, "no_speech_prob": 4.1752598917810246e-05}, {"id": 177, "seek": 132900, "start": 1333.0, "end": 1344.0, "text": " If you don't specify the options then this test won't run because this instruction only works within X core VELW.", "tokens": [759, 291, 500, 380, 16500, 264, 3956, 550, 341, 1500, 1582, 380, 1190, 570, 341, 10951, 787, 1985, 1951, 1783, 4965, 691, 3158, 54, 13], "temperature": 0.0, "avg_logprob": -0.11424526698152784, "compression_ratio": 1.5806451612903225, "no_speech_prob": 4.1752598917810246e-05}, {"id": 178, "seek": 132900, "start": 1344.0, "end": 1358.0, "text": " And then the last line or the last comment will be for checking if our instruction has been generated in the assembly.", "tokens": [400, 550, 264, 1036, 1622, 420, 264, 1036, 2871, 486, 312, 337, 8568, 498, 527, 10951, 575, 668, 10833, 294, 264, 12103, 13], "temperature": 0.0, "avg_logprob": -0.11424526698152784, "compression_ratio": 1.5806451612903225, "no_speech_prob": 4.1752598917810246e-05}, {"id": 179, "seek": 135800, "start": 1358.0, "end": 1361.0, "text": " And it should be generated once.", "tokens": [400, 309, 820, 312, 10833, 1564, 13], "temperature": 0.0, "avg_logprob": -0.05349387006556734, "compression_ratio": 1.2868217054263567, "no_speech_prob": 6.47700289846398e-05}, {"id": 180, "seek": 135800, "start": 1361.0, "end": 1363.0, "text": " There are dashes to escape.", "tokens": [821, 366, 8240, 279, 281, 7615, 13], "temperature": 0.0, "avg_logprob": -0.05349387006556734, "compression_ratio": 1.2868217054263567, "no_speech_prob": 6.47700289846398e-05}, {"id": 181, "seek": 135800, "start": 1363.0, "end": 1379.0, "text": " It's very sensitive because it's a regular expression type of framework.", "tokens": [467, 311, 588, 9477, 570, 309, 311, 257, 3890, 6114, 2010, 295, 8388, 13], "temperature": 0.0, "avg_logprob": -0.05349387006556734, "compression_ratio": 1.2868217054263567, "no_speech_prob": 6.47700289846398e-05}, {"id": 182, "seek": 135800, "start": 1379.0, "end": 1382.0, "text": " We've got a run script for this.", "tokens": [492, 600, 658, 257, 1190, 5755, 337, 341, 13], "temperature": 0.0, "avg_logprob": -0.05349387006556734, "compression_ratio": 1.2868217054263567, "no_speech_prob": 6.47700289846398e-05}, {"id": 183, "seek": 138200, "start": 1382.0, "end": 1390.0, "text": " It's very important to build GCC because I've been running tests without building GCC and wondering why it doesn't work.", "tokens": [467, 311, 588, 1021, 281, 1322, 460, 11717, 570, 286, 600, 668, 2614, 6921, 1553, 2390, 460, 11717, 293, 6359, 983, 309, 1177, 380, 589, 13], "temperature": 0.0, "avg_logprob": -0.10047461047317043, "compression_ratio": 1.4556962025316456, "no_speech_prob": 0.00012904904724564403}, {"id": 184, "seek": 138200, "start": 1390.0, "end": 1395.0, "text": " And it wasn't until our GCC experts told us, no, you've got a run build.", "tokens": [400, 309, 2067, 380, 1826, 527, 460, 11717, 8572, 1907, 505, 11, 572, 11, 291, 600, 658, 257, 1190, 1322, 13], "temperature": 0.0, "avg_logprob": -0.10047461047317043, "compression_ratio": 1.4556962025316456, "no_speech_prob": 0.00012904904724564403}, {"id": 185, "seek": 138200, "start": 1395.0, "end": 1403.0, "text": " You have to run GCC and then run it.", "tokens": [509, 362, 281, 1190, 460, 11717, 293, 550, 1190, 309, 13], "temperature": 0.0, "avg_logprob": -0.10047461047317043, "compression_ratio": 1.4556962025316456, "no_speech_prob": 0.00012904904724564403}, {"id": 186, "seek": 140300, "start": 1403.0, "end": 1414.0, "text": " So this shows the results from our run test scripts.", "tokens": [407, 341, 3110, 264, 3542, 490, 527, 1190, 1500, 23294, 13], "temperature": 0.0, "avg_logprob": -0.07178082117220251, "compression_ratio": 1.2598425196850394, "no_speech_prob": 5.169216365175089e-06}, {"id": 187, "seek": 140300, "start": 1414.0, "end": 1419.0, "text": " Although it's just one test, there are 18 passes.", "tokens": [5780, 309, 311, 445, 472, 1500, 11, 456, 366, 2443, 11335, 13], "temperature": 0.0, "avg_logprob": -0.07178082117220251, "compression_ratio": 1.2598425196850394, "no_speech_prob": 5.169216365175089e-06}, {"id": 188, "seek": 140300, "start": 1419.0, "end": 1423.0, "text": " That is because it goes through nine optimization levels.", "tokens": [663, 307, 570, 309, 1709, 807, 4949, 19618, 4358, 13], "temperature": 0.0, "avg_logprob": -0.07178082117220251, "compression_ratio": 1.2598425196850394, "no_speech_prob": 5.169216365175089e-06}, {"id": 189, "seek": 142300, "start": 1423.0, "end": 1437.0, "text": " The optimization level goes through a scan assembly test and then a compilation test.", "tokens": [440, 19618, 1496, 1709, 807, 257, 11049, 12103, 1500, 293, 550, 257, 40261, 1500, 13], "temperature": 0.0, "avg_logprob": -0.11963688173601704, "compression_ratio": 1.3964497041420119, "no_speech_prob": 1.4017071407579351e-05}, {"id": 190, "seek": 142300, "start": 1437.0, "end": 1444.0, "text": " Like I promised, I put up the slides for where all of this will be found.", "tokens": [1743, 286, 10768, 11, 286, 829, 493, 264, 9788, 337, 689, 439, 295, 341, 486, 312, 1352, 13], "temperature": 0.0, "avg_logprob": -0.11963688173601704, "compression_ratio": 1.3964497041420119, "no_speech_prob": 1.4017071407579351e-05}, {"id": 191, "seek": 142300, "start": 1444.0, "end": 1451.0, "text": " This will be found in GitHub's Open Hardware Core 5 Vinutils and Core 5 GCC.", "tokens": [639, 486, 312, 1352, 294, 23331, 311, 7238, 11817, 3039, 14798, 1025, 15011, 325, 4174, 293, 14798, 1025, 460, 11717, 13], "temperature": 0.0, "avg_logprob": -0.11963688173601704, "compression_ratio": 1.3964497041420119, "no_speech_prob": 1.4017071407579351e-05}, {"id": 192, "seek": 145100, "start": 1451.0, "end": 1454.0, "text": " This is also part of the Open Hardware group.", "tokens": [639, 307, 611, 644, 295, 264, 7238, 11817, 3039, 1594, 13], "temperature": 0.0, "avg_logprob": -0.10567205724581866, "compression_ratio": 1.4143646408839778, "no_speech_prob": 8.837782661430538e-05}, {"id": 193, "seek": 145100, "start": 1454.0, "end": 1462.0, "text": " We are still looking for volunteers and people to contribute to this project.", "tokens": [492, 366, 920, 1237, 337, 14352, 293, 561, 281, 10586, 281, 341, 1716, 13], "temperature": 0.0, "avg_logprob": -0.10567205724581866, "compression_ratio": 1.4143646408839778, "no_speech_prob": 8.837782661430538e-05}, {"id": 194, "seek": 145100, "start": 1462.0, "end": 1467.0, "text": " And it's very important to also mention the GCC internals manual.", "tokens": [400, 309, 311, 588, 1021, 281, 611, 2152, 264, 460, 11717, 2154, 1124, 9688, 13], "temperature": 0.0, "avg_logprob": -0.10567205724581866, "compression_ratio": 1.4143646408839778, "no_speech_prob": 8.837782661430538e-05}, {"id": 195, "seek": 145100, "start": 1467.0, "end": 1470.0, "text": " It's probably the guru of GCC.", "tokens": [467, 311, 1391, 264, 29949, 295, 460, 11717, 13], "temperature": 0.0, "avg_logprob": -0.10567205724581866, "compression_ratio": 1.4143646408839778, "no_speech_prob": 8.837782661430538e-05}, {"id": 196, "seek": 145100, "start": 1470.0, "end": 1476.0, "text": " That's what I rely on the most now.", "tokens": [663, 311, 437, 286, 10687, 322, 264, 881, 586, 13], "temperature": 0.0, "avg_logprob": -0.10567205724581866, "compression_ratio": 1.4143646408839778, "no_speech_prob": 8.837782661430538e-05}, {"id": 197, "seek": 147600, "start": 1476.0, "end": 1489.0, "text": " Thank you for listening to my presentation. Do you have any questions?", "tokens": [1044, 291, 337, 4764, 281, 452, 5860, 13, 1144, 291, 362, 604, 1651, 30], "temperature": 0.0, "avg_logprob": -0.20924205467349194, "compression_ratio": 1.382716049382716, "no_speech_prob": 4.60347619082313e-05}, {"id": 198, "seek": 147600, "start": 1489.0, "end": 1490.0, "text": " Yes?", "tokens": [1079, 30], "temperature": 0.0, "avg_logprob": -0.20924205467349194, "compression_ratio": 1.382716049382716, "no_speech_prob": 4.60347619082313e-05}, {"id": 199, "seek": 147600, "start": 1490.0, "end": 1491.0, "text": " I have a question.", "tokens": [286, 362, 257, 1168, 13], "temperature": 0.0, "avg_logprob": -0.20924205467349194, "compression_ratio": 1.382716049382716, "no_speech_prob": 4.60347619082313e-05}, {"id": 200, "seek": 147600, "start": 1491.0, "end": 1500.0, "text": " So I know that these built-in functions are used by the code people, which I think is what came before the Core 5 project, right?", "tokens": [407, 286, 458, 300, 613, 3094, 12, 259, 6828, 366, 1143, 538, 264, 3089, 561, 11, 597, 286, 519, 307, 437, 1361, 949, 264, 14798, 1025, 1716, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.20924205467349194, "compression_ratio": 1.382716049382716, "no_speech_prob": 4.60347619082313e-05}, {"id": 201, "seek": 150000, "start": 1500.0, "end": 1508.0, "text": " I think they use it for various mathematical functions to speed them up.", "tokens": [286, 519, 436, 764, 309, 337, 3683, 18894, 6828, 281, 3073, 552, 493, 13], "temperature": 0.0, "avg_logprob": -0.2174421422621783, "compression_ratio": 1.5687203791469195, "no_speech_prob": 0.0011415730696171522}, {"id": 202, "seek": 150000, "start": 1508.0, "end": 1519.0, "text": " I was just wondering, what I'm interested in, what I'm working on, is using higher level compilers to compile into automatically generated kernels.", "tokens": [286, 390, 445, 6359, 11, 437, 286, 478, 3102, 294, 11, 437, 286, 478, 1364, 322, 11, 307, 1228, 2946, 1496, 715, 388, 433, 281, 31413, 666, 6772, 10833, 23434, 1625, 13], "temperature": 0.0, "avg_logprob": -0.2174421422621783, "compression_ratio": 1.5687203791469195, "no_speech_prob": 0.0011415730696171522}, {"id": 203, "seek": 150000, "start": 1519.0, "end": 1526.0, "text": " What's not clear to me right now is that if I use a built-in, then I would need to compile to a C code, right?", "tokens": [708, 311, 406, 1850, 281, 385, 558, 586, 307, 300, 498, 286, 764, 257, 3094, 12, 259, 11, 550, 286, 576, 643, 281, 31413, 281, 257, 383, 3089, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.2174421422621783, "compression_ratio": 1.5687203791469195, "no_speech_prob": 0.0011415730696171522}, {"id": 204, "seek": 152600, "start": 1526.0, "end": 1535.0, "text": " Is there any way that you can still reuse part of this work without having to use C code, or would you always need to go to C code?", "tokens": [1119, 456, 604, 636, 300, 291, 393, 920, 26225, 644, 295, 341, 589, 1553, 1419, 281, 764, 383, 3089, 11, 420, 576, 291, 1009, 643, 281, 352, 281, 383, 3089, 30], "temperature": 0.0, "avg_logprob": -0.2535294171037345, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.0011583827435970306}, {"id": 205, "seek": 152600, "start": 1535.0, "end": 1539.0, "text": " For now, I've just been using C code, so I'm not really sure.", "tokens": [1171, 586, 11, 286, 600, 445, 668, 1228, 383, 3089, 11, 370, 286, 478, 406, 534, 988, 13], "temperature": 0.0, "avg_logprob": -0.2535294171037345, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.0011583827435970306}, {"id": 206, "seek": 152600, "start": 1539.0, "end": 1542.0, "text": " I don't know.", "tokens": [286, 500, 380, 458, 13], "temperature": 0.0, "avg_logprob": -0.2535294171037345, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.0011583827435970306}, {"id": 207, "seek": 152600, "start": 1542.0, "end": 1544.0, "text": " If you've got a fault, I'm fine.", "tokens": [759, 291, 600, 658, 257, 7441, 11, 286, 478, 2489, 13], "temperature": 0.0, "avg_logprob": -0.2535294171037345, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.0011583827435970306}, {"id": 208, "seek": 152600, "start": 1544.0, "end": 1549.0, "text": " There's the C API, so you can sort of wire it into it.", "tokens": [821, 311, 264, 383, 9362, 11, 370, 291, 393, 1333, 295, 6234, 309, 666, 309, 13], "temperature": 0.0, "avg_logprob": -0.2535294171037345, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.0011583827435970306}, {"id": 209, "seek": 152600, "start": 1549.0, "end": 1555.0, "text": " This is in the compiler, so you just need to find your own code to reach to the client.", "tokens": [639, 307, 294, 264, 31958, 11, 370, 291, 445, 643, 281, 915, 428, 1065, 3089, 281, 2524, 281, 264, 6423, 13], "temperature": 0.0, "avg_logprob": -0.2535294171037345, "compression_ratio": 1.6297872340425532, "no_speech_prob": 0.0011583827435970306}, {"id": 210, "seek": 155500, "start": 1555.0, "end": 1558.0, "text": " So in this case, you would also use these things in Fortran code.", "tokens": [407, 294, 341, 1389, 11, 291, 576, 611, 764, 613, 721, 294, 11002, 4257, 3089, 13], "temperature": 0.0, "avg_logprob": -0.37010578487230383, "compression_ratio": 1.5424528301886793, "no_speech_prob": 0.009881925769150257}, {"id": 211, "seek": 155500, "start": 1558.0, "end": 1560.0, "text": " You could, yeah.", "tokens": [509, 727, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.37010578487230383, "compression_ratio": 1.5424528301886793, "no_speech_prob": 0.009881925769150257}, {"id": 212, "seek": 155500, "start": 1560.0, "end": 1568.0, "text": " I have an amazing that myself, I've been working with the staff, so there's no reason for this not to work.", "tokens": [286, 362, 364, 2243, 300, 2059, 11, 286, 600, 668, 1364, 365, 264, 3525, 11, 370, 456, 311, 572, 1778, 337, 341, 406, 281, 589, 13], "temperature": 0.0, "avg_logprob": -0.37010578487230383, "compression_ratio": 1.5424528301886793, "no_speech_prob": 0.009881925769150257}, {"id": 213, "seek": 155500, "start": 1568.0, "end": 1574.0, "text": " It's expressed in terms of a C code, so it has to be expressed somehow.", "tokens": [467, 311, 12675, 294, 2115, 295, 257, 383, 3089, 11, 370, 309, 575, 281, 312, 12675, 6063, 13], "temperature": 0.0, "avg_logprob": -0.37010578487230383, "compression_ratio": 1.5424528301886793, "no_speech_prob": 0.009881925769150257}, {"id": 214, "seek": 155500, "start": 1574.0, "end": 1580.0, "text": " I was a bit confused more about the built-in concept in general,", "tokens": [286, 390, 257, 857, 9019, 544, 466, 264, 3094, 12, 259, 3410, 294, 2674, 11], "temperature": 0.0, "avg_logprob": -0.37010578487230383, "compression_ratio": 1.5424528301886793, "no_speech_prob": 0.009881925769150257}, {"id": 215, "seek": 158000, "start": 1580.0, "end": 1585.0, "text": " because I mean, usually people use C code to not be machine specific,", "tokens": [570, 286, 914, 11, 2673, 561, 764, 383, 3089, 281, 406, 312, 3479, 2685, 11], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 216, "seek": 158000, "start": 1585.0, "end": 1589.0, "text": " but if you use it like a built-in, then you become machine specific, right?", "tokens": [457, 498, 291, 764, 309, 411, 257, 3094, 12, 259, 11, 550, 291, 1813, 3479, 2685, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 217, "seek": 158000, "start": 1589.0, "end": 1590.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 218, "seek": 158000, "start": 1590.0, "end": 1591.0, "text": " Oh, yeah.", "tokens": [876, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 219, "seek": 158000, "start": 1591.0, "end": 1594.0, "text": " It depends on the built-in.", "tokens": [467, 5946, 322, 264, 3094, 12, 259, 13], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 220, "seek": 158000, "start": 1594.0, "end": 1597.0, "text": " GCC has built-ins that are sort of general.", "tokens": [460, 11717, 575, 3094, 12, 1292, 300, 366, 1333, 295, 2674, 13], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 221, "seek": 158000, "start": 1597.0, "end": 1606.0, "text": " I mean, like all the maths functions, for example, like a body of maths, it's not machine specific.", "tokens": [286, 914, 11, 411, 439, 264, 36287, 6828, 11, 337, 1365, 11, 411, 257, 1772, 295, 36287, 11, 309, 311, 406, 3479, 2685, 13], "temperature": 0.0, "avg_logprob": -0.2795527458190918, "compression_ratio": 1.6733668341708543, "no_speech_prob": 0.0007346193888224661}, {"id": 222, "seek": 160600, "start": 1606.0, "end": 1610.0, "text": " And it says, obviously, compiler specific.", "tokens": [400, 309, 1619, 11, 2745, 11, 31958, 2685, 13], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 223, "seek": 160600, "start": 1610.0, "end": 1618.0, "text": " It's not that specific in this case, yeah, but because you can have other kind of other mathematics.", "tokens": [467, 311, 406, 300, 2685, 294, 341, 1389, 11, 1338, 11, 457, 570, 291, 393, 362, 661, 733, 295, 661, 18666, 13], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 224, "seek": 160600, "start": 1618.0, "end": 1619.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 225, "seek": 160600, "start": 1619.0, "end": 1622.0, "text": " Okay, at least architecture specific, right?", "tokens": [1033, 11, 412, 1935, 9482, 2685, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 226, "seek": 160600, "start": 1622.0, "end": 1625.0, "text": " Well, actually it is not architecture specific.", "tokens": [1042, 11, 767, 309, 307, 406, 9482, 2685, 13], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 227, "seek": 160600, "start": 1625.0, "end": 1627.0, "text": " It's a general.", "tokens": [467, 311, 257, 2674, 13], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 228, "seek": 160600, "start": 1627.0, "end": 1632.0, "text": " Yeah, but even for mathematics built-in functions, you always have,", "tokens": [865, 11, 457, 754, 337, 18666, 3094, 12, 259, 6828, 11, 291, 1009, 362, 11], "temperature": 0.0, "avg_logprob": -0.35902562634698276, "compression_ratio": 1.6059113300492611, "no_speech_prob": 0.001637777779251337}, {"id": 229, "seek": 163200, "start": 1632.0, "end": 1637.0, "text": " not always, but mostly, yeah, kind of architecture specific.", "tokens": [406, 1009, 11, 457, 5240, 11, 1338, 11, 733, 295, 9482, 2685, 13], "temperature": 0.0, "avg_logprob": -0.35994318911903783, "compression_ratio": 1.4886363636363635, "no_speech_prob": 0.0012084904592484236}, {"id": 230, "seek": 163200, "start": 1637.0, "end": 1642.0, "text": " Oh, yeah, there can be stuff like encoding of numbers or such like.", "tokens": [876, 11, 1338, 11, 456, 393, 312, 1507, 411, 43430, 295, 3547, 420, 1270, 411, 13], "temperature": 0.0, "avg_logprob": -0.35994318911903783, "compression_ratio": 1.4886363636363635, "no_speech_prob": 0.0012084904592484236}, {"id": 231, "seek": 163200, "start": 1642.0, "end": 1643.0, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.35994318911903783, "compression_ratio": 1.4886363636363635, "no_speech_prob": 0.0012084904592484236}, {"id": 232, "seek": 163200, "start": 1643.0, "end": 1647.0, "text": " It's a sort of, you know, just because.", "tokens": [467, 311, 257, 1333, 295, 11, 291, 458, 11, 445, 570, 13], "temperature": 0.0, "avg_logprob": -0.35994318911903783, "compression_ratio": 1.4886363636363635, "no_speech_prob": 0.0012084904592484236}, {"id": 233, "seek": 163200, "start": 1647.0, "end": 1651.0, "text": " So it should work, yeah.", "tokens": [407, 309, 820, 589, 11, 1338, 13], "temperature": 0.0, "avg_logprob": -0.35994318911903783, "compression_ratio": 1.4886363636363635, "no_speech_prob": 0.0012084904592484236}, {"id": 234, "seek": 163200, "start": 1651.0, "end": 1657.0, "text": " Actually, that's one way to avoid these architecture specific.", "tokens": [5135, 11, 300, 311, 472, 636, 281, 5042, 613, 9482, 2685, 13], "temperature": 0.0, "avg_logprob": -0.35994318911903783, "compression_ratio": 1.4886363636363635, "no_speech_prob": 0.0012084904592484236}, {"id": 235, "seek": 165700, "start": 1657.0, "end": 1665.0, "text": " Like, rather than encoding a non-pattern into your code, just by using a constant or bit pattern", "tokens": [1743, 11, 2831, 813, 43430, 257, 2107, 12, 79, 1161, 77, 666, 428, 3089, 11, 445, 538, 1228, 257, 5754, 420, 857, 5102], "temperature": 0.0, "avg_logprob": -0.25440605948953066, "compression_ratio": 1.5529411764705883, "no_speech_prob": 0.0008254765416495502}, {"id": 236, "seek": 165700, "start": 1665.0, "end": 1673.0, "text": " and then sort of casting to proper floating point type, you can use built-in non.", "tokens": [293, 550, 1333, 295, 17301, 281, 2296, 12607, 935, 2010, 11, 291, 393, 764, 3094, 12, 259, 2107, 13], "temperature": 0.0, "avg_logprob": -0.25440605948953066, "compression_ratio": 1.5529411764705883, "no_speech_prob": 0.0008254765416495502}, {"id": 237, "seek": 167300, "start": 1673.0, "end": 1688.0, "text": " It's a built-in function that produces the correct encoding of a non for your target.", "tokens": [467, 311, 257, 3094, 12, 259, 2445, 300, 14725, 264, 3006, 43430, 295, 257, 2107, 337, 428, 3779, 13], "temperature": 0.0, "avg_logprob": -0.24622457292344835, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.00011328913387842476}, {"id": 238, "seek": 167300, "start": 1688.0, "end": 1690.0, "text": " Okay, thank you for listening to my presentation.", "tokens": [1033, 11, 1309, 291, 337, 4764, 281, 452, 5860, 13], "temperature": 0.0, "avg_logprob": -0.24622457292344835, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.00011328913387842476}, {"id": 239, "seek": 167300, "start": 1690.0, "end": 1692.0, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.24622457292344835, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.00011328913387842476}, {"id": 240, "seek": 167300, "start": 1692.0, "end": 1693.0, "text": " For me.", "tokens": [1171, 385, 13], "temperature": 0.0, "avg_logprob": -0.24622457292344835, "compression_ratio": 1.2727272727272727, "no_speech_prob": 0.00011328913387842476}, {"id": 241, "seek": 169300, "start": 1693.0, "end": 1704.0, "text": " Thank you.", "tokens": [50364, 1044, 291, 13, 50914], "temperature": 0.0, "avg_logprob": -0.5099914868672689, "compression_ratio": 0.5555555555555556, "no_speech_prob": 0.0003154009173158556}], "language": "en"}