{"text": " All right. Let's get started again. So, welcome back, everyone. The next talk is from Dylan about eBPF loader deep dive. Yes. Hello, everyone. Thank you for attending. Before we start, I have to make a quick confession. I'm only 80% done with my talk. No, but really, today I'm going to talk about eBPF loaders and while I'll do my best to go as deep as I can within the time constraints, there is of course so much more to go through. So, let's start with what is a loader for those of you who are not in the know. So, the term can be used in multiple contexts, but for the purpose of this talk, I will refer to a loader as any program that interacts with the kernel via syscalls. Or what you more commonly see is a program that uses eBPF loader library to do most of that work for it. So, examples of loaders are IP and TC, which can be used to load XDP programs or TC programs, for example, but also BPF tool, which can do the same or BPF trace, or even your own app if you decide to use a loader library and make something great. Loader libraries are basically obstructions on the eBPF syscalls and to make it easier to use, kind of like Lipsy, but for BPF, which is where the name for the first example comes from, the BPF. But of course, there are many others like Aya, where we had to talk before this on this day, or BCC, or CELUM, eBPF, for all examples of loader libraries, libraries that load BPF programs into the kernel. So, why do we need loaders? This is an example, this is the program example we're working with today. It's quite simple. So, if we, on the left side, I declare a map, which we will be using to store flow data, so packets and bytes per second, for combination of source address and destination address, and on the right is a bit of logic that checks that we have the correct, that we have enough data interpreted as IPv4. Now, there's a handle IPv4 function mentioned here, but it doesn't fit on a slide, so we'll get to that later. When I compile my program, I get what's called an ELF, an executable and linkable format, or linkable matter, I think about it, whatever. If you, a normal C program, if I were to pull any random Hello World C program from the internet, compile it like I showed in the above command, we'll get out an executable, and you can use it out of the box, no need for trickery or things. You make it executable, and you execute it, and you get Hello World on the command line. If you, if you get an EBPF program, and you try to compile it with commands you found on the internet, you'll get a relocatable. Now, if you try to execute it, you'll get an error, so it doesn't work. What you need is a loader. The executable that we have is like a, is like a premade IKEA furniture, but the relocatable we get for EBPF is two pieces, and perhaps if you're lucky, a guide on how to put them together. And this is the job of the loader, putting the pieces together and making it, and providing the guide to make it easy for you to use it. Now, an ELF as we generated has the following structure. So we have this large file, we start with an ELF header, which contains information like, this contains EBPF, and it's this many bits, this machine, but, and it has a bunch of segments, sorry. These sections have names, have names, and each of them can have a different format. So the string type has a bunch of strings. Our programs have a bunch of program code in them, et cetera, et cetera. But they also refer to each other. So you have all the arrows, and they point to each other, and they link to, they link to each other. But in this form, it's not that usable. Because the kernel only understands SysCalls and EBPF programs, it doesn't know how to handle such an ELF. So how does, but the, the BPF SysCall looks like, it's like this, if you, if you pull up the man page, we have a bunch of commands, each command has a, has attributes, and in the kernel they're defined in a very big union, and every command has its own set of attributes that you can use to, to instruct the kernel, to ask the kernel to do something for you. I can't go on over all of them because of time constraints, but the most important ones are loading your program, creating a map, loading BPF, and of course, interacting with that map, attaching it somewhere, et cetera. There are quite a few commands, each of them does slightly different things, and may, and the loaders, in most cases, provide functions that either call multiple of these to do a batch, like a big operation, a high-level operation, or they provide small wrappers for you to do your low-level operations yourself. There are also links, which is a newer concept, and you can pin, pin your objects to the file system, so they live longer than your program. And we have a few other miscellaneous functions for doing measurement statistics, iteration, et cetera, but I can't go in that, in this talk, unfortunately. So back to our program. When we write a program, we have a macro here that says SAC. We, that's quite unique for BPF. Every BPF program needs to have this section tag there, and this tells the compiler to put all of the program code in the specific section that we named. And the name of this section is for also convention, which can be used by the loader to inform it that this is an XDP program, so it should be interpreted as such. Now we can dump this section, so if we dump this section with LLVM object dump, then we get out this, which is hard to read if it's not annotated, but it's a bunch of BPF instructions starting with the opcode, so the actual opcode that tells it if it's add, subtract, whatever. Source and destination registers where these opcodes act on with offsets for jumps. These are relative, and intermediate data for, to say, load some data into a register like a constant value. And sometimes we can use two of them together to represent a 64-bit number, but we'll get to that later. We can also ask object dump to decompile this for us, and we'll get the decompiled BPF program. So the bytes on the left side and the actual program on the right side, but you'll notice that there's a call here. So one thing that I didn't tell you before is that the handle IPv4 function that we have is marked in such a way that it won't be inline, so it's a separate program, and BPF can do BPF to BPF function calls, and if you do that, it puts out this instruction, a function call instruction, but with minus zero. Where do we call to? Well, currently nowhere, because we haven't assembled the pieces of our furniture yet. So what actually, what also happens is that the compiler will emit relocation information, which we can, again, visualize, and it says, all right, we have a certain instruction that is given offset, and you should put it in relative address of this other function in here. Then we can go to the symbol table and we can look up this name, and it says, oh, that function lives in the.txt section, where for BPF programs, all of the function to function calls, all of the functions live together. So we have these two separate pieces of the puzzle, and they refer to each other. But the kernel only has one pointer for our instructions. It expects that every program we give it is one contiguous piece of memory with instructions, and it all should work. So we have some work to do. We need to figure out, or the loader rather, needs to figure out how it wants to lay out our programs, so piece all of the puzzles together, find all of these references, and then put in the correct offset. All of this happens in user space before we even go to the kernel. Now, second fun thing is that we can define our map. So again, we have the sec part,.maps, put it in the.maps section, and if we, and this is the function, this is the part that I have been hiding from you until now. It's also quite simple in terms of BPF programs. We get an IPv4 header, check that we can use it, and we write, or we get a value from the map, and if it doesn't exist, we write a new one and increment the values every time this happens to account for some information. So keep this program in mind, and then if we go look at the instructions again, the disassembled version this time, we see that we have two of these long lines which are zero at the end. So these are the 64-bit intermediate values that I was talking about, and they are just long to keep, to pre-allocate room for actual memory addresses later, instead of relative jumps. But they are zero, and these should be references to our map, and later on these will become pointers when the kernel gets its way with it. And in our case, we again need to figure out what to put in here. So same routine. We have relocation information. The relocation information points to the instructions that we had. It says you need to plug in a flow map here. We go to the symbol table, and there it says we have a.map section, and there lives a flow map. In this case, we handle it slightly differently, so we then have to go load this flow map first, get a file descriptor, which is our unique identifier for the map, and we need to actually put in that file descriptor into these empty values, so the kernel knows where to go. Mapping maps also is also a command, so we have the map create command, and it takes these arguments. I cut out a bit of the later ones, but these are the essential type, how big are my values, et cetera. Give it a nice name. And there are two ways to define these. We have the new way of doing it, which are called BTF maps, colloquially, on the left. But there's also the old way of doing it, using a BTF map definition on the right. Don't use it if you go into libbpf in the part of the libbpf, which is used during ebpf construction. It will warn you that you shouldn't use it and go for the left side. But the odd thing is that if you use these newer BTF maps on the left, and you go look at what's actually then written to your.map section, it's all zero. There's no information. It still keeps, it still allocates room for your map, but it will, but they'll all be zero, and there's no information. All information, instead, is in the type information of the flow map. So we have to get in what is BTF. BTF stands for BPF type format. It's derived from the actual dwarf debug symbols that already are used for normal C programs. But as a way compact or smaller version of it, which only really is concerned about type information and not about where and at which moment a variable lives. And these are used because ebpf itself is just too limiting, and we want to do more, especially in the verifier. So we have, for example, features like spinlocks, which should only be used on maps that have spinlock values in them. Or we have callback functions, so we can define these BPF functions, but instead give them to a helper function. But this helper needs to then know that it's the correct number of arguments and the correct type. So all of this type information we can give to the kernel. And that's why it's, especially if you want to use these new fancy features, it's important to use the BTF information. It also allows for flexible map arguments. So for example, if I go back, we have the definition. And one of the things you'll notice is that we have pinning as an attribute here. But you will not find it in the Cisco attributes. This is purely something that we communicate to the loader library in this case, that we communicate to the loader library, not just libbpf, but that's the name that it has currently. And we can do a lot of different cool things with that. It also provides debug information for us. So if we go look at loader programs, it will be annotated with the line information and from rich file we can read. And perhaps one of the coolest features is compile once run everywhere, which allows the loader and or the kernel to modify our program slightly. So it will run on multiple versions of the kernel, even if the internals have changed. So if we dump this BTF that we have from our example program, it looks like this. Features to note are the numbers on the left and square brackets. Those are the type ID. Besides it's actual type. So we have pointers, integers, arrays. You can basically represent every C type in BTF this way. There's an optional name and then there's a lot of information about the specific type. And they refer to each other. So you'll notice a lot of type ID is something else. So you can also visualize it by nesting it. I've done this manually. By the way, there's no comment on this, but this is how you can do it yourself. So we have, for example, a map section with a flow map in it. And you can see that we have the type, the key, the value. And we have this very detailed description of exactly how it structured at which offsets, which things live and names for it which are used to check all of these certain things. And also to create a loader bill, we use this to infer the actual value and key sizes to give to the kernel. This BTF is structured in, so it lives in the dot BTF section. And it's sort of structured like this. So we have this header, then types and a lot of strings. And each type starts with the same three fields. So we have a name offset, so an offset into the strings. We have information and a size or type depending on what the information says. This translates into the name and the type of the BTF information and then the last part is specific to that type. So encoding for ins or a list of fields for a structure, et cetera. We also have the dot BTF.ext, the extended version of it. And this contains function information, line information, and optionally core relocations. So the line information contains a bunch of lines. So it will annotate this instruction as part of this line of your original source program and functions to label every one of these BTF functions that you have defined. Loading the BTF itself is quite simple. You use the load BTF command in the BTF syscall or the BTF syscall, give it the blob that we have. It needs to be slightly changed, especially for the data size, the data section type, but that's more details to explain exactly why, and a bunch of logging information. Once you have it, we get a file descriptor of the BTF object, and of course we have all of these type IDs. So when we are loading our map again, there are these fields where you can say, this is my BTF object, which contains all of my types, and this is the type of my key, this is the type of my value, that's how we wire everything together. The same goes for programs. So we give it the program, the BTF of the program uses, and then we give it these file, these func information, line information blobs, which will make sure that everything is nice and annotated in the kernel. So we end up with a sort of hierarchy that looks like this. So we start by loading the BTF, we can then load our maps, which use it, and then once we have our map file descriptors, we can load our programs after we have of course assembled all of the pieces of our program. And that all happens, can happen within one call to a loader library. Now for the last part, the core, which I touched on a little bit earlier, like I said, compile once, run everywhere. There's this really good blog post for, which I encourage everyone who wants to use the feature, which contains information on how to actually use it. But what it boils down to is there are in LibBPF, there are these macros to make your life easier, and they boil down to a bunch of compiler built-ins. And they're basically, they're basically questions to ask the loader just before, or the kernel just before, or while loading the program. Like, where does, where is, what is the offset of this field? Where does this type even exist? Do I have this enum value? I have this small program that writes, that writes values to, or that captures a certain, or the cookie value of a socket when it closes. Not useful at all, but it does help us to illustrate the point. When this macro resolves, it looks like this, and the important part to notice here is that we do a helper call, and where the arrow starts, we have the socket pointer, and we have an offset, and we add an offset, which we get from this built-in function. This offset is then encoded, gets encoded in the 104 that we see here. This is this offset that we add to the pointer in the actual code. But the compiler will also emit this relocation, which will tell us that this might be a piece of the code that we want to tweak, depending on if the structure changes. So if we again look at this relocation, there, unfortunately, as far as I'm aware, is not a good command line tool to visualize or to decode this, so I decoded one manually. It looks like this, so it says, okay, instruction number two, which is the instruction that we were, that we were at. Instruction number two refers to type ID 18, and it has this accessor string. And this accessor string is a bunch of numbers, which is basically offsets like the field number that it tries to access. So the socket, then the second field would be sk-common, and then cookie, and so forth. Now, this type information that we knew when we created the program is included in the btf section. But the kernel also has btf types for all of its types it has. So we can do a comparison and see that, for example, it changed position, or we can't find a certain field. And our loader can do this, can resolve this, see it, and then patch our code, change this offset value right before we actually load it, which makes it possible to use it on so many different kernel versions. I'm out of time. That's everything I can offer you for now. Are there any questions? And thank you. Thank you. Any questions? There's one in the back. All right, okay. It's difficult now. Can you pass this on? Hey, thanks for the great talk. So I haven't dealt that much with btf, but since we have those binaries that we cannot really launch because we have to load them in another elf, right? At least as I understand. Would it make any sense to make either a loader that would just work out of the box for those binaries or use the bnfmtm-misk feature from the kernel to be able to load those btf elf files and use some kind of generic or general interface and just load them and run them? Yeah, but I think it does make sense to some extent. For example, the IP tool doesn't have anything additional, so it takes this elf and just loads it as best as it can. And there is probably some way to use the interpreter in the elf itself, just like we do for dynamically loaded executables. As far as I know, no one has tried it so far, but I think it could work at least for a limited use case where you don't have to, where you would only load something and pin it and then allow some other application to actually work with it afterwards. Thank you. All right, thanks. We are out of time. If you have more questions, you can find Dylan in the hallway. And yeah, thanks again.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 17.32, "text": " All right. Let's get started again. So, welcome back, everyone. The next talk is from Dylan", "tokens": [1057, 558, 13, 961, 311, 483, 1409, 797, 13, 407, 11, 2928, 646, 11, 1518, 13, 440, 958, 751, 307, 490, 28160], "temperature": 0.0, "avg_logprob": -0.308253666711232, "compression_ratio": 1.319277108433735, "no_speech_prob": 0.4429376423358917}, {"id": 1, "seek": 0, "start": 17.32, "end": 20.2, "text": " about eBPF loader deep dive.", "tokens": [466, 308, 33, 47, 37, 3677, 260, 2452, 9192, 13], "temperature": 0.0, "avg_logprob": -0.308253666711232, "compression_ratio": 1.319277108433735, "no_speech_prob": 0.4429376423358917}, {"id": 2, "seek": 0, "start": 20.2, "end": 28.400000000000002, "text": " Yes. Hello, everyone. Thank you for attending. Before we start, I have to make a quick confession.", "tokens": [1079, 13, 2425, 11, 1518, 13, 1044, 291, 337, 15862, 13, 4546, 321, 722, 11, 286, 362, 281, 652, 257, 1702, 29154, 13], "temperature": 0.0, "avg_logprob": -0.308253666711232, "compression_ratio": 1.319277108433735, "no_speech_prob": 0.4429376423358917}, {"id": 3, "seek": 2840, "start": 28.4, "end": 39.92, "text": " I'm only 80% done with my talk. No, but really, today I'm going to talk about eBPF loaders", "tokens": [286, 478, 787, 4688, 4, 1096, 365, 452, 751, 13, 883, 11, 457, 534, 11, 965, 286, 478, 516, 281, 751, 466, 308, 33, 47, 37, 3677, 433], "temperature": 0.0, "avg_logprob": -0.1632552086552487, "compression_ratio": 1.4064171122994653, "no_speech_prob": 0.0010273783700540662}, {"id": 4, "seek": 2840, "start": 39.92, "end": 44.879999999999995, "text": " and while I'll do my best to go as deep as I can within the time constraints, there is", "tokens": [293, 1339, 286, 603, 360, 452, 1151, 281, 352, 382, 2452, 382, 286, 393, 1951, 264, 565, 18491, 11, 456, 307], "temperature": 0.0, "avg_logprob": -0.1632552086552487, "compression_ratio": 1.4064171122994653, "no_speech_prob": 0.0010273783700540662}, {"id": 5, "seek": 2840, "start": 44.879999999999995, "end": 54.4, "text": " of course so much more to go through. So, let's start with what is a loader for those", "tokens": [295, 1164, 370, 709, 544, 281, 352, 807, 13, 407, 11, 718, 311, 722, 365, 437, 307, 257, 3677, 260, 337, 729], "temperature": 0.0, "avg_logprob": -0.1632552086552487, "compression_ratio": 1.4064171122994653, "no_speech_prob": 0.0010273783700540662}, {"id": 6, "seek": 5440, "start": 54.4, "end": 63.96, "text": " of you who are not in the know. So, the term can be used in multiple contexts, but for", "tokens": [295, 291, 567, 366, 406, 294, 264, 458, 13, 407, 11, 264, 1433, 393, 312, 1143, 294, 3866, 30628, 11, 457, 337], "temperature": 0.0, "avg_logprob": -0.2024740270666174, "compression_ratio": 1.4555555555555555, "no_speech_prob": 0.00027274523745290935}, {"id": 7, "seek": 5440, "start": 63.96, "end": 69.28, "text": " the purpose of this talk, I will refer to a loader as any program that interacts with", "tokens": [264, 4334, 295, 341, 751, 11, 286, 486, 2864, 281, 257, 3677, 260, 382, 604, 1461, 300, 43582, 365], "temperature": 0.0, "avg_logprob": -0.2024740270666174, "compression_ratio": 1.4555555555555555, "no_speech_prob": 0.00027274523745290935}, {"id": 8, "seek": 5440, "start": 69.28, "end": 78.6, "text": " the kernel via syscalls. Or what you more commonly see is a program that uses eBPF loader", "tokens": [264, 28256, 5766, 262, 749, 66, 39655, 13, 1610, 437, 291, 544, 12719, 536, 307, 257, 1461, 300, 4960, 308, 33, 47, 37, 3677, 260], "temperature": 0.0, "avg_logprob": -0.2024740270666174, "compression_ratio": 1.4555555555555555, "no_speech_prob": 0.00027274523745290935}, {"id": 9, "seek": 7860, "start": 78.6, "end": 86.75999999999999, "text": " library to do most of that work for it. So, examples of loaders are IP and TC, which can", "tokens": [6405, 281, 360, 881, 295, 300, 589, 337, 309, 13, 407, 11, 5110, 295, 3677, 433, 366, 8671, 293, 34150, 11, 597, 393], "temperature": 0.0, "avg_logprob": -0.16144699096679688, "compression_ratio": 1.5028901734104045, "no_speech_prob": 9.516817226540297e-05}, {"id": 10, "seek": 7860, "start": 86.75999999999999, "end": 92.47999999999999, "text": " be used to load XDP programs or TC programs, for example, but also BPF tool, which can", "tokens": [312, 1143, 281, 3677, 1783, 11373, 4268, 420, 34150, 4268, 11, 337, 1365, 11, 457, 611, 40533, 37, 2290, 11, 597, 393], "temperature": 0.0, "avg_logprob": -0.16144699096679688, "compression_ratio": 1.5028901734104045, "no_speech_prob": 9.516817226540297e-05}, {"id": 11, "seek": 7860, "start": 92.47999999999999, "end": 100.56, "text": " do the same or BPF trace, or even your own app if you decide to use a loader library", "tokens": [360, 264, 912, 420, 40533, 37, 13508, 11, 420, 754, 428, 1065, 724, 498, 291, 4536, 281, 764, 257, 3677, 260, 6405], "temperature": 0.0, "avg_logprob": -0.16144699096679688, "compression_ratio": 1.5028901734104045, "no_speech_prob": 9.516817226540297e-05}, {"id": 12, "seek": 10056, "start": 100.56, "end": 110.84, "text": " and make something great. Loader libraries are basically obstructions on the eBPF syscalls", "tokens": [293, 652, 746, 869, 13, 48408, 260, 15148, 366, 1936, 45579, 626, 322, 264, 308, 33, 47, 37, 262, 749, 66, 39655], "temperature": 0.0, "avg_logprob": -0.19699609120686848, "compression_ratio": 1.4802259887005649, "no_speech_prob": 0.00010863806528504938}, {"id": 13, "seek": 10056, "start": 110.84, "end": 119.6, "text": " and to make it easier to use, kind of like Lipsy, but for BPF, which is where the name", "tokens": [293, 281, 652, 309, 3571, 281, 764, 11, 733, 295, 411, 441, 2600, 88, 11, 457, 337, 40533, 37, 11, 597, 307, 689, 264, 1315], "temperature": 0.0, "avg_logprob": -0.19699609120686848, "compression_ratio": 1.4802259887005649, "no_speech_prob": 0.00010863806528504938}, {"id": 14, "seek": 10056, "start": 119.6, "end": 125.0, "text": " for the first example comes from, the BPF. But of course, there are many others like", "tokens": [337, 264, 700, 1365, 1487, 490, 11, 264, 40533, 37, 13, 583, 295, 1164, 11, 456, 366, 867, 2357, 411], "temperature": 0.0, "avg_logprob": -0.19699609120686848, "compression_ratio": 1.4802259887005649, "no_speech_prob": 0.00010863806528504938}, {"id": 15, "seek": 12500, "start": 125.0, "end": 131.96, "text": " Aya, where we had to talk before this on this day, or BCC, or CELUM, eBPF, for all examples", "tokens": [316, 3016, 11, 689, 321, 632, 281, 751, 949, 341, 322, 341, 786, 11, 420, 363, 11717, 11, 420, 383, 3158, 14340, 11, 308, 33, 47, 37, 11, 337, 439, 5110], "temperature": 0.0, "avg_logprob": -0.28804416421019, "compression_ratio": 1.4944444444444445, "no_speech_prob": 0.00013001660408917814}, {"id": 16, "seek": 12500, "start": 131.96, "end": 142.8, "text": " of loader libraries, libraries that load BPF programs into the kernel. So, why do we need", "tokens": [295, 3677, 260, 15148, 11, 15148, 300, 3677, 40533, 37, 4268, 666, 264, 28256, 13, 407, 11, 983, 360, 321, 643], "temperature": 0.0, "avg_logprob": -0.28804416421019, "compression_ratio": 1.4944444444444445, "no_speech_prob": 0.00013001660408917814}, {"id": 17, "seek": 12500, "start": 142.8, "end": 152.32, "text": " loaders? This is an example, this is the program example we're working with today. It's", "tokens": [3677, 433, 30, 639, 307, 364, 1365, 11, 341, 307, 264, 1461, 1365, 321, 434, 1364, 365, 965, 13, 467, 311], "temperature": 0.0, "avg_logprob": -0.28804416421019, "compression_ratio": 1.4944444444444445, "no_speech_prob": 0.00013001660408917814}, {"id": 18, "seek": 15232, "start": 152.32, "end": 158.95999999999998, "text": " quite simple. So, if we, on the left side, I declare a map, which we will be using to", "tokens": [1596, 2199, 13, 407, 11, 498, 321, 11, 322, 264, 1411, 1252, 11, 286, 19710, 257, 4471, 11, 597, 321, 486, 312, 1228, 281], "temperature": 0.0, "avg_logprob": -0.20558377970819888, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.0001551627938169986}, {"id": 19, "seek": 15232, "start": 158.95999999999998, "end": 166.07999999999998, "text": " store flow data, so packets and bytes per second, for combination of source address", "tokens": [3531, 3095, 1412, 11, 370, 30364, 293, 36088, 680, 1150, 11, 337, 6562, 295, 4009, 2985], "temperature": 0.0, "avg_logprob": -0.20558377970819888, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.0001551627938169986}, {"id": 20, "seek": 15232, "start": 166.07999999999998, "end": 172.76, "text": " and destination address, and on the right is a bit of logic that checks that we have", "tokens": [293, 12236, 2985, 11, 293, 322, 264, 558, 307, 257, 857, 295, 9952, 300, 13834, 300, 321, 362], "temperature": 0.0, "avg_logprob": -0.20558377970819888, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.0001551627938169986}, {"id": 21, "seek": 15232, "start": 172.76, "end": 181.28, "text": " the correct, that we have enough data interpreted as IPv4. Now, there's a handle IPv4 function", "tokens": [264, 3006, 11, 300, 321, 362, 1547, 1412, 26749, 382, 8671, 85, 19, 13, 823, 11, 456, 311, 257, 4813, 8671, 85, 19, 2445], "temperature": 0.0, "avg_logprob": -0.20558377970819888, "compression_ratio": 1.579185520361991, "no_speech_prob": 0.0001551627938169986}, {"id": 22, "seek": 18128, "start": 181.28, "end": 186.72, "text": " mentioned here, but it doesn't fit on a slide, so we'll get to that later. When I compile", "tokens": [2835, 510, 11, 457, 309, 1177, 380, 3318, 322, 257, 4137, 11, 370, 321, 603, 483, 281, 300, 1780, 13, 1133, 286, 31413], "temperature": 0.0, "avg_logprob": -0.1809096822933275, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.00015839464322198182}, {"id": 23, "seek": 18128, "start": 186.72, "end": 197.0, "text": " my program, I get what's called an ELF, an executable and linkable format, or linkable", "tokens": [452, 1461, 11, 286, 483, 437, 311, 1219, 364, 14426, 37, 11, 364, 7568, 712, 293, 2113, 712, 7877, 11, 420, 2113, 712], "temperature": 0.0, "avg_logprob": -0.1809096822933275, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.00015839464322198182}, {"id": 24, "seek": 18128, "start": 197.0, "end": 203.96, "text": " matter, I think about it, whatever. If you, a normal C program, if I were to pull any", "tokens": [1871, 11, 286, 519, 466, 309, 11, 2035, 13, 759, 291, 11, 257, 2710, 383, 1461, 11, 498, 286, 645, 281, 2235, 604], "temperature": 0.0, "avg_logprob": -0.1809096822933275, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.00015839464322198182}, {"id": 25, "seek": 18128, "start": 203.96, "end": 210.36, "text": " random Hello World C program from the internet, compile it like I showed in the above command,", "tokens": [4974, 2425, 3937, 383, 1461, 490, 264, 4705, 11, 31413, 309, 411, 286, 4712, 294, 264, 3673, 5622, 11], "temperature": 0.0, "avg_logprob": -0.1809096822933275, "compression_ratio": 1.5866666666666667, "no_speech_prob": 0.00015839464322198182}, {"id": 26, "seek": 21036, "start": 210.36, "end": 216.36, "text": " we'll get out an executable, and you can use it out of the box, no need for trickery or", "tokens": [321, 603, 483, 484, 364, 7568, 712, 11, 293, 291, 393, 764, 309, 484, 295, 264, 2424, 11, 572, 643, 337, 4282, 2109, 420], "temperature": 0.0, "avg_logprob": -0.1661082436056698, "compression_ratio": 1.7839195979899498, "no_speech_prob": 0.00010090763680636883}, {"id": 27, "seek": 21036, "start": 216.36, "end": 221.88000000000002, "text": " things. You make it executable, and you execute it, and you get Hello World on the command", "tokens": [721, 13, 509, 652, 309, 7568, 712, 11, 293, 291, 14483, 309, 11, 293, 291, 483, 2425, 3937, 322, 264, 5622], "temperature": 0.0, "avg_logprob": -0.1661082436056698, "compression_ratio": 1.7839195979899498, "no_speech_prob": 0.00010090763680636883}, {"id": 28, "seek": 21036, "start": 221.88000000000002, "end": 230.04000000000002, "text": " line. If you, if you get an EBPF program, and you try to compile it with commands you", "tokens": [1622, 13, 759, 291, 11, 498, 291, 483, 364, 50148, 47, 37, 1461, 11, 293, 291, 853, 281, 31413, 309, 365, 16901, 291], "temperature": 0.0, "avg_logprob": -0.1661082436056698, "compression_ratio": 1.7839195979899498, "no_speech_prob": 0.00010090763680636883}, {"id": 29, "seek": 21036, "start": 230.04000000000002, "end": 235.56, "text": " found on the internet, you'll get a relocatable. Now, if you try to execute it, you'll get", "tokens": [1352, 322, 264, 4705, 11, 291, 603, 483, 257, 26981, 31415, 13, 823, 11, 498, 291, 853, 281, 14483, 309, 11, 291, 603, 483], "temperature": 0.0, "avg_logprob": -0.1661082436056698, "compression_ratio": 1.7839195979899498, "no_speech_prob": 0.00010090763680636883}, {"id": 30, "seek": 23556, "start": 235.56, "end": 244.2, "text": " an error, so it doesn't work. What you need is a loader. The executable that we have is", "tokens": [364, 6713, 11, 370, 309, 1177, 380, 589, 13, 708, 291, 643, 307, 257, 3677, 260, 13, 440, 7568, 712, 300, 321, 362, 307], "temperature": 0.0, "avg_logprob": -0.1491904356041733, "compression_ratio": 1.5739910313901346, "no_speech_prob": 6.172965368023142e-05}, {"id": 31, "seek": 23556, "start": 244.2, "end": 251.44, "text": " like a, is like a premade IKEA furniture, but the relocatable we get for EBPF is two", "tokens": [411, 257, 11, 307, 411, 257, 5624, 762, 47728, 15671, 11, 457, 264, 26981, 31415, 321, 483, 337, 50148, 47, 37, 307, 732], "temperature": 0.0, "avg_logprob": -0.1491904356041733, "compression_ratio": 1.5739910313901346, "no_speech_prob": 6.172965368023142e-05}, {"id": 32, "seek": 23556, "start": 251.44, "end": 257.32, "text": " pieces, and perhaps if you're lucky, a guide on how to put them together. And this is the", "tokens": [3755, 11, 293, 4317, 498, 291, 434, 6356, 11, 257, 5934, 322, 577, 281, 829, 552, 1214, 13, 400, 341, 307, 264], "temperature": 0.0, "avg_logprob": -0.1491904356041733, "compression_ratio": 1.5739910313901346, "no_speech_prob": 6.172965368023142e-05}, {"id": 33, "seek": 23556, "start": 257.32, "end": 263.72, "text": " job of the loader, putting the pieces together and making it, and providing the guide to", "tokens": [1691, 295, 264, 3677, 260, 11, 3372, 264, 3755, 1214, 293, 1455, 309, 11, 293, 6530, 264, 5934, 281], "temperature": 0.0, "avg_logprob": -0.1491904356041733, "compression_ratio": 1.5739910313901346, "no_speech_prob": 6.172965368023142e-05}, {"id": 34, "seek": 26372, "start": 263.72, "end": 274.08000000000004, "text": " make it easy for you to use it. Now, an ELF as we generated has the following structure.", "tokens": [652, 309, 1858, 337, 291, 281, 764, 309, 13, 823, 11, 364, 14426, 37, 382, 321, 10833, 575, 264, 3480, 3877, 13], "temperature": 0.0, "avg_logprob": -0.23432109230443052, "compression_ratio": 1.4972677595628416, "no_speech_prob": 0.00011901035759365186}, {"id": 35, "seek": 26372, "start": 274.08000000000004, "end": 278.92, "text": " So we have this large file, we start with an ELF header, which contains information like,", "tokens": [407, 321, 362, 341, 2416, 3991, 11, 321, 722, 365, 364, 14426, 37, 23117, 11, 597, 8306, 1589, 411, 11], "temperature": 0.0, "avg_logprob": -0.23432109230443052, "compression_ratio": 1.4972677595628416, "no_speech_prob": 0.00011901035759365186}, {"id": 36, "seek": 26372, "start": 278.92, "end": 288.12, "text": " this contains EBPF, and it's this many bits, this machine, but, and it has a bunch of segments,", "tokens": [341, 8306, 50148, 47, 37, 11, 293, 309, 311, 341, 867, 9239, 11, 341, 3479, 11, 457, 11, 293, 309, 575, 257, 3840, 295, 19904, 11], "temperature": 0.0, "avg_logprob": -0.23432109230443052, "compression_ratio": 1.4972677595628416, "no_speech_prob": 0.00011901035759365186}, {"id": 37, "seek": 28812, "start": 288.12, "end": 298.16, "text": " sorry. These sections have names, have names, and each of them can have a different format.", "tokens": [2597, 13, 1981, 10863, 362, 5288, 11, 362, 5288, 11, 293, 1184, 295, 552, 393, 362, 257, 819, 7877, 13], "temperature": 0.0, "avg_logprob": -0.1678011213030134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00010536296758800745}, {"id": 38, "seek": 28812, "start": 298.16, "end": 303.32, "text": " So the string type has a bunch of strings. Our programs have a bunch of program code", "tokens": [407, 264, 6798, 2010, 575, 257, 3840, 295, 13985, 13, 2621, 4268, 362, 257, 3840, 295, 1461, 3089], "temperature": 0.0, "avg_logprob": -0.1678011213030134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00010536296758800745}, {"id": 39, "seek": 28812, "start": 303.32, "end": 310.68, "text": " in them, et cetera, et cetera. But they also refer to each other. So you have all the arrows,", "tokens": [294, 552, 11, 1030, 11458, 11, 1030, 11458, 13, 583, 436, 611, 2864, 281, 1184, 661, 13, 407, 291, 362, 439, 264, 19669, 11], "temperature": 0.0, "avg_logprob": -0.1678011213030134, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00010536296758800745}, {"id": 40, "seek": 31068, "start": 310.68, "end": 318.0, "text": " and they point to each other, and they link to, they link to each other. But in this form,", "tokens": [293, 436, 935, 281, 1184, 661, 11, 293, 436, 2113, 281, 11, 436, 2113, 281, 1184, 661, 13, 583, 294, 341, 1254, 11], "temperature": 0.0, "avg_logprob": -0.21040083327383366, "compression_ratio": 1.610091743119266, "no_speech_prob": 6.228070560609922e-05}, {"id": 41, "seek": 31068, "start": 318.0, "end": 327.36, "text": " it's not that usable. Because the kernel only understands SysCalls and EBPF programs, it", "tokens": [309, 311, 406, 300, 29975, 13, 1436, 264, 28256, 787, 15146, 318, 749, 34, 39655, 293, 50148, 47, 37, 4268, 11, 309], "temperature": 0.0, "avg_logprob": -0.21040083327383366, "compression_ratio": 1.610091743119266, "no_speech_prob": 6.228070560609922e-05}, {"id": 42, "seek": 31068, "start": 327.36, "end": 333.68, "text": " doesn't know how to handle such an ELF. So how does, but the, the BPF SysCall looks", "tokens": [1177, 380, 458, 577, 281, 4813, 1270, 364, 14426, 37, 13, 407, 577, 775, 11, 457, 264, 11, 264, 40533, 37, 318, 749, 34, 336, 1542], "temperature": 0.0, "avg_logprob": -0.21040083327383366, "compression_ratio": 1.610091743119266, "no_speech_prob": 6.228070560609922e-05}, {"id": 43, "seek": 31068, "start": 333.68, "end": 338.64, "text": " like, it's like this, if you, if you pull up the man page, we have a bunch of commands,", "tokens": [411, 11, 309, 311, 411, 341, 11, 498, 291, 11, 498, 291, 2235, 493, 264, 587, 3028, 11, 321, 362, 257, 3840, 295, 16901, 11], "temperature": 0.0, "avg_logprob": -0.21040083327383366, "compression_ratio": 1.610091743119266, "no_speech_prob": 6.228070560609922e-05}, {"id": 44, "seek": 33864, "start": 338.64, "end": 345.28, "text": " each command has a, has attributes, and in the kernel they're defined in a very big union,", "tokens": [1184, 5622, 575, 257, 11, 575, 17212, 11, 293, 294, 264, 28256, 436, 434, 7642, 294, 257, 588, 955, 11671, 11], "temperature": 0.0, "avg_logprob": -0.14849384410961255, "compression_ratio": 1.7490196078431373, "no_speech_prob": 6.153607682790607e-05}, {"id": 45, "seek": 33864, "start": 345.28, "end": 351.68, "text": " and every command has its own set of attributes that you can use to, to instruct the kernel,", "tokens": [293, 633, 5622, 575, 1080, 1065, 992, 295, 17212, 300, 291, 393, 764, 281, 11, 281, 7232, 264, 28256, 11], "temperature": 0.0, "avg_logprob": -0.14849384410961255, "compression_ratio": 1.7490196078431373, "no_speech_prob": 6.153607682790607e-05}, {"id": 46, "seek": 33864, "start": 351.68, "end": 357.0, "text": " to ask the kernel to do something for you. I can't go on over all of them because of", "tokens": [281, 1029, 264, 28256, 281, 360, 746, 337, 291, 13, 286, 393, 380, 352, 322, 670, 439, 295, 552, 570, 295], "temperature": 0.0, "avg_logprob": -0.14849384410961255, "compression_ratio": 1.7490196078431373, "no_speech_prob": 6.153607682790607e-05}, {"id": 47, "seek": 33864, "start": 357.0, "end": 361.84, "text": " time constraints, but the most important ones are loading your program, creating a map,", "tokens": [565, 18491, 11, 457, 264, 881, 1021, 2306, 366, 15114, 428, 1461, 11, 4084, 257, 4471, 11], "temperature": 0.0, "avg_logprob": -0.14849384410961255, "compression_ratio": 1.7490196078431373, "no_speech_prob": 6.153607682790607e-05}, {"id": 48, "seek": 33864, "start": 361.84, "end": 368.36, "text": " loading BPF, and of course, interacting with that map, attaching it somewhere, et cetera.", "tokens": [15114, 40533, 37, 11, 293, 295, 1164, 11, 18017, 365, 300, 4471, 11, 39074, 309, 4079, 11, 1030, 11458, 13], "temperature": 0.0, "avg_logprob": -0.14849384410961255, "compression_ratio": 1.7490196078431373, "no_speech_prob": 6.153607682790607e-05}, {"id": 49, "seek": 36836, "start": 368.36, "end": 374.92, "text": " There are quite a few commands, each of them does slightly different things, and may, and", "tokens": [821, 366, 1596, 257, 1326, 16901, 11, 1184, 295, 552, 775, 4748, 819, 721, 11, 293, 815, 11, 293], "temperature": 0.0, "avg_logprob": -0.16670711388748682, "compression_ratio": 1.6589861751152073, "no_speech_prob": 3.974522405769676e-05}, {"id": 50, "seek": 36836, "start": 374.92, "end": 381.6, "text": " the loaders, in most cases, provide functions that either call multiple of these to do a", "tokens": [264, 3677, 433, 11, 294, 881, 3331, 11, 2893, 6828, 300, 2139, 818, 3866, 295, 613, 281, 360, 257], "temperature": 0.0, "avg_logprob": -0.16670711388748682, "compression_ratio": 1.6589861751152073, "no_speech_prob": 3.974522405769676e-05}, {"id": 51, "seek": 36836, "start": 381.6, "end": 386.2, "text": " batch, like a big operation, a high-level operation, or they provide small wrappers for", "tokens": [15245, 11, 411, 257, 955, 6916, 11, 257, 1090, 12, 12418, 6916, 11, 420, 436, 2893, 1359, 7843, 15226, 337], "temperature": 0.0, "avg_logprob": -0.16670711388748682, "compression_ratio": 1.6589861751152073, "no_speech_prob": 3.974522405769676e-05}, {"id": 52, "seek": 36836, "start": 386.2, "end": 393.64, "text": " you to do your low-level operations yourself. There are also links, which is a newer concept,", "tokens": [291, 281, 360, 428, 2295, 12, 12418, 7705, 1803, 13, 821, 366, 611, 6123, 11, 597, 307, 257, 17628, 3410, 11], "temperature": 0.0, "avg_logprob": -0.16670711388748682, "compression_ratio": 1.6589861751152073, "no_speech_prob": 3.974522405769676e-05}, {"id": 53, "seek": 39364, "start": 393.64, "end": 400.08, "text": " and you can pin, pin your objects to the file system, so they live longer than your program.", "tokens": [293, 291, 393, 5447, 11, 5447, 428, 6565, 281, 264, 3991, 1185, 11, 370, 436, 1621, 2854, 813, 428, 1461, 13], "temperature": 0.0, "avg_logprob": -0.20105506561614656, "compression_ratio": 1.5753424657534247, "no_speech_prob": 3.845608443953097e-05}, {"id": 54, "seek": 39364, "start": 400.08, "end": 405.91999999999996, "text": " And we have a few other miscellaneous functions for doing measurement statistics, iteration,", "tokens": [400, 321, 362, 257, 1326, 661, 3346, 4164, 15447, 6828, 337, 884, 13160, 12523, 11, 24784, 11], "temperature": 0.0, "avg_logprob": -0.20105506561614656, "compression_ratio": 1.5753424657534247, "no_speech_prob": 3.845608443953097e-05}, {"id": 55, "seek": 39364, "start": 405.91999999999996, "end": 411.0, "text": " et cetera, but I can't go in that, in this talk, unfortunately.", "tokens": [1030, 11458, 11, 457, 286, 393, 380, 352, 294, 300, 11, 294, 341, 751, 11, 7015, 13], "temperature": 0.0, "avg_logprob": -0.20105506561614656, "compression_ratio": 1.5753424657534247, "no_speech_prob": 3.845608443953097e-05}, {"id": 56, "seek": 39364, "start": 411.0, "end": 419.76, "text": " So back to our program. When we write a program, we have a macro here that says SAC. We, that's", "tokens": [407, 646, 281, 527, 1461, 13, 1133, 321, 2464, 257, 1461, 11, 321, 362, 257, 18887, 510, 300, 1619, 318, 4378, 13, 492, 11, 300, 311], "temperature": 0.0, "avg_logprob": -0.20105506561614656, "compression_ratio": 1.5753424657534247, "no_speech_prob": 3.845608443953097e-05}, {"id": 57, "seek": 41976, "start": 419.76, "end": 427.56, "text": " quite unique for BPF. Every BPF program needs to have this section tag there, and this tells", "tokens": [1596, 3845, 337, 40533, 37, 13, 2048, 40533, 37, 1461, 2203, 281, 362, 341, 3541, 6162, 456, 11, 293, 341, 5112], "temperature": 0.0, "avg_logprob": -0.1493285755778468, "compression_ratio": 1.6220095693779903, "no_speech_prob": 4.505292235990055e-05}, {"id": 58, "seek": 41976, "start": 427.56, "end": 433.92, "text": " the compiler to put all of the program code in the specific section that we named. And", "tokens": [264, 31958, 281, 829, 439, 295, 264, 1461, 3089, 294, 264, 2685, 3541, 300, 321, 4926, 13, 400], "temperature": 0.0, "avg_logprob": -0.1493285755778468, "compression_ratio": 1.6220095693779903, "no_speech_prob": 4.505292235990055e-05}, {"id": 59, "seek": 41976, "start": 433.92, "end": 440.76, "text": " the name of this section is for also convention, which can be used by the loader to inform", "tokens": [264, 1315, 295, 341, 3541, 307, 337, 611, 10286, 11, 597, 393, 312, 1143, 538, 264, 3677, 260, 281, 1356], "temperature": 0.0, "avg_logprob": -0.1493285755778468, "compression_ratio": 1.6220095693779903, "no_speech_prob": 4.505292235990055e-05}, {"id": 60, "seek": 41976, "start": 440.76, "end": 448.0, "text": " it that this is an XDP program, so it should be interpreted as such.", "tokens": [309, 300, 341, 307, 364, 1783, 11373, 1461, 11, 370, 309, 820, 312, 26749, 382, 1270, 13], "temperature": 0.0, "avg_logprob": -0.1493285755778468, "compression_ratio": 1.6220095693779903, "no_speech_prob": 4.505292235990055e-05}, {"id": 61, "seek": 44800, "start": 448.0, "end": 454.8, "text": " Now we can dump this section, so if we dump this section with LLVM object dump, then we", "tokens": [823, 321, 393, 11430, 341, 3541, 11, 370, 498, 321, 11430, 341, 3541, 365, 441, 43, 53, 44, 2657, 11430, 11, 550, 321], "temperature": 0.0, "avg_logprob": -0.17169212572502368, "compression_ratio": 1.6457399103139014, "no_speech_prob": 7.871793059166521e-05}, {"id": 62, "seek": 44800, "start": 454.8, "end": 463.44, "text": " get out this, which is hard to read if it's not annotated, but it's a bunch of BPF instructions", "tokens": [483, 484, 341, 11, 597, 307, 1152, 281, 1401, 498, 309, 311, 406, 25339, 770, 11, 457, 309, 311, 257, 3840, 295, 40533, 37, 9415], "temperature": 0.0, "avg_logprob": -0.17169212572502368, "compression_ratio": 1.6457399103139014, "no_speech_prob": 7.871793059166521e-05}, {"id": 63, "seek": 44800, "start": 463.44, "end": 471.52, "text": " starting with the opcode, so the actual opcode that tells it if it's add, subtract, whatever.", "tokens": [2891, 365, 264, 999, 22332, 11, 370, 264, 3539, 999, 22332, 300, 5112, 309, 498, 309, 311, 909, 11, 16390, 11, 2035, 13], "temperature": 0.0, "avg_logprob": -0.17169212572502368, "compression_ratio": 1.6457399103139014, "no_speech_prob": 7.871793059166521e-05}, {"id": 64, "seek": 44800, "start": 471.52, "end": 477.6, "text": " Source and destination registers where these opcodes act on with offsets for jumps. These", "tokens": [29629, 293, 12236, 38351, 689, 613, 999, 66, 4789, 605, 322, 365, 39457, 1385, 337, 16704, 13, 1981], "temperature": 0.0, "avg_logprob": -0.17169212572502368, "compression_ratio": 1.6457399103139014, "no_speech_prob": 7.871793059166521e-05}, {"id": 65, "seek": 47760, "start": 477.6, "end": 485.6, "text": " are relative, and intermediate data for, to say, load some data into a register like", "tokens": [366, 4972, 11, 293, 19376, 1412, 337, 11, 281, 584, 11, 3677, 512, 1412, 666, 257, 7280, 411], "temperature": 0.0, "avg_logprob": -0.18339576301993904, "compression_ratio": 1.5466666666666666, "no_speech_prob": 3.830080459010787e-05}, {"id": 66, "seek": 47760, "start": 485.6, "end": 491.8, "text": " a constant value. And sometimes we can use two of them together to represent a 64-bit", "tokens": [257, 5754, 2158, 13, 400, 2171, 321, 393, 764, 732, 295, 552, 1214, 281, 2906, 257, 12145, 12, 5260], "temperature": 0.0, "avg_logprob": -0.18339576301993904, "compression_ratio": 1.5466666666666666, "no_speech_prob": 3.830080459010787e-05}, {"id": 67, "seek": 47760, "start": 491.8, "end": 498.64000000000004, "text": " number, but we'll get to that later. We can also ask object dump to decompile this for", "tokens": [1230, 11, 457, 321, 603, 483, 281, 300, 1780, 13, 492, 393, 611, 1029, 2657, 11430, 281, 22867, 794, 341, 337], "temperature": 0.0, "avg_logprob": -0.18339576301993904, "compression_ratio": 1.5466666666666666, "no_speech_prob": 3.830080459010787e-05}, {"id": 68, "seek": 47760, "start": 498.64000000000004, "end": 505.84000000000003, "text": " us, and we'll get the decompiled BPF program. So the bytes on the left side and the actual", "tokens": [505, 11, 293, 321, 603, 483, 264, 22867, 7292, 40533, 37, 1461, 13, 407, 264, 36088, 322, 264, 1411, 1252, 293, 264, 3539], "temperature": 0.0, "avg_logprob": -0.18339576301993904, "compression_ratio": 1.5466666666666666, "no_speech_prob": 3.830080459010787e-05}, {"id": 69, "seek": 50584, "start": 505.84, "end": 511.2, "text": " program on the right side, but you'll notice that there's a call here. So one thing that", "tokens": [1461, 322, 264, 558, 1252, 11, 457, 291, 603, 3449, 300, 456, 311, 257, 818, 510, 13, 407, 472, 551, 300], "temperature": 0.0, "avg_logprob": -0.13090033531188966, "compression_ratio": 1.6869158878504673, "no_speech_prob": 0.00012851857172790915}, {"id": 70, "seek": 50584, "start": 511.2, "end": 516.64, "text": " I didn't tell you before is that the handle IPv4 function that we have is marked in such", "tokens": [286, 994, 380, 980, 291, 949, 307, 300, 264, 4813, 8671, 85, 19, 2445, 300, 321, 362, 307, 12658, 294, 1270], "temperature": 0.0, "avg_logprob": -0.13090033531188966, "compression_ratio": 1.6869158878504673, "no_speech_prob": 0.00012851857172790915}, {"id": 71, "seek": 50584, "start": 516.64, "end": 524.56, "text": " a way that it won't be inline, so it's a separate program, and BPF can do BPF to BPF function", "tokens": [257, 636, 300, 309, 1582, 380, 312, 294, 1889, 11, 370, 309, 311, 257, 4994, 1461, 11, 293, 40533, 37, 393, 360, 40533, 37, 281, 40533, 37, 2445], "temperature": 0.0, "avg_logprob": -0.13090033531188966, "compression_ratio": 1.6869158878504673, "no_speech_prob": 0.00012851857172790915}, {"id": 72, "seek": 50584, "start": 524.56, "end": 531.76, "text": " calls, and if you do that, it puts out this instruction, a function call instruction, but", "tokens": [5498, 11, 293, 498, 291, 360, 300, 11, 309, 8137, 484, 341, 10951, 11, 257, 2445, 818, 10951, 11, 457], "temperature": 0.0, "avg_logprob": -0.13090033531188966, "compression_ratio": 1.6869158878504673, "no_speech_prob": 0.00012851857172790915}, {"id": 73, "seek": 53176, "start": 531.76, "end": 538.2, "text": " with minus zero. Where do we call to? Well, currently nowhere, because we haven't assembled", "tokens": [365, 3175, 4018, 13, 2305, 360, 321, 818, 281, 30, 1042, 11, 4362, 11159, 11, 570, 321, 2378, 380, 24204], "temperature": 0.0, "avg_logprob": -0.17107322604157205, "compression_ratio": 1.5454545454545454, "no_speech_prob": 3.853113594232127e-05}, {"id": 74, "seek": 53176, "start": 538.2, "end": 547.2, "text": " the pieces of our furniture yet. So what actually, what also happens is that the compiler will", "tokens": [264, 3755, 295, 527, 15671, 1939, 13, 407, 437, 767, 11, 437, 611, 2314, 307, 300, 264, 31958, 486], "temperature": 0.0, "avg_logprob": -0.17107322604157205, "compression_ratio": 1.5454545454545454, "no_speech_prob": 3.853113594232127e-05}, {"id": 75, "seek": 53176, "start": 547.2, "end": 553.4, "text": " emit relocation information, which we can, again, visualize, and it says, all right,", "tokens": [32084, 26981, 399, 1589, 11, 597, 321, 393, 11, 797, 11, 23273, 11, 293, 309, 1619, 11, 439, 558, 11], "temperature": 0.0, "avg_logprob": -0.17107322604157205, "compression_ratio": 1.5454545454545454, "no_speech_prob": 3.853113594232127e-05}, {"id": 76, "seek": 53176, "start": 553.4, "end": 559.3199999999999, "text": " we have a certain instruction that is given offset, and you should put it in relative", "tokens": [321, 362, 257, 1629, 10951, 300, 307, 2212, 18687, 11, 293, 291, 820, 829, 309, 294, 4972], "temperature": 0.0, "avg_logprob": -0.17107322604157205, "compression_ratio": 1.5454545454545454, "no_speech_prob": 3.853113594232127e-05}, {"id": 77, "seek": 55932, "start": 559.32, "end": 566.48, "text": " address of this other function in here. Then we can go to the symbol table and we can look", "tokens": [2985, 295, 341, 661, 2445, 294, 510, 13, 1396, 321, 393, 352, 281, 264, 5986, 3199, 293, 321, 393, 574], "temperature": 0.0, "avg_logprob": -0.140483644273546, "compression_ratio": 1.622754491017964, "no_speech_prob": 8.713861461728811e-05}, {"id": 78, "seek": 55932, "start": 566.48, "end": 574.88, "text": " up this name, and it says, oh, that function lives in the.txt section, where for BPF programs,", "tokens": [493, 341, 1315, 11, 293, 309, 1619, 11, 1954, 11, 300, 2445, 2909, 294, 264, 2411, 83, 734, 3541, 11, 689, 337, 40533, 37, 4268, 11], "temperature": 0.0, "avg_logprob": -0.140483644273546, "compression_ratio": 1.622754491017964, "no_speech_prob": 8.713861461728811e-05}, {"id": 79, "seek": 55932, "start": 574.88, "end": 582.5600000000001, "text": " all of the function to function calls, all of the functions live together. So we have", "tokens": [439, 295, 264, 2445, 281, 2445, 5498, 11, 439, 295, 264, 6828, 1621, 1214, 13, 407, 321, 362], "temperature": 0.0, "avg_logprob": -0.140483644273546, "compression_ratio": 1.622754491017964, "no_speech_prob": 8.713861461728811e-05}, {"id": 80, "seek": 58256, "start": 582.56, "end": 591.0799999999999, "text": " these two separate pieces of the puzzle, and they refer to each other. But the kernel", "tokens": [613, 732, 4994, 3755, 295, 264, 12805, 11, 293, 436, 2864, 281, 1184, 661, 13, 583, 264, 28256], "temperature": 0.0, "avg_logprob": -0.11078275333751332, "compression_ratio": 1.6136363636363635, "no_speech_prob": 4.563520633382723e-05}, {"id": 81, "seek": 58256, "start": 591.0799999999999, "end": 597.28, "text": " only has one pointer for our instructions. It expects that every program we give it is", "tokens": [787, 575, 472, 23918, 337, 527, 9415, 13, 467, 33280, 300, 633, 1461, 321, 976, 309, 307], "temperature": 0.0, "avg_logprob": -0.11078275333751332, "compression_ratio": 1.6136363636363635, "no_speech_prob": 4.563520633382723e-05}, {"id": 82, "seek": 58256, "start": 597.28, "end": 603.5999999999999, "text": " one contiguous piece of memory with instructions, and it all should work. So we have some work", "tokens": [472, 660, 30525, 2522, 295, 4675, 365, 9415, 11, 293, 309, 439, 820, 589, 13, 407, 321, 362, 512, 589], "temperature": 0.0, "avg_logprob": -0.11078275333751332, "compression_ratio": 1.6136363636363635, "no_speech_prob": 4.563520633382723e-05}, {"id": 83, "seek": 58256, "start": 603.5999999999999, "end": 608.52, "text": " to do. We need to figure out, or the loader rather, needs to figure out how it wants to", "tokens": [281, 360, 13, 492, 643, 281, 2573, 484, 11, 420, 264, 3677, 260, 2831, 11, 2203, 281, 2573, 484, 577, 309, 2738, 281], "temperature": 0.0, "avg_logprob": -0.11078275333751332, "compression_ratio": 1.6136363636363635, "no_speech_prob": 4.563520633382723e-05}, {"id": 84, "seek": 60852, "start": 608.52, "end": 613.48, "text": " lay out our programs, so piece all of the puzzles together, find all of these references,", "tokens": [2360, 484, 527, 4268, 11, 370, 2522, 439, 295, 264, 24138, 1214, 11, 915, 439, 295, 613, 15400, 11], "temperature": 0.0, "avg_logprob": -0.16275162599524673, "compression_ratio": 1.6495327102803738, "no_speech_prob": 6.941717583686113e-05}, {"id": 85, "seek": 60852, "start": 613.48, "end": 619.88, "text": " and then put in the correct offset. All of this happens in user space before we even", "tokens": [293, 550, 829, 294, 264, 3006, 18687, 13, 1057, 295, 341, 2314, 294, 4195, 1901, 949, 321, 754], "temperature": 0.0, "avg_logprob": -0.16275162599524673, "compression_ratio": 1.6495327102803738, "no_speech_prob": 6.941717583686113e-05}, {"id": 86, "seek": 60852, "start": 619.88, "end": 627.88, "text": " go to the kernel. Now, second fun thing is that we can define our map. So again, we have", "tokens": [352, 281, 264, 28256, 13, 823, 11, 1150, 1019, 551, 307, 300, 321, 393, 6964, 527, 4471, 13, 407, 797, 11, 321, 362], "temperature": 0.0, "avg_logprob": -0.16275162599524673, "compression_ratio": 1.6495327102803738, "no_speech_prob": 6.941717583686113e-05}, {"id": 87, "seek": 60852, "start": 627.88, "end": 637.56, "text": " the sec part,.maps, put it in the.maps section, and if we, and this is the function, this", "tokens": [264, 907, 644, 11, 2411, 76, 2382, 11, 829, 309, 294, 264, 2411, 76, 2382, 3541, 11, 293, 498, 321, 11, 293, 341, 307, 264, 2445, 11, 341], "temperature": 0.0, "avg_logprob": -0.16275162599524673, "compression_ratio": 1.6495327102803738, "no_speech_prob": 6.941717583686113e-05}, {"id": 88, "seek": 63756, "start": 637.56, "end": 643.68, "text": " is the part that I have been hiding from you until now. It's also quite simple in terms", "tokens": [307, 264, 644, 300, 286, 362, 668, 10596, 490, 291, 1826, 586, 13, 467, 311, 611, 1596, 2199, 294, 2115], "temperature": 0.0, "avg_logprob": -0.10574501752853394, "compression_ratio": 1.5301724137931034, "no_speech_prob": 5.92990945733618e-05}, {"id": 89, "seek": 63756, "start": 643.68, "end": 655.16, "text": " of BPF programs. We get an IPv4 header, check that we can use it, and we write, or we get", "tokens": [295, 40533, 37, 4268, 13, 492, 483, 364, 8671, 85, 19, 23117, 11, 1520, 300, 321, 393, 764, 309, 11, 293, 321, 2464, 11, 420, 321, 483], "temperature": 0.0, "avg_logprob": -0.10574501752853394, "compression_ratio": 1.5301724137931034, "no_speech_prob": 5.92990945733618e-05}, {"id": 90, "seek": 63756, "start": 655.16, "end": 659.88, "text": " a value from the map, and if it doesn't exist, we write a new one and increment the values", "tokens": [257, 2158, 490, 264, 4471, 11, 293, 498, 309, 1177, 380, 2514, 11, 321, 2464, 257, 777, 472, 293, 26200, 264, 4190], "temperature": 0.0, "avg_logprob": -0.10574501752853394, "compression_ratio": 1.5301724137931034, "no_speech_prob": 5.92990945733618e-05}, {"id": 91, "seek": 63756, "start": 659.88, "end": 666.4799999999999, "text": " every time this happens to account for some information. So keep this program in mind,", "tokens": [633, 565, 341, 2314, 281, 2696, 337, 512, 1589, 13, 407, 1066, 341, 1461, 294, 1575, 11], "temperature": 0.0, "avg_logprob": -0.10574501752853394, "compression_ratio": 1.5301724137931034, "no_speech_prob": 5.92990945733618e-05}, {"id": 92, "seek": 66648, "start": 666.48, "end": 671.08, "text": " and then if we go look at the instructions again, the disassembled version this time,", "tokens": [293, 550, 498, 321, 352, 574, 412, 264, 9415, 797, 11, 264, 717, 29386, 1493, 3037, 341, 565, 11], "temperature": 0.0, "avg_logprob": -0.17517051913521506, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0089255485800095e-05}, {"id": 93, "seek": 66648, "start": 671.08, "end": 677.32, "text": " we see that we have two of these long lines which are zero at the end. So these are the", "tokens": [321, 536, 300, 321, 362, 732, 295, 613, 938, 3876, 597, 366, 4018, 412, 264, 917, 13, 407, 613, 366, 264], "temperature": 0.0, "avg_logprob": -0.17517051913521506, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0089255485800095e-05}, {"id": 94, "seek": 66648, "start": 677.32, "end": 684.24, "text": " 64-bit intermediate values that I was talking about, and they are just long to keep, to", "tokens": [12145, 12, 5260, 19376, 4190, 300, 286, 390, 1417, 466, 11, 293, 436, 366, 445, 938, 281, 1066, 11, 281], "temperature": 0.0, "avg_logprob": -0.17517051913521506, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0089255485800095e-05}, {"id": 95, "seek": 66648, "start": 684.24, "end": 692.44, "text": " pre-allocate room for actual memory addresses later, instead of relative jumps. But they", "tokens": [659, 12, 336, 42869, 1808, 337, 3539, 4675, 16862, 1780, 11, 2602, 295, 4972, 16704, 13, 583, 436], "temperature": 0.0, "avg_logprob": -0.17517051913521506, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0089255485800095e-05}, {"id": 96, "seek": 69244, "start": 692.44, "end": 698.0400000000001, "text": " are zero, and these should be references to our map, and later on these will become pointers", "tokens": [366, 4018, 11, 293, 613, 820, 312, 15400, 281, 527, 4471, 11, 293, 1780, 322, 613, 486, 1813, 44548], "temperature": 0.0, "avg_logprob": -0.140036271966022, "compression_ratio": 1.6561085972850678, "no_speech_prob": 0.00011529136099852622}, {"id": 97, "seek": 69244, "start": 698.0400000000001, "end": 705.32, "text": " when the kernel gets its way with it. And in our case, we again need to figure out what", "tokens": [562, 264, 28256, 2170, 1080, 636, 365, 309, 13, 400, 294, 527, 1389, 11, 321, 797, 643, 281, 2573, 484, 437], "temperature": 0.0, "avg_logprob": -0.140036271966022, "compression_ratio": 1.6561085972850678, "no_speech_prob": 0.00011529136099852622}, {"id": 98, "seek": 69244, "start": 705.32, "end": 711.48, "text": " to put in here. So same routine. We have relocation information. The relocation information points", "tokens": [281, 829, 294, 510, 13, 407, 912, 9927, 13, 492, 362, 26981, 399, 1589, 13, 440, 26981, 399, 1589, 2793], "temperature": 0.0, "avg_logprob": -0.140036271966022, "compression_ratio": 1.6561085972850678, "no_speech_prob": 0.00011529136099852622}, {"id": 99, "seek": 69244, "start": 711.48, "end": 719.08, "text": " to the instructions that we had. It says you need to plug in a flow map here. We go to", "tokens": [281, 264, 9415, 300, 321, 632, 13, 467, 1619, 291, 643, 281, 5452, 294, 257, 3095, 4471, 510, 13, 492, 352, 281], "temperature": 0.0, "avg_logprob": -0.140036271966022, "compression_ratio": 1.6561085972850678, "no_speech_prob": 0.00011529136099852622}, {"id": 100, "seek": 71908, "start": 719.08, "end": 726.96, "text": " the symbol table, and there it says we have a.map section, and there lives a flow map.", "tokens": [264, 5986, 3199, 11, 293, 456, 309, 1619, 321, 362, 257, 2411, 24223, 3541, 11, 293, 456, 2909, 257, 3095, 4471, 13], "temperature": 0.0, "avg_logprob": -0.1154175522506878, "compression_ratio": 1.6822429906542056, "no_speech_prob": 4.963783794664778e-05}, {"id": 101, "seek": 71908, "start": 726.96, "end": 733.32, "text": " In this case, we handle it slightly differently, so we then have to go load this flow map first,", "tokens": [682, 341, 1389, 11, 321, 4813, 309, 4748, 7614, 11, 370, 321, 550, 362, 281, 352, 3677, 341, 3095, 4471, 700, 11], "temperature": 0.0, "avg_logprob": -0.1154175522506878, "compression_ratio": 1.6822429906542056, "no_speech_prob": 4.963783794664778e-05}, {"id": 102, "seek": 71908, "start": 733.32, "end": 738.0400000000001, "text": " get a file descriptor, which is our unique identifier for the map, and we need to actually", "tokens": [483, 257, 3991, 31280, 284, 11, 597, 307, 527, 3845, 45690, 337, 264, 4471, 11, 293, 321, 643, 281, 767], "temperature": 0.0, "avg_logprob": -0.1154175522506878, "compression_ratio": 1.6822429906542056, "no_speech_prob": 4.963783794664778e-05}, {"id": 103, "seek": 71908, "start": 738.0400000000001, "end": 747.44, "text": " put in that file descriptor into these empty values, so the kernel knows where to go.", "tokens": [829, 294, 300, 3991, 31280, 284, 666, 613, 6707, 4190, 11, 370, 264, 28256, 3255, 689, 281, 352, 13], "temperature": 0.0, "avg_logprob": -0.1154175522506878, "compression_ratio": 1.6822429906542056, "no_speech_prob": 4.963783794664778e-05}, {"id": 104, "seek": 74744, "start": 747.44, "end": 755.8800000000001, "text": " Mapping maps also is also a command, so we have the map create command, and it takes", "tokens": [376, 10534, 11317, 611, 307, 611, 257, 5622, 11, 370, 321, 362, 264, 4471, 1884, 5622, 11, 293, 309, 2516], "temperature": 0.0, "avg_logprob": -0.20138312359245455, "compression_ratio": 1.6073059360730593, "no_speech_prob": 0.00010961204679915681}, {"id": 105, "seek": 74744, "start": 755.8800000000001, "end": 760.96, "text": " these arguments. I cut out a bit of the later ones, but these are the essential type, how", "tokens": [613, 12869, 13, 286, 1723, 484, 257, 857, 295, 264, 1780, 2306, 11, 457, 613, 366, 264, 7115, 2010, 11, 577], "temperature": 0.0, "avg_logprob": -0.20138312359245455, "compression_ratio": 1.6073059360730593, "no_speech_prob": 0.00010961204679915681}, {"id": 106, "seek": 74744, "start": 760.96, "end": 769.12, "text": " big are my values, et cetera. Give it a nice name. And there are two ways to define these.", "tokens": [955, 366, 452, 4190, 11, 1030, 11458, 13, 5303, 309, 257, 1481, 1315, 13, 400, 456, 366, 732, 2098, 281, 6964, 613, 13], "temperature": 0.0, "avg_logprob": -0.20138312359245455, "compression_ratio": 1.6073059360730593, "no_speech_prob": 0.00010961204679915681}, {"id": 107, "seek": 74744, "start": 769.12, "end": 776.6, "text": " We have the new way of doing it, which are called BTF maps, colloquially, on the left.", "tokens": [492, 362, 264, 777, 636, 295, 884, 309, 11, 597, 366, 1219, 363, 20527, 11317, 11, 1263, 29826, 2270, 11, 322, 264, 1411, 13], "temperature": 0.0, "avg_logprob": -0.20138312359245455, "compression_ratio": 1.6073059360730593, "no_speech_prob": 0.00010961204679915681}, {"id": 108, "seek": 77660, "start": 776.6, "end": 783.0, "text": " But there's also the old way of doing it, using a BTF map definition on the right. Don't", "tokens": [583, 456, 311, 611, 264, 1331, 636, 295, 884, 309, 11, 1228, 257, 363, 20527, 4471, 7123, 322, 264, 558, 13, 1468, 380], "temperature": 0.0, "avg_logprob": -0.15209722981869594, "compression_ratio": 1.6775700934579438, "no_speech_prob": 4.9474499974166974e-05}, {"id": 109, "seek": 77660, "start": 783.0, "end": 791.44, "text": " use it if you go into libbpf in the part of the libbpf, which is used during ebpf construction.", "tokens": [764, 309, 498, 291, 352, 666, 22854, 65, 25302, 294, 264, 644, 295, 264, 22854, 65, 25302, 11, 597, 307, 1143, 1830, 308, 65, 25302, 6435, 13], "temperature": 0.0, "avg_logprob": -0.15209722981869594, "compression_ratio": 1.6775700934579438, "no_speech_prob": 4.9474499974166974e-05}, {"id": 110, "seek": 77660, "start": 791.44, "end": 797.24, "text": " It will warn you that you shouldn't use it and go for the left side. But the odd thing", "tokens": [467, 486, 12286, 291, 300, 291, 4659, 380, 764, 309, 293, 352, 337, 264, 1411, 1252, 13, 583, 264, 7401, 551], "temperature": 0.0, "avg_logprob": -0.15209722981869594, "compression_ratio": 1.6775700934579438, "no_speech_prob": 4.9474499974166974e-05}, {"id": 111, "seek": 77660, "start": 797.24, "end": 802.28, "text": " is that if you use these newer BTF maps on the left, and you go look at what's actually", "tokens": [307, 300, 498, 291, 764, 613, 17628, 363, 20527, 11317, 322, 264, 1411, 11, 293, 291, 352, 574, 412, 437, 311, 767], "temperature": 0.0, "avg_logprob": -0.15209722981869594, "compression_ratio": 1.6775700934579438, "no_speech_prob": 4.9474499974166974e-05}, {"id": 112, "seek": 80228, "start": 802.28, "end": 807.52, "text": " then written to your.map section, it's all zero. There's no information. It still keeps,", "tokens": [550, 3720, 281, 428, 2411, 24223, 3541, 11, 309, 311, 439, 4018, 13, 821, 311, 572, 1589, 13, 467, 920, 5965, 11], "temperature": 0.0, "avg_logprob": -0.16220763264870158, "compression_ratio": 1.674641148325359, "no_speech_prob": 0.00012220854114275426}, {"id": 113, "seek": 80228, "start": 807.52, "end": 812.64, "text": " it still allocates room for your map, but it will, but they'll all be zero, and there's", "tokens": [309, 920, 12660, 1024, 1808, 337, 428, 4471, 11, 457, 309, 486, 11, 457, 436, 603, 439, 312, 4018, 11, 293, 456, 311], "temperature": 0.0, "avg_logprob": -0.16220763264870158, "compression_ratio": 1.674641148325359, "no_speech_prob": 0.00012220854114275426}, {"id": 114, "seek": 80228, "start": 812.64, "end": 821.8, "text": " no information. All information, instead, is in the type information of the flow map.", "tokens": [572, 1589, 13, 1057, 1589, 11, 2602, 11, 307, 294, 264, 2010, 1589, 295, 264, 3095, 4471, 13], "temperature": 0.0, "avg_logprob": -0.16220763264870158, "compression_ratio": 1.674641148325359, "no_speech_prob": 0.00012220854114275426}, {"id": 115, "seek": 80228, "start": 821.8, "end": 830.4399999999999, "text": " So we have to get in what is BTF. BTF stands for BPF type format. It's derived from the", "tokens": [407, 321, 362, 281, 483, 294, 437, 307, 363, 20527, 13, 363, 20527, 7382, 337, 40533, 37, 2010, 7877, 13, 467, 311, 18949, 490, 264], "temperature": 0.0, "avg_logprob": -0.16220763264870158, "compression_ratio": 1.674641148325359, "no_speech_prob": 0.00012220854114275426}, {"id": 116, "seek": 83044, "start": 830.44, "end": 838.9200000000001, "text": " actual dwarf debug symbols that already are used for normal C programs. But as a way compact", "tokens": [3539, 35527, 24083, 16944, 300, 1217, 366, 1143, 337, 2710, 383, 4268, 13, 583, 382, 257, 636, 14679], "temperature": 0.0, "avg_logprob": -0.175714747850285, "compression_ratio": 1.5884955752212389, "no_speech_prob": 0.00011450622696429491}, {"id": 117, "seek": 83044, "start": 838.9200000000001, "end": 844.4000000000001, "text": " or smaller version of it, which only really is concerned about type information and not", "tokens": [420, 4356, 3037, 295, 309, 11, 597, 787, 534, 307, 5922, 466, 2010, 1589, 293, 406], "temperature": 0.0, "avg_logprob": -0.175714747850285, "compression_ratio": 1.5884955752212389, "no_speech_prob": 0.00011450622696429491}, {"id": 118, "seek": 83044, "start": 844.4000000000001, "end": 850.5600000000001, "text": " about where and at which moment a variable lives. And these are used because ebpf itself", "tokens": [466, 689, 293, 412, 597, 1623, 257, 7006, 2909, 13, 400, 613, 366, 1143, 570, 308, 65, 25302, 2564], "temperature": 0.0, "avg_logprob": -0.175714747850285, "compression_ratio": 1.5884955752212389, "no_speech_prob": 0.00011450622696429491}, {"id": 119, "seek": 83044, "start": 850.5600000000001, "end": 858.2, "text": " is just too limiting, and we want to do more, especially in the verifier. So we have, for", "tokens": [307, 445, 886, 22083, 11, 293, 321, 528, 281, 360, 544, 11, 2318, 294, 264, 1306, 9902, 13, 407, 321, 362, 11, 337], "temperature": 0.0, "avg_logprob": -0.175714747850285, "compression_ratio": 1.5884955752212389, "no_speech_prob": 0.00011450622696429491}, {"id": 120, "seek": 85820, "start": 858.2, "end": 865.0400000000001, "text": " example, features like spinlocks, which should only be used on maps that have spinlock values", "tokens": [1365, 11, 4122, 411, 6060, 34896, 11, 597, 820, 787, 312, 1143, 322, 11317, 300, 362, 6060, 4102, 4190], "temperature": 0.0, "avg_logprob": -0.14564489234577527, "compression_ratio": 1.6590909090909092, "no_speech_prob": 1.6141504602273926e-05}, {"id": 121, "seek": 85820, "start": 865.0400000000001, "end": 873.6800000000001, "text": " in them. Or we have callback functions, so we can define these BPF functions, but instead", "tokens": [294, 552, 13, 1610, 321, 362, 818, 3207, 6828, 11, 370, 321, 393, 6964, 613, 40533, 37, 6828, 11, 457, 2602], "temperature": 0.0, "avg_logprob": -0.14564489234577527, "compression_ratio": 1.6590909090909092, "no_speech_prob": 1.6141504602273926e-05}, {"id": 122, "seek": 85820, "start": 873.6800000000001, "end": 879.76, "text": " give them to a helper function. But this helper needs to then know that it's the correct number", "tokens": [976, 552, 281, 257, 36133, 2445, 13, 583, 341, 36133, 2203, 281, 550, 458, 300, 309, 311, 264, 3006, 1230], "temperature": 0.0, "avg_logprob": -0.14564489234577527, "compression_ratio": 1.6590909090909092, "no_speech_prob": 1.6141504602273926e-05}, {"id": 123, "seek": 85820, "start": 879.76, "end": 884.6, "text": " of arguments and the correct type. So all of this type information we can give to the", "tokens": [295, 12869, 293, 264, 3006, 2010, 13, 407, 439, 295, 341, 2010, 1589, 321, 393, 976, 281, 264], "temperature": 0.0, "avg_logprob": -0.14564489234577527, "compression_ratio": 1.6590909090909092, "no_speech_prob": 1.6141504602273926e-05}, {"id": 124, "seek": 88460, "start": 884.6, "end": 890.16, "text": " kernel. And that's why it's, especially if you want to use these new fancy features,", "tokens": [28256, 13, 400, 300, 311, 983, 309, 311, 11, 2318, 498, 291, 528, 281, 764, 613, 777, 10247, 4122, 11], "temperature": 0.0, "avg_logprob": -0.12644769834435504, "compression_ratio": 1.575221238938053, "no_speech_prob": 4.795445784111507e-05}, {"id": 125, "seek": 88460, "start": 890.16, "end": 896.52, "text": " it's important to use the BTF information. It also allows for flexible map arguments.", "tokens": [309, 311, 1021, 281, 764, 264, 363, 20527, 1589, 13, 467, 611, 4045, 337, 11358, 4471, 12869, 13], "temperature": 0.0, "avg_logprob": -0.12644769834435504, "compression_ratio": 1.575221238938053, "no_speech_prob": 4.795445784111507e-05}, {"id": 126, "seek": 88460, "start": 896.52, "end": 901.8000000000001, "text": " So for example, if I go back, we have the definition. And one of the things you'll notice", "tokens": [407, 337, 1365, 11, 498, 286, 352, 646, 11, 321, 362, 264, 7123, 13, 400, 472, 295, 264, 721, 291, 603, 3449], "temperature": 0.0, "avg_logprob": -0.12644769834435504, "compression_ratio": 1.575221238938053, "no_speech_prob": 4.795445784111507e-05}, {"id": 127, "seek": 88460, "start": 901.8000000000001, "end": 909.52, "text": " is that we have pinning as an attribute here. But you will not find it in the Cisco attributes.", "tokens": [307, 300, 321, 362, 5447, 773, 382, 364, 19667, 510, 13, 583, 291, 486, 406, 915, 309, 294, 264, 38528, 17212, 13], "temperature": 0.0, "avg_logprob": -0.12644769834435504, "compression_ratio": 1.575221238938053, "no_speech_prob": 4.795445784111507e-05}, {"id": 128, "seek": 90952, "start": 909.52, "end": 916.8, "text": " This is purely something that we communicate to the loader library in this case, that we", "tokens": [639, 307, 17491, 746, 300, 321, 7890, 281, 264, 3677, 260, 6405, 294, 341, 1389, 11, 300, 321], "temperature": 0.0, "avg_logprob": -0.15843686952695743, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.219088128185831e-05}, {"id": 129, "seek": 90952, "start": 916.8, "end": 926.16, "text": " communicate to the loader library, not just libbpf, but that's the name that it has currently.", "tokens": [7890, 281, 264, 3677, 260, 6405, 11, 406, 445, 22854, 65, 25302, 11, 457, 300, 311, 264, 1315, 300, 309, 575, 4362, 13], "temperature": 0.0, "avg_logprob": -0.15843686952695743, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.219088128185831e-05}, {"id": 130, "seek": 90952, "start": 926.16, "end": 930.64, "text": " And we can do a lot of different cool things with that. It also provides debug information", "tokens": [400, 321, 393, 360, 257, 688, 295, 819, 1627, 721, 365, 300, 13, 467, 611, 6417, 24083, 1589], "temperature": 0.0, "avg_logprob": -0.15843686952695743, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.219088128185831e-05}, {"id": 131, "seek": 90952, "start": 930.64, "end": 936.72, "text": " for us. So if we go look at loader programs, it will be annotated with the line information", "tokens": [337, 505, 13, 407, 498, 321, 352, 574, 412, 3677, 260, 4268, 11, 309, 486, 312, 25339, 770, 365, 264, 1622, 1589], "temperature": 0.0, "avg_logprob": -0.15843686952695743, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.219088128185831e-05}, {"id": 132, "seek": 93672, "start": 936.72, "end": 942.8000000000001, "text": " and from rich file we can read. And perhaps one of the coolest features is compile once", "tokens": [293, 490, 4593, 3991, 321, 393, 1401, 13, 400, 4317, 472, 295, 264, 22013, 4122, 307, 31413, 1564], "temperature": 0.0, "avg_logprob": -0.12728398421715045, "compression_ratio": 1.5990990990990992, "no_speech_prob": 7.719313725829124e-05}, {"id": 133, "seek": 93672, "start": 942.8000000000001, "end": 952.24, "text": " run everywhere, which allows the loader and or the kernel to modify our program slightly.", "tokens": [1190, 5315, 11, 597, 4045, 264, 3677, 260, 293, 420, 264, 28256, 281, 16927, 527, 1461, 4748, 13], "temperature": 0.0, "avg_logprob": -0.12728398421715045, "compression_ratio": 1.5990990990990992, "no_speech_prob": 7.719313725829124e-05}, {"id": 134, "seek": 93672, "start": 952.24, "end": 959.0, "text": " So it will run on multiple versions of the kernel, even if the internals have changed.", "tokens": [407, 309, 486, 1190, 322, 3866, 9606, 295, 264, 28256, 11, 754, 498, 264, 2154, 1124, 362, 3105, 13], "temperature": 0.0, "avg_logprob": -0.12728398421715045, "compression_ratio": 1.5990990990990992, "no_speech_prob": 7.719313725829124e-05}, {"id": 135, "seek": 93672, "start": 959.0, "end": 965.52, "text": " So if we dump this BTF that we have from our example program, it looks like this. Features", "tokens": [407, 498, 321, 11430, 341, 363, 20527, 300, 321, 362, 490, 527, 1365, 1461, 11, 309, 1542, 411, 341, 13, 3697, 3377], "temperature": 0.0, "avg_logprob": -0.12728398421715045, "compression_ratio": 1.5990990990990992, "no_speech_prob": 7.719313725829124e-05}, {"id": 136, "seek": 96552, "start": 965.52, "end": 972.8, "text": " to note are the numbers on the left and square brackets. Those are the type ID. Besides it's", "tokens": [281, 3637, 366, 264, 3547, 322, 264, 1411, 293, 3732, 26179, 13, 3950, 366, 264, 2010, 7348, 13, 13212, 309, 311], "temperature": 0.0, "avg_logprob": -0.16828067650955714, "compression_ratio": 1.5954545454545455, "no_speech_prob": 4.7359262680402026e-05}, {"id": 137, "seek": 96552, "start": 972.8, "end": 979.0799999999999, "text": " actual type. So we have pointers, integers, arrays. You can basically represent every C", "tokens": [3539, 2010, 13, 407, 321, 362, 44548, 11, 41674, 11, 41011, 13, 509, 393, 1936, 2906, 633, 383], "temperature": 0.0, "avg_logprob": -0.16828067650955714, "compression_ratio": 1.5954545454545455, "no_speech_prob": 4.7359262680402026e-05}, {"id": 138, "seek": 96552, "start": 979.0799999999999, "end": 986.24, "text": " type in BTF this way. There's an optional name and then there's a lot of information", "tokens": [2010, 294, 363, 20527, 341, 636, 13, 821, 311, 364, 17312, 1315, 293, 550, 456, 311, 257, 688, 295, 1589], "temperature": 0.0, "avg_logprob": -0.16828067650955714, "compression_ratio": 1.5954545454545455, "no_speech_prob": 4.7359262680402026e-05}, {"id": 139, "seek": 96552, "start": 986.24, "end": 991.88, "text": " about the specific type. And they refer to each other. So you'll notice a lot of type", "tokens": [466, 264, 2685, 2010, 13, 400, 436, 2864, 281, 1184, 661, 13, 407, 291, 603, 3449, 257, 688, 295, 2010], "temperature": 0.0, "avg_logprob": -0.16828067650955714, "compression_ratio": 1.5954545454545455, "no_speech_prob": 4.7359262680402026e-05}, {"id": 140, "seek": 99188, "start": 991.88, "end": 999.36, "text": " ID is something else. So you can also visualize it by nesting it. I've done this manually.", "tokens": [7348, 307, 746, 1646, 13, 407, 291, 393, 611, 23273, 309, 538, 297, 8714, 309, 13, 286, 600, 1096, 341, 16945, 13], "temperature": 0.0, "avg_logprob": -0.16482833980285017, "compression_ratio": 1.614678899082569, "no_speech_prob": 8.313919533975422e-05}, {"id": 141, "seek": 99188, "start": 999.36, "end": 1005.4399999999999, "text": " By the way, there's no comment on this, but this is how you can do it yourself. So we", "tokens": [3146, 264, 636, 11, 456, 311, 572, 2871, 322, 341, 11, 457, 341, 307, 577, 291, 393, 360, 309, 1803, 13, 407, 321], "temperature": 0.0, "avg_logprob": -0.16482833980285017, "compression_ratio": 1.614678899082569, "no_speech_prob": 8.313919533975422e-05}, {"id": 142, "seek": 99188, "start": 1005.4399999999999, "end": 1010.84, "text": " have, for example, a map section with a flow map in it. And you can see that we have the", "tokens": [362, 11, 337, 1365, 11, 257, 4471, 3541, 365, 257, 3095, 4471, 294, 309, 13, 400, 291, 393, 536, 300, 321, 362, 264], "temperature": 0.0, "avg_logprob": -0.16482833980285017, "compression_ratio": 1.614678899082569, "no_speech_prob": 8.313919533975422e-05}, {"id": 143, "seek": 99188, "start": 1010.84, "end": 1016.0, "text": " type, the key, the value. And we have this very detailed description of exactly how it", "tokens": [2010, 11, 264, 2141, 11, 264, 2158, 13, 400, 321, 362, 341, 588, 9942, 3855, 295, 2293, 577, 309], "temperature": 0.0, "avg_logprob": -0.16482833980285017, "compression_ratio": 1.614678899082569, "no_speech_prob": 8.313919533975422e-05}, {"id": 144, "seek": 101600, "start": 1016.0, "end": 1023.32, "text": " structured at which offsets, which things live and names for it which are used to check", "tokens": [18519, 412, 597, 39457, 1385, 11, 597, 721, 1621, 293, 5288, 337, 309, 597, 366, 1143, 281, 1520], "temperature": 0.0, "avg_logprob": -0.19463399116029131, "compression_ratio": 1.6759259259259258, "no_speech_prob": 5.782558582723141e-05}, {"id": 145, "seek": 101600, "start": 1023.32, "end": 1030.8, "text": " all of these certain things. And also to create a loader bill, we use this to infer the actual", "tokens": [439, 295, 613, 1629, 721, 13, 400, 611, 281, 1884, 257, 3677, 260, 2961, 11, 321, 764, 341, 281, 13596, 264, 3539], "temperature": 0.0, "avg_logprob": -0.19463399116029131, "compression_ratio": 1.6759259259259258, "no_speech_prob": 5.782558582723141e-05}, {"id": 146, "seek": 101600, "start": 1030.8, "end": 1037.4, "text": " value and key sizes to give to the kernel. This BTF is structured in, so it lives in", "tokens": [2158, 293, 2141, 11602, 281, 976, 281, 264, 28256, 13, 639, 363, 20527, 307, 18519, 294, 11, 370, 309, 2909, 294], "temperature": 0.0, "avg_logprob": -0.19463399116029131, "compression_ratio": 1.6759259259259258, "no_speech_prob": 5.782558582723141e-05}, {"id": 147, "seek": 101600, "start": 1037.4, "end": 1043.88, "text": " the dot BTF section. And it's sort of structured like this. So we have this header, then types", "tokens": [264, 5893, 363, 20527, 3541, 13, 400, 309, 311, 1333, 295, 18519, 411, 341, 13, 407, 321, 362, 341, 23117, 11, 550, 3467], "temperature": 0.0, "avg_logprob": -0.19463399116029131, "compression_ratio": 1.6759259259259258, "no_speech_prob": 5.782558582723141e-05}, {"id": 148, "seek": 104388, "start": 1043.88, "end": 1049.8400000000001, "text": " and a lot of strings. And each type starts with the same three fields. So we have a name", "tokens": [293, 257, 688, 295, 13985, 13, 400, 1184, 2010, 3719, 365, 264, 912, 1045, 7909, 13, 407, 321, 362, 257, 1315], "temperature": 0.0, "avg_logprob": -0.1187024550004439, "compression_ratio": 1.7524271844660195, "no_speech_prob": 7.103382085915655e-05}, {"id": 149, "seek": 104388, "start": 1049.8400000000001, "end": 1056.1200000000001, "text": " offset, so an offset into the strings. We have information and a size or type depending", "tokens": [18687, 11, 370, 364, 18687, 666, 264, 13985, 13, 492, 362, 1589, 293, 257, 2744, 420, 2010, 5413], "temperature": 0.0, "avg_logprob": -0.1187024550004439, "compression_ratio": 1.7524271844660195, "no_speech_prob": 7.103382085915655e-05}, {"id": 150, "seek": 104388, "start": 1056.1200000000001, "end": 1062.64, "text": " on what the information says. This translates into the name and the type of the BTF information", "tokens": [322, 437, 264, 1589, 1619, 13, 639, 28468, 666, 264, 1315, 293, 264, 2010, 295, 264, 363, 20527, 1589], "temperature": 0.0, "avg_logprob": -0.1187024550004439, "compression_ratio": 1.7524271844660195, "no_speech_prob": 7.103382085915655e-05}, {"id": 151, "seek": 104388, "start": 1062.64, "end": 1067.44, "text": " and then the last part is specific to that type. So encoding for ins or a list of fields", "tokens": [293, 550, 264, 1036, 644, 307, 2685, 281, 300, 2010, 13, 407, 43430, 337, 1028, 420, 257, 1329, 295, 7909], "temperature": 0.0, "avg_logprob": -0.1187024550004439, "compression_ratio": 1.7524271844660195, "no_speech_prob": 7.103382085915655e-05}, {"id": 152, "seek": 106744, "start": 1067.44, "end": 1077.92, "text": " for a structure, et cetera. We also have the dot BTF.ext, the extended version of it.", "tokens": [337, 257, 3877, 11, 1030, 11458, 13, 492, 611, 362, 264, 5893, 363, 20527, 13, 3828, 11, 264, 10913, 3037, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.13911877572536469, "compression_ratio": 1.6097560975609757, "no_speech_prob": 3.386069511179812e-05}, {"id": 153, "seek": 106744, "start": 1077.92, "end": 1084.3600000000001, "text": " And this contains function information, line information, and optionally core relocations.", "tokens": [400, 341, 8306, 2445, 1589, 11, 1622, 1589, 11, 293, 3614, 379, 4965, 26981, 763, 13], "temperature": 0.0, "avg_logprob": -0.13911877572536469, "compression_ratio": 1.6097560975609757, "no_speech_prob": 3.386069511179812e-05}, {"id": 154, "seek": 106744, "start": 1084.3600000000001, "end": 1091.72, "text": " So the line information contains a bunch of lines. So it will annotate this instruction", "tokens": [407, 264, 1622, 1589, 8306, 257, 3840, 295, 3876, 13, 407, 309, 486, 25339, 473, 341, 10951], "temperature": 0.0, "avg_logprob": -0.13911877572536469, "compression_ratio": 1.6097560975609757, "no_speech_prob": 3.386069511179812e-05}, {"id": 155, "seek": 109172, "start": 1091.72, "end": 1098.04, "text": " as part of this line of your original source program and functions to label every one of", "tokens": [382, 644, 295, 341, 1622, 295, 428, 3380, 4009, 1461, 293, 6828, 281, 7645, 633, 472, 295], "temperature": 0.0, "avg_logprob": -0.1920371262923531, "compression_ratio": 1.6431924882629108, "no_speech_prob": 3.684752664412372e-05}, {"id": 156, "seek": 109172, "start": 1098.04, "end": 1107.4, "text": " these BTF functions that you have defined. Loading the BTF itself is quite simple. You", "tokens": [613, 363, 20527, 6828, 300, 291, 362, 7642, 13, 6130, 8166, 264, 363, 20527, 2564, 307, 1596, 2199, 13, 509], "temperature": 0.0, "avg_logprob": -0.1920371262923531, "compression_ratio": 1.6431924882629108, "no_speech_prob": 3.684752664412372e-05}, {"id": 157, "seek": 109172, "start": 1107.4, "end": 1113.1200000000001, "text": " use the load BTF command in the BTF syscall or the BTF syscall, give it the blob that", "tokens": [764, 264, 3677, 363, 20527, 5622, 294, 264, 363, 20527, 262, 749, 45459, 420, 264, 363, 20527, 262, 749, 45459, 11, 976, 309, 264, 46115, 300], "temperature": 0.0, "avg_logprob": -0.1920371262923531, "compression_ratio": 1.6431924882629108, "no_speech_prob": 3.684752664412372e-05}, {"id": 158, "seek": 109172, "start": 1113.1200000000001, "end": 1119.72, "text": " we have. It needs to be slightly changed, especially for the data size, the data section", "tokens": [321, 362, 13, 467, 2203, 281, 312, 4748, 3105, 11, 2318, 337, 264, 1412, 2744, 11, 264, 1412, 3541], "temperature": 0.0, "avg_logprob": -0.1920371262923531, "compression_ratio": 1.6431924882629108, "no_speech_prob": 3.684752664412372e-05}, {"id": 159, "seek": 111972, "start": 1119.72, "end": 1129.28, "text": " type, but that's more details to explain exactly why, and a bunch of logging information.", "tokens": [2010, 11, 457, 300, 311, 544, 4365, 281, 2903, 2293, 983, 11, 293, 257, 3840, 295, 27991, 1589, 13], "temperature": 0.0, "avg_logprob": -0.1682495096678375, "compression_ratio": 1.5844748858447488, "no_speech_prob": 4.3945005018031225e-05}, {"id": 160, "seek": 111972, "start": 1129.28, "end": 1133.4, "text": " Once you have it, we get a file descriptor of the BTF object, and of course we have", "tokens": [3443, 291, 362, 309, 11, 321, 483, 257, 3991, 31280, 284, 295, 264, 363, 20527, 2657, 11, 293, 295, 1164, 321, 362], "temperature": 0.0, "avg_logprob": -0.1682495096678375, "compression_ratio": 1.5844748858447488, "no_speech_prob": 4.3945005018031225e-05}, {"id": 161, "seek": 111972, "start": 1133.4, "end": 1140.48, "text": " all of these type IDs. So when we are loading our map again, there are these fields where", "tokens": [439, 295, 613, 2010, 48212, 13, 407, 562, 321, 366, 15114, 527, 4471, 797, 11, 456, 366, 613, 7909, 689], "temperature": 0.0, "avg_logprob": -0.1682495096678375, "compression_ratio": 1.5844748858447488, "no_speech_prob": 4.3945005018031225e-05}, {"id": 162, "seek": 111972, "start": 1140.48, "end": 1145.16, "text": " you can say, this is my BTF object, which contains all of my types, and this is the", "tokens": [291, 393, 584, 11, 341, 307, 452, 363, 20527, 2657, 11, 597, 8306, 439, 295, 452, 3467, 11, 293, 341, 307, 264], "temperature": 0.0, "avg_logprob": -0.1682495096678375, "compression_ratio": 1.5844748858447488, "no_speech_prob": 4.3945005018031225e-05}, {"id": 163, "seek": 114516, "start": 1145.16, "end": 1151.68, "text": " type of my key, this is the type of my value, that's how we wire everything together.", "tokens": [2010, 295, 452, 2141, 11, 341, 307, 264, 2010, 295, 452, 2158, 11, 300, 311, 577, 321, 6234, 1203, 1214, 13], "temperature": 0.0, "avg_logprob": -0.15681563483344185, "compression_ratio": 1.688118811881188, "no_speech_prob": 3.071150422329083e-05}, {"id": 164, "seek": 114516, "start": 1151.68, "end": 1156.6000000000001, "text": " The same goes for programs. So we give it the program, the BTF of the program uses,", "tokens": [440, 912, 1709, 337, 4268, 13, 407, 321, 976, 309, 264, 1461, 11, 264, 363, 20527, 295, 264, 1461, 4960, 11], "temperature": 0.0, "avg_logprob": -0.15681563483344185, "compression_ratio": 1.688118811881188, "no_speech_prob": 3.071150422329083e-05}, {"id": 165, "seek": 114516, "start": 1156.6000000000001, "end": 1164.3200000000002, "text": " and then we give it these file, these func information, line information blobs, which", "tokens": [293, 550, 321, 976, 309, 613, 3991, 11, 613, 1019, 66, 1589, 11, 1622, 1589, 1749, 929, 11, 597], "temperature": 0.0, "avg_logprob": -0.15681563483344185, "compression_ratio": 1.688118811881188, "no_speech_prob": 3.071150422329083e-05}, {"id": 166, "seek": 114516, "start": 1164.3200000000002, "end": 1170.24, "text": " will make sure that everything is nice and annotated in the kernel. So we end up with", "tokens": [486, 652, 988, 300, 1203, 307, 1481, 293, 25339, 770, 294, 264, 28256, 13, 407, 321, 917, 493, 365], "temperature": 0.0, "avg_logprob": -0.15681563483344185, "compression_ratio": 1.688118811881188, "no_speech_prob": 3.071150422329083e-05}, {"id": 167, "seek": 117024, "start": 1170.24, "end": 1176.16, "text": " a sort of hierarchy that looks like this. So we start by loading the BTF, we can then", "tokens": [257, 1333, 295, 22333, 300, 1542, 411, 341, 13, 407, 321, 722, 538, 15114, 264, 363, 20527, 11, 321, 393, 550], "temperature": 0.0, "avg_logprob": -0.17479326074773616, "compression_ratio": 1.6935483870967742, "no_speech_prob": 5.13601626153104e-05}, {"id": 168, "seek": 117024, "start": 1176.16, "end": 1180.76, "text": " load our maps, which use it, and then once we have our map file descriptors, we can load", "tokens": [3677, 527, 11317, 11, 597, 764, 309, 11, 293, 550, 1564, 321, 362, 527, 4471, 3991, 31280, 830, 11, 321, 393, 3677], "temperature": 0.0, "avg_logprob": -0.17479326074773616, "compression_ratio": 1.6935483870967742, "no_speech_prob": 5.13601626153104e-05}, {"id": 169, "seek": 117024, "start": 1180.76, "end": 1186.92, "text": " our programs after we have of course assembled all of the pieces of our program. And that", "tokens": [527, 4268, 934, 321, 362, 295, 1164, 24204, 439, 295, 264, 3755, 295, 527, 1461, 13, 400, 300], "temperature": 0.0, "avg_logprob": -0.17479326074773616, "compression_ratio": 1.6935483870967742, "no_speech_prob": 5.13601626153104e-05}, {"id": 170, "seek": 117024, "start": 1186.92, "end": 1192.08, "text": " all happens, can happen within one call to a loader library.", "tokens": [439, 2314, 11, 393, 1051, 1951, 472, 818, 281, 257, 3677, 260, 6405, 13], "temperature": 0.0, "avg_logprob": -0.17479326074773616, "compression_ratio": 1.6935483870967742, "no_speech_prob": 5.13601626153104e-05}, {"id": 171, "seek": 117024, "start": 1192.08, "end": 1199.0, "text": " Now for the last part, the core, which I touched on a little bit earlier, like I said, compile", "tokens": [823, 337, 264, 1036, 644, 11, 264, 4965, 11, 597, 286, 9828, 322, 257, 707, 857, 3071, 11, 411, 286, 848, 11, 31413], "temperature": 0.0, "avg_logprob": -0.17479326074773616, "compression_ratio": 1.6935483870967742, "no_speech_prob": 5.13601626153104e-05}, {"id": 172, "seek": 119900, "start": 1199.0, "end": 1205.32, "text": " once, run everywhere. There's this really good blog post for, which I encourage everyone", "tokens": [1564, 11, 1190, 5315, 13, 821, 311, 341, 534, 665, 6968, 2183, 337, 11, 597, 286, 5373, 1518], "temperature": 0.0, "avg_logprob": -0.20072389685589334, "compression_ratio": 1.6008771929824561, "no_speech_prob": 8.804595563560724e-05}, {"id": 173, "seek": 119900, "start": 1205.32, "end": 1212.96, "text": " who wants to use the feature, which contains information on how to actually use it. But", "tokens": [567, 2738, 281, 764, 264, 4111, 11, 597, 8306, 1589, 322, 577, 281, 767, 764, 309, 13, 583], "temperature": 0.0, "avg_logprob": -0.20072389685589334, "compression_ratio": 1.6008771929824561, "no_speech_prob": 8.804595563560724e-05}, {"id": 174, "seek": 119900, "start": 1212.96, "end": 1220.84, "text": " what it boils down to is there are in LibBPF, there are these macros to make your life easier,", "tokens": [437, 309, 35049, 760, 281, 307, 456, 366, 294, 15834, 33, 47, 37, 11, 456, 366, 613, 7912, 2635, 281, 652, 428, 993, 3571, 11], "temperature": 0.0, "avg_logprob": -0.20072389685589334, "compression_ratio": 1.6008771929824561, "no_speech_prob": 8.804595563560724e-05}, {"id": 175, "seek": 119900, "start": 1220.84, "end": 1226.88, "text": " and they boil down to a bunch of compiler built-ins. And they're basically, they're basically", "tokens": [293, 436, 13329, 760, 281, 257, 3840, 295, 31958, 3094, 12, 1292, 13, 400, 436, 434, 1936, 11, 436, 434, 1936], "temperature": 0.0, "avg_logprob": -0.20072389685589334, "compression_ratio": 1.6008771929824561, "no_speech_prob": 8.804595563560724e-05}, {"id": 176, "seek": 122688, "start": 1226.88, "end": 1234.72, "text": " questions to ask the loader just before, or the kernel just before, or while loading", "tokens": [1651, 281, 1029, 264, 3677, 260, 445, 949, 11, 420, 264, 28256, 445, 949, 11, 420, 1339, 15114], "temperature": 0.0, "avg_logprob": -0.14652912513069485, "compression_ratio": 1.7586206896551724, "no_speech_prob": 8.657692524138838e-05}, {"id": 177, "seek": 122688, "start": 1234.72, "end": 1239.8000000000002, "text": " the program. Like, where does, where is, what is the offset of this field? Where does this", "tokens": [264, 1461, 13, 1743, 11, 689, 775, 11, 689, 307, 11, 437, 307, 264, 18687, 295, 341, 2519, 30, 2305, 775, 341], "temperature": 0.0, "avg_logprob": -0.14652912513069485, "compression_ratio": 1.7586206896551724, "no_speech_prob": 8.657692524138838e-05}, {"id": 178, "seek": 122688, "start": 1239.8000000000002, "end": 1248.0, "text": " type even exist? Do I have this enum value? I have this small program that writes, that", "tokens": [2010, 754, 2514, 30, 1144, 286, 362, 341, 465, 449, 2158, 30, 286, 362, 341, 1359, 1461, 300, 13657, 11, 300], "temperature": 0.0, "avg_logprob": -0.14652912513069485, "compression_ratio": 1.7586206896551724, "no_speech_prob": 8.657692524138838e-05}, {"id": 179, "seek": 122688, "start": 1248.0, "end": 1254.64, "text": " writes values to, or that captures a certain, or the cookie value of a socket when it closes.", "tokens": [13657, 4190, 281, 11, 420, 300, 27986, 257, 1629, 11, 420, 264, 14417, 2158, 295, 257, 19741, 562, 309, 24157, 13], "temperature": 0.0, "avg_logprob": -0.14652912513069485, "compression_ratio": 1.7586206896551724, "no_speech_prob": 8.657692524138838e-05}, {"id": 180, "seek": 125464, "start": 1254.64, "end": 1262.76, "text": " Not useful at all, but it does help us to illustrate the point. When this macro resolves,", "tokens": [1726, 4420, 412, 439, 11, 457, 309, 775, 854, 505, 281, 23221, 264, 935, 13, 1133, 341, 18887, 7923, 977, 11], "temperature": 0.0, "avg_logprob": -0.12702757312405494, "compression_ratio": 1.6729857819905214, "no_speech_prob": 0.0001422866334905848}, {"id": 181, "seek": 125464, "start": 1262.76, "end": 1269.96, "text": " it looks like this, and the important part to notice here is that we do a helper call,", "tokens": [309, 1542, 411, 341, 11, 293, 264, 1021, 644, 281, 3449, 510, 307, 300, 321, 360, 257, 36133, 818, 11], "temperature": 0.0, "avg_logprob": -0.12702757312405494, "compression_ratio": 1.6729857819905214, "no_speech_prob": 0.0001422866334905848}, {"id": 182, "seek": 125464, "start": 1269.96, "end": 1275.68, "text": " and where the arrow starts, we have the socket pointer, and we have an offset, and we add", "tokens": [293, 689, 264, 11610, 3719, 11, 321, 362, 264, 19741, 23918, 11, 293, 321, 362, 364, 18687, 11, 293, 321, 909], "temperature": 0.0, "avg_logprob": -0.12702757312405494, "compression_ratio": 1.6729857819905214, "no_speech_prob": 0.0001422866334905848}, {"id": 183, "seek": 125464, "start": 1275.68, "end": 1283.96, "text": " an offset, which we get from this built-in function. This offset is then encoded, gets", "tokens": [364, 18687, 11, 597, 321, 483, 490, 341, 3094, 12, 259, 2445, 13, 639, 18687, 307, 550, 2058, 12340, 11, 2170], "temperature": 0.0, "avg_logprob": -0.12702757312405494, "compression_ratio": 1.6729857819905214, "no_speech_prob": 0.0001422866334905848}, {"id": 184, "seek": 128396, "start": 1283.96, "end": 1289.08, "text": " encoded in the 104 that we see here. This is this offset that we add to the pointer in", "tokens": [2058, 12340, 294, 264, 47757, 300, 321, 536, 510, 13, 639, 307, 341, 18687, 300, 321, 909, 281, 264, 23918, 294], "temperature": 0.0, "avg_logprob": -0.14820130327914624, "compression_ratio": 1.6529680365296804, "no_speech_prob": 3.1545299862045795e-05}, {"id": 185, "seek": 128396, "start": 1289.08, "end": 1295.4, "text": " the actual code. But the compiler will also emit this relocation, which will tell us that", "tokens": [264, 3539, 3089, 13, 583, 264, 31958, 486, 611, 32084, 341, 26981, 399, 11, 597, 486, 980, 505, 300], "temperature": 0.0, "avg_logprob": -0.14820130327914624, "compression_ratio": 1.6529680365296804, "no_speech_prob": 3.1545299862045795e-05}, {"id": 186, "seek": 128396, "start": 1295.4, "end": 1301.6000000000001, "text": " this might be a piece of the code that we want to tweak, depending on if the structure changes.", "tokens": [341, 1062, 312, 257, 2522, 295, 264, 3089, 300, 321, 528, 281, 29879, 11, 5413, 322, 498, 264, 3877, 2962, 13], "temperature": 0.0, "avg_logprob": -0.14820130327914624, "compression_ratio": 1.6529680365296804, "no_speech_prob": 3.1545299862045795e-05}, {"id": 187, "seek": 128396, "start": 1301.6000000000001, "end": 1306.72, "text": " So if we again look at this relocation, there, unfortunately, as far as I'm aware, is not", "tokens": [407, 498, 321, 797, 574, 412, 341, 26981, 399, 11, 456, 11, 7015, 11, 382, 1400, 382, 286, 478, 3650, 11, 307, 406], "temperature": 0.0, "avg_logprob": -0.14820130327914624, "compression_ratio": 1.6529680365296804, "no_speech_prob": 3.1545299862045795e-05}, {"id": 188, "seek": 130672, "start": 1306.72, "end": 1314.6000000000001, "text": " a good command line tool to visualize or to decode this, so I decoded one manually. It", "tokens": [257, 665, 5622, 1622, 2290, 281, 23273, 420, 281, 979, 1429, 341, 11, 370, 286, 979, 12340, 472, 16945, 13, 467], "temperature": 0.0, "avg_logprob": -0.1597568924362595, "compression_ratio": 1.8227848101265822, "no_speech_prob": 4.0303646528627723e-05}, {"id": 189, "seek": 130672, "start": 1314.6000000000001, "end": 1318.16, "text": " looks like this, so it says, okay, instruction number two, which is the instruction that", "tokens": [1542, 411, 341, 11, 370, 309, 1619, 11, 1392, 11, 10951, 1230, 732, 11, 597, 307, 264, 10951, 300], "temperature": 0.0, "avg_logprob": -0.1597568924362595, "compression_ratio": 1.8227848101265822, "no_speech_prob": 4.0303646528627723e-05}, {"id": 190, "seek": 130672, "start": 1318.16, "end": 1324.72, "text": " we were, that we were at. Instruction number two refers to type ID 18, and it has this", "tokens": [321, 645, 11, 300, 321, 645, 412, 13, 2730, 3826, 1230, 732, 14942, 281, 2010, 7348, 2443, 11, 293, 309, 575, 341], "temperature": 0.0, "avg_logprob": -0.1597568924362595, "compression_ratio": 1.8227848101265822, "no_speech_prob": 4.0303646528627723e-05}, {"id": 191, "seek": 130672, "start": 1324.72, "end": 1329.0, "text": " accessor string. And this accessor string is a bunch of numbers, which is basically", "tokens": [2105, 284, 6798, 13, 400, 341, 2105, 284, 6798, 307, 257, 3840, 295, 3547, 11, 597, 307, 1936], "temperature": 0.0, "avg_logprob": -0.1597568924362595, "compression_ratio": 1.8227848101265822, "no_speech_prob": 4.0303646528627723e-05}, {"id": 192, "seek": 130672, "start": 1329.0, "end": 1335.44, "text": " offsets like the field number that it tries to access. So the socket, then the second", "tokens": [39457, 1385, 411, 264, 2519, 1230, 300, 309, 9898, 281, 2105, 13, 407, 264, 19741, 11, 550, 264, 1150], "temperature": 0.0, "avg_logprob": -0.1597568924362595, "compression_ratio": 1.8227848101265822, "no_speech_prob": 4.0303646528627723e-05}, {"id": 193, "seek": 133544, "start": 1335.44, "end": 1344.88, "text": " field would be sk-common, and then cookie, and so forth. Now, this type information that", "tokens": [2519, 576, 312, 1110, 12, 1112, 3317, 11, 293, 550, 14417, 11, 293, 370, 5220, 13, 823, 11, 341, 2010, 1589, 300], "temperature": 0.0, "avg_logprob": -0.20668167816965202, "compression_ratio": 1.5195530726256983, "no_speech_prob": 9.237718768417835e-05}, {"id": 194, "seek": 133544, "start": 1344.88, "end": 1350.68, "text": " we knew when we created the program is included in the btf section. But the kernel also has", "tokens": [321, 2586, 562, 321, 2942, 264, 1461, 307, 5556, 294, 264, 272, 83, 69, 3541, 13, 583, 264, 28256, 611, 575], "temperature": 0.0, "avg_logprob": -0.20668167816965202, "compression_ratio": 1.5195530726256983, "no_speech_prob": 9.237718768417835e-05}, {"id": 195, "seek": 133544, "start": 1350.68, "end": 1360.56, "text": " btf types for all of its types it has. So we can do a comparison and see that, for example,", "tokens": [272, 83, 69, 3467, 337, 439, 295, 1080, 3467, 309, 575, 13, 407, 321, 393, 360, 257, 9660, 293, 536, 300, 11, 337, 1365, 11], "temperature": 0.0, "avg_logprob": -0.20668167816965202, "compression_ratio": 1.5195530726256983, "no_speech_prob": 9.237718768417835e-05}, {"id": 196, "seek": 136056, "start": 1360.56, "end": 1368.04, "text": " it changed position, or we can't find a certain field. And our loader can do this, can resolve", "tokens": [309, 3105, 2535, 11, 420, 321, 393, 380, 915, 257, 1629, 2519, 13, 400, 527, 3677, 260, 393, 360, 341, 11, 393, 14151], "temperature": 0.0, "avg_logprob": -0.1488376973749517, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.00014057800581213087}, {"id": 197, "seek": 136056, "start": 1368.04, "end": 1375.2, "text": " this, see it, and then patch our code, change this offset value right before we actually", "tokens": [341, 11, 536, 309, 11, 293, 550, 9972, 527, 3089, 11, 1319, 341, 18687, 2158, 558, 949, 321, 767], "temperature": 0.0, "avg_logprob": -0.1488376973749517, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.00014057800581213087}, {"id": 198, "seek": 136056, "start": 1375.2, "end": 1380.6399999999999, "text": " load it, which makes it possible to use it on so many different kernel versions. I'm", "tokens": [3677, 309, 11, 597, 1669, 309, 1944, 281, 764, 309, 322, 370, 867, 819, 28256, 9606, 13, 286, 478], "temperature": 0.0, "avg_logprob": -0.1488376973749517, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.00014057800581213087}, {"id": 199, "seek": 136056, "start": 1380.6399999999999, "end": 1388.36, "text": " out of time. That's everything I can offer you for now. Are there any questions? And", "tokens": [484, 295, 565, 13, 663, 311, 1203, 286, 393, 2626, 291, 337, 586, 13, 2014, 456, 604, 1651, 30, 400], "temperature": 0.0, "avg_logprob": -0.1488376973749517, "compression_ratio": 1.5619469026548674, "no_speech_prob": 0.00014057800581213087}, {"id": 200, "seek": 138836, "start": 1388.36, "end": 1404.12, "text": " thank you. Thank you. Any questions? There's one in the back. All right, okay. It's difficult", "tokens": [1309, 291, 13, 1044, 291, 13, 2639, 1651, 30, 821, 311, 472, 294, 264, 646, 13, 1057, 558, 11, 1392, 13, 467, 311, 2252], "temperature": 0.0, "avg_logprob": -0.20842392104012625, "compression_ratio": 1.0689655172413792, "no_speech_prob": 0.0011892536422237754}, {"id": 201, "seek": 140412, "start": 1404.12, "end": 1418.3999999999999, "text": " now. Can you pass this on? Hey, thanks for the great talk. So I haven't", "tokens": [586, 13, 1664, 291, 1320, 341, 322, 30, 1911, 11, 3231, 337, 264, 869, 751, 13, 407, 286, 2378, 380], "temperature": 0.0, "avg_logprob": -0.13794976386471072, "compression_ratio": 1.4101123595505618, "no_speech_prob": 0.0005944266449660063}, {"id": 202, "seek": 140412, "start": 1418.3999999999999, "end": 1424.6399999999999, "text": " dealt that much with btf, but since we have those binaries that we cannot really launch", "tokens": [15991, 300, 709, 365, 272, 83, 69, 11, 457, 1670, 321, 362, 729, 5171, 4889, 300, 321, 2644, 534, 4025], "temperature": 0.0, "avg_logprob": -0.13794976386471072, "compression_ratio": 1.4101123595505618, "no_speech_prob": 0.0005944266449660063}, {"id": 203, "seek": 140412, "start": 1424.6399999999999, "end": 1430.6, "text": " because we have to load them in another elf, right? At least as I understand. Would it make", "tokens": [570, 321, 362, 281, 3677, 552, 294, 1071, 35565, 11, 558, 30, 1711, 1935, 382, 286, 1223, 13, 6068, 309, 652], "temperature": 0.0, "avg_logprob": -0.13794976386471072, "compression_ratio": 1.4101123595505618, "no_speech_prob": 0.0005944266449660063}, {"id": 204, "seek": 143060, "start": 1430.6, "end": 1438.76, "text": " any sense to make either a loader that would just work out of the box for those binaries", "tokens": [604, 2020, 281, 652, 2139, 257, 3677, 260, 300, 576, 445, 589, 484, 295, 264, 2424, 337, 729, 5171, 4889], "temperature": 0.0, "avg_logprob": -0.2639827996912137, "compression_ratio": 1.60625, "no_speech_prob": 0.00039337255293503404}, {"id": 205, "seek": 143060, "start": 1438.76, "end": 1449.12, "text": " or use the bnfmtm-misk feature from the kernel to be able to load those btf elf files and", "tokens": [420, 764, 264, 272, 77, 69, 42744, 76, 12, 76, 7797, 4111, 490, 264, 28256, 281, 312, 1075, 281, 3677, 729, 272, 83, 69, 35565, 7098, 293], "temperature": 0.0, "avg_logprob": -0.2639827996912137, "compression_ratio": 1.60625, "no_speech_prob": 0.00039337255293503404}, {"id": 206, "seek": 143060, "start": 1449.12, "end": 1455.12, "text": " use some kind of generic or general interface and just load them and run them?", "tokens": [764, 512, 733, 295, 19577, 420, 2674, 9226, 293, 445, 3677, 552, 293, 1190, 552, 30], "temperature": 0.0, "avg_logprob": -0.2639827996912137, "compression_ratio": 1.60625, "no_speech_prob": 0.00039337255293503404}, {"id": 207, "seek": 145512, "start": 1455.12, "end": 1464.6399999999999, "text": " Yeah, but I think it does make sense to some extent. For example, the IP tool doesn't have", "tokens": [865, 11, 457, 286, 519, 309, 775, 652, 2020, 281, 512, 8396, 13, 1171, 1365, 11, 264, 8671, 2290, 1177, 380, 362], "temperature": 0.0, "avg_logprob": -0.1237859421588005, "compression_ratio": 1.5764192139737991, "no_speech_prob": 6.468538049375638e-05}, {"id": 208, "seek": 145512, "start": 1464.6399999999999, "end": 1471.8, "text": " anything additional, so it takes this elf and just loads it as best as it can. And there", "tokens": [1340, 4497, 11, 370, 309, 2516, 341, 35565, 293, 445, 12668, 309, 382, 1151, 382, 309, 393, 13, 400, 456], "temperature": 0.0, "avg_logprob": -0.1237859421588005, "compression_ratio": 1.5764192139737991, "no_speech_prob": 6.468538049375638e-05}, {"id": 209, "seek": 145512, "start": 1471.8, "end": 1478.12, "text": " is probably some way to use the interpreter in the elf itself, just like we do for dynamically", "tokens": [307, 1391, 512, 636, 281, 764, 264, 34132, 294, 264, 35565, 2564, 11, 445, 411, 321, 360, 337, 43492], "temperature": 0.0, "avg_logprob": -0.1237859421588005, "compression_ratio": 1.5764192139737991, "no_speech_prob": 6.468538049375638e-05}, {"id": 210, "seek": 145512, "start": 1478.12, "end": 1483.84, "text": " loaded executables. As far as I know, no one has tried it so far, but I think it could", "tokens": [13210, 7568, 2965, 13, 1018, 1400, 382, 286, 458, 11, 572, 472, 575, 3031, 309, 370, 1400, 11, 457, 286, 519, 309, 727], "temperature": 0.0, "avg_logprob": -0.1237859421588005, "compression_ratio": 1.5764192139737991, "no_speech_prob": 6.468538049375638e-05}, {"id": 211, "seek": 148384, "start": 1483.84, "end": 1490.6, "text": " work at least for a limited use case where you don't have to, where you would only load", "tokens": [589, 412, 1935, 337, 257, 5567, 764, 1389, 689, 291, 500, 380, 362, 281, 11, 689, 291, 576, 787, 3677], "temperature": 0.0, "avg_logprob": -0.1982322335243225, "compression_ratio": 1.5311004784688995, "no_speech_prob": 0.0001045486205839552}, {"id": 212, "seek": 148384, "start": 1490.6, "end": 1496.8, "text": " something and pin it and then allow some other application to actually work with it afterwards.", "tokens": [746, 293, 5447, 309, 293, 550, 2089, 512, 661, 3861, 281, 767, 589, 365, 309, 10543, 13], "temperature": 0.0, "avg_logprob": -0.1982322335243225, "compression_ratio": 1.5311004784688995, "no_speech_prob": 0.0001045486205839552}, {"id": 213, "seek": 148384, "start": 1496.8, "end": 1500.1599999999999, "text": " Thank you. All right, thanks. We are out of time.", "tokens": [1044, 291, 13, 1057, 558, 11, 3231, 13, 492, 366, 484, 295, 565, 13], "temperature": 0.0, "avg_logprob": -0.1982322335243225, "compression_ratio": 1.5311004784688995, "no_speech_prob": 0.0001045486205839552}, {"id": 214, "seek": 150016, "start": 1500.16, "end": 1515.0400000000002, "text": " If you have more questions, you can find Dylan in the hallway. And yeah, thanks again.", "tokens": [50364, 759, 291, 362, 544, 1651, 11, 291, 393, 915, 28160, 294, 264, 23903, 13, 400, 1338, 11, 3231, 797, 13, 51108], "temperature": 0.0, "avg_logprob": -0.2762201972629713, "compression_ratio": 1.036144578313253, "no_speech_prob": 0.0007011743728071451}], "language": "en"}