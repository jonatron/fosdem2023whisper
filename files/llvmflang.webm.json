{"text": " Alright, we are going to start next talk. Next up, we have Kiran. Kiran will give us an update on flight. Hello everyone. As Christoph introduced, I'm Kiran. I work at ARM in the Fortran compiler team and today the task for me today is to give you all an update about the progress we have made with the flying development. This slide shows the contents of my presentation today. It's fairly simple. First, I start with an overview of the flying compiler. Then I give you a summary of the story, whatever has happened so far. Then I provide you with the status of the compiler. Finally, I identify a few of the major development efforts going on currently. This slide shows in brief the overview of the flying compiler. Flying is a new Fortran frontend developed from scratch. It has a traditional compiler flow. It's an LLVM based Fortran frontend. It's actually the Fortran frontend of LLVM. It generates LLVM IR, but it has a difference with the other frontend in the LLVM project Clang. While Clang lowers from the AST to LLVM IR, flying uses a high level intermediate representation called Fortran IR or FIR. That's what flying generates. It uses the MLIR infrastructure for FIR and MLIR interfaces with LLVM through the LLVM dialect. FIIR is converted to LLVM dialect and then the LLVM pipeline kicks in. This is basically the diagram that I have on the left hand side. Given a Fortran program, there is some parsing and semantic checks that happen. Finally, you get a flying pass tree that's fairly well defined. Then that code is lowered into Fortran IR and calls to the runtime. Then the Fortran IR is converted to the LLVM dialect. This slide summarizes the story so far with the flying compiler. Looking at the slide, this project started in 2018. It was during Euro LLVM 2018 that news about this compiler start to come out that there is a new Fortran frontend being written from scratch. One year later in April 2019, the project was accepted as the Fortran frontend of LLVM. Again, one year later in 2020, it was merged into the LLVM project as LLVM flying. When this happened, there was some code that was left behind. The project actually split into two repositories. The first one in the LLVM project, where the parsing and semantic checks and the code for the runtime was there. All the code that lowers from the parse tree to the Fortran IR got left behind because it was not ready at that time. It began to take a life of its own. People had to now sync these two repositories, sometimes commit to both two repositories, and you have all the overhead of maintaining a downstream project. Fortunately, sometime in April 2022, people decided to freeze all the downstream development and pushed all the code into upstream. Sometime in July 2022, this whole code is now in the LLVM project repository. Since then, the project has mostly followed the LLVM contributions process, and all the social guidelines are associated with it. When it was merged into LLVM, it was mostly a Fortran 95 compiler, but there were still a few missing pieces. The code was stabilized further, and all unknown features were marked with to-dos, so that if you try to compile an unsupported feature, it will give a message saying that this feature is not supported rather than giving a crash. At the same time, development has continued to support newer standards, newer Fortran standards features like features from Fortran 2003, Fortran 2008, and things like that. Also a lot of bug fixes went in, as well as people started to look at some performance work as well. This slide summarizes the current status of the compiler. The compiler is not yet ready for general use, but it is still fairly advanced in its support for various Fortran constructs. The driver is temporarily called flying new, and executables can be generated, but you have to use an option called flying experimental exec. The feature development of Fortran 95 is mostly complete, and as I mentioned before, development of Fortran 2003 and later features are in progress. The compiler has been tested with various commercial and free test feeds. It has also been verified with some HPC benchmarks like SNAP, Cloverleaf. We have also used the spec benchmarks to test it. We are also continuing to test it with other benchmarks like the OpenMP version of spec, other open source applications like open radios, and things like that. This driver's name was flying new, and the use of the experimental flag is currently being discussed. It is possible that those requirements will go away soon, and then people can just type flying to compile their application. There is a discourse thread on that currently under discussion. This slide summarizes the support level of flying for various Fortran standards. Fortran is a living language. As you can see, it has gone through a lot of revisions. There is another revision that is going to come in this year and one later in this decade. It is a living language, and it is continuing to make progress, adding new features and things like that, but it makes the job of the compiler engineers much harder because you are always trying to catch up. The initial standard that we track is 77, and the development work is complete. Fortran 95, as I mentioned before, is complete except for a few bits here and there. Work on 2003 is in progress, particularly on polymorphic types, but the parsing semantics and runtime mostly works. Similarly, with Fortran 2008 as well, parsing semantics and runtime works, but some of the features are in progress. Whereas, when you come to Fortran 2018, none of the lowering or codes and work has happened yet. Whereas, the parser and semantics and runtime should work fine for this code, modulo n e bux. Now, I have said that the compiler is able to compile a lot of Fortran code. How does the performance look like? This slide gives you a summary of where this compiler stands with respect to other compilers. The benchmark I have used for this slide is the respect 2017 benchmark, and all the Fortran benchmarks from that, either Fortran or mixed Fortran. I have compared it with the two compilers. One is the G Fortran 12 version, and the other one is the compiler called classic flank. There is a compiler that is previously open sourced by PGI, and that is actually the Fortran front end of many of the existing commercial compilers like AMD's, ARM's and Huawei's. So, I have compared it with both these compilers, and what I have at the bottom here is the geometric mean, if you consider the performance of all the benchmarks in this suite. So, you can see that compared to G Fortran, we are around 1.5 times the runtime it takes in flank, whereas compared to classic flank, it is around 1.38. So, for some of the benchmarks, we are mostly on par, but for some of the other benchmarks, there is still some work to be done. The comments column basically summarizes what are probably the issues that are there that causes this performance difference. Some of them are familiar things like alias analysis, the other things like intrinsic in lining and function specialization. Fortran has a lot of intrinsic functions. So, generally these are all implemented in the runtime. Because you have a lot of these intrinsics, the runtime is many times written in a generic fashion. So, you might not get the performance if you call the runtime function. Also, for simple arrays and all, it does not make much sense to incur the overhead, particularly if that function is being called in a loop or something like that. So, many times it is good to inline that code. So, in benchmarks like exchange too, there are a lot of functions like count, sum and any mean lock and all. That can be possibly be inline to get more performance. And exchange too happens to be one benchmark where if you have performed function specialization, you get much benefits. So, function specialization is a process where if you know the arguments to the function, you can generate a specialized version of that function based on the known parameters value. There are also other issues mostly associated with how arrays are handled in Fortran. So, by the definition of or how the standard interprets arrays in Fortran or array expressions in Fortran is that there is always a temporary associated with it. But when we generate code, if there are a lot of temporaries, you know a lot of work, a lot of time is consumed just for copying these arrays from one version to another. So, in many cases these copies can be optimized away, but we do not do a good job about it and that is what is causing this performance issue. So, few engineers have been working on this for some time now. A few months back, we were around 2x, but we are closing the gap you know as fast as possible. So, now in this slide, in the following slides, I summarize some of the major development efforts. So, I probably missed some of the efforts, but what I am going to summarize is first one is high level fare, that is a new dialect that is being written, that sits just above Fortran IR. I will come to the reason for that. Second one is I will try to have one or two slides about polymorphic types and how they are handled in flank. I look at some of the performance work that is being done. I briefly summarize the work that is done already and what are the work going on in open MP as well as the driver. So, when the compiler work started, the IR that we had is Fortran IR which represents a lot of the Fortran constructs, but what we found is that although it does model a lot of the Fortran constructs, there is still some gap between the Fortran source program and the Fortran IR. So, there is some information that is being lost like what are the variables in the source program, what were the annotations that were there on the variables and things like that and losing that meant that we might not be able to do some performance optimization. So, what people decided is that we need to, so that was one issue. The other issue was that the lowering was also proving to be a bit difficult because of the huge difference between the source and the IR. So, that is the reason why a new intermediate representation was introduced between Fortran IR and the source that is the HLFIR IR or the high level FIR. As I mentioned before, it enables optimizations and because it carries more information from the source, it is likely to generate better debug. So, this IR basically introduces two major concepts. One is that it models expressions that are not buffered. As I mentioned before, array expressions in Fortran generally involve temporary arrays and whenever we introduce that arrays into it or the buffers associated with it, it looks like a lot of low level code. Whereas, expressions that are not associated with these buffers are still higher level concepts. So, that if you have chains of intrinsic functions that operate on arrays, it is easy to do some kind of processing there to simplify those expressions. It also introduces the concept of variables. So, there is something, there is an operation in high level FIR called HLFIR variable which collects information about all the variables in a single place. So, that you know this is the variable and what its properties are. Some of these might be modeled by attributes like if you say that a Fortran variable is a pointer or allocatable that is marked as an attribute. It also identifies the shape of the array, you know if that is an array along with the memory associated with it. So, then the initial lowering will be from the Fortran source to a mix of high level FIR and FIR and then the high level FIR is converted again to FIR and then the rest of the pipeline kicks in as always. So, I would not be going into the details, but if people are interested there is a detail RFC you know inside the flying documents repository. But I will try to show you an example. So, this is the Fortran source code and what we have is a declaration of two arrays. The first array called Y is a two dimensional array, the second one is a single dimensional array and then we are summing all the rows or columns in the first array Y and storing it in the result array that is the array called S. I tried to put the FIR code for this in a slide, but it happened to be too much and it would not fit in one slide or two slides. So, I have just left the comments here whereas the source code is completely gone. So, you can see that there is some FIR aloca which allocates that array and the name of that variable was part of that aloca. You can also see that there is a call to the runtime for the sum function. You can see some comments that I mentioned there that the runtime calls and it allocates a buffer on the heap and then returns that and then that heap is copied to the real variable and the original heap is deallocated. Not much here, but if you come to the HLFIR you know you can actually fit that into a single slide because it models things at a higher level. So, the important difference to notice here is that there is an HLFIR declare that there are two HLFIR declares that declares the variables that are there in your program. So, you can see that there are two arrays S and Y they have a representation for that and instead of a runtime call you have an operation called HLFIR sum that actually returns something called an HLFIR expression. So, there is no buffer associated with it or the runtime is not called there is no memory allocated as of now and then that is assigned from the expression to the original variable that is a result array S. So, basically I just want to show that you know this is at a higher level it has some concepts called variables and it has also some things called expressions. I will now move on to polymorphic types. Polymorphic types came as part of the FORTRAN 2003 standard. The types are only known at runtime FORTRAN has the class type for specifying such a type. You know if you have a class type it can refer to either that type or any of the type that extends from it. So, extension is the name for the inheritance concept that is there in some other languages. Again I will not go into much details I have an example in the next slide, but if people are interested they can check this RFC. So, only the example that I have on the left hand side there is a type called point. We call it derived types in FORTRAN and then you have a three dimensional type it extends from point and basically it just adds another field to it. We have a class type that is called P3D and then you call this subroutine called foe and then this subroutine accepts it as a class type of the base type. Then there is a construct called select type in FORTRAN that you know that can at runtime identify which type it is. So, if its type is point 3D then something is printed, if its type is point something else is printed. So, the modeling mostly follows what is there in this code. We have something called the FIR type and that type has the ones in green are the extended type, the ones in red are the base type. You can see that there is a FIR class that has inside it FIR type and then you have this FIR select type construct which tries to match between the base type or the extended type and then it branches off to the basic blocks that handle it. It is basic block one for the extended type and they are basic block two for the base type. So, at runtime also when you generate further lower level code like LVM there will be some comparison instructions that compares whether it is that type. Types will probably be represented as structures that are global. So, you can compare with it to know what is the real type. So, next I move to alias analysis. So, alias analysis is important to distinguish between different arrays that can potentially alias as well as to say that two arrays cannot definitely alias. The rules of aliasing in Fortran is different from what is there in C and so you know we cannot directly reuse whatever is there in C. In general I mean there are exceptions and lot of other special cases. Arrays do not overlap unless you specify that you know some array is a pointer and another array is a target and then these two can overlap. Ideally we should benefit from the restrict patches that are being worked on, but that work is not yet complete. We also have some issues with pointer escape and all. That is all captured in this RFC by Slava. But we still need to do some kind of alias analysis because otherwise as we saw in some of the earlier slides where I show the performance results you know the performance is hampered by the lack of alias information in the LLVM optimizer. We probably have some more information at the fair level, but much of the optimization is currently delegated to LLVM. So, LLVM still needs that information to do the optimizations. So, as a first step what we have done is that you know we are trying to distinguish between accessing the descriptor versus accessing another memory. So, as I might have probably mentioned before Fortran has arrays and it does it is very good at arrays. So, sometimes to pass additional information you cannot just pass just a pointer. You might need to pass additional information like its rank or its you know starting dimension starting extents value or its ending low basically the lower bounds or upper bounds to see whether that array has a stride or not you know there are all these information that can be passed in the descriptor. The descriptor is generally modeled as a structure at the LLVM level. So, you have to go and fetch the contents from the descriptor by loading. Now, this load can potentially alias with other arrays if you directly load from that. So, we are trying to just distinguish these using alias analysis information using TBA. So, that is what we have on this slide. I do not know how clear it is, but then this is in the LLVM MLIR dialect not in the LLVM IR representation. So, we have this TBA information that is being generated here. So, if you know TBA it is mostly trees and if one node is an ancestor of the other node then they alias, but if they are in separate sub trace they do not alias. So, you can see that the ones in gray is any data access the ones in yellow is whether when you are accessing a descriptor member. And if you go back to the source code. So, what I have here is in the simple program is a subroutine. Subroutine is a procedure which does not return a value in Fortran. The two values A and B, A is an array and B is a scalar both of integer type. I am loading the value at the tenth location and putting in this putting in this variable B. And you can see that whenever we are accessing the descriptor that is in this case the descriptor is as access possibly for a stride. We use the TBA with the yellow color and whenever we access something related to B we use the one with the gray one. So, you can distinguish that these do not alias and sometimes when it is in loops we get some performance benefits. So, the next one is code gen of assume shape array arguments. So, as I have mentioned before Fortran has different kinds of arrays one is assume shape. What assume shape means is that you know if you have an argument it takes the shape of the array that you pass to it. So, you can have you can either pass it an array of you know you can either pass it an array of a non size or an unknown size and it will accept both of them. So, this causes some issues particularly because you know the arrays can also be strided. So, if the array is strided then if you have a loop that is working on that array you have to fetch consecutive elements from the array. If it is strided then you have to increment it by the stride and usually you have to load from the descriptor to find the stride. And then you set stride to find the next element. So, sometimes this can be modeled by you know scatter gather loads and stores, but sometimes it is not possible, but in many cases the stride is actually one you are actually passing a consecutive array. So, we can do some versioning. So, it is represented in high level source here if you have some input code like this an array there is an array called x and you are looping over it. Then you can create a version of it in if the stride is one do this if otherwise do this right. And then this side of the portion loop this side of the version becomes easier to optimize and vectorize. I just have two more slides I will probably just run through it. We are nearing open mp 1.1 completion there are still a few items to complete like privatization atomic reduction and detail testing, but a lot of other things are still going on in parallel there is basic support for task SIMD construct. We have been able to run it with some spec speed benchmarks and it works things in progress include target off loading it just started task dependencies and new loop related constructs. We also made a lot of progress with the driver it can now generate executables, but what is new is that we now handle target specification, fast math, MLIR level optimizations previously only LVM optimization over there now we can control MLIR optimizations as well as LVM pass plugins. People are continuing to work on LTO saving optimization records and supporting something called stack arrays. This final slide just says that you are all welcome to contribute to this project and the details of this are here. Thank you. Yeah, I mean as of now we do not have so the basically the question was that when you traverse across the various layers in MLIR and LVM IR is the debug information preserved. So, the whole concept of the HLFIR operation is to you know put that information somewhere in MLIR at the highest level and then we plan to propagate it further down. So, the HLFIR declare has a corresponding FIR declare it will lower to that and from the FIR declare when we convert to LVM we will just pass on that debug information, but debug support is quite early in flank as of now only function names and location numbers as supported, but also may be not by default it is just a pass separately running the code to add that the driver is still pending. Yes. Everything that since standard or some well known extensions are there, but it is a lot of dusty deck code is was tested with it, but I do not know whether the specific thing that you have in mind is supported or not you have to try out or look at the documentation. So, the question was whether old Fortran 77 code or legacy extensions are supported. So, I am trying to understand what needs to be done for open MP because open MP is a completely separate project right. Yeah. So, the question is what needs to be done separately for open MP. So, as far as open MP is concerned all the open MP work is mainly represented at the MLIR level by a separate dialect called the open MP dialect. Then that dialect sits in the main MLIR repository and from the source program when we generate it you know we create these additional operations for the open MP dialect and it has regions in MLIR. So, it can capture things like you know a parallel directive much better compared to LVM. So, roughly speaking open MP is a set of intrinsics more or less. I mean it is not as I mean intrinsic when you whenever you say it is kind of some kind of function, but these are MLIR operations right. So, if you have something called a parallel directive there is an operation in MLIR called omp.parallel and it might have lot of clauses like you know what is the you know threading model and things like that. So, all those information is captured at that level along with the code that comes in that parallel region and what we do actually now is that we are trying to share code with Clang. So, there is some code that is refactored from Clang and put into something called the open MP IR builder. So, when we lower it from this dialect to LVM we use that to generate the LVM IR. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 12.6, "text": " Alright, we are going to start next talk. Next up, we have Kiran. Kiran will give us", "tokens": [50364, 2798, 11, 321, 366, 516, 281, 722, 958, 751, 13, 3087, 493, 11, 321, 362, 11305, 282, 13, 11305, 282, 486, 976, 505, 50994], "temperature": 0.0, "avg_logprob": -0.3367395270360659, "compression_ratio": 1.4184782608695652, "no_speech_prob": 0.18336202204227448}, {"id": 1, "seek": 0, "start": 12.6, "end": 24.2, "text": " an update on flight. Hello everyone. As Christoph introduced, I'm Kiran. I work at ARM in", "tokens": [50994, 364, 5623, 322, 7018, 13, 2425, 1518, 13, 1018, 2040, 5317, 7268, 11, 286, 478, 11305, 282, 13, 286, 589, 412, 45209, 294, 51574], "temperature": 0.0, "avg_logprob": -0.3367395270360659, "compression_ratio": 1.4184782608695652, "no_speech_prob": 0.18336202204227448}, {"id": 2, "seek": 0, "start": 24.2, "end": 29.16, "text": " the Fortran compiler team and today the task for me today is to give you all an update", "tokens": [51574, 264, 11002, 4257, 31958, 1469, 293, 965, 264, 5633, 337, 385, 965, 307, 281, 976, 291, 439, 364, 5623, 51822], "temperature": 0.0, "avg_logprob": -0.3367395270360659, "compression_ratio": 1.4184782608695652, "no_speech_prob": 0.18336202204227448}, {"id": 3, "seek": 2916, "start": 29.16, "end": 36.64, "text": " about the progress we have made with the flying development. This slide shows the contents", "tokens": [50364, 466, 264, 4205, 321, 362, 1027, 365, 264, 7137, 3250, 13, 639, 4137, 3110, 264, 15768, 50738], "temperature": 0.0, "avg_logprob": -0.16072493160472195, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.028752531856298447}, {"id": 4, "seek": 2916, "start": 36.64, "end": 41.480000000000004, "text": " of my presentation today. It's fairly simple. First, I start with an overview of the flying", "tokens": [50738, 295, 452, 5860, 965, 13, 467, 311, 6457, 2199, 13, 2386, 11, 286, 722, 365, 364, 12492, 295, 264, 7137, 50980], "temperature": 0.0, "avg_logprob": -0.16072493160472195, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.028752531856298447}, {"id": 5, "seek": 2916, "start": 41.480000000000004, "end": 47.96, "text": " compiler. Then I give you a summary of the story, whatever has happened so far. Then", "tokens": [50980, 31958, 13, 1396, 286, 976, 291, 257, 12691, 295, 264, 1657, 11, 2035, 575, 2011, 370, 1400, 13, 1396, 51304], "temperature": 0.0, "avg_logprob": -0.16072493160472195, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.028752531856298447}, {"id": 6, "seek": 2916, "start": 47.96, "end": 55.28, "text": " I provide you with the status of the compiler. Finally, I identify a few of the major development", "tokens": [51304, 286, 2893, 291, 365, 264, 6558, 295, 264, 31958, 13, 6288, 11, 286, 5876, 257, 1326, 295, 264, 2563, 3250, 51670], "temperature": 0.0, "avg_logprob": -0.16072493160472195, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.028752531856298447}, {"id": 7, "seek": 5528, "start": 55.28, "end": 65.6, "text": " efforts going on currently. This slide shows in brief the overview of the flying compiler.", "tokens": [50364, 6484, 516, 322, 4362, 13, 639, 4137, 3110, 294, 5353, 264, 12492, 295, 264, 7137, 31958, 13, 50880], "temperature": 0.0, "avg_logprob": -0.12701321621330416, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.003026610938832164}, {"id": 8, "seek": 5528, "start": 65.6, "end": 70.6, "text": " Flying is a new Fortran frontend developed from scratch. It has a traditional compiler", "tokens": [50880, 34287, 307, 257, 777, 11002, 4257, 1868, 521, 4743, 490, 8459, 13, 467, 575, 257, 5164, 31958, 51130], "temperature": 0.0, "avg_logprob": -0.12701321621330416, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.003026610938832164}, {"id": 9, "seek": 5528, "start": 70.6, "end": 76.68, "text": " flow. It's an LLVM based Fortran frontend. It's actually the Fortran frontend of LLVM.", "tokens": [51130, 3095, 13, 467, 311, 364, 441, 43, 53, 44, 2361, 11002, 4257, 1868, 521, 13, 467, 311, 767, 264, 11002, 4257, 1868, 521, 295, 441, 43, 53, 44, 13, 51434], "temperature": 0.0, "avg_logprob": -0.12701321621330416, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.003026610938832164}, {"id": 10, "seek": 5528, "start": 76.68, "end": 82.76, "text": " It generates LLVM IR, but it has a difference with the other frontend in the LLVM project", "tokens": [51434, 467, 23815, 441, 43, 53, 44, 16486, 11, 457, 309, 575, 257, 2649, 365, 264, 661, 1868, 521, 294, 264, 441, 43, 53, 44, 1716, 51738], "temperature": 0.0, "avg_logprob": -0.12701321621330416, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.003026610938832164}, {"id": 11, "seek": 8276, "start": 82.80000000000001, "end": 90.12, "text": " Clang. While Clang lowers from the AST to LLVM IR, flying uses a high level intermediate", "tokens": [50366, 2033, 656, 13, 3987, 2033, 656, 44936, 490, 264, 316, 6840, 281, 441, 43, 53, 44, 16486, 11, 7137, 4960, 257, 1090, 1496, 19376, 50732], "temperature": 0.0, "avg_logprob": -0.21210863749186198, "compression_ratio": 1.4371584699453552, "no_speech_prob": 0.00046547988313250244}, {"id": 12, "seek": 8276, "start": 90.12, "end": 97.64, "text": " representation called Fortran IR or FIR. That's what flying generates. It uses the", "tokens": [50732, 10290, 1219, 11002, 4257, 16486, 420, 41538, 13, 663, 311, 437, 7137, 23815, 13, 467, 4960, 264, 51108], "temperature": 0.0, "avg_logprob": -0.21210863749186198, "compression_ratio": 1.4371584699453552, "no_speech_prob": 0.00046547988313250244}, {"id": 13, "seek": 8276, "start": 97.64, "end": 106.04, "text": " MLIR infrastructure for FIR and MLIR interfaces with LLVM through the LLVM dialect. FIIR is", "tokens": [51108, 21601, 7740, 6896, 337, 41538, 293, 21601, 7740, 28416, 365, 441, 43, 53, 44, 807, 264, 441, 43, 53, 44, 24652, 13, 479, 40, 7740, 307, 51528], "temperature": 0.0, "avg_logprob": -0.21210863749186198, "compression_ratio": 1.4371584699453552, "no_speech_prob": 0.00046547988313250244}, {"id": 14, "seek": 10604, "start": 106.04, "end": 112.84, "text": " converted to LLVM dialect and then the LLVM pipeline kicks in. This is basically the", "tokens": [50364, 16424, 281, 441, 43, 53, 44, 24652, 293, 550, 264, 441, 43, 53, 44, 15517, 21293, 294, 13, 639, 307, 1936, 264, 50704], "temperature": 0.0, "avg_logprob": -0.2018946958391854, "compression_ratio": 1.5426008968609866, "no_speech_prob": 0.00024535579723306}, {"id": 15, "seek": 10604, "start": 112.84, "end": 117.68, "text": " diagram that I have on the left hand side. Given a Fortran program, there is some parsing", "tokens": [50704, 10686, 300, 286, 362, 322, 264, 1411, 1011, 1252, 13, 18600, 257, 11002, 4257, 1461, 11, 456, 307, 512, 21156, 278, 50946], "temperature": 0.0, "avg_logprob": -0.2018946958391854, "compression_ratio": 1.5426008968609866, "no_speech_prob": 0.00024535579723306}, {"id": 16, "seek": 10604, "start": 117.68, "end": 122.36000000000001, "text": " and semantic checks that happen. Finally, you get a flying pass tree that's fairly", "tokens": [50946, 293, 47982, 13834, 300, 1051, 13, 6288, 11, 291, 483, 257, 7137, 1320, 4230, 300, 311, 6457, 51180], "temperature": 0.0, "avg_logprob": -0.2018946958391854, "compression_ratio": 1.5426008968609866, "no_speech_prob": 0.00024535579723306}, {"id": 17, "seek": 10604, "start": 122.36000000000001, "end": 129.4, "text": " well defined. Then that code is lowered into Fortran IR and calls to the runtime. Then", "tokens": [51180, 731, 7642, 13, 1396, 300, 3089, 307, 28466, 666, 11002, 4257, 16486, 293, 5498, 281, 264, 34474, 13, 1396, 51532], "temperature": 0.0, "avg_logprob": -0.2018946958391854, "compression_ratio": 1.5426008968609866, "no_speech_prob": 0.00024535579723306}, {"id": 18, "seek": 12940, "start": 129.4, "end": 139.28, "text": " the Fortran IR is converted to the LLVM dialect. This slide summarizes the story so far with", "tokens": [50364, 264, 11002, 4257, 16486, 307, 16424, 281, 264, 441, 43, 53, 44, 24652, 13, 639, 4137, 14611, 5660, 264, 1657, 370, 1400, 365, 50858], "temperature": 0.0, "avg_logprob": -0.16801451293515487, "compression_ratio": 1.5, "no_speech_prob": 5.064034121460281e-05}, {"id": 19, "seek": 12940, "start": 139.28, "end": 146.68, "text": " the flying compiler. Looking at the slide, this project started in 2018. It was during", "tokens": [50858, 264, 7137, 31958, 13, 11053, 412, 264, 4137, 11, 341, 1716, 1409, 294, 6096, 13, 467, 390, 1830, 51228], "temperature": 0.0, "avg_logprob": -0.16801451293515487, "compression_ratio": 1.5, "no_speech_prob": 5.064034121460281e-05}, {"id": 20, "seek": 12940, "start": 146.68, "end": 152.20000000000002, "text": " Euro LLVM 2018 that news about this compiler start to come out that there is a new Fortran", "tokens": [51228, 3010, 441, 43, 53, 44, 6096, 300, 2583, 466, 341, 31958, 722, 281, 808, 484, 300, 456, 307, 257, 777, 11002, 4257, 51504], "temperature": 0.0, "avg_logprob": -0.16801451293515487, "compression_ratio": 1.5, "no_speech_prob": 5.064034121460281e-05}, {"id": 21, "seek": 15220, "start": 152.2, "end": 160.0, "text": " frontend being written from scratch. One year later in April 2019, the project was", "tokens": [50364, 1868, 521, 885, 3720, 490, 8459, 13, 1485, 1064, 1780, 294, 6929, 6071, 11, 264, 1716, 390, 50754], "temperature": 0.0, "avg_logprob": -0.12897599886541497, "compression_ratio": 1.4883720930232558, "no_speech_prob": 0.0017819465138018131}, {"id": 22, "seek": 15220, "start": 160.0, "end": 166.48, "text": " accepted as the Fortran frontend of LLVM. Again, one year later in 2020, it was merged", "tokens": [50754, 9035, 382, 264, 11002, 4257, 1868, 521, 295, 441, 43, 53, 44, 13, 3764, 11, 472, 1064, 1780, 294, 4808, 11, 309, 390, 36427, 51078], "temperature": 0.0, "avg_logprob": -0.12897599886541497, "compression_ratio": 1.4883720930232558, "no_speech_prob": 0.0017819465138018131}, {"id": 23, "seek": 15220, "start": 166.48, "end": 174.39999999999998, "text": " into the LLVM project as LLVM flying. When this happened, there was some code that was", "tokens": [51078, 666, 264, 441, 43, 53, 44, 1716, 382, 441, 43, 53, 44, 7137, 13, 1133, 341, 2011, 11, 456, 390, 512, 3089, 300, 390, 51474], "temperature": 0.0, "avg_logprob": -0.12897599886541497, "compression_ratio": 1.4883720930232558, "no_speech_prob": 0.0017819465138018131}, {"id": 24, "seek": 17440, "start": 174.4, "end": 183.4, "text": " left behind. The project actually split into two repositories. The first one in the LLVM", "tokens": [50364, 1411, 2261, 13, 440, 1716, 767, 7472, 666, 732, 22283, 2083, 13, 440, 700, 472, 294, 264, 441, 43, 53, 44, 50814], "temperature": 0.0, "avg_logprob": -0.1634543177845714, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0209578238427639}, {"id": 25, "seek": 17440, "start": 183.4, "end": 189.88, "text": " project, where the parsing and semantic checks and the code for the runtime was there. All", "tokens": [50814, 1716, 11, 689, 264, 21156, 278, 293, 47982, 13834, 293, 264, 3089, 337, 264, 34474, 390, 456, 13, 1057, 51138], "temperature": 0.0, "avg_logprob": -0.1634543177845714, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0209578238427639}, {"id": 26, "seek": 17440, "start": 189.88, "end": 195.08, "text": " the code that lowers from the parse tree to the Fortran IR got left behind because it was", "tokens": [51138, 264, 3089, 300, 44936, 490, 264, 48377, 4230, 281, 264, 11002, 4257, 16486, 658, 1411, 2261, 570, 309, 390, 51398], "temperature": 0.0, "avg_logprob": -0.1634543177845714, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0209578238427639}, {"id": 27, "seek": 17440, "start": 195.08, "end": 202.44, "text": " not ready at that time. It began to take a life of its own. People had to now sync these", "tokens": [51398, 406, 1919, 412, 300, 565, 13, 467, 4283, 281, 747, 257, 993, 295, 1080, 1065, 13, 3432, 632, 281, 586, 20271, 613, 51766], "temperature": 0.0, "avg_logprob": -0.1634543177845714, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0209578238427639}, {"id": 28, "seek": 20244, "start": 202.44, "end": 208.12, "text": " two repositories, sometimes commit to both two repositories, and you have all the overhead", "tokens": [50364, 732, 22283, 2083, 11, 2171, 5599, 281, 1293, 732, 22283, 2083, 11, 293, 291, 362, 439, 264, 19922, 50648], "temperature": 0.0, "avg_logprob": -0.13443882872418658, "compression_ratio": 1.7028301886792452, "no_speech_prob": 0.0011692959815263748}, {"id": 29, "seek": 20244, "start": 208.12, "end": 215.48, "text": " of maintaining a downstream project. Fortunately, sometime in April 2022, people decided to", "tokens": [50648, 295, 14916, 257, 30621, 1716, 13, 20652, 11, 15053, 294, 6929, 20229, 11, 561, 3047, 281, 51016], "temperature": 0.0, "avg_logprob": -0.13443882872418658, "compression_ratio": 1.7028301886792452, "no_speech_prob": 0.0011692959815263748}, {"id": 30, "seek": 20244, "start": 215.48, "end": 220.92, "text": " freeze all the downstream development and pushed all the code into upstream. Sometime", "tokens": [51016, 15959, 439, 264, 30621, 3250, 293, 9152, 439, 264, 3089, 666, 33915, 13, 3379, 1312, 51288], "temperature": 0.0, "avg_logprob": -0.13443882872418658, "compression_ratio": 1.7028301886792452, "no_speech_prob": 0.0011692959815263748}, {"id": 31, "seek": 20244, "start": 220.92, "end": 228.68, "text": " in July 2022, this whole code is now in the LLVM project repository. Since then, the project", "tokens": [51288, 294, 7370, 20229, 11, 341, 1379, 3089, 307, 586, 294, 264, 441, 43, 53, 44, 1716, 25841, 13, 4162, 550, 11, 264, 1716, 51676], "temperature": 0.0, "avg_logprob": -0.13443882872418658, "compression_ratio": 1.7028301886792452, "no_speech_prob": 0.0011692959815263748}, {"id": 32, "seek": 22868, "start": 228.68, "end": 236.0, "text": " has mostly followed the LLVM contributions process, and all the social guidelines are", "tokens": [50364, 575, 5240, 6263, 264, 441, 43, 53, 44, 15725, 1399, 11, 293, 439, 264, 2093, 12470, 366, 50730], "temperature": 0.0, "avg_logprob": -0.18390934119063818, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0023221573792397976}, {"id": 33, "seek": 22868, "start": 236.0, "end": 245.08, "text": " associated with it. When it was merged into LLVM, it was mostly a Fortran 95 compiler,", "tokens": [50730, 6615, 365, 309, 13, 1133, 309, 390, 36427, 666, 441, 43, 53, 44, 11, 309, 390, 5240, 257, 11002, 4257, 13420, 31958, 11, 51184], "temperature": 0.0, "avg_logprob": -0.18390934119063818, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0023221573792397976}, {"id": 34, "seek": 22868, "start": 245.08, "end": 250.44, "text": " but there were still a few missing pieces. The code was stabilized further, and all unknown", "tokens": [51184, 457, 456, 645, 920, 257, 1326, 5361, 3755, 13, 440, 3089, 390, 48384, 3052, 11, 293, 439, 9841, 51452], "temperature": 0.0, "avg_logprob": -0.18390934119063818, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0023221573792397976}, {"id": 35, "seek": 22868, "start": 250.44, "end": 256.48, "text": " features were marked with to-dos, so that if you try to compile an unsupported feature,", "tokens": [51452, 4122, 645, 12658, 365, 281, 12, 33749, 11, 370, 300, 498, 291, 853, 281, 31413, 364, 2693, 10504, 14813, 4111, 11, 51754], "temperature": 0.0, "avg_logprob": -0.18390934119063818, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0023221573792397976}, {"id": 36, "seek": 25648, "start": 256.48, "end": 263.08000000000004, "text": " it will give a message saying that this feature is not supported rather than giving a crash.", "tokens": [50364, 309, 486, 976, 257, 3636, 1566, 300, 341, 4111, 307, 406, 8104, 2831, 813, 2902, 257, 8252, 13, 50694], "temperature": 0.0, "avg_logprob": -0.1705059239893784, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.031125320121645927}, {"id": 37, "seek": 25648, "start": 263.08000000000004, "end": 268.6, "text": " At the same time, development has continued to support newer standards, newer Fortran", "tokens": [50694, 1711, 264, 912, 565, 11, 3250, 575, 7014, 281, 1406, 17628, 7787, 11, 17628, 11002, 4257, 50970], "temperature": 0.0, "avg_logprob": -0.1705059239893784, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.031125320121645927}, {"id": 38, "seek": 25648, "start": 268.6, "end": 275.96000000000004, "text": " standards features like features from Fortran 2003, Fortran 2008, and things like that.", "tokens": [50970, 7787, 4122, 411, 4122, 490, 11002, 4257, 16416, 11, 11002, 4257, 10389, 11, 293, 721, 411, 300, 13, 51338], "temperature": 0.0, "avg_logprob": -0.1705059239893784, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.031125320121645927}, {"id": 39, "seek": 25648, "start": 275.96000000000004, "end": 280.20000000000005, "text": " Also a lot of bug fixes went in, as well as people started to look at some performance", "tokens": [51338, 2743, 257, 688, 295, 7426, 32539, 1437, 294, 11, 382, 731, 382, 561, 1409, 281, 574, 412, 512, 3389, 51550], "temperature": 0.0, "avg_logprob": -0.1705059239893784, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.031125320121645927}, {"id": 40, "seek": 28020, "start": 280.2, "end": 292.59999999999997, "text": " work as well. This slide summarizes the current status of the compiler. The compiler is not", "tokens": [50364, 589, 382, 731, 13, 639, 4137, 14611, 5660, 264, 2190, 6558, 295, 264, 31958, 13, 440, 31958, 307, 406, 50984], "temperature": 0.0, "avg_logprob": -0.17143934200971556, "compression_ratio": 1.591549295774648, "no_speech_prob": 0.0040067280642688274}, {"id": 41, "seek": 28020, "start": 292.59999999999997, "end": 298.71999999999997, "text": " yet ready for general use, but it is still fairly advanced in its support for various", "tokens": [50984, 1939, 1919, 337, 2674, 764, 11, 457, 309, 307, 920, 6457, 7339, 294, 1080, 1406, 337, 3683, 51290], "temperature": 0.0, "avg_logprob": -0.17143934200971556, "compression_ratio": 1.591549295774648, "no_speech_prob": 0.0040067280642688274}, {"id": 42, "seek": 28020, "start": 298.71999999999997, "end": 304.48, "text": " Fortran constructs. The driver is temporarily called flying new, and executables can be", "tokens": [51290, 11002, 4257, 7690, 82, 13, 440, 6787, 307, 23750, 1219, 7137, 777, 11, 293, 7568, 2965, 393, 312, 51578], "temperature": 0.0, "avg_logprob": -0.17143934200971556, "compression_ratio": 1.591549295774648, "no_speech_prob": 0.0040067280642688274}, {"id": 43, "seek": 28020, "start": 304.48, "end": 309.2, "text": " generated, but you have to use an option called flying experimental exec.", "tokens": [51578, 10833, 11, 457, 291, 362, 281, 764, 364, 3614, 1219, 7137, 17069, 4454, 13, 51814], "temperature": 0.0, "avg_logprob": -0.17143934200971556, "compression_ratio": 1.591549295774648, "no_speech_prob": 0.0040067280642688274}, {"id": 44, "seek": 30920, "start": 309.2, "end": 314.15999999999997, "text": " The feature development of Fortran 95 is mostly complete, and as I mentioned before, development", "tokens": [50364, 440, 4111, 3250, 295, 11002, 4257, 13420, 307, 5240, 3566, 11, 293, 382, 286, 2835, 949, 11, 3250, 50612], "temperature": 0.0, "avg_logprob": -0.1638743378395258, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.003592369146645069}, {"id": 45, "seek": 30920, "start": 314.15999999999997, "end": 319.8, "text": " of Fortran 2003 and later features are in progress. The compiler has been tested with", "tokens": [50612, 295, 11002, 4257, 16416, 293, 1780, 4122, 366, 294, 4205, 13, 440, 31958, 575, 668, 8246, 365, 50894], "temperature": 0.0, "avg_logprob": -0.1638743378395258, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.003592369146645069}, {"id": 46, "seek": 30920, "start": 319.8, "end": 327.52, "text": " various commercial and free test feeds. It has also been verified with some HPC benchmarks", "tokens": [50894, 3683, 6841, 293, 1737, 1500, 23712, 13, 467, 575, 611, 668, 31197, 365, 512, 12557, 34, 43751, 51280], "temperature": 0.0, "avg_logprob": -0.1638743378395258, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.003592369146645069}, {"id": 47, "seek": 30920, "start": 327.52, "end": 336.2, "text": " like SNAP, Cloverleaf. We have also used the spec benchmarks to test it. We are also continuing", "tokens": [51280, 411, 13955, 4715, 11, 31901, 331, 306, 2792, 13, 492, 362, 611, 1143, 264, 1608, 43751, 281, 1500, 309, 13, 492, 366, 611, 9289, 51714], "temperature": 0.0, "avg_logprob": -0.1638743378395258, "compression_ratio": 1.5974025974025974, "no_speech_prob": 0.003592369146645069}, {"id": 48, "seek": 33620, "start": 336.2, "end": 342.88, "text": " to test it with other benchmarks like the OpenMP version of spec, other open source", "tokens": [50364, 281, 1500, 309, 365, 661, 43751, 411, 264, 7238, 12224, 3037, 295, 1608, 11, 661, 1269, 4009, 50698], "temperature": 0.0, "avg_logprob": -0.1726244158214993, "compression_ratio": 1.5369458128078817, "no_speech_prob": 0.0009252159507013857}, {"id": 49, "seek": 33620, "start": 342.88, "end": 347.36, "text": " applications like open radios, and things like that.", "tokens": [50698, 5821, 411, 1269, 2843, 2717, 11, 293, 721, 411, 300, 13, 50922], "temperature": 0.0, "avg_logprob": -0.1726244158214993, "compression_ratio": 1.5369458128078817, "no_speech_prob": 0.0009252159507013857}, {"id": 50, "seek": 33620, "start": 347.36, "end": 355.08, "text": " This driver's name was flying new, and the use of the experimental flag is currently", "tokens": [50922, 639, 6787, 311, 1315, 390, 7137, 777, 11, 293, 264, 764, 295, 264, 17069, 7166, 307, 4362, 51308], "temperature": 0.0, "avg_logprob": -0.1726244158214993, "compression_ratio": 1.5369458128078817, "no_speech_prob": 0.0009252159507013857}, {"id": 51, "seek": 33620, "start": 355.08, "end": 362.0, "text": " being discussed. It is possible that those requirements will go away soon, and then people", "tokens": [51308, 885, 7152, 13, 467, 307, 1944, 300, 729, 7728, 486, 352, 1314, 2321, 11, 293, 550, 561, 51654], "temperature": 0.0, "avg_logprob": -0.1726244158214993, "compression_ratio": 1.5369458128078817, "no_speech_prob": 0.0009252159507013857}, {"id": 52, "seek": 36200, "start": 362.0, "end": 369.72, "text": " can just type flying to compile their application. There is a discourse thread on that currently", "tokens": [50364, 393, 445, 2010, 7137, 281, 31413, 641, 3861, 13, 821, 307, 257, 23938, 7207, 322, 300, 4362, 50750], "temperature": 0.0, "avg_logprob": -0.14586162567138672, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.000791482743807137}, {"id": 53, "seek": 36200, "start": 369.72, "end": 377.92, "text": " under discussion. This slide summarizes the support level of", "tokens": [50750, 833, 5017, 13, 639, 4137, 14611, 5660, 264, 1406, 1496, 295, 51160], "temperature": 0.0, "avg_logprob": -0.14586162567138672, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.000791482743807137}, {"id": 54, "seek": 36200, "start": 377.92, "end": 385.0, "text": " flying for various Fortran standards. Fortran is a living language. As you can see, it has", "tokens": [51160, 7137, 337, 3683, 11002, 4257, 7787, 13, 11002, 4257, 307, 257, 2647, 2856, 13, 1018, 291, 393, 536, 11, 309, 575, 51514], "temperature": 0.0, "avg_logprob": -0.14586162567138672, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.000791482743807137}, {"id": 55, "seek": 36200, "start": 385.0, "end": 389.64, "text": " gone through a lot of revisions. There is another revision that is going to come in this", "tokens": [51514, 2780, 807, 257, 688, 295, 3698, 4252, 13, 821, 307, 1071, 34218, 300, 307, 516, 281, 808, 294, 341, 51746], "temperature": 0.0, "avg_logprob": -0.14586162567138672, "compression_ratio": 1.6519607843137254, "no_speech_prob": 0.000791482743807137}, {"id": 56, "seek": 38964, "start": 389.64, "end": 395.88, "text": " year and one later in this decade. It is a living language, and it is continuing to", "tokens": [50364, 1064, 293, 472, 1780, 294, 341, 10378, 13, 467, 307, 257, 2647, 2856, 11, 293, 309, 307, 9289, 281, 50676], "temperature": 0.0, "avg_logprob": -0.18379205760389272, "compression_ratio": 1.5613382899628252, "no_speech_prob": 0.0002958906698040664}, {"id": 57, "seek": 38964, "start": 395.88, "end": 400.56, "text": " make progress, adding new features and things like that, but it makes the job of the compiler", "tokens": [50676, 652, 4205, 11, 5127, 777, 4122, 293, 721, 411, 300, 11, 457, 309, 1669, 264, 1691, 295, 264, 31958, 50910], "temperature": 0.0, "avg_logprob": -0.18379205760389272, "compression_ratio": 1.5613382899628252, "no_speech_prob": 0.0002958906698040664}, {"id": 58, "seek": 38964, "start": 400.56, "end": 405.91999999999996, "text": " engineers much harder because you are always trying to catch up.", "tokens": [50910, 11955, 709, 6081, 570, 291, 366, 1009, 1382, 281, 3745, 493, 13, 51178], "temperature": 0.0, "avg_logprob": -0.18379205760389272, "compression_ratio": 1.5613382899628252, "no_speech_prob": 0.0002958906698040664}, {"id": 59, "seek": 38964, "start": 405.91999999999996, "end": 411.03999999999996, "text": " The initial standard that we track is 77, and the development work is complete. Fortran", "tokens": [51178, 440, 5883, 3832, 300, 321, 2837, 307, 25546, 11, 293, 264, 3250, 589, 307, 3566, 13, 11002, 4257, 51434], "temperature": 0.0, "avg_logprob": -0.18379205760389272, "compression_ratio": 1.5613382899628252, "no_speech_prob": 0.0002958906698040664}, {"id": 60, "seek": 38964, "start": 411.03999999999996, "end": 418.4, "text": " 95, as I mentioned before, is complete except for a few bits here and there. Work on 2003", "tokens": [51434, 13420, 11, 382, 286, 2835, 949, 11, 307, 3566, 3993, 337, 257, 1326, 9239, 510, 293, 456, 13, 6603, 322, 16416, 51802], "temperature": 0.0, "avg_logprob": -0.18379205760389272, "compression_ratio": 1.5613382899628252, "no_speech_prob": 0.0002958906698040664}, {"id": 61, "seek": 41840, "start": 418.4, "end": 424.96, "text": " is in progress, particularly on polymorphic types, but the parsing semantics and runtime", "tokens": [50364, 307, 294, 4205, 11, 4098, 322, 6754, 76, 18191, 299, 3467, 11, 457, 264, 21156, 278, 4361, 45298, 293, 34474, 50692], "temperature": 0.0, "avg_logprob": -0.1423405541314019, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.008574854582548141}, {"id": 62, "seek": 41840, "start": 424.96, "end": 431.67999999999995, "text": " mostly works. Similarly, with Fortran 2008 as well, parsing semantics and runtime works,", "tokens": [50692, 5240, 1985, 13, 13157, 11, 365, 11002, 4257, 10389, 382, 731, 11, 21156, 278, 4361, 45298, 293, 34474, 1985, 11, 51028], "temperature": 0.0, "avg_logprob": -0.1423405541314019, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.008574854582548141}, {"id": 63, "seek": 41840, "start": 431.67999999999995, "end": 438.15999999999997, "text": " but some of the features are in progress. Whereas, when you come to Fortran 2018, none", "tokens": [51028, 457, 512, 295, 264, 4122, 366, 294, 4205, 13, 13813, 11, 562, 291, 808, 281, 11002, 4257, 6096, 11, 6022, 51352], "temperature": 0.0, "avg_logprob": -0.1423405541314019, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.008574854582548141}, {"id": 64, "seek": 41840, "start": 438.15999999999997, "end": 443.47999999999996, "text": " of the lowering or codes and work has happened yet. Whereas, the parser and semantics and", "tokens": [51352, 295, 264, 28124, 420, 14211, 293, 589, 575, 2011, 1939, 13, 13813, 11, 264, 21156, 260, 293, 4361, 45298, 293, 51618], "temperature": 0.0, "avg_logprob": -0.1423405541314019, "compression_ratio": 1.7611940298507462, "no_speech_prob": 0.008574854582548141}, {"id": 65, "seek": 44348, "start": 443.48, "end": 448.08000000000004, "text": " runtime should work fine for this code, modulo n e bux.", "tokens": [50364, 34474, 820, 589, 2489, 337, 341, 3089, 11, 1072, 13455, 297, 308, 758, 87, 13, 50594], "temperature": 0.0, "avg_logprob": -0.2605793564407914, "compression_ratio": 1.5742574257425743, "no_speech_prob": 0.0655786320567131}, {"id": 66, "seek": 44348, "start": 448.08000000000004, "end": 456.32, "text": " Now, I have said that the compiler is able to compile a lot of Fortran code. How does", "tokens": [50594, 823, 11, 286, 362, 848, 300, 264, 31958, 307, 1075, 281, 31413, 257, 688, 295, 11002, 4257, 3089, 13, 1012, 775, 51006], "temperature": 0.0, "avg_logprob": -0.2605793564407914, "compression_ratio": 1.5742574257425743, "no_speech_prob": 0.0655786320567131}, {"id": 67, "seek": 44348, "start": 456.32, "end": 462.96000000000004, "text": " the performance look like? This slide gives you a summary of where this compiler stands", "tokens": [51006, 264, 3389, 574, 411, 30, 639, 4137, 2709, 291, 257, 12691, 295, 689, 341, 31958, 7382, 51338], "temperature": 0.0, "avg_logprob": -0.2605793564407914, "compression_ratio": 1.5742574257425743, "no_speech_prob": 0.0655786320567131}, {"id": 68, "seek": 44348, "start": 462.96000000000004, "end": 471.04, "text": " with respect to other compilers. The benchmark I have used for this slide is the respect", "tokens": [51338, 365, 3104, 281, 661, 715, 388, 433, 13, 440, 18927, 286, 362, 1143, 337, 341, 4137, 307, 264, 3104, 51742], "temperature": 0.0, "avg_logprob": -0.2605793564407914, "compression_ratio": 1.5742574257425743, "no_speech_prob": 0.0655786320567131}, {"id": 69, "seek": 47104, "start": 471.08000000000004, "end": 477.8, "text": " 2017 benchmark, and all the Fortran benchmarks from that, either Fortran or mixed Fortran.", "tokens": [50366, 6591, 18927, 11, 293, 439, 264, 11002, 4257, 43751, 490, 300, 11, 2139, 11002, 4257, 420, 7467, 11002, 4257, 13, 50702], "temperature": 0.0, "avg_logprob": -0.1940456133210257, "compression_ratio": 1.6941747572815533, "no_speech_prob": 0.0021486287005245686}, {"id": 70, "seek": 47104, "start": 477.8, "end": 482.88, "text": " I have compared it with the two compilers. One is the G Fortran 12 version, and the other", "tokens": [50702, 286, 362, 5347, 309, 365, 264, 732, 715, 388, 433, 13, 1485, 307, 264, 460, 11002, 4257, 2272, 3037, 11, 293, 264, 661, 50956], "temperature": 0.0, "avg_logprob": -0.1940456133210257, "compression_ratio": 1.6941747572815533, "no_speech_prob": 0.0021486287005245686}, {"id": 71, "seek": 47104, "start": 482.88, "end": 487.98, "text": " one is the compiler called classic flank. There is a compiler that is previously open", "tokens": [50956, 472, 307, 264, 31958, 1219, 7230, 36318, 13, 821, 307, 257, 31958, 300, 307, 8046, 1269, 51211], "temperature": 0.0, "avg_logprob": -0.1940456133210257, "compression_ratio": 1.6941747572815533, "no_speech_prob": 0.0021486287005245686}, {"id": 72, "seek": 47104, "start": 487.98, "end": 494.44, "text": " sourced by PGI, and that is actually the Fortran front end of many of the existing", "tokens": [51211, 11006, 1232, 538, 430, 26252, 11, 293, 300, 307, 767, 264, 11002, 4257, 1868, 917, 295, 867, 295, 264, 6741, 51534], "temperature": 0.0, "avg_logprob": -0.1940456133210257, "compression_ratio": 1.6941747572815533, "no_speech_prob": 0.0021486287005245686}, {"id": 73, "seek": 49444, "start": 494.44, "end": 499.96, "text": " commercial compilers like AMD's, ARM's and Huawei's.", "tokens": [50364, 6841, 715, 388, 433, 411, 34808, 311, 11, 45209, 311, 293, 28542, 311, 13, 50640], "temperature": 0.0, "avg_logprob": -0.21884368186773256, "compression_ratio": 1.5, "no_speech_prob": 0.00020025671983603388}, {"id": 74, "seek": 49444, "start": 499.96, "end": 506.96, "text": " So, I have compared it with both these compilers, and what I have at the bottom here is the", "tokens": [50640, 407, 11, 286, 362, 5347, 309, 365, 1293, 613, 715, 388, 433, 11, 293, 437, 286, 362, 412, 264, 2767, 510, 307, 264, 50990], "temperature": 0.0, "avg_logprob": -0.21884368186773256, "compression_ratio": 1.5, "no_speech_prob": 0.00020025671983603388}, {"id": 75, "seek": 49444, "start": 506.96, "end": 512.76, "text": " geometric mean, if you consider the performance of all the benchmarks in this suite.", "tokens": [50990, 33246, 914, 11, 498, 291, 1949, 264, 3389, 295, 439, 264, 43751, 294, 341, 14205, 13, 51280], "temperature": 0.0, "avg_logprob": -0.21884368186773256, "compression_ratio": 1.5, "no_speech_prob": 0.00020025671983603388}, {"id": 76, "seek": 49444, "start": 512.76, "end": 520.76, "text": " So, you can see that compared to G Fortran, we are around 1.5 times the runtime it takes", "tokens": [51280, 407, 11, 291, 393, 536, 300, 5347, 281, 460, 11002, 4257, 11, 321, 366, 926, 502, 13, 20, 1413, 264, 34474, 309, 2516, 51680], "temperature": 0.0, "avg_logprob": -0.21884368186773256, "compression_ratio": 1.5, "no_speech_prob": 0.00020025671983603388}, {"id": 77, "seek": 52076, "start": 520.76, "end": 529.08, "text": " in flank, whereas compared to classic flank, it is around 1.38. So, for some of the benchmarks,", "tokens": [50364, 294, 36318, 11, 9735, 5347, 281, 7230, 36318, 11, 309, 307, 926, 502, 13, 12625, 13, 407, 11, 337, 512, 295, 264, 43751, 11, 50780], "temperature": 0.0, "avg_logprob": -0.19874829131287414, "compression_ratio": 1.606060606060606, "no_speech_prob": 0.00014880498929414898}, {"id": 78, "seek": 52076, "start": 529.08, "end": 534.6, "text": " we are mostly on par, but for some of the other benchmarks, there is still some work", "tokens": [50780, 321, 366, 5240, 322, 971, 11, 457, 337, 512, 295, 264, 661, 43751, 11, 456, 307, 920, 512, 589, 51056], "temperature": 0.0, "avg_logprob": -0.19874829131287414, "compression_ratio": 1.606060606060606, "no_speech_prob": 0.00014880498929414898}, {"id": 79, "seek": 52076, "start": 534.6, "end": 541.48, "text": " to be done. The comments column basically summarizes what are probably the issues that", "tokens": [51056, 281, 312, 1096, 13, 440, 3053, 7738, 1936, 14611, 5660, 437, 366, 1391, 264, 2663, 300, 51400], "temperature": 0.0, "avg_logprob": -0.19874829131287414, "compression_ratio": 1.606060606060606, "no_speech_prob": 0.00014880498929414898}, {"id": 80, "seek": 52076, "start": 541.48, "end": 545.36, "text": " are there that causes this performance difference.", "tokens": [51400, 366, 456, 300, 7700, 341, 3389, 2649, 13, 51594], "temperature": 0.0, "avg_logprob": -0.19874829131287414, "compression_ratio": 1.606060606060606, "no_speech_prob": 0.00014880498929414898}, {"id": 81, "seek": 54536, "start": 546.04, "end": 553.52, "text": " Some of them are familiar things like alias analysis, the other things like intrinsic", "tokens": [50398, 2188, 295, 552, 366, 4963, 721, 411, 419, 4609, 5215, 11, 264, 661, 721, 411, 35698, 50772], "temperature": 0.0, "avg_logprob": -0.2238275714036895, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0007529196445830166}, {"id": 82, "seek": 54536, "start": 553.52, "end": 561.36, "text": " in lining and function specialization. Fortran has a lot of intrinsic functions. So, generally", "tokens": [50772, 294, 19628, 293, 2445, 2121, 2144, 13, 11002, 4257, 575, 257, 688, 295, 35698, 6828, 13, 407, 11, 5101, 51164], "temperature": 0.0, "avg_logprob": -0.2238275714036895, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0007529196445830166}, {"id": 83, "seek": 54536, "start": 561.36, "end": 566.36, "text": " these are all implemented in the runtime. Because you have a lot of these intrinsics,", "tokens": [51164, 613, 366, 439, 12270, 294, 264, 34474, 13, 1436, 291, 362, 257, 688, 295, 613, 28621, 1167, 11, 51414], "temperature": 0.0, "avg_logprob": -0.2238275714036895, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0007529196445830166}, {"id": 84, "seek": 54536, "start": 566.36, "end": 571.64, "text": " the runtime is many times written in a generic fashion. So, you might not get the performance", "tokens": [51414, 264, 34474, 307, 867, 1413, 3720, 294, 257, 19577, 6700, 13, 407, 11, 291, 1062, 406, 483, 264, 3389, 51678], "temperature": 0.0, "avg_logprob": -0.2238275714036895, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.0007529196445830166}, {"id": 85, "seek": 57164, "start": 571.76, "end": 576.42, "text": " if you call the runtime function. Also, for simple arrays and all, it does not make much", "tokens": [50370, 498, 291, 818, 264, 34474, 2445, 13, 2743, 11, 337, 2199, 41011, 293, 439, 11, 309, 775, 406, 652, 709, 50603], "temperature": 0.0, "avg_logprob": -0.20437084862945276, "compression_ratio": 1.71875, "no_speech_prob": 0.005727122072130442}, {"id": 86, "seek": 57164, "start": 576.42, "end": 580.56, "text": " sense to incur the overhead, particularly if that function is being called in a loop", "tokens": [50603, 2020, 281, 35774, 264, 19922, 11, 4098, 498, 300, 2445, 307, 885, 1219, 294, 257, 6367, 50810], "temperature": 0.0, "avg_logprob": -0.20437084862945276, "compression_ratio": 1.71875, "no_speech_prob": 0.005727122072130442}, {"id": 87, "seek": 57164, "start": 580.56, "end": 587.56, "text": " or something like that. So, many times it is good to inline that code. So, in benchmarks", "tokens": [50810, 420, 746, 411, 300, 13, 407, 11, 867, 1413, 309, 307, 665, 281, 294, 1889, 300, 3089, 13, 407, 11, 294, 43751, 51160], "temperature": 0.0, "avg_logprob": -0.20437084862945276, "compression_ratio": 1.71875, "no_speech_prob": 0.005727122072130442}, {"id": 88, "seek": 57164, "start": 587.56, "end": 595.06, "text": " like exchange too, there are a lot of functions like count, sum and any mean lock and all.", "tokens": [51160, 411, 7742, 886, 11, 456, 366, 257, 688, 295, 6828, 411, 1207, 11, 2408, 293, 604, 914, 4017, 293, 439, 13, 51535], "temperature": 0.0, "avg_logprob": -0.20437084862945276, "compression_ratio": 1.71875, "no_speech_prob": 0.005727122072130442}, {"id": 89, "seek": 57164, "start": 595.06, "end": 600.92, "text": " That can be possibly be inline to get more performance. And exchange too happens to be", "tokens": [51535, 663, 393, 312, 6264, 312, 294, 1889, 281, 483, 544, 3389, 13, 400, 7742, 886, 2314, 281, 312, 51828], "temperature": 0.0, "avg_logprob": -0.20437084862945276, "compression_ratio": 1.71875, "no_speech_prob": 0.005727122072130442}, {"id": 90, "seek": 60092, "start": 600.92, "end": 607.24, "text": " one benchmark where if you have performed function specialization, you get much benefits.", "tokens": [50364, 472, 18927, 689, 498, 291, 362, 10332, 2445, 2121, 2144, 11, 291, 483, 709, 5311, 13, 50680], "temperature": 0.0, "avg_logprob": -0.2033158302307129, "compression_ratio": 1.7075471698113207, "no_speech_prob": 0.0004582697292789817}, {"id": 91, "seek": 60092, "start": 607.24, "end": 612.7199999999999, "text": " So, function specialization is a process where if you know the arguments to the function,", "tokens": [50680, 407, 11, 2445, 2121, 2144, 307, 257, 1399, 689, 498, 291, 458, 264, 12869, 281, 264, 2445, 11, 50954], "temperature": 0.0, "avg_logprob": -0.2033158302307129, "compression_ratio": 1.7075471698113207, "no_speech_prob": 0.0004582697292789817}, {"id": 92, "seek": 60092, "start": 612.7199999999999, "end": 618.0, "text": " you can generate a specialized version of that function based on the known parameters", "tokens": [50954, 291, 393, 8460, 257, 19813, 3037, 295, 300, 2445, 2361, 322, 264, 2570, 9834, 51218], "temperature": 0.0, "avg_logprob": -0.2033158302307129, "compression_ratio": 1.7075471698113207, "no_speech_prob": 0.0004582697292789817}, {"id": 93, "seek": 60092, "start": 618.0, "end": 619.5, "text": " value.", "tokens": [51218, 2158, 13, 51293], "temperature": 0.0, "avg_logprob": -0.2033158302307129, "compression_ratio": 1.7075471698113207, "no_speech_prob": 0.0004582697292789817}, {"id": 94, "seek": 60092, "start": 619.5, "end": 626.9599999999999, "text": " There are also other issues mostly associated with how arrays are handled in Fortran. So,", "tokens": [51293, 821, 366, 611, 661, 2663, 5240, 6615, 365, 577, 41011, 366, 18033, 294, 11002, 4257, 13, 407, 11, 51666], "temperature": 0.0, "avg_logprob": -0.2033158302307129, "compression_ratio": 1.7075471698113207, "no_speech_prob": 0.0004582697292789817}, {"id": 95, "seek": 62696, "start": 626.96, "end": 632.6, "text": " by the definition of or how the standard interprets arrays in Fortran or array expressions", "tokens": [50364, 538, 264, 7123, 295, 420, 577, 264, 3832, 17489, 1373, 41011, 294, 11002, 4257, 420, 10225, 15277, 50646], "temperature": 0.0, "avg_logprob": -0.1756713173606179, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.0019541732035577297}, {"id": 96, "seek": 62696, "start": 632.6, "end": 638.48, "text": " in Fortran is that there is always a temporary associated with it. But when we generate code,", "tokens": [50646, 294, 11002, 4257, 307, 300, 456, 307, 1009, 257, 13413, 6615, 365, 309, 13, 583, 562, 321, 8460, 3089, 11, 50940], "temperature": 0.0, "avg_logprob": -0.1756713173606179, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.0019541732035577297}, {"id": 97, "seek": 62696, "start": 638.48, "end": 643.76, "text": " if there are a lot of temporaries, you know a lot of work, a lot of time is consumed just", "tokens": [50940, 498, 456, 366, 257, 688, 295, 8219, 4889, 11, 291, 458, 257, 688, 295, 589, 11, 257, 688, 295, 565, 307, 21226, 445, 51204], "temperature": 0.0, "avg_logprob": -0.1756713173606179, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.0019541732035577297}, {"id": 98, "seek": 62696, "start": 643.76, "end": 648.6, "text": " for copying these arrays from one version to another. So, in many cases these copies", "tokens": [51204, 337, 27976, 613, 41011, 490, 472, 3037, 281, 1071, 13, 407, 11, 294, 867, 3331, 613, 14341, 51446], "temperature": 0.0, "avg_logprob": -0.1756713173606179, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.0019541732035577297}, {"id": 99, "seek": 62696, "start": 648.6, "end": 653.76, "text": " can be optimized away, but we do not do a good job about it and that is what is causing", "tokens": [51446, 393, 312, 26941, 1314, 11, 457, 321, 360, 406, 360, 257, 665, 1691, 466, 309, 293, 300, 307, 437, 307, 9853, 51704], "temperature": 0.0, "avg_logprob": -0.1756713173606179, "compression_ratio": 1.725868725868726, "no_speech_prob": 0.0019541732035577297}, {"id": 100, "seek": 65376, "start": 653.76, "end": 655.12, "text": " this performance issue.", "tokens": [50364, 341, 3389, 2734, 13, 50432], "temperature": 0.0, "avg_logprob": -0.20256688971268502, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.0007096228073351085}, {"id": 101, "seek": 65376, "start": 655.12, "end": 660.24, "text": " So, few engineers have been working on this for some time now. A few months back, we were", "tokens": [50432, 407, 11, 1326, 11955, 362, 668, 1364, 322, 341, 337, 512, 565, 586, 13, 316, 1326, 2493, 646, 11, 321, 645, 50688], "temperature": 0.0, "avg_logprob": -0.20256688971268502, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.0007096228073351085}, {"id": 102, "seek": 65376, "start": 660.24, "end": 669.88, "text": " around 2x, but we are closing the gap you know as fast as possible. So, now in this", "tokens": [50688, 926, 568, 87, 11, 457, 321, 366, 10377, 264, 7417, 291, 458, 382, 2370, 382, 1944, 13, 407, 11, 586, 294, 341, 51170], "temperature": 0.0, "avg_logprob": -0.20256688971268502, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.0007096228073351085}, {"id": 103, "seek": 65376, "start": 669.88, "end": 675.08, "text": " slide, in the following slides, I summarize some of the major development efforts. So,", "tokens": [51170, 4137, 11, 294, 264, 3480, 9788, 11, 286, 20858, 512, 295, 264, 2563, 3250, 6484, 13, 407, 11, 51430], "temperature": 0.0, "avg_logprob": -0.20256688971268502, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.0007096228073351085}, {"id": 104, "seek": 65376, "start": 675.08, "end": 681.4399999999999, "text": " I probably missed some of the efforts, but what I am going to summarize is first one", "tokens": [51430, 286, 1391, 6721, 512, 295, 264, 6484, 11, 457, 437, 286, 669, 516, 281, 20858, 307, 700, 472, 51748], "temperature": 0.0, "avg_logprob": -0.20256688971268502, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.0007096228073351085}, {"id": 105, "seek": 68144, "start": 681.44, "end": 687.0, "text": " is high level fare, that is a new dialect that is being written, that sits just above", "tokens": [50364, 307, 1090, 1496, 11994, 11, 300, 307, 257, 777, 24652, 300, 307, 885, 3720, 11, 300, 12696, 445, 3673, 50642], "temperature": 0.0, "avg_logprob": -0.1883876243334138, "compression_ratio": 1.645933014354067, "no_speech_prob": 0.0022165304981172085}, {"id": 106, "seek": 68144, "start": 687.0, "end": 694.48, "text": " Fortran IR. I will come to the reason for that. Second one is I will try to have one", "tokens": [50642, 11002, 4257, 16486, 13, 286, 486, 808, 281, 264, 1778, 337, 300, 13, 5736, 472, 307, 286, 486, 853, 281, 362, 472, 51016], "temperature": 0.0, "avg_logprob": -0.1883876243334138, "compression_ratio": 1.645933014354067, "no_speech_prob": 0.0022165304981172085}, {"id": 107, "seek": 68144, "start": 694.48, "end": 700.2800000000001, "text": " or two slides about polymorphic types and how they are handled in flank. I look at some", "tokens": [51016, 420, 732, 9788, 466, 6754, 76, 18191, 299, 3467, 293, 577, 436, 366, 18033, 294, 36318, 13, 286, 574, 412, 512, 51306], "temperature": 0.0, "avg_logprob": -0.1883876243334138, "compression_ratio": 1.645933014354067, "no_speech_prob": 0.0022165304981172085}, {"id": 108, "seek": 68144, "start": 700.2800000000001, "end": 706.48, "text": " of the performance work that is being done. I briefly summarize the work that is done", "tokens": [51306, 295, 264, 3389, 589, 300, 307, 885, 1096, 13, 286, 10515, 20858, 264, 589, 300, 307, 1096, 51616], "temperature": 0.0, "avg_logprob": -0.1883876243334138, "compression_ratio": 1.645933014354067, "no_speech_prob": 0.0022165304981172085}, {"id": 109, "seek": 70648, "start": 706.48, "end": 713.64, "text": " already and what are the work going on in open MP as well as the driver.", "tokens": [50364, 1217, 293, 437, 366, 264, 589, 516, 322, 294, 1269, 14146, 382, 731, 382, 264, 6787, 13, 50722], "temperature": 0.0, "avg_logprob": -0.15967286053825827, "compression_ratio": 1.6683417085427135, "no_speech_prob": 0.0015246802940964699}, {"id": 110, "seek": 70648, "start": 713.64, "end": 722.44, "text": " So, when the compiler work started, the IR that we had is Fortran IR which represents", "tokens": [50722, 407, 11, 562, 264, 31958, 589, 1409, 11, 264, 16486, 300, 321, 632, 307, 11002, 4257, 16486, 597, 8855, 51162], "temperature": 0.0, "avg_logprob": -0.15967286053825827, "compression_ratio": 1.6683417085427135, "no_speech_prob": 0.0015246802940964699}, {"id": 111, "seek": 70648, "start": 722.44, "end": 728.08, "text": " a lot of the Fortran constructs, but what we found is that although it does model a", "tokens": [51162, 257, 688, 295, 264, 11002, 4257, 7690, 82, 11, 457, 437, 321, 1352, 307, 300, 4878, 309, 775, 2316, 257, 51444], "temperature": 0.0, "avg_logprob": -0.15967286053825827, "compression_ratio": 1.6683417085427135, "no_speech_prob": 0.0015246802940964699}, {"id": 112, "seek": 70648, "start": 728.08, "end": 734.64, "text": " lot of the Fortran constructs, there is still some gap between the Fortran source program", "tokens": [51444, 688, 295, 264, 11002, 4257, 7690, 82, 11, 456, 307, 920, 512, 7417, 1296, 264, 11002, 4257, 4009, 1461, 51772], "temperature": 0.0, "avg_logprob": -0.15967286053825827, "compression_ratio": 1.6683417085427135, "no_speech_prob": 0.0015246802940964699}, {"id": 113, "seek": 73464, "start": 735.0, "end": 740.04, "text": " and the Fortran IR. So, there is some information that is being lost like what are the variables", "tokens": [50382, 293, 264, 11002, 4257, 16486, 13, 407, 11, 456, 307, 512, 1589, 300, 307, 885, 2731, 411, 437, 366, 264, 9102, 50634], "temperature": 0.0, "avg_logprob": -0.13153078870953255, "compression_ratio": 1.836, "no_speech_prob": 0.00013551536540035158}, {"id": 114, "seek": 73464, "start": 740.04, "end": 744.4399999999999, "text": " in the source program, what were the annotations that were there on the variables and things", "tokens": [50634, 294, 264, 4009, 1461, 11, 437, 645, 264, 25339, 763, 300, 645, 456, 322, 264, 9102, 293, 721, 50854], "temperature": 0.0, "avg_logprob": -0.13153078870953255, "compression_ratio": 1.836, "no_speech_prob": 0.00013551536540035158}, {"id": 115, "seek": 73464, "start": 744.4399999999999, "end": 751.4399999999999, "text": " like that and losing that meant that we might not be able to do some performance optimization.", "tokens": [50854, 411, 300, 293, 7027, 300, 4140, 300, 321, 1062, 406, 312, 1075, 281, 360, 512, 3389, 19618, 13, 51204], "temperature": 0.0, "avg_logprob": -0.13153078870953255, "compression_ratio": 1.836, "no_speech_prob": 0.00013551536540035158}, {"id": 116, "seek": 73464, "start": 751.4399999999999, "end": 757.52, "text": " So, what people decided is that we need to, so that was one issue. The other issue was", "tokens": [51204, 407, 11, 437, 561, 3047, 307, 300, 321, 643, 281, 11, 370, 300, 390, 472, 2734, 13, 440, 661, 2734, 390, 51508], "temperature": 0.0, "avg_logprob": -0.13153078870953255, "compression_ratio": 1.836, "no_speech_prob": 0.00013551536540035158}, {"id": 117, "seek": 73464, "start": 757.52, "end": 761.88, "text": " that the lowering was also proving to be a bit difficult because of the huge difference", "tokens": [51508, 300, 264, 28124, 390, 611, 27221, 281, 312, 257, 857, 2252, 570, 295, 264, 2603, 2649, 51726], "temperature": 0.0, "avg_logprob": -0.13153078870953255, "compression_ratio": 1.836, "no_speech_prob": 0.00013551536540035158}, {"id": 118, "seek": 76188, "start": 761.88, "end": 767.72, "text": " between the source and the IR. So, that is the reason why a new intermediate representation", "tokens": [50364, 1296, 264, 4009, 293, 264, 16486, 13, 407, 11, 300, 307, 264, 1778, 983, 257, 777, 19376, 10290, 50656], "temperature": 0.0, "avg_logprob": -0.1789098580678304, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.001081380876712501}, {"id": 119, "seek": 76188, "start": 767.72, "end": 774.64, "text": " was introduced between Fortran IR and the source that is the HLFIR IR or the high level", "tokens": [50656, 390, 7268, 1296, 11002, 4257, 16486, 293, 264, 4009, 300, 307, 264, 389, 43, 37, 7740, 16486, 420, 264, 1090, 1496, 51002], "temperature": 0.0, "avg_logprob": -0.1789098580678304, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.001081380876712501}, {"id": 120, "seek": 76188, "start": 774.64, "end": 781.04, "text": " FIR. As I mentioned before, it enables optimizations and because it carries more information from", "tokens": [51002, 41538, 13, 1018, 286, 2835, 949, 11, 309, 17077, 5028, 14455, 293, 570, 309, 16402, 544, 1589, 490, 51322], "temperature": 0.0, "avg_logprob": -0.1789098580678304, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.001081380876712501}, {"id": 121, "seek": 76188, "start": 781.04, "end": 784.8, "text": " the source, it is likely to generate better debug.", "tokens": [51322, 264, 4009, 11, 309, 307, 3700, 281, 8460, 1101, 24083, 13, 51510], "temperature": 0.0, "avg_logprob": -0.1789098580678304, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.001081380876712501}, {"id": 122, "seek": 76188, "start": 784.8, "end": 791.32, "text": " So, this IR basically introduces two major concepts. One is that it models expressions", "tokens": [51510, 407, 11, 341, 16486, 1936, 31472, 732, 2563, 10392, 13, 1485, 307, 300, 309, 5245, 15277, 51836], "temperature": 0.0, "avg_logprob": -0.1789098580678304, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.001081380876712501}, {"id": 123, "seek": 79132, "start": 791.44, "end": 796.7600000000001, "text": " that are not buffered. As I mentioned before, array expressions in Fortran generally involve", "tokens": [50370, 300, 366, 406, 9204, 4073, 13, 1018, 286, 2835, 949, 11, 10225, 15277, 294, 11002, 4257, 5101, 9494, 50636], "temperature": 0.0, "avg_logprob": -0.17650489109318432, "compression_ratio": 1.68348623853211, "no_speech_prob": 0.00010554042091825977}, {"id": 124, "seek": 79132, "start": 796.7600000000001, "end": 803.7600000000001, "text": " temporary arrays and whenever we introduce that arrays into it or the buffers associated", "tokens": [50636, 13413, 41011, 293, 5699, 321, 5366, 300, 41011, 666, 309, 420, 264, 9204, 433, 6615, 50986], "temperature": 0.0, "avg_logprob": -0.17650489109318432, "compression_ratio": 1.68348623853211, "no_speech_prob": 0.00010554042091825977}, {"id": 125, "seek": 79132, "start": 804.5600000000001, "end": 811.5600000000001, "text": " with it, it looks like a lot of low level code. Whereas, expressions that are not associated", "tokens": [51026, 365, 309, 11, 309, 1542, 411, 257, 688, 295, 2295, 1496, 3089, 13, 13813, 11, 15277, 300, 366, 406, 6615, 51376], "temperature": 0.0, "avg_logprob": -0.17650489109318432, "compression_ratio": 1.68348623853211, "no_speech_prob": 0.00010554042091825977}, {"id": 126, "seek": 79132, "start": 813.5200000000001, "end": 819.8000000000001, "text": " with these buffers are still higher level concepts. So, that if you have chains of intrinsic", "tokens": [51474, 365, 613, 9204, 433, 366, 920, 2946, 1496, 10392, 13, 407, 11, 300, 498, 291, 362, 12626, 295, 35698, 51788], "temperature": 0.0, "avg_logprob": -0.17650489109318432, "compression_ratio": 1.68348623853211, "no_speech_prob": 0.00010554042091825977}, {"id": 127, "seek": 81980, "start": 820.16, "end": 824.5999999999999, "text": " functions that operate on arrays, it is easy to do some kind of processing there to simplify", "tokens": [50382, 6828, 300, 9651, 322, 41011, 11, 309, 307, 1858, 281, 360, 512, 733, 295, 9007, 456, 281, 20460, 50604], "temperature": 0.0, "avg_logprob": -0.16259017357459435, "compression_ratio": 1.7440273037542662, "no_speech_prob": 5.738374966313131e-05}, {"id": 128, "seek": 81980, "start": 824.5999999999999, "end": 828.92, "text": " those expressions. It also introduces the concept of variables.", "tokens": [50604, 729, 15277, 13, 467, 611, 31472, 264, 3410, 295, 9102, 13, 50820], "temperature": 0.0, "avg_logprob": -0.16259017357459435, "compression_ratio": 1.7440273037542662, "no_speech_prob": 5.738374966313131e-05}, {"id": 129, "seek": 81980, "start": 828.92, "end": 835.12, "text": " So, there is something, there is an operation in high level FIR called HLFIR variable which", "tokens": [50820, 407, 11, 456, 307, 746, 11, 456, 307, 364, 6916, 294, 1090, 1496, 41538, 1219, 389, 43, 37, 7740, 7006, 597, 51130], "temperature": 0.0, "avg_logprob": -0.16259017357459435, "compression_ratio": 1.7440273037542662, "no_speech_prob": 5.738374966313131e-05}, {"id": 130, "seek": 81980, "start": 835.12, "end": 839.4, "text": " collects information about all the variables in a single place. So, that you know this", "tokens": [51130, 39897, 1589, 466, 439, 264, 9102, 294, 257, 2167, 1081, 13, 407, 11, 300, 291, 458, 341, 51344], "temperature": 0.0, "avg_logprob": -0.16259017357459435, "compression_ratio": 1.7440273037542662, "no_speech_prob": 5.738374966313131e-05}, {"id": 131, "seek": 81980, "start": 839.4, "end": 843.9599999999999, "text": " is the variable and what its properties are. Some of these might be modeled by attributes", "tokens": [51344, 307, 264, 7006, 293, 437, 1080, 7221, 366, 13, 2188, 295, 613, 1062, 312, 37140, 538, 17212, 51572], "temperature": 0.0, "avg_logprob": -0.16259017357459435, "compression_ratio": 1.7440273037542662, "no_speech_prob": 5.738374966313131e-05}, {"id": 132, "seek": 81980, "start": 843.9599999999999, "end": 848.76, "text": " like if you say that a Fortran variable is a pointer or allocatable that is marked as", "tokens": [51572, 411, 498, 291, 584, 300, 257, 11002, 4257, 7006, 307, 257, 23918, 420, 12660, 31415, 300, 307, 12658, 382, 51812], "temperature": 0.0, "avg_logprob": -0.16259017357459435, "compression_ratio": 1.7440273037542662, "no_speech_prob": 5.738374966313131e-05}, {"id": 133, "seek": 84876, "start": 848.76, "end": 855.72, "text": " an attribute. It also identifies the shape of the array, you know if that is an array", "tokens": [50364, 364, 19667, 13, 467, 611, 34597, 264, 3909, 295, 264, 10225, 11, 291, 458, 498, 300, 307, 364, 10225, 50712], "temperature": 0.0, "avg_logprob": -0.17869491355363712, "compression_ratio": 1.6780487804878048, "no_speech_prob": 0.0001273030648007989}, {"id": 134, "seek": 84876, "start": 855.72, "end": 862.72, "text": " along with the memory associated with it. So, then the initial lowering will be from", "tokens": [50712, 2051, 365, 264, 4675, 6615, 365, 309, 13, 407, 11, 550, 264, 5883, 28124, 486, 312, 490, 51062], "temperature": 0.0, "avg_logprob": -0.17869491355363712, "compression_ratio": 1.6780487804878048, "no_speech_prob": 0.0001273030648007989}, {"id": 135, "seek": 84876, "start": 863.12, "end": 869.2, "text": " the Fortran source to a mix of high level FIR and FIR and then the high level FIR is", "tokens": [51082, 264, 11002, 4257, 4009, 281, 257, 2890, 295, 1090, 1496, 41538, 293, 41538, 293, 550, 264, 1090, 1496, 41538, 307, 51386], "temperature": 0.0, "avg_logprob": -0.17869491355363712, "compression_ratio": 1.6780487804878048, "no_speech_prob": 0.0001273030648007989}, {"id": 136, "seek": 84876, "start": 869.2, "end": 875.0, "text": " converted again to FIR and then the rest of the pipeline kicks in as always. So, I would", "tokens": [51386, 16424, 797, 281, 41538, 293, 550, 264, 1472, 295, 264, 15517, 21293, 294, 382, 1009, 13, 407, 11, 286, 576, 51676], "temperature": 0.0, "avg_logprob": -0.17869491355363712, "compression_ratio": 1.6780487804878048, "no_speech_prob": 0.0001273030648007989}, {"id": 137, "seek": 87500, "start": 875.08, "end": 880.56, "text": " not be going into the details, but if people are interested there is a detail RFC you know", "tokens": [50368, 406, 312, 516, 666, 264, 4365, 11, 457, 498, 561, 366, 3102, 456, 307, 257, 2607, 497, 18671, 291, 458, 50642], "temperature": 0.0, "avg_logprob": -0.20627811976841517, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.0006985521758906543}, {"id": 138, "seek": 87500, "start": 880.56, "end": 887.56, "text": " inside the flying documents repository. But I will try to show you an example.", "tokens": [50642, 1854, 264, 7137, 8512, 25841, 13, 583, 286, 486, 853, 281, 855, 291, 364, 1365, 13, 50992], "temperature": 0.0, "avg_logprob": -0.20627811976841517, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.0006985521758906543}, {"id": 139, "seek": 87500, "start": 887.56, "end": 893.76, "text": " So, this is the Fortran source code and what we have is a declaration of two arrays. The", "tokens": [50992, 407, 11, 341, 307, 264, 11002, 4257, 4009, 3089, 293, 437, 321, 362, 307, 257, 27606, 295, 732, 41011, 13, 440, 51302], "temperature": 0.0, "avg_logprob": -0.20627811976841517, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.0006985521758906543}, {"id": 140, "seek": 87500, "start": 893.76, "end": 897.52, "text": " first array called Y is a two dimensional array, the second one is a single dimensional", "tokens": [51302, 700, 10225, 1219, 398, 307, 257, 732, 18795, 10225, 11, 264, 1150, 472, 307, 257, 2167, 18795, 51490], "temperature": 0.0, "avg_logprob": -0.20627811976841517, "compression_ratio": 1.5727272727272728, "no_speech_prob": 0.0006985521758906543}, {"id": 141, "seek": 89752, "start": 897.52, "end": 904.52, "text": " array and then we are summing all the rows or columns in the first array Y and storing", "tokens": [50364, 10225, 293, 550, 321, 366, 2408, 2810, 439, 264, 13241, 420, 13766, 294, 264, 700, 10225, 398, 293, 26085, 50714], "temperature": 0.0, "avg_logprob": -0.16025822136991769, "compression_ratio": 1.6527777777777777, "no_speech_prob": 0.00022341030125971884}, {"id": 142, "seek": 89752, "start": 905.68, "end": 912.68, "text": " it in the result array that is the array called S. I tried to put the FIR code for this in", "tokens": [50772, 309, 294, 264, 1874, 10225, 300, 307, 264, 10225, 1219, 318, 13, 286, 3031, 281, 829, 264, 41538, 3089, 337, 341, 294, 51122], "temperature": 0.0, "avg_logprob": -0.16025822136991769, "compression_ratio": 1.6527777777777777, "no_speech_prob": 0.00022341030125971884}, {"id": 143, "seek": 89752, "start": 913.72, "end": 919.28, "text": " a slide, but it happened to be too much and it would not fit in one slide or two slides.", "tokens": [51174, 257, 4137, 11, 457, 309, 2011, 281, 312, 886, 709, 293, 309, 576, 406, 3318, 294, 472, 4137, 420, 732, 9788, 13, 51452], "temperature": 0.0, "avg_logprob": -0.16025822136991769, "compression_ratio": 1.6527777777777777, "no_speech_prob": 0.00022341030125971884}, {"id": 144, "seek": 89752, "start": 919.28, "end": 925.0799999999999, "text": " So, I have just left the comments here whereas the source code is completely gone. So, you", "tokens": [51452, 407, 11, 286, 362, 445, 1411, 264, 3053, 510, 9735, 264, 4009, 3089, 307, 2584, 2780, 13, 407, 11, 291, 51742], "temperature": 0.0, "avg_logprob": -0.16025822136991769, "compression_ratio": 1.6527777777777777, "no_speech_prob": 0.00022341030125971884}, {"id": 145, "seek": 92508, "start": 925.12, "end": 930.9200000000001, "text": " can see that there is some FIR aloca which allocates that array and the name of that variable", "tokens": [50366, 393, 536, 300, 456, 307, 512, 41538, 419, 24035, 597, 12660, 1024, 300, 10225, 293, 264, 1315, 295, 300, 7006, 50656], "temperature": 0.0, "avg_logprob": -0.18471060242763784, "compression_ratio": 1.8877005347593583, "no_speech_prob": 0.00045037121162749827}, {"id": 146, "seek": 92508, "start": 930.9200000000001, "end": 936.12, "text": " was part of that aloca. You can also see that there is a call to the runtime for the sum", "tokens": [50656, 390, 644, 295, 300, 419, 24035, 13, 509, 393, 611, 536, 300, 456, 307, 257, 818, 281, 264, 34474, 337, 264, 2408, 50916], "temperature": 0.0, "avg_logprob": -0.18471060242763784, "compression_ratio": 1.8877005347593583, "no_speech_prob": 0.00045037121162749827}, {"id": 147, "seek": 92508, "start": 936.12, "end": 943.12, "text": " function. You can see some comments that I mentioned there that the runtime calls and", "tokens": [50916, 2445, 13, 509, 393, 536, 512, 3053, 300, 286, 2835, 456, 300, 264, 34474, 5498, 293, 51266], "temperature": 0.0, "avg_logprob": -0.18471060242763784, "compression_ratio": 1.8877005347593583, "no_speech_prob": 0.00045037121162749827}, {"id": 148, "seek": 92508, "start": 945.2800000000001, "end": 950.44, "text": " it allocates a buffer on the heap and then returns that and then that heap is copied", "tokens": [51374, 309, 12660, 1024, 257, 21762, 322, 264, 33591, 293, 550, 11247, 300, 293, 550, 300, 33591, 307, 25365, 51632], "temperature": 0.0, "avg_logprob": -0.18471060242763784, "compression_ratio": 1.8877005347593583, "no_speech_prob": 0.00045037121162749827}, {"id": 149, "seek": 95044, "start": 950.48, "end": 957.48, "text": " to the real variable and the original heap is deallocated. Not much here, but if you", "tokens": [50366, 281, 264, 957, 7006, 293, 264, 3380, 33591, 307, 368, 336, 905, 770, 13, 1726, 709, 510, 11, 457, 498, 291, 50716], "temperature": 0.0, "avg_logprob": -0.17510590345963187, "compression_ratio": 1.7044334975369457, "no_speech_prob": 0.0003512974362820387}, {"id": 150, "seek": 95044, "start": 957.6800000000001, "end": 964.6800000000001, "text": " come to the HLFIR you know you can actually fit that into a single slide because it models", "tokens": [50726, 808, 281, 264, 389, 43, 37, 7740, 291, 458, 291, 393, 767, 3318, 300, 666, 257, 2167, 4137, 570, 309, 5245, 51076], "temperature": 0.0, "avg_logprob": -0.17510590345963187, "compression_ratio": 1.7044334975369457, "no_speech_prob": 0.0003512974362820387}, {"id": 151, "seek": 95044, "start": 965.2800000000001, "end": 970.4000000000001, "text": " things at a higher level. So, the important difference to notice here is that there is", "tokens": [51106, 721, 412, 257, 2946, 1496, 13, 407, 11, 264, 1021, 2649, 281, 3449, 510, 307, 300, 456, 307, 51362], "temperature": 0.0, "avg_logprob": -0.17510590345963187, "compression_ratio": 1.7044334975369457, "no_speech_prob": 0.0003512974362820387}, {"id": 152, "seek": 95044, "start": 970.4000000000001, "end": 975.32, "text": " an HLFIR declare that there are two HLFIR declares that declares the variables that", "tokens": [51362, 364, 389, 43, 37, 7740, 19710, 300, 456, 366, 732, 389, 43, 37, 7740, 979, 19415, 300, 979, 19415, 264, 9102, 300, 51608], "temperature": 0.0, "avg_logprob": -0.17510590345963187, "compression_ratio": 1.7044334975369457, "no_speech_prob": 0.0003512974362820387}, {"id": 153, "seek": 97532, "start": 975.32, "end": 980.9200000000001, "text": " are there in your program. So, you can see that there are two arrays S and Y they have", "tokens": [50364, 366, 456, 294, 428, 1461, 13, 407, 11, 291, 393, 536, 300, 456, 366, 732, 41011, 318, 293, 398, 436, 362, 50644], "temperature": 0.0, "avg_logprob": -0.18044151979334214, "compression_ratio": 1.799163179916318, "no_speech_prob": 0.0013665076112374663}, {"id": 154, "seek": 97532, "start": 980.9200000000001, "end": 986.6, "text": " a representation for that and instead of a runtime call you have an operation called", "tokens": [50644, 257, 10290, 337, 300, 293, 2602, 295, 257, 34474, 818, 291, 362, 364, 6916, 1219, 50928], "temperature": 0.0, "avg_logprob": -0.18044151979334214, "compression_ratio": 1.799163179916318, "no_speech_prob": 0.0013665076112374663}, {"id": 155, "seek": 97532, "start": 986.6, "end": 992.24, "text": " HLFIR sum that actually returns something called an HLFIR expression. So, there is no", "tokens": [50928, 389, 43, 37, 7740, 2408, 300, 767, 11247, 746, 1219, 364, 389, 43, 37, 7740, 6114, 13, 407, 11, 456, 307, 572, 51210], "temperature": 0.0, "avg_logprob": -0.18044151979334214, "compression_ratio": 1.799163179916318, "no_speech_prob": 0.0013665076112374663}, {"id": 156, "seek": 97532, "start": 992.24, "end": 996.84, "text": " buffer associated with it or the runtime is not called there is no memory allocated as", "tokens": [51210, 21762, 6615, 365, 309, 420, 264, 34474, 307, 406, 1219, 456, 307, 572, 4675, 29772, 382, 51440], "temperature": 0.0, "avg_logprob": -0.18044151979334214, "compression_ratio": 1.799163179916318, "no_speech_prob": 0.0013665076112374663}, {"id": 157, "seek": 97532, "start": 996.84, "end": 1002.7600000000001, "text": " of now and then that is assigned from the expression to the original variable that is", "tokens": [51440, 295, 586, 293, 550, 300, 307, 13279, 490, 264, 6114, 281, 264, 3380, 7006, 300, 307, 51736], "temperature": 0.0, "avg_logprob": -0.18044151979334214, "compression_ratio": 1.799163179916318, "no_speech_prob": 0.0013665076112374663}, {"id": 158, "seek": 100276, "start": 1002.76, "end": 1009.4399999999999, "text": " a result array S. So, basically I just want to show that you", "tokens": [50364, 257, 1874, 10225, 318, 13, 407, 11, 1936, 286, 445, 528, 281, 855, 300, 291, 50698], "temperature": 0.0, "avg_logprob": -0.21828160005457262, "compression_ratio": 1.5235849056603774, "no_speech_prob": 0.00031987670809030533}, {"id": 159, "seek": 100276, "start": 1009.4399999999999, "end": 1015.16, "text": " know this is at a higher level it has some concepts called variables and it has also", "tokens": [50698, 458, 341, 307, 412, 257, 2946, 1496, 309, 575, 512, 10392, 1219, 9102, 293, 309, 575, 611, 50984], "temperature": 0.0, "avg_logprob": -0.21828160005457262, "compression_ratio": 1.5235849056603774, "no_speech_prob": 0.00031987670809030533}, {"id": 160, "seek": 100276, "start": 1015.16, "end": 1021.96, "text": " some things called expressions. I will now move on to polymorphic types. Polymorphic", "tokens": [50984, 512, 721, 1219, 15277, 13, 286, 486, 586, 1286, 322, 281, 6754, 76, 18191, 299, 3467, 13, 18553, 76, 18191, 299, 51324], "temperature": 0.0, "avg_logprob": -0.21828160005457262, "compression_ratio": 1.5235849056603774, "no_speech_prob": 0.00031987670809030533}, {"id": 161, "seek": 100276, "start": 1021.96, "end": 1028.96, "text": " types came as part of the FORTRAN 2003 standard. The types are only known at runtime FORTRAN", "tokens": [51324, 3467, 1361, 382, 644, 295, 264, 15174, 25936, 1770, 16416, 3832, 13, 440, 3467, 366, 787, 2570, 412, 34474, 15174, 25936, 1770, 51674], "temperature": 0.0, "avg_logprob": -0.21828160005457262, "compression_ratio": 1.5235849056603774, "no_speech_prob": 0.00031987670809030533}, {"id": 162, "seek": 102896, "start": 1029.08, "end": 1034.16, "text": " has the class type for specifying such a type. You know if you have a class type it can", "tokens": [50370, 575, 264, 1508, 2010, 337, 1608, 5489, 1270, 257, 2010, 13, 509, 458, 498, 291, 362, 257, 1508, 2010, 309, 393, 50624], "temperature": 0.0, "avg_logprob": -0.16612403797653486, "compression_ratio": 1.7183673469387755, "no_speech_prob": 0.0013456190936267376}, {"id": 163, "seek": 102896, "start": 1034.16, "end": 1039.44, "text": " refer to either that type or any of the type that extends from it. So, extension is the", "tokens": [50624, 2864, 281, 2139, 300, 2010, 420, 604, 295, 264, 2010, 300, 26448, 490, 309, 13, 407, 11, 10320, 307, 264, 50888], "temperature": 0.0, "avg_logprob": -0.16612403797653486, "compression_ratio": 1.7183673469387755, "no_speech_prob": 0.0013456190936267376}, {"id": 164, "seek": 102896, "start": 1039.44, "end": 1045.68, "text": " name for the inheritance concept that is there in some other languages. Again I will not", "tokens": [50888, 1315, 337, 264, 32122, 3410, 300, 307, 456, 294, 512, 661, 8650, 13, 3764, 286, 486, 406, 51200], "temperature": 0.0, "avg_logprob": -0.16612403797653486, "compression_ratio": 1.7183673469387755, "no_speech_prob": 0.0013456190936267376}, {"id": 165, "seek": 102896, "start": 1045.68, "end": 1049.4, "text": " go into much details I have an example in the next slide, but if people are interested", "tokens": [51200, 352, 666, 709, 4365, 286, 362, 364, 1365, 294, 264, 958, 4137, 11, 457, 498, 561, 366, 3102, 51386], "temperature": 0.0, "avg_logprob": -0.16612403797653486, "compression_ratio": 1.7183673469387755, "no_speech_prob": 0.0013456190936267376}, {"id": 166, "seek": 102896, "start": 1049.4, "end": 1054.32, "text": " they can check this RFC. So, only the example that I have on the left", "tokens": [51386, 436, 393, 1520, 341, 497, 18671, 13, 407, 11, 787, 264, 1365, 300, 286, 362, 322, 264, 1411, 51632], "temperature": 0.0, "avg_logprob": -0.16612403797653486, "compression_ratio": 1.7183673469387755, "no_speech_prob": 0.0013456190936267376}, {"id": 167, "seek": 105432, "start": 1054.3999999999999, "end": 1061.0, "text": " hand side there is a type called point. We call it derived types in FORTRAN and then", "tokens": [50368, 1011, 1252, 456, 307, 257, 2010, 1219, 935, 13, 492, 818, 309, 18949, 3467, 294, 15174, 25936, 1770, 293, 550, 50698], "temperature": 0.0, "avg_logprob": -0.21464367346330124, "compression_ratio": 1.7411167512690355, "no_speech_prob": 0.0004238276742398739}, {"id": 168, "seek": 105432, "start": 1061.0, "end": 1065.48, "text": " you have a three dimensional type it extends from point and basically it just adds another", "tokens": [50698, 291, 362, 257, 1045, 18795, 2010, 309, 26448, 490, 935, 293, 1936, 309, 445, 10860, 1071, 50922], "temperature": 0.0, "avg_logprob": -0.21464367346330124, "compression_ratio": 1.7411167512690355, "no_speech_prob": 0.0004238276742398739}, {"id": 169, "seek": 105432, "start": 1065.48, "end": 1072.48, "text": " field to it. We have a class type that is called P3D and then you call this subroutine", "tokens": [50922, 2519, 281, 309, 13, 492, 362, 257, 1508, 2010, 300, 307, 1219, 430, 18, 35, 293, 550, 291, 818, 341, 1422, 81, 45075, 51272], "temperature": 0.0, "avg_logprob": -0.21464367346330124, "compression_ratio": 1.7411167512690355, "no_speech_prob": 0.0004238276742398739}, {"id": 170, "seek": 105432, "start": 1076.3999999999999, "end": 1083.3999999999999, "text": " called foe and then this subroutine accepts it as a class type of the base type.", "tokens": [51468, 1219, 726, 68, 293, 550, 341, 1422, 81, 45075, 33538, 309, 382, 257, 1508, 2010, 295, 264, 3096, 2010, 13, 51818], "temperature": 0.0, "avg_logprob": -0.21464367346330124, "compression_ratio": 1.7411167512690355, "no_speech_prob": 0.0004238276742398739}, {"id": 171, "seek": 108432, "start": 1084.6799999999998, "end": 1090.58, "text": " Then there is a construct called select type in FORTRAN that you know that can at runtime", "tokens": [50382, 1396, 456, 307, 257, 7690, 1219, 3048, 2010, 294, 15174, 25936, 1770, 300, 291, 458, 300, 393, 412, 34474, 50677], "temperature": 0.0, "avg_logprob": -0.18449522138715865, "compression_ratio": 1.7918367346938775, "no_speech_prob": 0.00039809459121897817}, {"id": 172, "seek": 108432, "start": 1090.58, "end": 1095.04, "text": " identify which type it is. So, if its type is point 3D then something is printed, if", "tokens": [50677, 5876, 597, 2010, 309, 307, 13, 407, 11, 498, 1080, 2010, 307, 935, 805, 35, 550, 746, 307, 13567, 11, 498, 50900], "temperature": 0.0, "avg_logprob": -0.18449522138715865, "compression_ratio": 1.7918367346938775, "no_speech_prob": 0.00039809459121897817}, {"id": 173, "seek": 108432, "start": 1095.04, "end": 1100.52, "text": " its type is point something else is printed. So, the modeling mostly follows what is there", "tokens": [50900, 1080, 2010, 307, 935, 746, 1646, 307, 13567, 13, 407, 11, 264, 15983, 5240, 10002, 437, 307, 456, 51174], "temperature": 0.0, "avg_logprob": -0.18449522138715865, "compression_ratio": 1.7918367346938775, "no_speech_prob": 0.00039809459121897817}, {"id": 174, "seek": 108432, "start": 1100.52, "end": 1107.52, "text": " in this code. We have something called the FIR type and that type has the ones in green", "tokens": [51174, 294, 341, 3089, 13, 492, 362, 746, 1219, 264, 479, 7740, 2010, 293, 300, 2010, 575, 264, 2306, 294, 3092, 51524], "temperature": 0.0, "avg_logprob": -0.18449522138715865, "compression_ratio": 1.7918367346938775, "no_speech_prob": 0.00039809459121897817}, {"id": 175, "seek": 108432, "start": 1107.56, "end": 1113.1599999999999, "text": " are the extended type, the ones in red are the base type. You can see that there is a", "tokens": [51526, 366, 264, 10913, 2010, 11, 264, 2306, 294, 2182, 366, 264, 3096, 2010, 13, 509, 393, 536, 300, 456, 307, 257, 51806], "temperature": 0.0, "avg_logprob": -0.18449522138715865, "compression_ratio": 1.7918367346938775, "no_speech_prob": 0.00039809459121897817}, {"id": 176, "seek": 111316, "start": 1113.2, "end": 1120.2, "text": " FIR class that has inside it FIR type and then you have this FIR select type construct", "tokens": [50366, 479, 7740, 1508, 300, 575, 1854, 309, 479, 7740, 2010, 293, 550, 291, 362, 341, 479, 7740, 3048, 2010, 7690, 50716], "temperature": 0.0, "avg_logprob": -0.17028204600016275, "compression_ratio": 1.8368421052631578, "no_speech_prob": 0.00031482113990932703}, {"id": 177, "seek": 111316, "start": 1121.96, "end": 1128.96, "text": " which tries to match between the base type or the extended type and then it branches", "tokens": [50804, 597, 9898, 281, 2995, 1296, 264, 3096, 2010, 420, 264, 10913, 2010, 293, 550, 309, 14770, 51154], "temperature": 0.0, "avg_logprob": -0.17028204600016275, "compression_ratio": 1.8368421052631578, "no_speech_prob": 0.00031482113990932703}, {"id": 178, "seek": 111316, "start": 1130.0, "end": 1135.28, "text": " off to the basic blocks that handle it. It is basic block one for the extended type and", "tokens": [51206, 766, 281, 264, 3875, 8474, 300, 4813, 309, 13, 467, 307, 3875, 3461, 472, 337, 264, 10913, 2010, 293, 51470], "temperature": 0.0, "avg_logprob": -0.17028204600016275, "compression_ratio": 1.8368421052631578, "no_speech_prob": 0.00031482113990932703}, {"id": 179, "seek": 111316, "start": 1135.28, "end": 1140.92, "text": " they are basic block two for the base type. So, at runtime also when you generate further", "tokens": [51470, 436, 366, 3875, 3461, 732, 337, 264, 3096, 2010, 13, 407, 11, 412, 34474, 611, 562, 291, 8460, 3052, 51752], "temperature": 0.0, "avg_logprob": -0.17028204600016275, "compression_ratio": 1.8368421052631578, "no_speech_prob": 0.00031482113990932703}, {"id": 180, "seek": 114092, "start": 1140.96, "end": 1146.48, "text": " lower level code like LVM there will be some comparison instructions that compares whether", "tokens": [50366, 3126, 1496, 3089, 411, 441, 53, 44, 456, 486, 312, 512, 9660, 9415, 300, 38334, 1968, 50642], "temperature": 0.0, "avg_logprob": -0.1915420256939131, "compression_ratio": 1.7344398340248963, "no_speech_prob": 0.0003918969596270472}, {"id": 181, "seek": 114092, "start": 1146.48, "end": 1151.3200000000002, "text": " it is that type. Types will probably be represented as structures that are global. So, you can", "tokens": [50642, 309, 307, 300, 2010, 13, 5569, 5190, 486, 1391, 312, 10379, 382, 9227, 300, 366, 4338, 13, 407, 11, 291, 393, 50884], "temperature": 0.0, "avg_logprob": -0.1915420256939131, "compression_ratio": 1.7344398340248963, "no_speech_prob": 0.0003918969596270472}, {"id": 182, "seek": 114092, "start": 1151.3200000000002, "end": 1155.0800000000002, "text": " compare with it to know what is the real type.", "tokens": [50884, 6794, 365, 309, 281, 458, 437, 307, 264, 957, 2010, 13, 51072], "temperature": 0.0, "avg_logprob": -0.1915420256939131, "compression_ratio": 1.7344398340248963, "no_speech_prob": 0.0003918969596270472}, {"id": 183, "seek": 114092, "start": 1155.0800000000002, "end": 1162.0800000000002, "text": " So, next I move to alias analysis. So, alias analysis is important to distinguish between", "tokens": [51072, 407, 11, 958, 286, 1286, 281, 419, 4609, 5215, 13, 407, 11, 419, 4609, 5215, 307, 1021, 281, 20206, 1296, 51422], "temperature": 0.0, "avg_logprob": -0.1915420256939131, "compression_ratio": 1.7344398340248963, "no_speech_prob": 0.0003918969596270472}, {"id": 184, "seek": 114092, "start": 1164.2, "end": 1170.24, "text": " different arrays that can potentially alias as well as to say that two arrays cannot definitely", "tokens": [51528, 819, 41011, 300, 393, 7263, 419, 4609, 382, 731, 382, 281, 584, 300, 732, 41011, 2644, 2138, 51830], "temperature": 0.0, "avg_logprob": -0.1915420256939131, "compression_ratio": 1.7344398340248963, "no_speech_prob": 0.0003918969596270472}, {"id": 185, "seek": 117024, "start": 1170.24, "end": 1176.52, "text": " alias. The rules of aliasing in Fortran is different from what is there in C and so you", "tokens": [50364, 419, 4609, 13, 440, 4474, 295, 10198, 3349, 294, 11002, 4257, 307, 819, 490, 437, 307, 456, 294, 383, 293, 370, 291, 50678], "temperature": 0.0, "avg_logprob": -0.2085677745730378, "compression_ratio": 1.680952380952381, "no_speech_prob": 0.00016345642507076263}, {"id": 186, "seek": 117024, "start": 1176.52, "end": 1183.52, "text": " know we cannot directly reuse whatever is there in C. In general I mean there are exceptions", "tokens": [50678, 458, 321, 2644, 3838, 26225, 2035, 307, 456, 294, 383, 13, 682, 2674, 286, 914, 456, 366, 22847, 51028], "temperature": 0.0, "avg_logprob": -0.2085677745730378, "compression_ratio": 1.680952380952381, "no_speech_prob": 0.00016345642507076263}, {"id": 187, "seek": 117024, "start": 1183.72, "end": 1189.68, "text": " and lot of other special cases. Arrays do not overlap unless you specify that you know", "tokens": [51038, 293, 688, 295, 661, 2121, 3331, 13, 1587, 36212, 360, 406, 19959, 5969, 291, 16500, 300, 291, 458, 51336], "temperature": 0.0, "avg_logprob": -0.2085677745730378, "compression_ratio": 1.680952380952381, "no_speech_prob": 0.00016345642507076263}, {"id": 188, "seek": 117024, "start": 1189.68, "end": 1195.64, "text": " some array is a pointer and another array is a target and then these two can overlap.", "tokens": [51336, 512, 10225, 307, 257, 23918, 293, 1071, 10225, 307, 257, 3779, 293, 550, 613, 732, 393, 19959, 13, 51634], "temperature": 0.0, "avg_logprob": -0.2085677745730378, "compression_ratio": 1.680952380952381, "no_speech_prob": 0.00016345642507076263}, {"id": 189, "seek": 119564, "start": 1196.44, "end": 1200.76, "text": " Ideally we should benefit from the restrict patches that are being worked on, but that", "tokens": [50404, 40817, 321, 820, 5121, 490, 264, 7694, 26531, 300, 366, 885, 2732, 322, 11, 457, 300, 50620], "temperature": 0.0, "avg_logprob": -0.19276446216511275, "compression_ratio": 1.6282527881040891, "no_speech_prob": 0.00010070820280816406}, {"id": 190, "seek": 119564, "start": 1200.76, "end": 1206.3200000000002, "text": " work is not yet complete. We also have some issues with pointer escape and all. That is", "tokens": [50620, 589, 307, 406, 1939, 3566, 13, 492, 611, 362, 512, 2663, 365, 23918, 7615, 293, 439, 13, 663, 307, 50898], "temperature": 0.0, "avg_logprob": -0.19276446216511275, "compression_ratio": 1.6282527881040891, "no_speech_prob": 0.00010070820280816406}, {"id": 191, "seek": 119564, "start": 1206.3200000000002, "end": 1213.3200000000002, "text": " all captured in this RFC by Slava. But we still need to do some kind of alias analysis", "tokens": [50898, 439, 11828, 294, 341, 497, 18671, 538, 6187, 4061, 13, 583, 321, 920, 643, 281, 360, 512, 733, 295, 419, 4609, 5215, 51248], "temperature": 0.0, "avg_logprob": -0.19276446216511275, "compression_ratio": 1.6282527881040891, "no_speech_prob": 0.00010070820280816406}, {"id": 192, "seek": 119564, "start": 1214.44, "end": 1219.0400000000002, "text": " because otherwise as we saw in some of the earlier slides where I show the performance", "tokens": [51304, 570, 5911, 382, 321, 1866, 294, 512, 295, 264, 3071, 9788, 689, 286, 855, 264, 3389, 51534], "temperature": 0.0, "avg_logprob": -0.19276446216511275, "compression_ratio": 1.6282527881040891, "no_speech_prob": 0.00010070820280816406}, {"id": 193, "seek": 119564, "start": 1219.0400000000002, "end": 1225.2, "text": " results you know the performance is hampered by the lack of alias information in the LLVM", "tokens": [51534, 3542, 291, 458, 264, 3389, 307, 7852, 40004, 538, 264, 5011, 295, 419, 4609, 1589, 294, 264, 441, 43, 53, 44, 51842], "temperature": 0.0, "avg_logprob": -0.19276446216511275, "compression_ratio": 1.6282527881040891, "no_speech_prob": 0.00010070820280816406}, {"id": 194, "seek": 122520, "start": 1225.24, "end": 1230.0, "text": " optimizer. We probably have some more information at the fair level, but much of the optimization", "tokens": [50366, 5028, 6545, 13, 492, 1391, 362, 512, 544, 1589, 412, 264, 3143, 1496, 11, 457, 709, 295, 264, 19618, 50604], "temperature": 0.0, "avg_logprob": -0.17253084497137383, "compression_ratio": 1.6787330316742082, "no_speech_prob": 0.00022340010036714375}, {"id": 195, "seek": 122520, "start": 1230.0, "end": 1236.0, "text": " is currently delegated to LLVM. So, LLVM still needs that information to do the optimizations.", "tokens": [50604, 307, 4362, 15824, 770, 281, 441, 43, 53, 44, 13, 407, 11, 441, 43, 53, 44, 920, 2203, 300, 1589, 281, 360, 264, 5028, 14455, 13, 50904], "temperature": 0.0, "avg_logprob": -0.17253084497137383, "compression_ratio": 1.6787330316742082, "no_speech_prob": 0.00022340010036714375}, {"id": 196, "seek": 122520, "start": 1236.0, "end": 1242.72, "text": " So, as a first step what we have done is that you know we are trying to distinguish between", "tokens": [50904, 407, 11, 382, 257, 700, 1823, 437, 321, 362, 1096, 307, 300, 291, 458, 321, 366, 1382, 281, 20206, 1296, 51240], "temperature": 0.0, "avg_logprob": -0.17253084497137383, "compression_ratio": 1.6787330316742082, "no_speech_prob": 0.00022340010036714375}, {"id": 197, "seek": 122520, "start": 1242.72, "end": 1249.64, "text": " accessing the descriptor versus accessing another memory. So, as I might have probably", "tokens": [51240, 26440, 264, 31280, 284, 5717, 26440, 1071, 4675, 13, 407, 11, 382, 286, 1062, 362, 1391, 51586], "temperature": 0.0, "avg_logprob": -0.17253084497137383, "compression_ratio": 1.6787330316742082, "no_speech_prob": 0.00022340010036714375}, {"id": 198, "seek": 124964, "start": 1249.64, "end": 1255.0, "text": " mentioned before Fortran has arrays and it does it is very good at arrays. So, sometimes", "tokens": [50364, 2835, 949, 11002, 4257, 575, 41011, 293, 309, 775, 309, 307, 588, 665, 412, 41011, 13, 407, 11, 2171, 50632], "temperature": 0.0, "avg_logprob": -0.24115018049875894, "compression_ratio": 1.829875518672199, "no_speech_prob": 0.0025107853580266237}, {"id": 199, "seek": 124964, "start": 1255.0, "end": 1259.72, "text": " to pass additional information you cannot just pass just a pointer. You might need to", "tokens": [50632, 281, 1320, 4497, 1589, 291, 2644, 445, 1320, 445, 257, 23918, 13, 509, 1062, 643, 281, 50868], "temperature": 0.0, "avg_logprob": -0.24115018049875894, "compression_ratio": 1.829875518672199, "no_speech_prob": 0.0025107853580266237}, {"id": 200, "seek": 124964, "start": 1259.72, "end": 1266.72, "text": " pass additional information like its rank or its you know starting dimension starting", "tokens": [50868, 1320, 4497, 1589, 411, 1080, 6181, 420, 1080, 291, 458, 2891, 10139, 2891, 51218], "temperature": 0.0, "avg_logprob": -0.24115018049875894, "compression_ratio": 1.829875518672199, "no_speech_prob": 0.0025107853580266237}, {"id": 201, "seek": 124964, "start": 1267.3200000000002, "end": 1273.6000000000001, "text": " extents value or its ending low basically the lower bounds or upper bounds to see whether", "tokens": [51248, 1279, 791, 2158, 420, 1080, 8121, 2295, 1936, 264, 3126, 29905, 420, 6597, 29905, 281, 536, 1968, 51562], "temperature": 0.0, "avg_logprob": -0.24115018049875894, "compression_ratio": 1.829875518672199, "no_speech_prob": 0.0025107853580266237}, {"id": 202, "seek": 124964, "start": 1273.6000000000001, "end": 1278.16, "text": " that array has a stride or not you know there are all these information that can be passed", "tokens": [51562, 300, 10225, 575, 257, 1056, 482, 420, 406, 291, 458, 456, 366, 439, 613, 1589, 300, 393, 312, 4678, 51790], "temperature": 0.0, "avg_logprob": -0.24115018049875894, "compression_ratio": 1.829875518672199, "no_speech_prob": 0.0025107853580266237}, {"id": 203, "seek": 127816, "start": 1278.16, "end": 1282.44, "text": " in the descriptor. The descriptor is generally modeled as a structure at the LLVM level.", "tokens": [50364, 294, 264, 31280, 284, 13, 440, 31280, 284, 307, 5101, 37140, 382, 257, 3877, 412, 264, 441, 43, 53, 44, 1496, 13, 50578], "temperature": 0.0, "avg_logprob": -0.14246772130330404, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.00037406032788567245}, {"id": 204, "seek": 127816, "start": 1282.44, "end": 1288.2, "text": " So, you have to go and fetch the contents from the descriptor by loading. Now, this load", "tokens": [50578, 407, 11, 291, 362, 281, 352, 293, 23673, 264, 15768, 490, 264, 31280, 284, 538, 15114, 13, 823, 11, 341, 3677, 50866], "temperature": 0.0, "avg_logprob": -0.14246772130330404, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.00037406032788567245}, {"id": 205, "seek": 127816, "start": 1288.2, "end": 1293.2, "text": " can potentially alias with other arrays if you directly load from that. So, we are trying", "tokens": [50866, 393, 7263, 419, 4609, 365, 661, 41011, 498, 291, 3838, 3677, 490, 300, 13, 407, 11, 321, 366, 1382, 51116], "temperature": 0.0, "avg_logprob": -0.14246772130330404, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.00037406032788567245}, {"id": 206, "seek": 127816, "start": 1293.2, "end": 1299.8000000000002, "text": " to just distinguish these using alias analysis information using TBA. So, that is what we", "tokens": [51116, 281, 445, 20206, 613, 1228, 419, 4609, 5215, 1589, 1228, 314, 9295, 13, 407, 11, 300, 307, 437, 321, 51446], "temperature": 0.0, "avg_logprob": -0.14246772130330404, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.00037406032788567245}, {"id": 207, "seek": 127816, "start": 1299.8000000000002, "end": 1306.8000000000002, "text": " have on this slide. I do not know how clear it is, but then this is in the LLVM MLIR dialect", "tokens": [51446, 362, 322, 341, 4137, 13, 286, 360, 406, 458, 577, 1850, 309, 307, 11, 457, 550, 341, 307, 294, 264, 441, 43, 53, 44, 21601, 7740, 24652, 51796], "temperature": 0.0, "avg_logprob": -0.14246772130330404, "compression_ratio": 1.6917293233082706, "no_speech_prob": 0.00037406032788567245}, {"id": 208, "seek": 130680, "start": 1307.8, "end": 1313.32, "text": " not in the LLVM IR representation. So, we have this TBA information that is being generated", "tokens": [50414, 406, 294, 264, 441, 43, 53, 44, 16486, 10290, 13, 407, 11, 321, 362, 341, 314, 9295, 1589, 300, 307, 885, 10833, 50690], "temperature": 0.0, "avg_logprob": -0.19689107182049992, "compression_ratio": 1.6772727272727272, "no_speech_prob": 7.141361857065931e-05}, {"id": 209, "seek": 130680, "start": 1313.32, "end": 1320.32, "text": " here. So, if you know TBA it is mostly trees and if one node is an ancestor of the other", "tokens": [50690, 510, 13, 407, 11, 498, 291, 458, 314, 9295, 309, 307, 5240, 5852, 293, 498, 472, 9984, 307, 364, 40032, 295, 264, 661, 51040], "temperature": 0.0, "avg_logprob": -0.19689107182049992, "compression_ratio": 1.6772727272727272, "no_speech_prob": 7.141361857065931e-05}, {"id": 210, "seek": 130680, "start": 1320.6399999999999, "end": 1325.8799999999999, "text": " node then they alias, but if they are in separate sub trace they do not alias. So, you can see", "tokens": [51056, 9984, 550, 436, 419, 4609, 11, 457, 498, 436, 366, 294, 4994, 1422, 13508, 436, 360, 406, 419, 4609, 13, 407, 11, 291, 393, 536, 51318], "temperature": 0.0, "avg_logprob": -0.19689107182049992, "compression_ratio": 1.6772727272727272, "no_speech_prob": 7.141361857065931e-05}, {"id": 211, "seek": 130680, "start": 1325.8799999999999, "end": 1332.72, "text": " that the ones in gray is any data access the ones in yellow is whether when you are accessing", "tokens": [51318, 300, 264, 2306, 294, 10855, 307, 604, 1412, 2105, 264, 2306, 294, 5566, 307, 1968, 562, 291, 366, 26440, 51660], "temperature": 0.0, "avg_logprob": -0.19689107182049992, "compression_ratio": 1.6772727272727272, "no_speech_prob": 7.141361857065931e-05}, {"id": 212, "seek": 133272, "start": 1332.72, "end": 1336.3600000000001, "text": " a descriptor member.", "tokens": [50364, 257, 31280, 284, 4006, 13, 50546], "temperature": 0.0, "avg_logprob": -0.2006535810582778, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.000588130671530962}, {"id": 213, "seek": 133272, "start": 1336.3600000000001, "end": 1340.2, "text": " And if you go back to the source code. So, what I have here is in the simple program", "tokens": [50546, 400, 498, 291, 352, 646, 281, 264, 4009, 3089, 13, 407, 11, 437, 286, 362, 510, 307, 294, 264, 2199, 1461, 50738], "temperature": 0.0, "avg_logprob": -0.2006535810582778, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.000588130671530962}, {"id": 214, "seek": 133272, "start": 1340.2, "end": 1346.2, "text": " is a subroutine. Subroutine is a procedure which does not return a value in Fortran.", "tokens": [50738, 307, 257, 1422, 81, 45075, 13, 8511, 81, 45075, 307, 257, 10747, 597, 775, 406, 2736, 257, 2158, 294, 11002, 4257, 13, 51038], "temperature": 0.0, "avg_logprob": -0.2006535810582778, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.000588130671530962}, {"id": 215, "seek": 133272, "start": 1346.2, "end": 1352.3600000000001, "text": " The two values A and B, A is an array and B is a scalar both of integer type. I am loading", "tokens": [51038, 440, 732, 4190, 316, 293, 363, 11, 316, 307, 364, 10225, 293, 363, 307, 257, 39684, 1293, 295, 24922, 2010, 13, 286, 669, 15114, 51346], "temperature": 0.0, "avg_logprob": -0.2006535810582778, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.000588130671530962}, {"id": 216, "seek": 133272, "start": 1352.3600000000001, "end": 1358.2, "text": " the value at the tenth location and putting in this putting in this variable B. And you", "tokens": [51346, 264, 2158, 412, 264, 27269, 4914, 293, 3372, 294, 341, 3372, 294, 341, 7006, 363, 13, 400, 291, 51638], "temperature": 0.0, "avg_logprob": -0.2006535810582778, "compression_ratio": 1.6327433628318584, "no_speech_prob": 0.000588130671530962}, {"id": 217, "seek": 135820, "start": 1358.2, "end": 1364.8400000000001, "text": " can see that whenever we are accessing the descriptor that is in this case the descriptor", "tokens": [50364, 393, 536, 300, 5699, 321, 366, 26440, 264, 31280, 284, 300, 307, 294, 341, 1389, 264, 31280, 284, 50696], "temperature": 0.0, "avg_logprob": -0.20383615603392152, "compression_ratio": 1.7294685990338163, "no_speech_prob": 0.0001910860009957105}, {"id": 218, "seek": 135820, "start": 1364.8400000000001, "end": 1371.64, "text": " is as access possibly for a stride. We use the TBA with the yellow color and whenever", "tokens": [50696, 307, 382, 2105, 6264, 337, 257, 1056, 482, 13, 492, 764, 264, 314, 9295, 365, 264, 5566, 2017, 293, 5699, 51036], "temperature": 0.0, "avg_logprob": -0.20383615603392152, "compression_ratio": 1.7294685990338163, "no_speech_prob": 0.0001910860009957105}, {"id": 219, "seek": 135820, "start": 1371.64, "end": 1377.88, "text": " we access something related to B we use the one with the gray one. So, you can distinguish", "tokens": [51036, 321, 2105, 746, 4077, 281, 363, 321, 764, 264, 472, 365, 264, 10855, 472, 13, 407, 11, 291, 393, 20206, 51348], "temperature": 0.0, "avg_logprob": -0.20383615603392152, "compression_ratio": 1.7294685990338163, "no_speech_prob": 0.0001910860009957105}, {"id": 220, "seek": 135820, "start": 1377.88, "end": 1384.72, "text": " that these do not alias and sometimes when it is in loops we get some performance benefits.", "tokens": [51348, 300, 613, 360, 406, 419, 4609, 293, 2171, 562, 309, 307, 294, 16121, 321, 483, 512, 3389, 5311, 13, 51690], "temperature": 0.0, "avg_logprob": -0.20383615603392152, "compression_ratio": 1.7294685990338163, "no_speech_prob": 0.0001910860009957105}, {"id": 221, "seek": 138472, "start": 1385.72, "end": 1393.56, "text": " So, the next one is code gen of assume shape array arguments. So, as I have mentioned before", "tokens": [50414, 407, 11, 264, 958, 472, 307, 3089, 1049, 295, 6552, 3909, 10225, 12869, 13, 407, 11, 382, 286, 362, 2835, 949, 50806], "temperature": 0.0, "avg_logprob": -0.18559936947292752, "compression_ratio": 1.8936170212765957, "no_speech_prob": 0.0004582018300425261}, {"id": 222, "seek": 138472, "start": 1393.56, "end": 1397.92, "text": " Fortran has different kinds of arrays one is assume shape. What assume shape means is", "tokens": [50806, 11002, 4257, 575, 819, 3685, 295, 41011, 472, 307, 6552, 3909, 13, 708, 6552, 3909, 1355, 307, 51024], "temperature": 0.0, "avg_logprob": -0.18559936947292752, "compression_ratio": 1.8936170212765957, "no_speech_prob": 0.0004582018300425261}, {"id": 223, "seek": 138472, "start": 1397.92, "end": 1403.56, "text": " that you know if you have an argument it takes the shape of the array that you pass to it.", "tokens": [51024, 300, 291, 458, 498, 291, 362, 364, 6770, 309, 2516, 264, 3909, 295, 264, 10225, 300, 291, 1320, 281, 309, 13, 51306], "temperature": 0.0, "avg_logprob": -0.18559936947292752, "compression_ratio": 1.8936170212765957, "no_speech_prob": 0.0004582018300425261}, {"id": 224, "seek": 138472, "start": 1403.56, "end": 1411.0, "text": " So, you can have you can either pass it an array of you know you can either pass it an", "tokens": [51306, 407, 11, 291, 393, 362, 291, 393, 2139, 1320, 309, 364, 10225, 295, 291, 458, 291, 393, 2139, 1320, 309, 364, 51678], "temperature": 0.0, "avg_logprob": -0.18559936947292752, "compression_ratio": 1.8936170212765957, "no_speech_prob": 0.0004582018300425261}, {"id": 225, "seek": 141100, "start": 1411.0, "end": 1419.96, "text": " array of a non size or an unknown size and it will accept both of them. So, this causes", "tokens": [50364, 10225, 295, 257, 2107, 2744, 420, 364, 9841, 2744, 293, 309, 486, 3241, 1293, 295, 552, 13, 407, 11, 341, 7700, 50812], "temperature": 0.0, "avg_logprob": -0.1453449335965243, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.00041729380609467626}, {"id": 226, "seek": 141100, "start": 1419.96, "end": 1425.24, "text": " some issues particularly because you know the arrays can also be strided. So, if the", "tokens": [50812, 512, 2663, 4098, 570, 291, 458, 264, 41011, 393, 611, 312, 1056, 2112, 13, 407, 11, 498, 264, 51076], "temperature": 0.0, "avg_logprob": -0.1453449335965243, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.00041729380609467626}, {"id": 227, "seek": 141100, "start": 1425.24, "end": 1429.24, "text": " array is strided then if you have a loop that is working on that array you have to fetch", "tokens": [51076, 10225, 307, 1056, 2112, 550, 498, 291, 362, 257, 6367, 300, 307, 1364, 322, 300, 10225, 291, 362, 281, 23673, 51276], "temperature": 0.0, "avg_logprob": -0.1453449335965243, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.00041729380609467626}, {"id": 228, "seek": 141100, "start": 1429.24, "end": 1433.48, "text": " consecutive elements from the array. If it is strided then you have to increment it by", "tokens": [51276, 30497, 4959, 490, 264, 10225, 13, 759, 309, 307, 1056, 2112, 550, 291, 362, 281, 26200, 309, 538, 51488], "temperature": 0.0, "avg_logprob": -0.1453449335965243, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.00041729380609467626}, {"id": 229, "seek": 141100, "start": 1433.48, "end": 1440.52, "text": " the stride and usually you have to load from the descriptor to find the stride. And then", "tokens": [51488, 264, 1056, 482, 293, 2673, 291, 362, 281, 3677, 490, 264, 31280, 284, 281, 915, 264, 1056, 482, 13, 400, 550, 51840], "temperature": 0.0, "avg_logprob": -0.1453449335965243, "compression_ratio": 1.8836206896551724, "no_speech_prob": 0.00041729380609467626}, {"id": 230, "seek": 144052, "start": 1440.56, "end": 1447.72, "text": " you set stride to find the next element. So, sometimes this can be modeled by you know", "tokens": [50366, 291, 992, 1056, 482, 281, 915, 264, 958, 4478, 13, 407, 11, 2171, 341, 393, 312, 37140, 538, 291, 458, 50724], "temperature": 0.0, "avg_logprob": -0.18785503298737283, "compression_ratio": 1.6635071090047393, "no_speech_prob": 0.0001660219277255237}, {"id": 231, "seek": 144052, "start": 1447.72, "end": 1453.52, "text": " scatter gather loads and stores, but sometimes it is not possible, but in many cases the", "tokens": [50724, 34951, 5448, 12668, 293, 9512, 11, 457, 2171, 309, 307, 406, 1944, 11, 457, 294, 867, 3331, 264, 51014], "temperature": 0.0, "avg_logprob": -0.18785503298737283, "compression_ratio": 1.6635071090047393, "no_speech_prob": 0.0001660219277255237}, {"id": 232, "seek": 144052, "start": 1453.52, "end": 1457.96, "text": " stride is actually one you are actually passing a consecutive array. So, we can do some", "tokens": [51014, 1056, 482, 307, 767, 472, 291, 366, 767, 8437, 257, 30497, 10225, 13, 407, 11, 321, 393, 360, 512, 51236], "temperature": 0.0, "avg_logprob": -0.18785503298737283, "compression_ratio": 1.6635071090047393, "no_speech_prob": 0.0001660219277255237}, {"id": 233, "seek": 144052, "start": 1457.96, "end": 1464.24, "text": " versioning. So, it is represented in high level source here if you have some input code", "tokens": [51236, 3037, 278, 13, 407, 11, 309, 307, 10379, 294, 1090, 1496, 4009, 510, 498, 291, 362, 512, 4846, 3089, 51550], "temperature": 0.0, "avg_logprob": -0.18785503298737283, "compression_ratio": 1.6635071090047393, "no_speech_prob": 0.0001660219277255237}, {"id": 234, "seek": 146424, "start": 1464.24, "end": 1470.64, "text": " like this an array there is an array called x and you are looping over it. Then you can", "tokens": [50364, 411, 341, 364, 10225, 456, 307, 364, 10225, 1219, 2031, 293, 291, 366, 6367, 278, 670, 309, 13, 1396, 291, 393, 50684], "temperature": 0.0, "avg_logprob": -0.21646073423785928, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00017399257922079414}, {"id": 235, "seek": 146424, "start": 1470.64, "end": 1477.64, "text": " create a version of it in if the stride is one do this if otherwise do this right. And", "tokens": [50684, 1884, 257, 3037, 295, 309, 294, 498, 264, 1056, 482, 307, 472, 360, 341, 498, 5911, 360, 341, 558, 13, 400, 51034], "temperature": 0.0, "avg_logprob": -0.21646073423785928, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00017399257922079414}, {"id": 236, "seek": 146424, "start": 1477.64, "end": 1482.44, "text": " then this side of the portion loop this side of the version becomes easier to optimize", "tokens": [51034, 550, 341, 1252, 295, 264, 8044, 6367, 341, 1252, 295, 264, 3037, 3643, 3571, 281, 19719, 51274], "temperature": 0.0, "avg_logprob": -0.21646073423785928, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00017399257922079414}, {"id": 237, "seek": 146424, "start": 1482.44, "end": 1489.88, "text": " and vectorize. I just have two more slides I will probably", "tokens": [51274, 293, 8062, 1125, 13, 286, 445, 362, 732, 544, 9788, 286, 486, 1391, 51646], "temperature": 0.0, "avg_logprob": -0.21646073423785928, "compression_ratio": 1.6666666666666667, "no_speech_prob": 0.00017399257922079414}, {"id": 238, "seek": 148988, "start": 1490.0400000000002, "end": 1495.48, "text": " just run through it. We are nearing open mp 1.1 completion there are still a few items", "tokens": [50372, 445, 1190, 807, 309, 13, 492, 366, 408, 1921, 1269, 275, 79, 502, 13, 16, 19372, 456, 366, 920, 257, 1326, 4754, 50644], "temperature": 0.0, "avg_logprob": -0.22429235164935774, "compression_ratio": 1.6534296028880866, "no_speech_prob": 0.06269240379333496}, {"id": 239, "seek": 148988, "start": 1495.48, "end": 1501.6000000000001, "text": " to complete like privatization atomic reduction and detail testing, but a lot of other things", "tokens": [50644, 281, 3566, 411, 31856, 2144, 22275, 11004, 293, 2607, 4997, 11, 457, 257, 688, 295, 661, 721, 50950], "temperature": 0.0, "avg_logprob": -0.22429235164935774, "compression_ratio": 1.6534296028880866, "no_speech_prob": 0.06269240379333496}, {"id": 240, "seek": 148988, "start": 1501.6000000000001, "end": 1506.24, "text": " are still going on in parallel there is basic support for task SIMD construct. We have been", "tokens": [50950, 366, 920, 516, 322, 294, 8952, 456, 307, 3875, 1406, 337, 5633, 24738, 35, 7690, 13, 492, 362, 668, 51182], "temperature": 0.0, "avg_logprob": -0.22429235164935774, "compression_ratio": 1.6534296028880866, "no_speech_prob": 0.06269240379333496}, {"id": 241, "seek": 148988, "start": 1506.24, "end": 1512.48, "text": " able to run it with some spec speed benchmarks and it works things in progress include target", "tokens": [51182, 1075, 281, 1190, 309, 365, 512, 1608, 3073, 43751, 293, 309, 1985, 721, 294, 4205, 4090, 3779, 51494], "temperature": 0.0, "avg_logprob": -0.22429235164935774, "compression_ratio": 1.6534296028880866, "no_speech_prob": 0.06269240379333496}, {"id": 242, "seek": 148988, "start": 1512.48, "end": 1519.2800000000002, "text": " off loading it just started task dependencies and new loop related constructs. We also made", "tokens": [51494, 766, 15114, 309, 445, 1409, 5633, 36606, 293, 777, 6367, 4077, 7690, 82, 13, 492, 611, 1027, 51834], "temperature": 0.0, "avg_logprob": -0.22429235164935774, "compression_ratio": 1.6534296028880866, "no_speech_prob": 0.06269240379333496}, {"id": 243, "seek": 151928, "start": 1519.28, "end": 1526.32, "text": " a lot of progress with the driver it can now generate executables, but what is new is that", "tokens": [50364, 257, 688, 295, 4205, 365, 264, 6787, 309, 393, 586, 8460, 7568, 2965, 11, 457, 437, 307, 777, 307, 300, 50716], "temperature": 0.0, "avg_logprob": -0.20601490893995905, "compression_ratio": 1.6133333333333333, "no_speech_prob": 0.001647920347750187}, {"id": 244, "seek": 151928, "start": 1526.32, "end": 1531.28, "text": " we now handle target specification, fast math, MLIR level optimizations previously only", "tokens": [50716, 321, 586, 4813, 3779, 31256, 11, 2370, 5221, 11, 21601, 7740, 1496, 5028, 14455, 8046, 787, 50964], "temperature": 0.0, "avg_logprob": -0.20601490893995905, "compression_ratio": 1.6133333333333333, "no_speech_prob": 0.001647920347750187}, {"id": 245, "seek": 151928, "start": 1531.28, "end": 1538.04, "text": " LVM optimization over there now we can control MLIR optimizations as well as LVM pass plugins.", "tokens": [50964, 441, 53, 44, 19618, 670, 456, 586, 321, 393, 1969, 21601, 7740, 5028, 14455, 382, 731, 382, 441, 53, 44, 1320, 33759, 13, 51302], "temperature": 0.0, "avg_logprob": -0.20601490893995905, "compression_ratio": 1.6133333333333333, "no_speech_prob": 0.001647920347750187}, {"id": 246, "seek": 151928, "start": 1538.04, "end": 1543.2, "text": " People are continuing to work on LTO saving optimization records and supporting something", "tokens": [51302, 3432, 366, 9289, 281, 589, 322, 441, 15427, 6816, 19618, 7724, 293, 7231, 746, 51560], "temperature": 0.0, "avg_logprob": -0.20601490893995905, "compression_ratio": 1.6133333333333333, "no_speech_prob": 0.001647920347750187}, {"id": 247, "seek": 154320, "start": 1543.2, "end": 1550.4, "text": " called stack arrays. This final slide just says that you are all welcome to contribute", "tokens": [50364, 1219, 8630, 41011, 13, 639, 2572, 4137, 445, 1619, 300, 291, 366, 439, 2928, 281, 10586, 50724], "temperature": 0.0, "avg_logprob": -0.29754837581089566, "compression_ratio": 1.3363636363636364, "no_speech_prob": 0.010972365736961365}, {"id": 248, "seek": 154320, "start": 1550.4, "end": 1554.52, "text": " to this project and the details of this are here. Thank you.", "tokens": [50724, 281, 341, 1716, 293, 264, 4365, 295, 341, 366, 510, 13, 1044, 291, 13, 50930], "temperature": 0.0, "avg_logprob": -0.29754837581089566, "compression_ratio": 1.3363636363636364, "no_speech_prob": 0.010972365736961365}, {"id": 249, "seek": 157320, "start": 1573.2, "end": 1583.04, "text": " Yeah, I mean as of now we do not have so the basically the question was that when you traverse", "tokens": [50364, 865, 11, 286, 914, 382, 295, 586, 321, 360, 406, 362, 370, 264, 1936, 264, 1168, 390, 300, 562, 291, 45674, 50856], "temperature": 0.0, "avg_logprob": -0.23226684652349, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.003883148543536663}, {"id": 250, "seek": 157320, "start": 1583.04, "end": 1589.52, "text": " across the various layers in MLIR and LVM IR is the debug information preserved. So,", "tokens": [50856, 2108, 264, 3683, 7914, 294, 21601, 7740, 293, 441, 53, 44, 16486, 307, 264, 24083, 1589, 22242, 13, 407, 11, 51180], "temperature": 0.0, "avg_logprob": -0.23226684652349, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.003883148543536663}, {"id": 251, "seek": 157320, "start": 1589.52, "end": 1595.28, "text": " the whole concept of the HLFIR operation is to you know put that information somewhere", "tokens": [51180, 264, 1379, 3410, 295, 264, 389, 43, 37, 7740, 6916, 307, 281, 291, 458, 829, 300, 1589, 4079, 51468], "temperature": 0.0, "avg_logprob": -0.23226684652349, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.003883148543536663}, {"id": 252, "seek": 157320, "start": 1595.28, "end": 1601.28, "text": " in MLIR at the highest level and then we plan to propagate it further down. So, the HLFIR", "tokens": [51468, 294, 21601, 7740, 412, 264, 6343, 1496, 293, 550, 321, 1393, 281, 48256, 309, 3052, 760, 13, 407, 11, 264, 389, 43, 37, 7740, 51768], "temperature": 0.0, "avg_logprob": -0.23226684652349, "compression_ratio": 1.5892857142857142, "no_speech_prob": 0.003883148543536663}, {"id": 253, "seek": 160128, "start": 1601.28, "end": 1606.3999999999999, "text": " declare has a corresponding FIR declare it will lower to that and from the FIR declare", "tokens": [50364, 19710, 575, 257, 11760, 479, 7740, 19710, 309, 486, 3126, 281, 300, 293, 490, 264, 479, 7740, 19710, 50620], "temperature": 0.0, "avg_logprob": -0.2130950064886184, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.000458040798548609}, {"id": 254, "seek": 160128, "start": 1606.3999999999999, "end": 1611.08, "text": " when we convert to LVM we will just pass on that debug information, but debug support", "tokens": [50620, 562, 321, 7620, 281, 441, 53, 44, 321, 486, 445, 1320, 322, 300, 24083, 1589, 11, 457, 24083, 1406, 50854], "temperature": 0.0, "avg_logprob": -0.2130950064886184, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.000458040798548609}, {"id": 255, "seek": 160128, "start": 1611.08, "end": 1618.56, "text": " is quite early in flank as of now only function names and location numbers as supported, but", "tokens": [50854, 307, 1596, 2440, 294, 36318, 382, 295, 586, 787, 2445, 5288, 293, 4914, 3547, 382, 8104, 11, 457, 51228], "temperature": 0.0, "avg_logprob": -0.2130950064886184, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.000458040798548609}, {"id": 256, "seek": 160128, "start": 1618.56, "end": 1625.36, "text": " also may be not by default it is just a pass separately running the code to add that the", "tokens": [51228, 611, 815, 312, 406, 538, 7576, 309, 307, 445, 257, 1320, 14759, 2614, 264, 3089, 281, 909, 300, 264, 51568], "temperature": 0.0, "avg_logprob": -0.2130950064886184, "compression_ratio": 1.6164383561643836, "no_speech_prob": 0.000458040798548609}, {"id": 257, "seek": 162536, "start": 1625.36, "end": 1632.36, "text": " driver is still pending. Yes.", "tokens": [50364, 6787, 307, 920, 32110, 13, 1079, 13, 50714], "temperature": 0.0, "avg_logprob": -0.3177796158136106, "compression_ratio": 1.4166666666666667, "no_speech_prob": 0.01971760205924511}, {"id": 258, "seek": 162536, "start": 1632.36, "end": 1647.28, "text": " Everything that since standard or some well known extensions are there, but it is a lot", "tokens": [50714, 5471, 300, 1670, 3832, 420, 512, 731, 2570, 25129, 366, 456, 11, 457, 309, 307, 257, 688, 51460], "temperature": 0.0, "avg_logprob": -0.3177796158136106, "compression_ratio": 1.4166666666666667, "no_speech_prob": 0.01971760205924511}, {"id": 259, "seek": 162536, "start": 1647.28, "end": 1651.84, "text": " of dusty deck code is was tested with it, but I do not know whether the specific thing", "tokens": [51460, 295, 41973, 9341, 3089, 307, 390, 8246, 365, 309, 11, 457, 286, 360, 406, 458, 1968, 264, 2685, 551, 51688], "temperature": 0.0, "avg_logprob": -0.3177796158136106, "compression_ratio": 1.4166666666666667, "no_speech_prob": 0.01971760205924511}, {"id": 260, "seek": 165184, "start": 1651.84, "end": 1657.12, "text": " that you have in mind is supported or not you have to try out or look at the documentation.", "tokens": [50364, 300, 291, 362, 294, 1575, 307, 8104, 420, 406, 291, 362, 281, 853, 484, 420, 574, 412, 264, 14333, 13, 50628], "temperature": 0.0, "avg_logprob": -0.2588437617510215, "compression_ratio": 1.7169811320754718, "no_speech_prob": 0.027554655447602272}, {"id": 261, "seek": 165184, "start": 1657.12, "end": 1665.36, "text": " So, the question was whether old Fortran 77 code or legacy extensions are supported.", "tokens": [50628, 407, 11, 264, 1168, 390, 1968, 1331, 11002, 4257, 25546, 3089, 420, 11711, 25129, 366, 8104, 13, 51040], "temperature": 0.0, "avg_logprob": -0.2588437617510215, "compression_ratio": 1.7169811320754718, "no_speech_prob": 0.027554655447602272}, {"id": 262, "seek": 165184, "start": 1665.36, "end": 1673.52, "text": " So, I am trying to understand what needs to be done for open MP because open MP is a completely", "tokens": [51040, 407, 11, 286, 669, 1382, 281, 1223, 437, 2203, 281, 312, 1096, 337, 1269, 14146, 570, 1269, 14146, 307, 257, 2584, 51448], "temperature": 0.0, "avg_logprob": -0.2588437617510215, "compression_ratio": 1.7169811320754718, "no_speech_prob": 0.027554655447602272}, {"id": 263, "seek": 165184, "start": 1673.52, "end": 1679.6, "text": " separate project right. Yeah. So, the question is what needs to be done separately for open", "tokens": [51448, 4994, 1716, 558, 13, 865, 13, 407, 11, 264, 1168, 307, 437, 2203, 281, 312, 1096, 14759, 337, 1269, 51752], "temperature": 0.0, "avg_logprob": -0.2588437617510215, "compression_ratio": 1.7169811320754718, "no_speech_prob": 0.027554655447602272}, {"id": 264, "seek": 167960, "start": 1679.6799999999998, "end": 1687.6799999999998, "text": " MP. So, as far as open MP is concerned all the open MP work is mainly represented at", "tokens": [50368, 14146, 13, 407, 11, 382, 1400, 382, 1269, 14146, 307, 5922, 439, 264, 1269, 14146, 589, 307, 8704, 10379, 412, 50768], "temperature": 0.0, "avg_logprob": -0.17335359440293424, "compression_ratio": 1.69377990430622, "no_speech_prob": 0.0031226894352585077}, {"id": 265, "seek": 167960, "start": 1687.6799999999998, "end": 1693.9599999999998, "text": " the MLIR level by a separate dialect called the open MP dialect. Then that dialect sits", "tokens": [50768, 264, 21601, 7740, 1496, 538, 257, 4994, 24652, 1219, 264, 1269, 14146, 24652, 13, 1396, 300, 24652, 12696, 51082], "temperature": 0.0, "avg_logprob": -0.17335359440293424, "compression_ratio": 1.69377990430622, "no_speech_prob": 0.0031226894352585077}, {"id": 266, "seek": 167960, "start": 1693.9599999999998, "end": 1701.3999999999999, "text": " in the main MLIR repository and from the source program when we generate it you know we create", "tokens": [51082, 294, 264, 2135, 21601, 7740, 25841, 293, 490, 264, 4009, 1461, 562, 321, 8460, 309, 291, 458, 321, 1884, 51454], "temperature": 0.0, "avg_logprob": -0.17335359440293424, "compression_ratio": 1.69377990430622, "no_speech_prob": 0.0031226894352585077}, {"id": 267, "seek": 167960, "start": 1701.3999999999999, "end": 1706.28, "text": " these additional operations for the open MP dialect and it has regions in MLIR. So, it", "tokens": [51454, 613, 4497, 7705, 337, 264, 1269, 14146, 24652, 293, 309, 575, 10682, 294, 21601, 7740, 13, 407, 11, 309, 51698], "temperature": 0.0, "avg_logprob": -0.17335359440293424, "compression_ratio": 1.69377990430622, "no_speech_prob": 0.0031226894352585077}, {"id": 268, "seek": 170628, "start": 1706.32, "end": 1712.32, "text": " can capture things like you know a parallel directive much better compared to LVM.", "tokens": [50366, 393, 7983, 721, 411, 291, 458, 257, 8952, 45444, 709, 1101, 5347, 281, 441, 53, 44, 13, 50666], "temperature": 0.0, "avg_logprob": -0.28052316060880333, "compression_ratio": 1.5533980582524272, "no_speech_prob": 0.0062844776548445225}, {"id": 269, "seek": 170628, "start": 1712.32, "end": 1718.32, "text": " So, roughly speaking open MP is a set of intrinsics more or less.", "tokens": [50666, 407, 11, 9810, 4124, 1269, 14146, 307, 257, 992, 295, 28621, 1167, 544, 420, 1570, 13, 50966], "temperature": 0.0, "avg_logprob": -0.28052316060880333, "compression_ratio": 1.5533980582524272, "no_speech_prob": 0.0062844776548445225}, {"id": 270, "seek": 170628, "start": 1718.32, "end": 1725.82, "text": " I mean it is not as I mean intrinsic when you whenever you say it is kind of some kind", "tokens": [50966, 286, 914, 309, 307, 406, 382, 286, 914, 35698, 562, 291, 5699, 291, 584, 309, 307, 733, 295, 512, 733, 51341], "temperature": 0.0, "avg_logprob": -0.28052316060880333, "compression_ratio": 1.5533980582524272, "no_speech_prob": 0.0062844776548445225}, {"id": 271, "seek": 170628, "start": 1725.82, "end": 1730.36, "text": " of function, but these are MLIR operations right. So, if you have something called a", "tokens": [51341, 295, 2445, 11, 457, 613, 366, 21601, 7740, 7705, 558, 13, 407, 11, 498, 291, 362, 746, 1219, 257, 51568], "temperature": 0.0, "avg_logprob": -0.28052316060880333, "compression_ratio": 1.5533980582524272, "no_speech_prob": 0.0062844776548445225}, {"id": 272, "seek": 173036, "start": 1730.3999999999999, "end": 1736.3999999999999, "text": " parallel directive there is an operation in MLIR called omp.parallel and it might have", "tokens": [50366, 8952, 45444, 456, 307, 364, 6916, 294, 21601, 7740, 1219, 277, 2455, 13, 2181, 336, 338, 293, 309, 1062, 362, 50666], "temperature": 0.0, "avg_logprob": -0.13362594951282847, "compression_ratio": 1.7817460317460319, "no_speech_prob": 0.0005882207187823951}, {"id": 273, "seek": 173036, "start": 1736.3999999999999, "end": 1742.3999999999999, "text": " lot of clauses like you know what is the you know threading model and things like that.", "tokens": [50666, 688, 295, 49072, 411, 291, 458, 437, 307, 264, 291, 458, 7207, 278, 2316, 293, 721, 411, 300, 13, 50966], "temperature": 0.0, "avg_logprob": -0.13362594951282847, "compression_ratio": 1.7817460317460319, "no_speech_prob": 0.0005882207187823951}, {"id": 274, "seek": 173036, "start": 1742.3999999999999, "end": 1748.0, "text": " So, all those information is captured at that level along with the code that comes in that", "tokens": [50966, 407, 11, 439, 729, 1589, 307, 11828, 412, 300, 1496, 2051, 365, 264, 3089, 300, 1487, 294, 300, 51246], "temperature": 0.0, "avg_logprob": -0.13362594951282847, "compression_ratio": 1.7817460317460319, "no_speech_prob": 0.0005882207187823951}, {"id": 275, "seek": 173036, "start": 1748.0, "end": 1752.76, "text": " parallel region and what we do actually now is that we are trying to share code with Clang.", "tokens": [51246, 8952, 4458, 293, 437, 321, 360, 767, 586, 307, 300, 321, 366, 1382, 281, 2073, 3089, 365, 2033, 656, 13, 51484], "temperature": 0.0, "avg_logprob": -0.13362594951282847, "compression_ratio": 1.7817460317460319, "no_speech_prob": 0.0005882207187823951}, {"id": 276, "seek": 173036, "start": 1752.76, "end": 1757.56, "text": " So, there is some code that is refactored from Clang and put into something called the open", "tokens": [51484, 407, 11, 456, 307, 512, 3089, 300, 307, 1895, 578, 2769, 490, 2033, 656, 293, 829, 666, 746, 1219, 264, 1269, 51724], "temperature": 0.0, "avg_logprob": -0.13362594951282847, "compression_ratio": 1.7817460317460319, "no_speech_prob": 0.0005882207187823951}, {"id": 277, "seek": 175756, "start": 1757.6399999999999, "end": 1764.6399999999999, "text": " MP IR builder. So, when we lower it from this dialect to LVM we use that to generate the", "tokens": [50368, 14146, 16486, 27377, 13, 407, 11, 562, 321, 3126, 309, 490, 341, 24652, 281, 441, 53, 44, 321, 764, 300, 281, 8460, 264, 50718], "temperature": 0.0, "avg_logprob": -0.2053694857491387, "compression_ratio": 1.1263157894736842, "no_speech_prob": 0.006285127718001604}, {"id": 278, "seek": 175756, "start": 1764.6399999999999, "end": 1768.1599999999999, "text": " LVM IR. Thank you.", "tokens": [50718, 441, 53, 44, 16486, 13, 1044, 291, 13, 50894], "temperature": 0.0, "avg_logprob": -0.2053694857491387, "compression_ratio": 1.1263157894736842, "no_speech_prob": 0.006285127718001604}], "language": "en"}