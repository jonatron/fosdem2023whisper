{"text": " Welcome to my talk, Lisp Scheme, Powerful Introspection and Extensibility. My name is Jakub Tienkiewicz, you can find me online with my handle Jacobik, I am a senior software developer from Poland. I focus mostly on JavaScript language, I am open source developer and Polish Wikipedia editor. I am also a mentor and a teacher. We will talk about Lisp and Scheme history, we will do quick introduction to Scheme, next we will talk about Lisp Scheme history and the most important part of the talk is about Lisp Scheme, how it works. To get most out of this talk you need to know basic of JavaScript. Lisp was presented in 1960s by John McCarthy and his famous paper Recursive Functions of Symbolic Expression and Direct Computation by Machine Part 1. Part 2 was never created, it was based on Lambda Calculus by Alonzo Tertz and the paper explained an eval function that was written in the Lisp itself. One of McCarthy's students, Steve Russell, decided to implement the eval function on the IBM 704 and it was first interpreter of the Lisp language. The syntax of the interpreter was a little bit different than the one described in the paper because of the limitations of the keyboard on the IBM mainframe. Lisp stands for Lisp Processing. The most important thing about the language is that it's homoiconic, which means that the Lisp code is represented by Lisp, the main data structure. It was heavily used by AI research at the beginning and it was great source of inspiration for most modern programming languages. There are few so-called dialects of Lisp which are used today. Scheme, Clojure, MX Lisp, Racket and Common Lisp. Scheme was invented in 1970s at MIT by Guy L. Steele and Gerald J. Sassman when they investigated the actor model. The language is defined by specifications RNRS, which stands for Revisited Report on Language Scheme. Where number indicates how many times it was revisited. Second version was Revisited Revisited, so it used power off to make the name shorter. There are also official extensions to the language, SRFI, Scheme Request for Implementations, which adds new language features. The official website for the language is Scheme.org. Now let's talk about basic of Scheme. In most modern programming languages, when you have a function call, you use syntax like this, where you have a function name and in parentheses there are arguments separated by a comma. In List and Scheme on the other hand, the code is created from S-expressions. A list created by parentheses, where first element is a function and arguments separated by a space. And you can mess those lists. What is important with this expression is that those are not operators. They are plus and aesthetic symbols, which are names of the functions. So they are in fact function calls. So they are written in the same way as a sign function. As I've mentioned, code and data use the same data structures. So it's important to distinguish data from code. This is done by quotations. The first expression is code and the second is data, a list of numbers. To define variables in Scheme, you use define. That can also be used to define a function. And let is used to create local variables. And this is how you define an if statement that will print a message depending on a Boolean expression. Define if and let expressions are special syntax which works differently than the normal functions. And you can define your own syntax like this by using macros. For example, we can define macrofrop that when passing expression with infix notation will sum the numbers using prefix notation. In Scheme, there are two types of macros. First are list macros that accept code as data and return new list that will be evaluated. And the second are hygienic macros that use pattern matching syntax. These macros are used probably by all list dialects. But hygienic macros are specific to Scheme and dialect based on Scheme. To learn more about Scheme, I suggest a book, Sketchy Scheme by Nils M. Horm. You can find the older version of the book on Internet Archive by a suggest to get the latest version from this link. The main topic of this talk is leaps. Scheme in implementation written in JavaScript. So let's quickly talk about history of this project. It started on KotPen as a list based on Scheme. I wanted to create Emacs in browser and wanted to have something like EmacsList. That's why leaps from the beginning have an optional dynamic scope that is a characteristic feature of EmacsList. Fpcat Scheme because it's much simpler than other dialects. You can still find the first version of the interpreter on KotPen. Leaps was inspired by EmacsList and Python, mostly about the introspection features and that all functions have documentation inside the code, which you can access from the REPL. The last version of leaps that you can access from the NPM repository as a stable release is version 0.20.3. But on a certain point, I decided that I want a full Scheme implementation, not only leaps based on Scheme. And I've started working on the code on the devil branch. But at one point, it turns out that there are way too many breaking changes to release the next version. That's why I released it as 1.0 beta and the latest version is 16. At the beginning, the whole code was written in JavaScript. But when I was making an effort toward full Scheme implementation, more and more code was written in Scheme. Now almost half of the leaps code is Scheme. And now there is a time for the demo. This is the official website for the leaps project. And what's cool about this is that here you have a bookmarklet and you can drag this link to your bookmarks and execute it on a different page. For instance, here there is a first lecture of the structure of the interpretation of the program. A classic video lectures from MIT. You can evaluate Scheme code that you see on the screen. The feature of the rebel is that there are syntax high-liking and parenthesis matching and also each macro and functions have documentation if you hover over the name. Here you have documentation for define. Here you have documentation for asterisk multiplication operator. You can also undock the panel with the rebel and use it inside the window that you can drag and drop on the page. Another cool feature of the rebel is that you can execute it on PDF files. But I've tested this only on Chrome browser. This PDF document is Scheme language specification. But it often gives problems if you try to execute code that is inside this document in the rebel. For instance, on page 12, there's this quotations. If you try to execute this code in the rebel, you give it this kind of warning. But you can fix this error by executing this code. You execute it, suddenly you can evaluate this expression. This is a special kind of function that creates syntax extension. Here you can have documentation for this function. Syntax extensions allow to define new syntax similar to the one defined in JavaScript, like those quotations. Here you can see vector literals, defined by hash sign. Vectors are also created as syntax extensions. And Scheme vectors are just JavaScript R writes. Similar syntax extension is ampersand that define JavaScript object literals. Here we can see that representation of object literals looks the same as the code. This is another feature of Libs that allow to define new representation for different instances. Scheme vectors are also defined in the same way. You can use both features to define homo-iconic data types. You can use both features to define homo-iconic data types. Records are the way to define new data types in Scheme that is defined in the specification on page 27. You can define syntax extension for this record. The third argument to set special indicates how the makePerson function should receive the arguments. The list or as a normal arguments. This feature may be removed in the future to simplify the code. The dot notation in the last argument is taken from JavaScript to simplify interaction with the hosting language. Libs is a global object that you can inspect with the dir function inspired by Python. In the same way, you can access any JavaScript object or a function. By let's go back to our record example. A person is a class. And you can create an instance of that class with a new macro. Or with makePerson function created by Scheme record type. We can also use our syntax extension to create a new person object. Now let's add a representation of this new data type. And now we can evaluate the code and have the same representation. The queue parameter indicates if the result should be quoted or not. In the wrapper, the strings are quoted because they use Scheme write function. But you can use display function that don't use quotations. But with setRapper you can make representation of the records without the new syntax. And you can use display function to make representation of the records without the new syntax. And you can use display function to make representation of the records without the new syntax. With this feature, you can easily serialize and deserialize custom data types. For instance, when saving in browser local storage. We use that eval because readReturnsList as data that needs to be evaluated to get the instance of the person object. To get the property of the speaker object, you can use dot special macro. Or you can use JavaScript dot notation. The next feature I want to discuss is introspection. You can use upper post function to search the environment. This is a list of functions and macros that match a given string. In this case, vector. You can also use regular expressions to make the search more specific. And this is a list of typed vectors. Each of those constructors have also the syntax extension that allow to create those vectors according to scheme specification. Each scheme type at vector is in fact JavaScript type at RI. And each of those RIs have its own representation. So they look like the code that defines them. You can access the documentation and the source code of the every function macro and fiber defined by lips. You can access the name, the documentation and the source code of this function. What's cool about the code is that it's live object that you can modify. The double underscore syntax is inspired by Python magic properties. You can also inspect the internals of other lips objects like symbols or numbers. Lips support full numerical tower. Here's a complex number, but it's not yet fully unit tested, so there are no guarantees that everything works correctly by 100%. You can also inspect the list objects. The instance of function use JavaScript instance of operator to check if argument is instance of the object. Here it check if x is lips list and it written true. You can use the standard list function to get the third element of the list. But you can also access internal pair objects defined by lips. The proposed function that I've showed a few moments ago allows to search the environment, but in lips you can also access environment objects themselves and do cool things with them. You can inspect them. As you can see there is double underscore nth property that you can read. Object keys is a JavaScript function that returns r i of strings, so it's represented as a scheme vector. Those are all objects defined inside the repo, including lips internals. You can see our person class and you can access it using environment object. Make person was our representation of the person instance using set wrapper. Inside the environment object there is also another double underscore property parent, which allows you to access a lexical scope time. You can access both x fibers from the scope 10 inside a one expression. You can also access both x fibers from the scope 10. You can also modify the scope inside the chain. Set is a generic macro that allows to modify any JavaScript object, not only lips internals. Another feature of lips is that you can act as stack frames of function calls. They are also environment objects inspired by the air programming language that has a lot of lips under the hood. Here the function test can modify the scope outside the function call. Another function similar to parent frame is plural parent frames, which returns a list of stack frames. With both parent frames and underscore code access you can modify the function that call a given function anywhere inside the call stack chain. The long arrow is a macro for invoking methods and the cally is lips object similar to JavaScript object with the same name. The long arrow macro is a convenient method to create the chain of method calls. This code demonstrates another fundamental feature of lips, where everything is automatically assigned away by default when needed. Fetch is a javascript function that returns a promise which results to a resource object. That object has a text method that also returns a promise. Here we can skip them which makes the code simpler than the javascript equivalent. The match in the code is a string method and the number one returns first group from the regular expression. The whole expression returns the main header of the lips website, but when needed you can quote the promise and use it as an object. you Now let's back to our presentation for a final thought. As you was able to see from the demo, lips is pretty flexible and powerful, but it has its limitations. One of the limitations is that macro are on time. There is no macro expansion time. There are also some performance issues. One of the reasons for it may be the lack of macro expansion time, but you can fix those issues by embedding javascript code in tight lips. The most important things that are missing are first call continuations and tail call optimizations and also the syntax rules scheme hygienic macro system is not working exactly as it should. All this can be improved in the future. Thank you for listening to my presentation.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.040000000000001, "text": " Welcome to my talk, Lisp Scheme, Powerful Introspection and Extensibility.", "tokens": [50364, 4027, 281, 452, 751, 11, 441, 7631, 2065, 5729, 11, 7086, 906, 5681, 2635, 19997, 293, 9881, 694, 2841, 13, 50916], "temperature": 0.0, "avg_logprob": -0.2935383136455829, "compression_ratio": 1.4553571428571428, "no_speech_prob": 0.2513665556907654}, {"id": 1, "seek": 0, "start": 11.040000000000001, "end": 16.32, "text": " My name is Jakub Tienkiewicz, you can find me online with my handle Jacobik, I am a", "tokens": [50916, 1222, 1315, 307, 15029, 836, 314, 1053, 74, 1093, 17946, 11, 291, 393, 915, 385, 2950, 365, 452, 4813, 14117, 1035, 11, 286, 669, 257, 51180], "temperature": 0.0, "avg_logprob": -0.2935383136455829, "compression_ratio": 1.4553571428571428, "no_speech_prob": 0.2513665556907654}, {"id": 2, "seek": 0, "start": 16.32, "end": 18.56, "text": " senior software developer from Poland.", "tokens": [51180, 7965, 4722, 10754, 490, 15950, 13, 51292], "temperature": 0.0, "avg_logprob": -0.2935383136455829, "compression_ratio": 1.4553571428571428, "no_speech_prob": 0.2513665556907654}, {"id": 3, "seek": 0, "start": 18.56, "end": 23.2, "text": " I focus mostly on JavaScript language, I am open source developer and Polish Wikipedia", "tokens": [51292, 286, 1879, 5240, 322, 15778, 2856, 11, 286, 669, 1269, 4009, 10754, 293, 18504, 28999, 51524], "temperature": 0.0, "avg_logprob": -0.2935383136455829, "compression_ratio": 1.4553571428571428, "no_speech_prob": 0.2513665556907654}, {"id": 4, "seek": 0, "start": 23.2, "end": 24.2, "text": " editor.", "tokens": [51524, 9839, 13, 51574], "temperature": 0.0, "avg_logprob": -0.2935383136455829, "compression_ratio": 1.4553571428571428, "no_speech_prob": 0.2513665556907654}, {"id": 5, "seek": 0, "start": 24.2, "end": 26.68, "text": " I am also a mentor and a teacher.", "tokens": [51574, 286, 669, 611, 257, 14478, 293, 257, 5027, 13, 51698], "temperature": 0.0, "avg_logprob": -0.2935383136455829, "compression_ratio": 1.4553571428571428, "no_speech_prob": 0.2513665556907654}, {"id": 6, "seek": 2668, "start": 26.68, "end": 33.84, "text": " We will talk about Lisp and Scheme history, we will do quick introduction to Scheme, next", "tokens": [50364, 492, 486, 751, 466, 441, 7631, 293, 2065, 5729, 2503, 11, 321, 486, 360, 1702, 9339, 281, 2065, 5729, 11, 958, 50722], "temperature": 0.0, "avg_logprob": -0.2140499750773112, "compression_ratio": 1.651376146788991, "no_speech_prob": 0.10773645341396332}, {"id": 7, "seek": 2668, "start": 33.84, "end": 40.16, "text": " we will talk about Lisp Scheme history and the most important part of the talk is about", "tokens": [50722, 321, 486, 751, 466, 441, 7631, 2065, 5729, 2503, 293, 264, 881, 1021, 644, 295, 264, 751, 307, 466, 51038], "temperature": 0.0, "avg_logprob": -0.2140499750773112, "compression_ratio": 1.651376146788991, "no_speech_prob": 0.10773645341396332}, {"id": 8, "seek": 2668, "start": 40.16, "end": 42.480000000000004, "text": " Lisp Scheme, how it works.", "tokens": [51038, 441, 7631, 2065, 5729, 11, 577, 309, 1985, 13, 51154], "temperature": 0.0, "avg_logprob": -0.2140499750773112, "compression_ratio": 1.651376146788991, "no_speech_prob": 0.10773645341396332}, {"id": 9, "seek": 2668, "start": 42.480000000000004, "end": 46.8, "text": " To get most out of this talk you need to know basic of JavaScript.", "tokens": [51154, 1407, 483, 881, 484, 295, 341, 751, 291, 643, 281, 458, 3875, 295, 15778, 13, 51370], "temperature": 0.0, "avg_logprob": -0.2140499750773112, "compression_ratio": 1.651376146788991, "no_speech_prob": 0.10773645341396332}, {"id": 10, "seek": 2668, "start": 46.8, "end": 53.0, "text": " Lisp was presented in 1960s by John McCarthy and his famous paper Recursive Functions of", "tokens": [51370, 441, 7631, 390, 8212, 294, 16157, 82, 538, 2619, 44085, 293, 702, 4618, 3035, 9647, 2156, 488, 11166, 3916, 295, 51680], "temperature": 0.0, "avg_logprob": -0.2140499750773112, "compression_ratio": 1.651376146788991, "no_speech_prob": 0.10773645341396332}, {"id": 11, "seek": 5300, "start": 53.0, "end": 57.72, "text": " Symbolic Expression and Direct Computation by Machine Part 1.", "tokens": [50364, 3902, 5612, 299, 21391, 2775, 293, 18308, 37804, 399, 538, 22155, 4100, 502, 13, 50600], "temperature": 0.0, "avg_logprob": -0.24476410715203537, "compression_ratio": 1.4795081967213115, "no_speech_prob": 0.05179247632622719}, {"id": 12, "seek": 5300, "start": 57.72, "end": 63.96, "text": " Part 2 was never created, it was based on Lambda Calculus by Alonzo Tertz and the paper", "tokens": [50600, 4100, 568, 390, 1128, 2942, 11, 309, 390, 2361, 322, 45691, 3511, 36002, 538, 967, 266, 4765, 314, 911, 89, 293, 264, 3035, 50912], "temperature": 0.0, "avg_logprob": -0.24476410715203537, "compression_ratio": 1.4795081967213115, "no_speech_prob": 0.05179247632622719}, {"id": 13, "seek": 5300, "start": 63.96, "end": 68.84, "text": " explained an eval function that was written in the Lisp itself.", "tokens": [50912, 8825, 364, 1073, 304, 2445, 300, 390, 3720, 294, 264, 441, 7631, 2564, 13, 51156], "temperature": 0.0, "avg_logprob": -0.24476410715203537, "compression_ratio": 1.4795081967213115, "no_speech_prob": 0.05179247632622719}, {"id": 14, "seek": 5300, "start": 68.84, "end": 74.12, "text": " One of McCarthy's students, Steve Russell, decided to implement the eval function on", "tokens": [51156, 1485, 295, 44085, 311, 1731, 11, 7466, 20937, 11, 3047, 281, 4445, 264, 1073, 304, 2445, 322, 51420], "temperature": 0.0, "avg_logprob": -0.24476410715203537, "compression_ratio": 1.4795081967213115, "no_speech_prob": 0.05179247632622719}, {"id": 15, "seek": 5300, "start": 74.12, "end": 79.8, "text": " the IBM 704 and it was first interpreter of the Lisp language.", "tokens": [51420, 264, 23487, 5285, 19, 293, 309, 390, 700, 34132, 295, 264, 441, 7631, 2856, 13, 51704], "temperature": 0.0, "avg_logprob": -0.24476410715203537, "compression_ratio": 1.4795081967213115, "no_speech_prob": 0.05179247632622719}, {"id": 16, "seek": 7980, "start": 79.8, "end": 84.12, "text": " The syntax of the interpreter was a little bit different than the one described in the", "tokens": [50364, 440, 28431, 295, 264, 34132, 390, 257, 707, 857, 819, 813, 264, 472, 7619, 294, 264, 50580], "temperature": 0.0, "avg_logprob": -0.1851335305434007, "compression_ratio": 1.6475095785440612, "no_speech_prob": 0.07003883272409439}, {"id": 17, "seek": 7980, "start": 84.12, "end": 90.12, "text": " paper because of the limitations of the keyboard on the IBM mainframe.", "tokens": [50580, 3035, 570, 295, 264, 15705, 295, 264, 10186, 322, 264, 23487, 2135, 17265, 13, 50880], "temperature": 0.0, "avg_logprob": -0.1851335305434007, "compression_ratio": 1.6475095785440612, "no_speech_prob": 0.07003883272409439}, {"id": 18, "seek": 7980, "start": 90.12, "end": 92.28, "text": " Lisp stands for Lisp Processing.", "tokens": [50880, 441, 7631, 7382, 337, 441, 7631, 31093, 278, 13, 50988], "temperature": 0.0, "avg_logprob": -0.1851335305434007, "compression_ratio": 1.6475095785440612, "no_speech_prob": 0.07003883272409439}, {"id": 19, "seek": 7980, "start": 92.28, "end": 97.44, "text": " The most important thing about the language is that it's homoiconic, which means that", "tokens": [50988, 440, 881, 1021, 551, 466, 264, 2856, 307, 300, 309, 311, 3655, 78, 299, 11630, 11, 597, 1355, 300, 51246], "temperature": 0.0, "avg_logprob": -0.1851335305434007, "compression_ratio": 1.6475095785440612, "no_speech_prob": 0.07003883272409439}, {"id": 20, "seek": 7980, "start": 97.44, "end": 101.88, "text": " the Lisp code is represented by Lisp, the main data structure.", "tokens": [51246, 264, 441, 7631, 3089, 307, 10379, 538, 441, 7631, 11, 264, 2135, 1412, 3877, 13, 51468], "temperature": 0.0, "avg_logprob": -0.1851335305434007, "compression_ratio": 1.6475095785440612, "no_speech_prob": 0.07003883272409439}, {"id": 21, "seek": 7980, "start": 101.88, "end": 107.96, "text": " It was heavily used by AI research at the beginning and it was great source of inspiration", "tokens": [51468, 467, 390, 10950, 1143, 538, 7318, 2132, 412, 264, 2863, 293, 309, 390, 869, 4009, 295, 10249, 51772], "temperature": 0.0, "avg_logprob": -0.1851335305434007, "compression_ratio": 1.6475095785440612, "no_speech_prob": 0.07003883272409439}, {"id": 22, "seek": 10796, "start": 108.03999999999999, "end": 110.36, "text": " for most modern programming languages.", "tokens": [50368, 337, 881, 4363, 9410, 8650, 13, 50484], "temperature": 0.0, "avg_logprob": -0.22332801458970555, "compression_ratio": 1.4959349593495934, "no_speech_prob": 0.03393527492880821}, {"id": 23, "seek": 10796, "start": 110.36, "end": 114.75999999999999, "text": " There are few so-called dialects of Lisp which are used today.", "tokens": [50484, 821, 366, 1326, 370, 12, 11880, 24652, 82, 295, 441, 7631, 597, 366, 1143, 965, 13, 50704], "temperature": 0.0, "avg_logprob": -0.22332801458970555, "compression_ratio": 1.4959349593495934, "no_speech_prob": 0.03393527492880821}, {"id": 24, "seek": 10796, "start": 114.75999999999999, "end": 118.67999999999999, "text": " Scheme, Clojure, MX Lisp, Racket and Common Lisp.", "tokens": [50704, 2065, 5729, 11, 31901, 73, 540, 11, 47509, 441, 7631, 11, 497, 501, 302, 293, 18235, 441, 7631, 13, 50900], "temperature": 0.0, "avg_logprob": -0.22332801458970555, "compression_ratio": 1.4959349593495934, "no_speech_prob": 0.03393527492880821}, {"id": 25, "seek": 10796, "start": 119.24, "end": 126.44, "text": " Scheme was invented in 1970s at MIT by Guy L. Steele and Gerald J. Sassman", "tokens": [50928, 2065, 5729, 390, 14479, 294, 14577, 82, 412, 13100, 538, 14690, 441, 13, 745, 1653, 306, 293, 38332, 508, 13, 318, 640, 1601, 51288], "temperature": 0.0, "avg_logprob": -0.22332801458970555, "compression_ratio": 1.4959349593495934, "no_speech_prob": 0.03393527492880821}, {"id": 26, "seek": 10796, "start": 126.44, "end": 128.84, "text": " when they investigated the actor model.", "tokens": [51288, 562, 436, 30070, 264, 8747, 2316, 13, 51408], "temperature": 0.0, "avg_logprob": -0.22332801458970555, "compression_ratio": 1.4959349593495934, "no_speech_prob": 0.03393527492880821}, {"id": 27, "seek": 10796, "start": 128.84, "end": 135.95999999999998, "text": " The language is defined by specifications RNRS, which stands for Revisited Report on Language Scheme.", "tokens": [51408, 440, 2856, 307, 7642, 538, 29448, 45702, 43580, 11, 597, 7382, 337, 1300, 4938, 1226, 16057, 322, 24445, 2065, 5729, 13, 51764], "temperature": 0.0, "avg_logprob": -0.22332801458970555, "compression_ratio": 1.4959349593495934, "no_speech_prob": 0.03393527492880821}, {"id": 28, "seek": 13596, "start": 135.96, "end": 139.4, "text": " Where number indicates how many times it was revisited.", "tokens": [50364, 2305, 1230, 16203, 577, 867, 1413, 309, 390, 20767, 1226, 13, 50536], "temperature": 0.0, "avg_logprob": -0.12805081417686062, "compression_ratio": 1.6044444444444443, "no_speech_prob": 0.04265051707625389}, {"id": 29, "seek": 13596, "start": 139.4, "end": 146.28, "text": " Second version was Revisited Revisited, so it used power off to make the name shorter.", "tokens": [50536, 5736, 3037, 390, 1300, 4938, 1226, 1300, 4938, 1226, 11, 370, 309, 1143, 1347, 766, 281, 652, 264, 1315, 11639, 13, 50880], "temperature": 0.0, "avg_logprob": -0.12805081417686062, "compression_ratio": 1.6044444444444443, "no_speech_prob": 0.04265051707625389}, {"id": 30, "seek": 13596, "start": 146.28, "end": 152.28, "text": " There are also official extensions to the language, SRFI, Scheme Request for Implementations,", "tokens": [50880, 821, 366, 611, 4783, 25129, 281, 264, 2856, 11, 20840, 38568, 11, 2065, 5729, 1300, 20343, 337, 4331, 43704, 763, 11, 51180], "temperature": 0.0, "avg_logprob": -0.12805081417686062, "compression_ratio": 1.6044444444444443, "no_speech_prob": 0.04265051707625389}, {"id": 31, "seek": 13596, "start": 152.28, "end": 154.68, "text": " which adds new language features.", "tokens": [51180, 597, 10860, 777, 2856, 4122, 13, 51300], "temperature": 0.0, "avg_logprob": -0.12805081417686062, "compression_ratio": 1.6044444444444443, "no_speech_prob": 0.04265051707625389}, {"id": 32, "seek": 13596, "start": 154.68, "end": 158.84, "text": " The official website for the language is Scheme.org.", "tokens": [51300, 440, 4783, 3144, 337, 264, 2856, 307, 2065, 5729, 13, 4646, 13, 51508], "temperature": 0.0, "avg_logprob": -0.12805081417686062, "compression_ratio": 1.6044444444444443, "no_speech_prob": 0.04265051707625389}, {"id": 33, "seek": 13596, "start": 158.84, "end": 161.4, "text": " Now let's talk about basic of Scheme.", "tokens": [51508, 823, 718, 311, 751, 466, 3875, 295, 2065, 5729, 13, 51636], "temperature": 0.0, "avg_logprob": -0.12805081417686062, "compression_ratio": 1.6044444444444443, "no_speech_prob": 0.04265051707625389}, {"id": 34, "seek": 16140, "start": 161.4, "end": 167.0, "text": " In most modern programming languages, when you have a function call, you use syntax like this,", "tokens": [50364, 682, 881, 4363, 9410, 8650, 11, 562, 291, 362, 257, 2445, 818, 11, 291, 764, 28431, 411, 341, 11, 50644], "temperature": 0.0, "avg_logprob": -0.17084440934030634, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.027394965291023254}, {"id": 35, "seek": 16140, "start": 167.0, "end": 173.08, "text": " where you have a function name and in parentheses there are arguments separated by a comma.", "tokens": [50644, 689, 291, 362, 257, 2445, 1315, 293, 294, 34153, 456, 366, 12869, 12005, 538, 257, 22117, 13, 50948], "temperature": 0.0, "avg_logprob": -0.17084440934030634, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.027394965291023254}, {"id": 36, "seek": 16140, "start": 173.08, "end": 178.6, "text": " In List and Scheme on the other hand, the code is created from S-expressions.", "tokens": [50948, 682, 17668, 293, 2065, 5729, 322, 264, 661, 1011, 11, 264, 3089, 307, 2942, 490, 318, 12, 3121, 11637, 626, 13, 51224], "temperature": 0.0, "avg_logprob": -0.17084440934030634, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.027394965291023254}, {"id": 37, "seek": 16140, "start": 178.6, "end": 185.96, "text": " A list created by parentheses, where first element is a function and arguments separated by a space.", "tokens": [51224, 316, 1329, 2942, 538, 34153, 11, 689, 700, 4478, 307, 257, 2445, 293, 12869, 12005, 538, 257, 1901, 13, 51592], "temperature": 0.0, "avg_logprob": -0.17084440934030634, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.027394965291023254}, {"id": 38, "seek": 16140, "start": 185.96, "end": 187.32, "text": " And you can mess those lists.", "tokens": [51592, 400, 291, 393, 2082, 729, 14511, 13, 51660], "temperature": 0.0, "avg_logprob": -0.17084440934030634, "compression_ratio": 1.7555555555555555, "no_speech_prob": 0.027394965291023254}, {"id": 39, "seek": 18732, "start": 187.32, "end": 191.88, "text": " What is important with this expression is that those are not operators.", "tokens": [50364, 708, 307, 1021, 365, 341, 6114, 307, 300, 729, 366, 406, 19077, 13, 50592], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 40, "seek": 18732, "start": 191.88, "end": 196.28, "text": " They are plus and aesthetic symbols, which are names of the functions.", "tokens": [50592, 814, 366, 1804, 293, 20092, 16944, 11, 597, 366, 5288, 295, 264, 6828, 13, 50812], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 41, "seek": 18732, "start": 196.28, "end": 198.35999999999999, "text": " So they are in fact function calls.", "tokens": [50812, 407, 436, 366, 294, 1186, 2445, 5498, 13, 50916], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 42, "seek": 18732, "start": 198.35999999999999, "end": 201.72, "text": " So they are written in the same way as a sign function.", "tokens": [50916, 407, 436, 366, 3720, 294, 264, 912, 636, 382, 257, 1465, 2445, 13, 51084], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 43, "seek": 18732, "start": 202.35999999999999, "end": 206.2, "text": " As I've mentioned, code and data use the same data structures.", "tokens": [51116, 1018, 286, 600, 2835, 11, 3089, 293, 1412, 764, 264, 912, 1412, 9227, 13, 51308], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 44, "seek": 18732, "start": 206.2, "end": 209.07999999999998, "text": " So it's important to distinguish data from code.", "tokens": [51308, 407, 309, 311, 1021, 281, 20206, 1412, 490, 3089, 13, 51452], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 45, "seek": 18732, "start": 209.72, "end": 211.56, "text": " This is done by quotations.", "tokens": [51484, 639, 307, 1096, 538, 9641, 763, 13, 51576], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 46, "seek": 18732, "start": 211.56, "end": 216.51999999999998, "text": " The first expression is code and the second is data, a list of numbers.", "tokens": [51576, 440, 700, 6114, 307, 3089, 293, 264, 1150, 307, 1412, 11, 257, 1329, 295, 3547, 13, 51824], "temperature": 0.0, "avg_logprob": -0.08688115651628613, "compression_ratio": 1.7768924302788844, "no_speech_prob": 0.013500647619366646}, {"id": 47, "seek": 21652, "start": 216.52, "end": 219.16, "text": " To define variables in Scheme, you use define.", "tokens": [50364, 1407, 6964, 9102, 294, 2065, 5729, 11, 291, 764, 6964, 13, 50496], "temperature": 0.0, "avg_logprob": -0.12594013412793478, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.012717409059405327}, {"id": 48, "seek": 21652, "start": 219.88000000000002, "end": 222.84, "text": " That can also be used to define a function.", "tokens": [50532, 663, 393, 611, 312, 1143, 281, 6964, 257, 2445, 13, 50680], "temperature": 0.0, "avg_logprob": -0.12594013412793478, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.012717409059405327}, {"id": 49, "seek": 21652, "start": 222.84, "end": 226.36, "text": " And let is used to create local variables.", "tokens": [50680, 400, 718, 307, 1143, 281, 1884, 2654, 9102, 13, 50856], "temperature": 0.0, "avg_logprob": -0.12594013412793478, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.012717409059405327}, {"id": 50, "seek": 21652, "start": 226.36, "end": 233.16000000000003, "text": " And this is how you define an if statement that will print a message depending on a Boolean expression.", "tokens": [50856, 400, 341, 307, 577, 291, 6964, 364, 498, 5629, 300, 486, 4482, 257, 3636, 5413, 322, 257, 23351, 28499, 6114, 13, 51196], "temperature": 0.0, "avg_logprob": -0.12594013412793478, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.012717409059405327}, {"id": 51, "seek": 21652, "start": 233.8, "end": 240.68, "text": " Define if and let expressions are special syntax which works differently than the normal functions.", "tokens": [51228, 9548, 533, 498, 293, 718, 15277, 366, 2121, 28431, 597, 1985, 7614, 813, 264, 2710, 6828, 13, 51572], "temperature": 0.0, "avg_logprob": -0.12594013412793478, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.012717409059405327}, {"id": 52, "seek": 21652, "start": 240.68, "end": 244.92000000000002, "text": " And you can define your own syntax like this by using macros.", "tokens": [51572, 400, 291, 393, 6964, 428, 1065, 28431, 411, 341, 538, 1228, 7912, 2635, 13, 51784], "temperature": 0.0, "avg_logprob": -0.12594013412793478, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.012717409059405327}, {"id": 53, "seek": 24492, "start": 244.92, "end": 250.44, "text": " For example, we can define macrofrop that when passing expression with infix notation", "tokens": [50364, 1171, 1365, 11, 321, 393, 6964, 18887, 69, 1513, 300, 562, 8437, 6114, 365, 1536, 970, 24657, 50640], "temperature": 0.0, "avg_logprob": -0.1624679270478868, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.005779527127742767}, {"id": 54, "seek": 24492, "start": 250.44, "end": 253.23999999999998, "text": " will sum the numbers using prefix notation.", "tokens": [50640, 486, 2408, 264, 3547, 1228, 46969, 24657, 13, 50780], "temperature": 0.0, "avg_logprob": -0.1624679270478868, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.005779527127742767}, {"id": 55, "seek": 24492, "start": 253.23999999999998, "end": 255.64, "text": " In Scheme, there are two types of macros.", "tokens": [50780, 682, 2065, 5729, 11, 456, 366, 732, 3467, 295, 7912, 2635, 13, 50900], "temperature": 0.0, "avg_logprob": -0.1624679270478868, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.005779527127742767}, {"id": 56, "seek": 24492, "start": 255.64, "end": 263.08, "text": " First are list macros that accept code as data and return new list that will be evaluated.", "tokens": [50900, 2386, 366, 1329, 7912, 2635, 300, 3241, 3089, 382, 1412, 293, 2736, 777, 1329, 300, 486, 312, 25509, 13, 51272], "temperature": 0.0, "avg_logprob": -0.1624679270478868, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.005779527127742767}, {"id": 57, "seek": 24492, "start": 263.08, "end": 266.76, "text": " And the second are hygienic macros that use pattern matching syntax.", "tokens": [51272, 400, 264, 1150, 366, 24470, 1053, 299, 7912, 2635, 300, 764, 5102, 14324, 28431, 13, 51456], "temperature": 0.0, "avg_logprob": -0.1624679270478868, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.005779527127742767}, {"id": 58, "seek": 24492, "start": 267.32, "end": 270.68, "text": " These macros are used probably by all list dialects.", "tokens": [51484, 1981, 7912, 2635, 366, 1143, 1391, 538, 439, 1329, 24652, 82, 13, 51652], "temperature": 0.0, "avg_logprob": -0.1624679270478868, "compression_ratio": 1.641025641025641, "no_speech_prob": 0.005779527127742767}, {"id": 59, "seek": 27068, "start": 271.16, "end": 276.36, "text": " But hygienic macros are specific to Scheme and dialect based on Scheme.", "tokens": [50388, 583, 24470, 1053, 299, 7912, 2635, 366, 2685, 281, 2065, 5729, 293, 24652, 2361, 322, 2065, 5729, 13, 50648], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 60, "seek": 27068, "start": 276.36, "end": 279.0, "text": " To learn more about Scheme, I suggest a book,", "tokens": [50648, 1407, 1466, 544, 466, 2065, 5729, 11, 286, 3402, 257, 1446, 11, 50780], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 61, "seek": 27068, "start": 279.0, "end": 281.32, "text": " Sketchy Scheme by Nils M. Horm.", "tokens": [50780, 45012, 28629, 2065, 5729, 538, 426, 4174, 376, 13, 389, 687, 13, 50896], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 62, "seek": 27068, "start": 282.04, "end": 285.88, "text": " You can find the older version of the book on Internet Archive", "tokens": [50932, 509, 393, 915, 264, 4906, 3037, 295, 264, 1446, 322, 7703, 10984, 488, 51124], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 63, "seek": 27068, "start": 285.88, "end": 288.92, "text": " by a suggest to get the latest version from this link.", "tokens": [51124, 538, 257, 3402, 281, 483, 264, 6792, 3037, 490, 341, 2113, 13, 51276], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 64, "seek": 27068, "start": 290.04, "end": 292.12, "text": " The main topic of this talk is leaps.", "tokens": [51332, 440, 2135, 4829, 295, 341, 751, 307, 476, 2382, 13, 51436], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 65, "seek": 27068, "start": 292.68, "end": 295.56, "text": " Scheme in implementation written in JavaScript.", "tokens": [51464, 2065, 5729, 294, 11420, 3720, 294, 15778, 13, 51608], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 66, "seek": 27068, "start": 295.56, "end": 298.44, "text": " So let's quickly talk about history of this project.", "tokens": [51608, 407, 718, 311, 2661, 751, 466, 2503, 295, 341, 1716, 13, 51752], "temperature": 0.0, "avg_logprob": -0.15683224326685855, "compression_ratio": 1.5984251968503937, "no_speech_prob": 0.02483857423067093}, {"id": 67, "seek": 29844, "start": 299.24, "end": 302.92, "text": " It started on KotPen as a list based on Scheme.", "tokens": [50404, 467, 1409, 322, 30123, 47, 268, 382, 257, 1329, 2361, 322, 2065, 5729, 13, 50588], "temperature": 0.0, "avg_logprob": -0.15901684761047363, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.016434235498309135}, {"id": 68, "seek": 29844, "start": 303.88, "end": 309.71999999999997, "text": " I wanted to create Emacs in browser and wanted to have something like EmacsList.", "tokens": [50636, 286, 1415, 281, 1884, 3968, 44937, 294, 11185, 293, 1415, 281, 362, 746, 411, 3968, 44937, 43, 468, 13, 50928], "temperature": 0.0, "avg_logprob": -0.15901684761047363, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.016434235498309135}, {"id": 69, "seek": 29844, "start": 310.68, "end": 315.56, "text": " That's why leaps from the beginning have an optional dynamic scope", "tokens": [50976, 663, 311, 983, 476, 2382, 490, 264, 2863, 362, 364, 17312, 8546, 11923, 51220], "temperature": 0.0, "avg_logprob": -0.15901684761047363, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.016434235498309135}, {"id": 70, "seek": 29844, "start": 315.56, "end": 318.2, "text": " that is a characteristic feature of EmacsList.", "tokens": [51220, 300, 307, 257, 16282, 4111, 295, 3968, 44937, 43, 468, 13, 51352], "temperature": 0.0, "avg_logprob": -0.15901684761047363, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.016434235498309135}, {"id": 71, "seek": 29844, "start": 319.15999999999997, "end": 323.15999999999997, "text": " Fpcat Scheme because it's much simpler than other dialects.", "tokens": [51400, 479, 79, 18035, 2065, 5729, 570, 309, 311, 709, 18587, 813, 661, 24652, 82, 13, 51600], "temperature": 0.0, "avg_logprob": -0.15901684761047363, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.016434235498309135}, {"id": 72, "seek": 29844, "start": 323.88, "end": 328.2, "text": " You can still find the first version of the interpreter on KotPen.", "tokens": [51636, 509, 393, 920, 915, 264, 700, 3037, 295, 264, 34132, 322, 30123, 47, 268, 13, 51852], "temperature": 0.0, "avg_logprob": -0.15901684761047363, "compression_ratio": 1.5905172413793103, "no_speech_prob": 0.016434235498309135}, {"id": 73, "seek": 32844, "start": 328.92, "end": 335.71999999999997, "text": " Leaps was inspired by EmacsList and Python, mostly about the introspection features", "tokens": [50388, 1456, 2382, 390, 7547, 538, 3968, 44937, 43, 468, 293, 15329, 11, 5240, 466, 264, 560, 2635, 19997, 4122, 50728], "temperature": 0.0, "avg_logprob": -0.1199817955493927, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.005750236101448536}, {"id": 74, "seek": 32844, "start": 335.71999999999997, "end": 339.32, "text": " and that all functions have documentation inside the code,", "tokens": [50728, 293, 300, 439, 6828, 362, 14333, 1854, 264, 3089, 11, 50908], "temperature": 0.0, "avg_logprob": -0.1199817955493927, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.005750236101448536}, {"id": 75, "seek": 32844, "start": 339.32, "end": 341.56, "text": " which you can access from the REPL.", "tokens": [50908, 597, 291, 393, 2105, 490, 264, 31511, 43, 13, 51020], "temperature": 0.0, "avg_logprob": -0.1199817955493927, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.005750236101448536}, {"id": 76, "seek": 32844, "start": 341.56, "end": 346.52, "text": " The last version of leaps that you can access from the NPM repository", "tokens": [51020, 440, 1036, 3037, 295, 476, 2382, 300, 291, 393, 2105, 490, 264, 426, 18819, 25841, 51268], "temperature": 0.0, "avg_logprob": -0.1199817955493927, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.005750236101448536}, {"id": 77, "seek": 32844, "start": 346.52, "end": 350.76, "text": " as a stable release is version 0.20.3.", "tokens": [51268, 382, 257, 8351, 4374, 307, 3037, 1958, 13, 2009, 13, 18, 13, 51480], "temperature": 0.0, "avg_logprob": -0.1199817955493927, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.005750236101448536}, {"id": 78, "seek": 32844, "start": 351.4, "end": 357.32, "text": " But on a certain point, I decided that I want a full Scheme implementation,", "tokens": [51512, 583, 322, 257, 1629, 935, 11, 286, 3047, 300, 286, 528, 257, 1577, 2065, 5729, 11420, 11, 51808], "temperature": 0.0, "avg_logprob": -0.1199817955493927, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.005750236101448536}, {"id": 79, "seek": 35732, "start": 357.32, "end": 359.56, "text": " not only leaps based on Scheme.", "tokens": [50364, 406, 787, 476, 2382, 2361, 322, 2065, 5729, 13, 50476], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 80, "seek": 35732, "start": 360.2, "end": 363.64, "text": " And I've started working on the code on the devil branch.", "tokens": [50508, 400, 286, 600, 1409, 1364, 322, 264, 3089, 322, 264, 13297, 9819, 13, 50680], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 81, "seek": 35732, "start": 363.64, "end": 367.8, "text": " But at one point, it turns out that there are way too many", "tokens": [50680, 583, 412, 472, 935, 11, 309, 4523, 484, 300, 456, 366, 636, 886, 867, 50888], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 82, "seek": 35732, "start": 367.8, "end": 370.12, "text": " breaking changes to release the next version.", "tokens": [50888, 7697, 2962, 281, 4374, 264, 958, 3037, 13, 51004], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 83, "seek": 35732, "start": 370.12, "end": 376.2, "text": " That's why I released it as 1.0 beta and the latest version is 16.", "tokens": [51004, 663, 311, 983, 286, 4736, 309, 382, 502, 13, 15, 9861, 293, 264, 6792, 3037, 307, 3165, 13, 51308], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 84, "seek": 35732, "start": 377.0, "end": 380.2, "text": " At the beginning, the whole code was written in JavaScript.", "tokens": [51348, 1711, 264, 2863, 11, 264, 1379, 3089, 390, 3720, 294, 15778, 13, 51508], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 85, "seek": 35732, "start": 380.2, "end": 384.44, "text": " But when I was making an effort toward full Scheme implementation,", "tokens": [51508, 583, 562, 286, 390, 1455, 364, 4630, 7361, 1577, 2065, 5729, 11420, 11, 51720], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 86, "seek": 35732, "start": 384.44, "end": 386.52, "text": " more and more code was written in Scheme.", "tokens": [51720, 544, 293, 544, 3089, 390, 3720, 294, 2065, 5729, 13, 51824], "temperature": 0.0, "avg_logprob": -0.10697412490844727, "compression_ratio": 1.6602316602316602, "no_speech_prob": 0.008957859128713608}, {"id": 87, "seek": 38732, "start": 387.88, "end": 390.44, "text": " Now almost half of the leaps code is Scheme.", "tokens": [50392, 823, 1920, 1922, 295, 264, 476, 2382, 3089, 307, 2065, 5729, 13, 50520], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 88, "seek": 38732, "start": 391.56, "end": 393.48, "text": " And now there is a time for the demo.", "tokens": [50576, 400, 586, 456, 307, 257, 565, 337, 264, 10723, 13, 50672], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 89, "seek": 38732, "start": 395.64, "end": 398.44, "text": " This is the official website for the leaps project.", "tokens": [50780, 639, 307, 264, 4783, 3144, 337, 264, 476, 2382, 1716, 13, 50920], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 90, "seek": 38732, "start": 398.44, "end": 402.12, "text": " And what's cool about this is that here you have a bookmarklet", "tokens": [50920, 400, 437, 311, 1627, 466, 341, 307, 300, 510, 291, 362, 257, 1446, 5638, 2631, 51104], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 91, "seek": 38732, "start": 402.68, "end": 405.71999999999997, "text": " and you can drag this link to your bookmarks", "tokens": [51132, 293, 291, 393, 5286, 341, 2113, 281, 428, 1446, 37307, 51284], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 92, "seek": 38732, "start": 406.92, "end": 409.0, "text": " and execute it on a different page.", "tokens": [51344, 293, 14483, 309, 322, 257, 819, 3028, 13, 51448], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 93, "seek": 38732, "start": 409.0, "end": 411.88, "text": " For instance, here there is a first lecture", "tokens": [51448, 1171, 5197, 11, 510, 456, 307, 257, 700, 7991, 51592], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 94, "seek": 38732, "start": 411.88, "end": 414.92, "text": " of the structure of the interpretation of the program.", "tokens": [51592, 295, 264, 3877, 295, 264, 14174, 295, 264, 1461, 13, 51744], "temperature": 0.0, "avg_logprob": -0.11846275699948802, "compression_ratio": 1.6981981981981982, "no_speech_prob": 0.009445752948522568}, {"id": 95, "seek": 41492, "start": 414.92, "end": 418.52000000000004, "text": " A classic video lectures from MIT.", "tokens": [50364, 316, 7230, 960, 16564, 490, 13100, 13, 50544], "temperature": 0.0, "avg_logprob": -0.28510516030447824, "compression_ratio": 1.2644628099173554, "no_speech_prob": 0.0240623839199543}, {"id": 96, "seek": 41492, "start": 422.28000000000003, "end": 432.52000000000004, "text": " You can evaluate Scheme code that you see on the screen.", "tokens": [50732, 509, 393, 13059, 2065, 5729, 3089, 300, 291, 536, 322, 264, 2568, 13, 51244], "temperature": 0.0, "avg_logprob": -0.28510516030447824, "compression_ratio": 1.2644628099173554, "no_speech_prob": 0.0240623839199543}, {"id": 97, "seek": 41492, "start": 440.6, "end": 443.88, "text": " The feature of the rebel is that there are syntax high-liking", "tokens": [51648, 440, 4111, 295, 264, 28293, 307, 300, 456, 366, 28431, 1090, 12, 75, 13085, 51812], "temperature": 0.0, "avg_logprob": -0.28510516030447824, "compression_ratio": 1.2644628099173554, "no_speech_prob": 0.0240623839199543}, {"id": 98, "seek": 44388, "start": 443.88, "end": 448.76, "text": " and parenthesis matching and also each macro and functions", "tokens": [50364, 293, 23350, 9374, 14324, 293, 611, 1184, 18887, 293, 6828, 50608], "temperature": 0.0, "avg_logprob": -0.19352412223815918, "compression_ratio": 1.7955801104972375, "no_speech_prob": 0.006448666099458933}, {"id": 99, "seek": 44388, "start": 448.76, "end": 451.4, "text": " have documentation if you hover over the name.", "tokens": [50608, 362, 14333, 498, 291, 20076, 670, 264, 1315, 13, 50740], "temperature": 0.0, "avg_logprob": -0.19352412223815918, "compression_ratio": 1.7955801104972375, "no_speech_prob": 0.006448666099458933}, {"id": 100, "seek": 44388, "start": 452.2, "end": 454.52, "text": " Here you have documentation for define.", "tokens": [50780, 1692, 291, 362, 14333, 337, 6964, 13, 50896], "temperature": 0.0, "avg_logprob": -0.19352412223815918, "compression_ratio": 1.7955801104972375, "no_speech_prob": 0.006448666099458933}, {"id": 101, "seek": 44388, "start": 455.24, "end": 459.96, "text": " Here you have documentation for asterisk multiplication operator.", "tokens": [50932, 1692, 291, 362, 14333, 337, 257, 3120, 7797, 27290, 12973, 13, 51168], "temperature": 0.0, "avg_logprob": -0.19352412223815918, "compression_ratio": 1.7955801104972375, "no_speech_prob": 0.006448666099458933}, {"id": 102, "seek": 44388, "start": 461.32, "end": 464.76, "text": " You can also undock the panel with the rebel", "tokens": [51236, 509, 393, 611, 674, 1560, 264, 4831, 365, 264, 28293, 51408], "temperature": 0.0, "avg_logprob": -0.19352412223815918, "compression_ratio": 1.7955801104972375, "no_speech_prob": 0.006448666099458933}, {"id": 103, "seek": 44388, "start": 466.52, "end": 470.12, "text": " and use it inside the window that you can drag and drop on the page.", "tokens": [51496, 293, 764, 309, 1854, 264, 4910, 300, 291, 393, 5286, 293, 3270, 322, 264, 3028, 13, 51676], "temperature": 0.0, "avg_logprob": -0.19352412223815918, "compression_ratio": 1.7955801104972375, "no_speech_prob": 0.006448666099458933}, {"id": 104, "seek": 47388, "start": 474.12, "end": 480.84, "text": " Another cool feature of the rebel is that you can execute it on PDF files.", "tokens": [50376, 3996, 1627, 4111, 295, 264, 28293, 307, 300, 291, 393, 14483, 309, 322, 17752, 7098, 13, 50712], "temperature": 0.0, "avg_logprob": -0.16201288308670272, "compression_ratio": 1.4861878453038675, "no_speech_prob": 0.001392016769386828}, {"id": 105, "seek": 47388, "start": 484.04, "end": 486.76, "text": " But I've tested this only on Chrome browser.", "tokens": [50872, 583, 286, 600, 8246, 341, 787, 322, 15327, 11185, 13, 51008], "temperature": 0.0, "avg_logprob": -0.16201288308670272, "compression_ratio": 1.4861878453038675, "no_speech_prob": 0.001392016769386828}, {"id": 106, "seek": 47388, "start": 488.12, "end": 491.15999999999997, "text": " This PDF document is Scheme language specification.", "tokens": [51076, 639, 17752, 4166, 307, 2065, 5729, 2856, 31256, 13, 51228], "temperature": 0.0, "avg_logprob": -0.16201288308670272, "compression_ratio": 1.4861878453038675, "no_speech_prob": 0.001392016769386828}, {"id": 107, "seek": 47388, "start": 492.68, "end": 496.12, "text": " But it often gives problems if you try to execute code", "tokens": [51304, 583, 309, 2049, 2709, 2740, 498, 291, 853, 281, 14483, 3089, 51476], "temperature": 0.0, "avg_logprob": -0.16201288308670272, "compression_ratio": 1.4861878453038675, "no_speech_prob": 0.001392016769386828}, {"id": 108, "seek": 47388, "start": 496.12, "end": 498.92, "text": " that is inside this document in the rebel.", "tokens": [51476, 300, 307, 1854, 341, 4166, 294, 264, 28293, 13, 51616], "temperature": 0.0, "avg_logprob": -0.16201288308670272, "compression_ratio": 1.4861878453038675, "no_speech_prob": 0.001392016769386828}, {"id": 109, "seek": 49892, "start": 499.40000000000003, "end": 504.68, "text": " For instance, on page 12, there's this quotations.", "tokens": [50388, 1171, 5197, 11, 322, 3028, 2272, 11, 456, 311, 341, 9641, 763, 13, 50652], "temperature": 0.0, "avg_logprob": -0.19766587922067352, "compression_ratio": 1.4906832298136645, "no_speech_prob": 0.020194292068481445}, {"id": 110, "seek": 49892, "start": 504.68, "end": 507.16, "text": " If you try to execute this code in the rebel,", "tokens": [50652, 759, 291, 853, 281, 14483, 341, 3089, 294, 264, 28293, 11, 50776], "temperature": 0.0, "avg_logprob": -0.19766587922067352, "compression_ratio": 1.4906832298136645, "no_speech_prob": 0.020194292068481445}, {"id": 111, "seek": 49892, "start": 508.36, "end": 510.76, "text": " you give it this kind of warning.", "tokens": [50836, 291, 976, 309, 341, 733, 295, 9164, 13, 50956], "temperature": 0.0, "avg_logprob": -0.19766587922067352, "compression_ratio": 1.4906832298136645, "no_speech_prob": 0.020194292068481445}, {"id": 112, "seek": 49892, "start": 512.9200000000001, "end": 516.12, "text": " But you can fix this error by executing this code.", "tokens": [51064, 583, 291, 393, 3191, 341, 6713, 538, 32368, 341, 3089, 13, 51224], "temperature": 0.0, "avg_logprob": -0.19766587922067352, "compression_ratio": 1.4906832298136645, "no_speech_prob": 0.020194292068481445}, {"id": 113, "seek": 49892, "start": 520.44, "end": 526.2, "text": " You execute it, suddenly you can evaluate this expression.", "tokens": [51440, 509, 14483, 309, 11, 5800, 291, 393, 13059, 341, 6114, 13, 51728], "temperature": 0.0, "avg_logprob": -0.19766587922067352, "compression_ratio": 1.4906832298136645, "no_speech_prob": 0.020194292068481445}, {"id": 114, "seek": 52620, "start": 527.1600000000001, "end": 533.8000000000001, "text": " This is a special kind of function that creates syntax extension.", "tokens": [50412, 639, 307, 257, 2121, 733, 295, 2445, 300, 7829, 28431, 10320, 13, 50744], "temperature": 0.0, "avg_logprob": -0.13634283402386835, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.004650929011404514}, {"id": 115, "seek": 52620, "start": 534.6, "end": 537.5600000000001, "text": " Here you can have documentation for this function.", "tokens": [50784, 1692, 291, 393, 362, 14333, 337, 341, 2445, 13, 50932], "temperature": 0.0, "avg_logprob": -0.13634283402386835, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.004650929011404514}, {"id": 116, "seek": 52620, "start": 539.88, "end": 543.24, "text": " Syntax extensions allow to define new syntax", "tokens": [51048, 3902, 580, 2797, 25129, 2089, 281, 6964, 777, 28431, 51216], "temperature": 0.0, "avg_logprob": -0.13634283402386835, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.004650929011404514}, {"id": 117, "seek": 52620, "start": 543.24, "end": 547.4000000000001, "text": " similar to the one defined in JavaScript, like those quotations.", "tokens": [51216, 2531, 281, 264, 472, 7642, 294, 15778, 11, 411, 729, 9641, 763, 13, 51424], "temperature": 0.0, "avg_logprob": -0.13634283402386835, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.004650929011404514}, {"id": 118, "seek": 52620, "start": 548.36, "end": 552.6800000000001, "text": " Here you can see vector literals, defined by hash sign.", "tokens": [51472, 1692, 291, 393, 536, 8062, 2733, 1124, 11, 7642, 538, 22019, 1465, 13, 51688], "temperature": 0.0, "avg_logprob": -0.13634283402386835, "compression_ratio": 1.6022727272727273, "no_speech_prob": 0.004650929011404514}, {"id": 119, "seek": 55268, "start": 553.2399999999999, "end": 556.4399999999999, "text": " Vectors are also created as syntax extensions.", "tokens": [50392, 691, 557, 830, 366, 611, 2942, 382, 28431, 25129, 13, 50552], "temperature": 0.0, "avg_logprob": -0.19079450701103837, "compression_ratio": 1.6305732484076434, "no_speech_prob": 0.016808224841952324}, {"id": 120, "seek": 55268, "start": 558.04, "end": 561.56, "text": " And Scheme vectors are just JavaScript R writes.", "tokens": [50632, 400, 2065, 5729, 18875, 366, 445, 15778, 497, 13657, 13, 50808], "temperature": 0.0, "avg_logprob": -0.19079450701103837, "compression_ratio": 1.6305732484076434, "no_speech_prob": 0.016808224841952324}, {"id": 121, "seek": 55268, "start": 562.52, "end": 567.64, "text": " Similar syntax extension is ampersand that define JavaScript object literals.", "tokens": [50856, 10905, 28431, 10320, 307, 18648, 433, 474, 300, 6964, 15778, 2657, 2733, 1124, 13, 51112], "temperature": 0.0, "avg_logprob": -0.19079450701103837, "compression_ratio": 1.6305732484076434, "no_speech_prob": 0.016808224841952324}, {"id": 122, "seek": 55268, "start": 574.8399999999999, "end": 580.12, "text": " Here we can see that representation of object literals looks the same as the code.", "tokens": [51472, 1692, 321, 393, 536, 300, 10290, 295, 2657, 2733, 1124, 1542, 264, 912, 382, 264, 3089, 13, 51736], "temperature": 0.0, "avg_logprob": -0.19079450701103837, "compression_ratio": 1.6305732484076434, "no_speech_prob": 0.016808224841952324}, {"id": 123, "seek": 58012, "start": 581.08, "end": 584.28, "text": " This is another feature of Libs that allow to define", "tokens": [50412, 639, 307, 1071, 4111, 295, 15834, 82, 300, 2089, 281, 6964, 50572], "temperature": 0.0, "avg_logprob": -0.2154839038848877, "compression_ratio": 1.4335664335664335, "no_speech_prob": 0.010405578650534153}, {"id": 124, "seek": 58012, "start": 584.28, "end": 586.76, "text": " new representation for different instances.", "tokens": [50572, 777, 10290, 337, 819, 14519, 13, 50696], "temperature": 0.0, "avg_logprob": -0.2154839038848877, "compression_ratio": 1.4335664335664335, "no_speech_prob": 0.010405578650534153}, {"id": 125, "seek": 58012, "start": 587.4, "end": 590.28, "text": " Scheme vectors are also defined in the same way.", "tokens": [50728, 2065, 5729, 18875, 366, 611, 7642, 294, 264, 912, 636, 13, 50872], "temperature": 0.0, "avg_logprob": -0.2154839038848877, "compression_ratio": 1.4335664335664335, "no_speech_prob": 0.010405578650534153}, {"id": 126, "seek": 58012, "start": 592.44, "end": 598.28, "text": " You can use both features to define homo-iconic data types.", "tokens": [50980, 509, 393, 764, 1293, 4122, 281, 6964, 3655, 78, 12, 299, 11630, 1412, 3467, 13, 51272], "temperature": 0.0, "avg_logprob": -0.2154839038848877, "compression_ratio": 1.4335664335664335, "no_speech_prob": 0.010405578650534153}, {"id": 127, "seek": 61012, "start": 610.6, "end": 612.6, "text": " You can use both features to define homo-iconic data types.", "tokens": [50388, 509, 393, 764, 1293, 4122, 281, 6964, 3655, 78, 12, 299, 11630, 1412, 3467, 13, 50488], "temperature": 0.0, "avg_logprob": -0.3735282637856223, "compression_ratio": 1.38135593220339, "no_speech_prob": 0.06041179224848747}, {"id": 128, "seek": 61012, "start": 630.84, "end": 635.32, "text": " Records are the way to define new data types in Scheme", "tokens": [51400, 31928, 366, 264, 636, 281, 6964, 777, 1412, 3467, 294, 2065, 5729, 51624], "temperature": 0.0, "avg_logprob": -0.3735282637856223, "compression_ratio": 1.38135593220339, "no_speech_prob": 0.06041179224848747}, {"id": 129, "seek": 61012, "start": 635.32, "end": 639.0, "text": " that is defined in the specification on page 27.", "tokens": [51624, 300, 307, 7642, 294, 264, 31256, 322, 3028, 7634, 13, 51808], "temperature": 0.0, "avg_logprob": -0.3735282637856223, "compression_ratio": 1.38135593220339, "no_speech_prob": 0.06041179224848747}, {"id": 130, "seek": 64012, "start": 640.28, "end": 656.28, "text": " You can define syntax extension for this record.", "tokens": [50372, 509, 393, 6964, 28431, 10320, 337, 341, 2136, 13, 51172], "temperature": 0.0, "avg_logprob": -0.36882578242908826, "compression_ratio": 1.1219512195121952, "no_speech_prob": 0.053054749965667725}, {"id": 131, "seek": 64012, "start": 664.6, "end": 667.32, "text": " The third argument to set special indicates", "tokens": [51588, 440, 2636, 6770, 281, 992, 2121, 16203, 51724], "temperature": 0.0, "avg_logprob": -0.36882578242908826, "compression_ratio": 1.1219512195121952, "no_speech_prob": 0.053054749965667725}, {"id": 132, "seek": 66732, "start": 667.88, "end": 671.96, "text": " how the makePerson function should receive the arguments.", "tokens": [50392, 577, 264, 652, 47, 3953, 2445, 820, 4774, 264, 12869, 13, 50596], "temperature": 0.0, "avg_logprob": -0.13685659082924448, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.011938154697418213}, {"id": 133, "seek": 66732, "start": 671.96, "end": 674.5200000000001, "text": " The list or as a normal arguments.", "tokens": [50596, 440, 1329, 420, 382, 257, 2710, 12869, 13, 50724], "temperature": 0.0, "avg_logprob": -0.13685659082924448, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.011938154697418213}, {"id": 134, "seek": 66732, "start": 675.24, "end": 678.9200000000001, "text": " This feature may be removed in the future to simplify the code.", "tokens": [50760, 639, 4111, 815, 312, 7261, 294, 264, 2027, 281, 20460, 264, 3089, 13, 50944], "temperature": 0.0, "avg_logprob": -0.13685659082924448, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.011938154697418213}, {"id": 135, "seek": 66732, "start": 679.5600000000001, "end": 683.32, "text": " The dot notation in the last argument is taken from JavaScript", "tokens": [50976, 440, 5893, 24657, 294, 264, 1036, 6770, 307, 2726, 490, 15778, 51164], "temperature": 0.0, "avg_logprob": -0.13685659082924448, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.011938154697418213}, {"id": 136, "seek": 66732, "start": 683.32, "end": 686.6800000000001, "text": " to simplify interaction with the hosting language.", "tokens": [51164, 281, 20460, 9285, 365, 264, 16058, 2856, 13, 51332], "temperature": 0.0, "avg_logprob": -0.13685659082924448, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.011938154697418213}, {"id": 137, "seek": 66732, "start": 686.6800000000001, "end": 692.6, "text": " Libs is a global object that you can inspect with the dir function inspired by Python.", "tokens": [51332, 15834, 82, 307, 257, 4338, 2657, 300, 291, 393, 15018, 365, 264, 4746, 2445, 7547, 538, 15329, 13, 51628], "temperature": 0.0, "avg_logprob": -0.13685659082924448, "compression_ratio": 1.676056338028169, "no_speech_prob": 0.011938154697418213}, {"id": 138, "seek": 69732, "start": 697.8000000000001, "end": 707.8000000000001, "text": " In the same way, you can access any JavaScript object or a function.", "tokens": [50388, 682, 264, 912, 636, 11, 291, 393, 2105, 604, 15778, 2657, 420, 257, 2445, 13, 50888], "temperature": 0.0, "avg_logprob": -0.40240001678466797, "compression_ratio": 0.9577464788732394, "no_speech_prob": 0.00438552163541317}, {"id": 139, "seek": 70780, "start": 707.8, "end": 724.4399999999999, "text": " By let's go back to our record example.", "tokens": [50364, 3146, 718, 311, 352, 646, 281, 527, 2136, 1365, 13, 51196], "temperature": 0.0, "avg_logprob": -0.22003130010656408, "compression_ratio": 1.2058823529411764, "no_speech_prob": 0.023073194548487663}, {"id": 140, "seek": 70780, "start": 725.4799999999999, "end": 726.68, "text": " A person is a class.", "tokens": [51248, 316, 954, 307, 257, 1508, 13, 51308], "temperature": 0.0, "avg_logprob": -0.22003130010656408, "compression_ratio": 1.2058823529411764, "no_speech_prob": 0.023073194548487663}, {"id": 141, "seek": 70780, "start": 730.8399999999999, "end": 734.76, "text": " And you can create an instance of that class with a new macro.", "tokens": [51516, 400, 291, 393, 1884, 364, 5197, 295, 300, 1508, 365, 257, 777, 18887, 13, 51712], "temperature": 0.0, "avg_logprob": -0.22003130010656408, "compression_ratio": 1.2058823529411764, "no_speech_prob": 0.023073194548487663}, {"id": 142, "seek": 73780, "start": 738.1999999999999, "end": 753.7199999999999, "text": " Or with makePerson function created by Scheme record type.", "tokens": [50384, 1610, 365, 652, 47, 3953, 2445, 2942, 538, 2065, 5729, 2136, 2010, 13, 51160], "temperature": 0.0, "avg_logprob": -0.3018682599067688, "compression_ratio": 1.2115384615384615, "no_speech_prob": 0.0018098674481734633}, {"id": 143, "seek": 73780, "start": 757.9599999999999, "end": 765.7199999999999, "text": " We can also use our syntax extension to create a new person object.", "tokens": [51372, 492, 393, 611, 764, 527, 28431, 10320, 281, 1884, 257, 777, 954, 2657, 13, 51760], "temperature": 0.0, "avg_logprob": -0.3018682599067688, "compression_ratio": 1.2115384615384615, "no_speech_prob": 0.0018098674481734633}, {"id": 144, "seek": 76780, "start": 767.8, "end": 783.7199999999999, "text": " Now let's add a representation of this new data type.", "tokens": [50376, 823, 718, 311, 909, 257, 10290, 295, 341, 777, 1412, 2010, 13, 51160], "temperature": 0.0, "avg_logprob": -0.2904948870340983, "compression_ratio": 0.8833333333333333, "no_speech_prob": 0.007439319510012865}, {"id": 145, "seek": 79780, "start": 797.8, "end": 823.7199999999999, "text": " And now we can evaluate the code and have the same representation.", "tokens": [50400, 400, 586, 321, 393, 13059, 264, 3089, 293, 362, 264, 912, 10290, 13, 51660], "temperature": 0.0, "avg_logprob": -0.11233573406934738, "compression_ratio": 1.0153846153846153, "no_speech_prob": 0.021856285631656647}, {"id": 146, "seek": 82780, "start": 827.8, "end": 840.76, "text": " The queue parameter indicates if the result should be quoted or not.", "tokens": [50364, 440, 18639, 13075, 16203, 498, 264, 1874, 820, 312, 30047, 420, 406, 13, 51012], "temperature": 0.0, "avg_logprob": -0.23685646057128906, "compression_ratio": 1.3125, "no_speech_prob": 0.023949986323714256}, {"id": 147, "seek": 82780, "start": 840.76, "end": 853.7199999999999, "text": " In the wrapper, the strings are quoted because they use Scheme write function.", "tokens": [51012, 682, 264, 46906, 11, 264, 13985, 366, 30047, 570, 436, 764, 2065, 5729, 2464, 2445, 13, 51660], "temperature": 0.0, "avg_logprob": -0.23685646057128906, "compression_ratio": 1.3125, "no_speech_prob": 0.023949986323714256}, {"id": 148, "seek": 85372, "start": 854.6800000000001, "end": 865.64, "text": " But you can use display function that don't use quotations.", "tokens": [50412, 583, 291, 393, 764, 4674, 2445, 300, 500, 380, 764, 9641, 763, 13, 50960], "temperature": 0.0, "avg_logprob": -0.2815408706665039, "compression_ratio": 1.3063063063063063, "no_speech_prob": 0.010582216084003448}, {"id": 149, "seek": 85372, "start": 865.64, "end": 879.64, "text": " But with setRapper you can make representation of the records without the new syntax.", "tokens": [50960, 583, 365, 992, 49, 34456, 291, 393, 652, 10290, 295, 264, 7724, 1553, 264, 777, 28431, 13, 51660], "temperature": 0.0, "avg_logprob": -0.2815408706665039, "compression_ratio": 1.3063063063063063, "no_speech_prob": 0.010582216084003448}, {"id": 150, "seek": 88372, "start": 883.72, "end": 891.64, "text": " And you can use display function to make representation of the records without the new syntax.", "tokens": [50364, 400, 291, 393, 764, 4674, 2445, 281, 652, 10290, 295, 264, 7724, 1553, 264, 777, 28431, 13, 50760], "temperature": 0.0, "avg_logprob": -0.7878822803497314, "compression_ratio": 2.1724137931034484, "no_speech_prob": 0.7447994947433472}, {"id": 151, "seek": 88372, "start": 891.64, "end": 901.64, "text": " And you can use display function to make representation of the records without the new syntax.", "tokens": [50760, 400, 291, 393, 764, 4674, 2445, 281, 652, 10290, 295, 264, 7724, 1553, 264, 777, 28431, 13, 51260], "temperature": 0.0, "avg_logprob": -0.7878822803497314, "compression_ratio": 2.1724137931034484, "no_speech_prob": 0.7447994947433472}, {"id": 152, "seek": 90164, "start": 901.96, "end": 923.48, "text": " With this feature, you can easily serialize and deserialize custom data types.", "tokens": [50380, 2022, 341, 4111, 11, 291, 393, 3612, 17436, 1125, 293, 730, 260, 831, 1125, 2375, 1412, 3467, 13, 51456], "temperature": 0.0, "avg_logprob": -0.32794234969399194, "compression_ratio": 1.0833333333333333, "no_speech_prob": 0.04577285051345825}, {"id": 153, "seek": 92348, "start": 923.48, "end": 927.32, "text": " For instance, when saving in browser local storage.", "tokens": [50364, 1171, 5197, 11, 562, 6816, 294, 11185, 2654, 6725, 13, 50556], "temperature": 0.0, "avg_logprob": -0.3566381014310397, "compression_ratio": 0.8793103448275862, "no_speech_prob": 0.15265344083309174}, {"id": 154, "seek": 95348, "start": 953.48, "end": 974.12, "text": " We use that eval because readReturnsList as data that needs to be evaluated to get the", "tokens": [50364, 492, 764, 300, 1073, 304, 570, 1401, 49, 302, 925, 82, 43, 468, 382, 1412, 300, 2203, 281, 312, 25509, 281, 483, 264, 51396], "temperature": 0.0, "avg_logprob": -0.2775111961364746, "compression_ratio": 1.4692307692307693, "no_speech_prob": 0.031199397519230843}, {"id": 155, "seek": 95348, "start": 974.12, "end": 981.64, "text": " instance of the person object. To get the property of the speaker object, you can use dot special macro.", "tokens": [51396, 5197, 295, 264, 954, 2657, 13, 1407, 483, 264, 4707, 295, 264, 8145, 2657, 11, 291, 393, 764, 5893, 2121, 18887, 13, 51772], "temperature": 0.0, "avg_logprob": -0.2775111961364746, "compression_ratio": 1.4692307692307693, "no_speech_prob": 0.031199397519230843}, {"id": 156, "seek": 98348, "start": 984.2, "end": 989.0, "text": " Or you can use JavaScript dot notation.", "tokens": [50400, 1610, 291, 393, 764, 15778, 5893, 24657, 13, 50640], "temperature": 0.0, "avg_logprob": -0.19303874616269712, "compression_ratio": 1.4563758389261745, "no_speech_prob": 0.00981669221073389}, {"id": 157, "seek": 98348, "start": 993.24, "end": 1000.9200000000001, "text": " The next feature I want to discuss is introspection. You can use upper post function to search the", "tokens": [50852, 440, 958, 4111, 286, 528, 281, 2248, 307, 560, 2635, 19997, 13, 509, 393, 764, 6597, 2183, 2445, 281, 3164, 264, 51236], "temperature": 0.0, "avg_logprob": -0.19303874616269712, "compression_ratio": 1.4563758389261745, "no_speech_prob": 0.00981669221073389}, {"id": 158, "seek": 98348, "start": 1000.9200000000001, "end": 1012.44, "text": " environment. This is a list of functions and macros that match a given string.", "tokens": [51236, 2823, 13, 639, 307, 257, 1329, 295, 6828, 293, 7912, 2635, 300, 2995, 257, 2212, 6798, 13, 51812], "temperature": 0.0, "avg_logprob": -0.19303874616269712, "compression_ratio": 1.4563758389261745, "no_speech_prob": 0.00981669221073389}, {"id": 159, "seek": 101244, "start": 1012.44, "end": 1025.4, "text": " In this case, vector. You can also use regular expressions to make the search more specific.", "tokens": [50364, 682, 341, 1389, 11, 8062, 13, 509, 393, 611, 764, 3890, 15277, 281, 652, 264, 3164, 544, 2685, 13, 51012], "temperature": 0.0, "avg_logprob": -0.21218554869942044, "compression_ratio": 1.0823529411764705, "no_speech_prob": 0.07252021878957748}, {"id": 160, "seek": 102540, "start": 1025.96, "end": 1042.0400000000002, "text": " And this is a list of typed vectors. Each of those constructors have also", "tokens": [50392, 400, 341, 307, 257, 1329, 295, 33941, 18875, 13, 6947, 295, 729, 7690, 830, 362, 611, 51196], "temperature": 0.0, "avg_logprob": -0.23344058990478517, "compression_ratio": 1.0138888888888888, "no_speech_prob": 0.023283472284674644}, {"id": 161, "seek": 104204, "start": 1042.12, "end": 1058.68, "text": " the syntax extension that allow to create those vectors according to scheme specification.", "tokens": [50368, 264, 28431, 10320, 300, 2089, 281, 1884, 729, 18875, 4650, 281, 12232, 31256, 13, 51196], "temperature": 0.0, "avg_logprob": -0.28814218157813665, "compression_ratio": 1.3880597014925373, "no_speech_prob": 0.04992375895380974}, {"id": 162, "seek": 104204, "start": 1058.92, "end": 1066.6, "text": " Each scheme type at vector is in fact JavaScript type at RI. And each of those RIs have its own", "tokens": [51208, 6947, 12232, 2010, 412, 8062, 307, 294, 1186, 15778, 2010, 412, 30474, 13, 400, 1184, 295, 729, 497, 6802, 362, 1080, 1065, 51592], "temperature": 0.0, "avg_logprob": -0.28814218157813665, "compression_ratio": 1.3880597014925373, "no_speech_prob": 0.04992375895380974}, {"id": 163, "seek": 106660, "start": 1066.6, "end": 1072.6799999999998, "text": " representation. So they look like the code that defines them. You can access the documentation", "tokens": [50364, 10290, 13, 407, 436, 574, 411, 264, 3089, 300, 23122, 552, 13, 509, 393, 2105, 264, 14333, 50668], "temperature": 0.0, "avg_logprob": -0.18761678175492721, "compression_ratio": 1.564516129032258, "no_speech_prob": 0.0817810446023941}, {"id": 164, "seek": 106660, "start": 1072.6799999999998, "end": 1080.12, "text": " and the source code of the every function macro and fiber defined by lips. You can access the name,", "tokens": [50668, 293, 264, 4009, 3089, 295, 264, 633, 2445, 18887, 293, 12874, 7642, 538, 10118, 13, 509, 393, 2105, 264, 1315, 11, 51040], "temperature": 0.0, "avg_logprob": -0.18761678175492721, "compression_ratio": 1.564516129032258, "no_speech_prob": 0.0817810446023941}, {"id": 165, "seek": 108012, "start": 1080.28, "end": 1088.76, "text": " the documentation", "tokens": [50372, 264, 14333, 50796], "temperature": 0.0, "avg_logprob": -0.24183867772420248, "compression_ratio": 1.288888888888889, "no_speech_prob": 0.019074635580182076}, {"id": 166, "seek": 108012, "start": 1091.9599999999998, "end": 1099.7199999999998, "text": " and the source code of this function. What's cool about the code is that it's live object that you", "tokens": [50956, 293, 264, 4009, 3089, 295, 341, 2445, 13, 708, 311, 1627, 466, 264, 3089, 307, 300, 309, 311, 1621, 2657, 300, 291, 51344], "temperature": 0.0, "avg_logprob": -0.24183867772420248, "compression_ratio": 1.288888888888889, "no_speech_prob": 0.019074635580182076}, {"id": 167, "seek": 109972, "start": 1099.72, "end": 1111.32, "text": " can modify.", "tokens": [50364, 393, 16927, 13, 50944], "temperature": 0.0, "avg_logprob": -0.28648013653962506, "compression_ratio": 1.0813953488372092, "no_speech_prob": 0.19390517473220825}, {"id": 168, "seek": 109972, "start": 1123.32, "end": 1128.84, "text": " The double underscore syntax is inspired by Python magic properties. You can also", "tokens": [51544, 440, 3834, 37556, 28431, 307, 7547, 538, 15329, 5585, 7221, 13, 509, 393, 611, 51820], "temperature": 0.0, "avg_logprob": -0.28648013653962506, "compression_ratio": 1.0813953488372092, "no_speech_prob": 0.19390517473220825}, {"id": 169, "seek": 112884, "start": 1128.84, "end": 1140.4399999999998, "text": " inspect the internals of other lips objects like symbols", "tokens": [50364, 15018, 264, 2154, 1124, 295, 661, 10118, 6565, 411, 16944, 50944], "temperature": 0.0, "avg_logprob": -0.2810819413926866, "compression_ratio": 1.0149253731343284, "no_speech_prob": 0.046396054327487946}, {"id": 170, "seek": 112884, "start": 1151.0, "end": 1152.4399999999998, "text": " or numbers.", "tokens": [51472, 420, 3547, 13, 51544], "temperature": 0.0, "avg_logprob": -0.2810819413926866, "compression_ratio": 1.0149253731343284, "no_speech_prob": 0.046396054327487946}, {"id": 171, "seek": 115884, "start": 1158.84, "end": 1169.8799999999999, "text": " Lips support full numerical tower. Here's a complex number, but it's not yet fully unit tested,", "tokens": [50364, 441, 2600, 1406, 1577, 29054, 10567, 13, 1692, 311, 257, 3997, 1230, 11, 457, 309, 311, 406, 1939, 4498, 4985, 8246, 11, 50916], "temperature": 0.0, "avg_logprob": -0.2984324952830439, "compression_ratio": 1.304054054054054, "no_speech_prob": 0.021134700626134872}, {"id": 172, "seek": 115884, "start": 1169.8799999999999, "end": 1178.36, "text": " so there are no guarantees that everything works correctly by 100%. You can also inspect the list", "tokens": [50916, 370, 456, 366, 572, 32567, 300, 1203, 1985, 8944, 538, 2319, 6856, 509, 393, 611, 15018, 264, 1329, 51340], "temperature": 0.0, "avg_logprob": -0.2984324952830439, "compression_ratio": 1.304054054054054, "no_speech_prob": 0.021134700626134872}, {"id": 173, "seek": 117836, "start": 1178.36, "end": 1189.9599999999998, "text": " objects.", "tokens": [50364, 6565, 13, 50944], "temperature": 0.0, "avg_logprob": -0.3557474613189697, "compression_ratio": 1.2962962962962963, "no_speech_prob": 0.022365640848875046}, {"id": 174, "seek": 117836, "start": 1192.6799999999998, "end": 1199.56, "text": " The instance of function use JavaScript instance of operator to check if argument is instance of", "tokens": [51080, 440, 5197, 295, 2445, 764, 15778, 5197, 295, 12973, 281, 1520, 498, 6770, 307, 5197, 295, 51424], "temperature": 0.0, "avg_logprob": -0.3557474613189697, "compression_ratio": 1.2962962962962963, "no_speech_prob": 0.022365640848875046}, {"id": 175, "seek": 119956, "start": 1199.56, "end": 1208.36, "text": " the object. Here it check if x is lips list and it written true. You can use the standard", "tokens": [50364, 264, 2657, 13, 1692, 309, 1520, 498, 2031, 307, 10118, 1329, 293, 309, 3720, 2074, 13, 509, 393, 764, 264, 3832, 50804], "temperature": 0.0, "avg_logprob": -0.18569965111581901, "compression_ratio": 1.330188679245283, "no_speech_prob": 0.015848983079195023}, {"id": 176, "seek": 119956, "start": 1208.36, "end": 1211.1599999999999, "text": " list function to get the third element of the list.", "tokens": [50804, 1329, 2445, 281, 483, 264, 2636, 4478, 295, 264, 1329, 13, 50944], "temperature": 0.0, "avg_logprob": -0.18569965111581901, "compression_ratio": 1.330188679245283, "no_speech_prob": 0.015848983079195023}, {"id": 177, "seek": 121116, "start": 1211.4, "end": 1226.76, "text": " But you can also access internal pair objects defined by lips.", "tokens": [50376, 583, 291, 393, 611, 2105, 6920, 6119, 6565, 7642, 538, 10118, 13, 51144], "temperature": 0.0, "avg_logprob": -0.2875620722770691, "compression_ratio": 0.96875, "no_speech_prob": 0.04626278579235077}, {"id": 178, "seek": 122676, "start": 1226.76, "end": 1244.76, "text": " The proposed function that I've showed a few moments ago allows to search the environment,", "tokens": [50364, 440, 10348, 2445, 300, 286, 600, 4712, 257, 1326, 6065, 2057, 4045, 281, 3164, 264, 2823, 11, 51264], "temperature": 0.0, "avg_logprob": -0.2194748640060425, "compression_ratio": 1.3656716417910448, "no_speech_prob": 0.023434067144989967}, {"id": 179, "seek": 122676, "start": 1245.56, "end": 1251.64, "text": " but in lips you can also access environment objects themselves and do cool things with them.", "tokens": [51304, 457, 294, 10118, 291, 393, 611, 2105, 2823, 6565, 2969, 293, 360, 1627, 721, 365, 552, 13, 51608], "temperature": 0.0, "avg_logprob": -0.2194748640060425, "compression_ratio": 1.3656716417910448, "no_speech_prob": 0.023434067144989967}, {"id": 180, "seek": 125164, "start": 1251.88, "end": 1261.24, "text": " You can inspect them.", "tokens": [50376, 509, 393, 15018, 552, 13, 50844], "temperature": 0.0, "avg_logprob": -0.42928728690514195, "compression_ratio": 1.1875, "no_speech_prob": 0.04533176124095917}, {"id": 181, "seek": 125164, "start": 1265.88, "end": 1273.24, "text": " As you can see there is double underscore nth property that you can read.", "tokens": [51076, 1018, 291, 393, 536, 456, 307, 3834, 37556, 297, 392, 4707, 300, 291, 393, 1401, 13, 51444], "temperature": 0.0, "avg_logprob": -0.42928728690514195, "compression_ratio": 1.1875, "no_speech_prob": 0.04533176124095917}, {"id": 182, "seek": 128164, "start": 1281.88, "end": 1289.88, "text": " Object keys is a JavaScript function that returns r i of strings, so it's represented as a scheme", "tokens": [50376, 24753, 9317, 307, 257, 15778, 2445, 300, 11247, 367, 741, 295, 13985, 11, 370, 309, 311, 10379, 382, 257, 12232, 50776], "temperature": 0.0, "avg_logprob": -0.20190932832915207, "compression_ratio": 1.4406779661016949, "no_speech_prob": 0.006750112399458885}, {"id": 183, "seek": 128164, "start": 1289.88, "end": 1297.24, "text": " vector. Those are all objects defined inside the repo, including lips internals. You can see", "tokens": [50776, 8062, 13, 3950, 366, 439, 6565, 7642, 1854, 264, 49040, 11, 3009, 10118, 2154, 1124, 13, 509, 393, 536, 51144], "temperature": 0.0, "avg_logprob": -0.20190932832915207, "compression_ratio": 1.4406779661016949, "no_speech_prob": 0.006750112399458885}, {"id": 184, "seek": 128164, "start": 1297.24, "end": 1303.24, "text": " our person class and you can access it using environment object.", "tokens": [51144, 527, 954, 1508, 293, 291, 393, 2105, 309, 1228, 2823, 2657, 13, 51444], "temperature": 0.0, "avg_logprob": -0.20190932832915207, "compression_ratio": 1.4406779661016949, "no_speech_prob": 0.006750112399458885}, {"id": 185, "seek": 134164, "start": 1342.0400000000002, "end": 1350.0400000000002, "text": " Make person was our representation of the person instance using set wrapper.", "tokens": [50384, 4387, 954, 390, 527, 10290, 295, 264, 954, 5197, 1228, 992, 46906, 13, 50784], "temperature": 0.0, "avg_logprob": -0.2770158350467682, "compression_ratio": 1.3583333333333334, "no_speech_prob": 0.006302890367805958}, {"id": 186, "seek": 134164, "start": 1350.0400000000002, "end": 1356.0400000000002, "text": " Inside the environment object there is also another double underscore property parent,", "tokens": [50784, 15123, 264, 2823, 2657, 456, 307, 611, 1071, 3834, 37556, 4707, 2596, 11, 51084], "temperature": 0.0, "avg_logprob": -0.2770158350467682, "compression_ratio": 1.3583333333333334, "no_speech_prob": 0.006302890367805958}, {"id": 187, "seek": 135604, "start": 1356.04, "end": 1362.44, "text": " which allows you to access a lexical scope time.", "tokens": [50368, 597, 4045, 291, 281, 2105, 257, 476, 87, 804, 11923, 565, 13, 50684], "temperature": 0.0, "avg_logprob": -0.3981723149617513, "compression_ratio": 0.9056603773584906, "no_speech_prob": 0.1591280847787857}, {"id": 188, "seek": 138604, "start": 1386.04, "end": 1406.44, "text": " You can access both x fibers from the scope 10 inside a one expression.", "tokens": [50392, 509, 393, 2105, 1293, 2031, 25252, 490, 264, 11923, 1266, 1854, 257, 472, 6114, 13, 51384], "temperature": 0.0, "avg_logprob": -0.3029782242245144, "compression_ratio": 1.0, "no_speech_prob": 0.02223503403365612}, {"id": 189, "seek": 141604, "start": 1416.04, "end": 1422.44, "text": " You can also access both x fibers from the scope 10.", "tokens": [50364, 509, 393, 611, 2105, 1293, 2031, 25252, 490, 264, 11923, 1266, 13, 50684], "temperature": 0.0, "avg_logprob": -0.9970571517944335, "compression_ratio": 0.8666666666666667, "no_speech_prob": 0.6458223462104797}, {"id": 190, "seek": 144604, "start": 1446.84, "end": 1456.44, "text": " You can also modify the scope inside the chain.", "tokens": [50404, 509, 393, 611, 16927, 264, 11923, 1854, 264, 5021, 13, 50884], "temperature": 0.0, "avg_logprob": -0.16259724753243582, "compression_ratio": 0.9038461538461539, "no_speech_prob": 0.029801616445183754}, {"id": 191, "seek": 145644, "start": 1456.6000000000001, "end": 1480.8400000000001, "text": " Set is a generic macro that allows to modify any JavaScript object, not only lips internals.", "tokens": [50372, 8928, 307, 257, 19577, 18887, 300, 4045, 281, 16927, 604, 15778, 2657, 11, 406, 787, 10118, 2154, 1124, 13, 51584], "temperature": 0.0, "avg_logprob": -0.24584314097528873, "compression_ratio": 1.0952380952380953, "no_speech_prob": 0.010556547902524471}, {"id": 192, "seek": 148084, "start": 1481.3999999999999, "end": 1485.72, "text": " Another feature of lips is that you can act as stack frames of function calls.", "tokens": [50392, 3996, 4111, 295, 10118, 307, 300, 291, 393, 605, 382, 8630, 12083, 295, 2445, 5498, 13, 50608], "temperature": 0.0, "avg_logprob": -0.1787304570597987, "compression_ratio": 1.233644859813084, "no_speech_prob": 0.022438403218984604}, {"id": 193, "seek": 148084, "start": 1487.0, "end": 1490.6799999999998, "text": " They are also environment objects inspired by the air", "tokens": [50672, 814, 366, 611, 2823, 6565, 7547, 538, 264, 1988, 50856], "temperature": 0.0, "avg_logprob": -0.1787304570597987, "compression_ratio": 1.233644859813084, "no_speech_prob": 0.022438403218984604}, {"id": 194, "seek": 149068, "start": 1490.68, "end": 1495.3200000000002, "text": " programming language that has a lot of lips under the hood.", "tokens": [50364, 9410, 2856, 300, 575, 257, 688, 295, 10118, 833, 264, 13376, 13, 50596], "temperature": 0.0, "avg_logprob": -0.34805533091227214, "compression_ratio": 0.9672131147540983, "no_speech_prob": 0.27063482999801636}, {"id": 195, "seek": 155068, "start": 1550.68, "end": 1557.88, "text": " Here the function test can modify the scope outside the function call.", "tokens": [50364, 1692, 264, 2445, 1500, 393, 16927, 264, 11923, 2380, 264, 2445, 818, 13, 50724], "temperature": 0.0, "avg_logprob": -0.15078720056785727, "compression_ratio": 1.7094594594594594, "no_speech_prob": 0.0028629405423998833}, {"id": 196, "seek": 155068, "start": 1557.88, "end": 1564.28, "text": " Another function similar to parent frame is plural parent frames, which returns a list", "tokens": [50724, 3996, 2445, 2531, 281, 2596, 3920, 307, 25377, 2596, 12083, 11, 597, 11247, 257, 1329, 51044], "temperature": 0.0, "avg_logprob": -0.15078720056785727, "compression_ratio": 1.7094594594594594, "no_speech_prob": 0.0028629405423998833}, {"id": 197, "seek": 155068, "start": 1564.28, "end": 1572.04, "text": " of stack frames. With both parent frames and underscore code access you can modify the function", "tokens": [51044, 295, 8630, 12083, 13, 2022, 1293, 2596, 12083, 293, 37556, 3089, 2105, 291, 393, 16927, 264, 2445, 51432], "temperature": 0.0, "avg_logprob": -0.15078720056785727, "compression_ratio": 1.7094594594594594, "no_speech_prob": 0.0028629405423998833}, {"id": 198, "seek": 157204, "start": 1572.04, "end": 1576.6, "text": " that call a given function anywhere inside the call stack chain.", "tokens": [50364, 300, 818, 257, 2212, 2445, 4992, 1854, 264, 818, 8630, 5021, 13, 50592], "temperature": 0.0, "avg_logprob": -0.3813514073689779, "compression_ratio": 1.0, "no_speech_prob": 0.042721498757600784}, {"id": 199, "seek": 160204, "start": 1602.68, "end": 1627.24, "text": " The long arrow is a macro for invoking methods and the cally is lips object similar to", "tokens": [50396, 440, 938, 11610, 307, 257, 18887, 337, 1048, 5953, 7150, 293, 264, 818, 88, 307, 10118, 2657, 2531, 281, 51624], "temperature": 0.0, "avg_logprob": -0.3211682361105214, "compression_ratio": 1.1168831168831168, "no_speech_prob": 0.08332894742488861}, {"id": 200, "seek": 162724, "start": 1627.32, "end": 1633.16, "text": " JavaScript object with the same name. The long arrow macro is a convenient method", "tokens": [50368, 15778, 2657, 365, 264, 912, 1315, 13, 440, 938, 11610, 18887, 307, 257, 10851, 3170, 50660], "temperature": 0.0, "avg_logprob": -0.23750315393720353, "compression_ratio": 1.2040816326530612, "no_speech_prob": 0.07614343613386154}, {"id": 201, "seek": 162724, "start": 1633.16, "end": 1635.72, "text": " to create the chain of method calls.", "tokens": [50660, 281, 1884, 264, 5021, 295, 3170, 5498, 13, 50788], "temperature": 0.0, "avg_logprob": -0.23750315393720353, "compression_ratio": 1.2040816326530612, "no_speech_prob": 0.07614343613386154}, {"id": 202, "seek": 165724, "start": 1657.8, "end": 1667.24, "text": " This code demonstrates another fundamental feature of lips,", "tokens": [50392, 639, 3089, 31034, 1071, 8088, 4111, 295, 10118, 11, 50864], "temperature": 0.0, "avg_logprob": -0.16057470978283492, "compression_ratio": 1.5384615384615385, "no_speech_prob": 0.0053384569473564625}, {"id": 203, "seek": 165724, "start": 1668.04, "end": 1673.16, "text": " where everything is automatically assigned away by default when needed.", "tokens": [50904, 689, 1203, 307, 6772, 13279, 1314, 538, 7576, 562, 2978, 13, 51160], "temperature": 0.0, "avg_logprob": -0.16057470978283492, "compression_ratio": 1.5384615384615385, "no_speech_prob": 0.0053384569473564625}, {"id": 204, "seek": 165724, "start": 1673.16, "end": 1679.72, "text": " Fetch is a javascript function that returns a promise which results to a resource object.", "tokens": [51160, 479, 7858, 307, 257, 361, 37331, 5944, 2445, 300, 11247, 257, 6228, 597, 3542, 281, 257, 7684, 2657, 13, 51488], "temperature": 0.0, "avg_logprob": -0.16057470978283492, "compression_ratio": 1.5384615384615385, "no_speech_prob": 0.0053384569473564625}, {"id": 205, "seek": 165724, "start": 1679.72, "end": 1684.1200000000001, "text": " That object has a text method that also returns a promise.", "tokens": [51488, 663, 2657, 575, 257, 2487, 3170, 300, 611, 11247, 257, 6228, 13, 51708], "temperature": 0.0, "avg_logprob": -0.16057470978283492, "compression_ratio": 1.5384615384615385, "no_speech_prob": 0.0053384569473564625}, {"id": 206, "seek": 168412, "start": 1684.12, "end": 1688.9199999999998, "text": " Here we can skip them which makes the code simpler than the javascript equivalent.", "tokens": [50364, 1692, 321, 393, 10023, 552, 597, 1669, 264, 3089, 18587, 813, 264, 361, 37331, 5944, 10344, 13, 50604], "temperature": 0.0, "avg_logprob": -0.1362130964124525, "compression_ratio": 1.5804878048780489, "no_speech_prob": 0.020570315420627594}, {"id": 207, "seek": 168412, "start": 1689.4799999999998, "end": 1694.76, "text": " The match in the code is a string method and the number one returns first group from the", "tokens": [50632, 440, 2995, 294, 264, 3089, 307, 257, 6798, 3170, 293, 264, 1230, 472, 11247, 700, 1594, 490, 264, 50896], "temperature": 0.0, "avg_logprob": -0.1362130964124525, "compression_ratio": 1.5804878048780489, "no_speech_prob": 0.020570315420627594}, {"id": 208, "seek": 168412, "start": 1694.76, "end": 1700.4399999999998, "text": " regular expression. The whole expression returns the main header of the lips website,", "tokens": [50896, 3890, 6114, 13, 440, 1379, 6114, 11247, 264, 2135, 23117, 295, 264, 10118, 3144, 11, 51180], "temperature": 0.0, "avg_logprob": -0.1362130964124525, "compression_ratio": 1.5804878048780489, "no_speech_prob": 0.020570315420627594}, {"id": 209, "seek": 168412, "start": 1700.4399999999998, "end": 1704.84, "text": " but when needed you can quote the promise and use it as an object.", "tokens": [51180, 457, 562, 2978, 291, 393, 6513, 264, 6228, 293, 764, 309, 382, 364, 2657, 13, 51400], "temperature": 0.0, "avg_logprob": -0.1362130964124525, "compression_ratio": 1.5804878048780489, "no_speech_prob": 0.020570315420627594}, {"id": 210, "seek": 171412, "start": 1714.12, "end": 1715.5, "text": " you", "tokens": [50408, 291, 50433], "temperature": 0.0, "avg_logprob": -0.8894014954566956, "compression_ratio": 0.2727272727272727, "no_speech_prob": 0.9427703022956848}, {"id": 211, "seek": 174412, "start": 1744.84, "end": 1755.7199999999998, "text": " Now let's back to our presentation for a final thought.", "tokens": [50400, 823, 718, 311, 646, 281, 527, 5860, 337, 257, 2572, 1194, 13, 50944], "temperature": 0.0, "avg_logprob": -0.1545790639416925, "compression_ratio": 1.4458598726114649, "no_speech_prob": 0.010367874056100845}, {"id": 212, "seek": 174412, "start": 1757.56, "end": 1763.6399999999999, "text": " As you was able to see from the demo, lips is pretty flexible and powerful,", "tokens": [51036, 1018, 291, 390, 1075, 281, 536, 490, 264, 10723, 11, 10118, 307, 1238, 11358, 293, 4005, 11, 51340], "temperature": 0.0, "avg_logprob": -0.1545790639416925, "compression_ratio": 1.4458598726114649, "no_speech_prob": 0.010367874056100845}, {"id": 213, "seek": 174412, "start": 1763.6399999999999, "end": 1770.84, "text": " but it has its limitations. One of the limitations is that macro are on time. There is no macro", "tokens": [51340, 457, 309, 575, 1080, 15705, 13, 1485, 295, 264, 15705, 307, 300, 18887, 366, 322, 565, 13, 821, 307, 572, 18887, 51700], "temperature": 0.0, "avg_logprob": -0.1545790639416925, "compression_ratio": 1.4458598726114649, "no_speech_prob": 0.010367874056100845}, {"id": 214, "seek": 177084, "start": 1770.9199999999998, "end": 1777.6399999999999, "text": " expansion time. There are also some performance issues. One of the reasons for it may be the lack", "tokens": [50368, 11260, 565, 13, 821, 366, 611, 512, 3389, 2663, 13, 1485, 295, 264, 4112, 337, 309, 815, 312, 264, 5011, 50704], "temperature": 0.0, "avg_logprob": -0.11033276149204799, "compression_ratio": 1.6288209606986899, "no_speech_prob": 0.07433777302503586}, {"id": 215, "seek": 177084, "start": 1777.6399999999999, "end": 1783.72, "text": " of macro expansion time, but you can fix those issues by embedding javascript code in tight", "tokens": [50704, 295, 18887, 11260, 565, 11, 457, 291, 393, 3191, 729, 2663, 538, 12240, 3584, 361, 37331, 5944, 3089, 294, 4524, 51008], "temperature": 0.0, "avg_logprob": -0.11033276149204799, "compression_ratio": 1.6288209606986899, "no_speech_prob": 0.07433777302503586}, {"id": 216, "seek": 177084, "start": 1783.72, "end": 1790.1999999999998, "text": " lips. The most important things that are missing are first call continuations and tail call", "tokens": [51008, 10118, 13, 440, 881, 1021, 721, 300, 366, 5361, 366, 700, 818, 2993, 763, 293, 6838, 818, 51332], "temperature": 0.0, "avg_logprob": -0.11033276149204799, "compression_ratio": 1.6288209606986899, "no_speech_prob": 0.07433777302503586}, {"id": 217, "seek": 177084, "start": 1790.1999999999998, "end": 1797.3999999999999, "text": " optimizations and also the syntax rules scheme hygienic macro system is not working exactly", "tokens": [51332, 5028, 14455, 293, 611, 264, 28431, 4474, 12232, 24470, 1053, 299, 18887, 1185, 307, 406, 1364, 2293, 51692], "temperature": 0.0, "avg_logprob": -0.11033276149204799, "compression_ratio": 1.6288209606986899, "no_speech_prob": 0.07433777302503586}, {"id": 218, "seek": 179740, "start": 1797.4, "end": 1803.96, "text": " as it should. All this can be improved in the future. Thank you for listening to my presentation.", "tokens": [50364, 382, 309, 820, 13, 1057, 341, 393, 312, 9689, 294, 264, 2027, 13, 1044, 291, 337, 4764, 281, 452, 5860, 13, 50692], "temperature": 0.0, "avg_logprob": -0.18086296319961548, "compression_ratio": 1.1149425287356323, "no_speech_prob": 0.08660754561424255}], "language": "en"}