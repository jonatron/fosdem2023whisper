{"text": " Okay. Thank you. It's great to be here for the first time. Really in person. I really feel. Yes. You're a regular feature, actually. Oh, so far only online. It was so sad always, always in my small little room. So here I am. Want to talk about fusion again like the last years. What I want to talk about here is about algebraic effects and types and what has changed in the last year in that respect in the fusion language. Short background to me. I did a lot in compilers, mostly in the Java area in the past for about 30 years. And also did quite a bit on garbage collection. So I enjoyed the previous talks here quite a lot. But now to the fusion language, which is what I'm currently working on. And the main idea behind the fusion language is that we see more and more language getting more and more overloaded with more and more features and concepts and new things being introduced. While in fusion, we try to reduce this to one single concept, which is a fusion feature. And that's basically an abstraction for things like classes, methods, interfaces, and so on. And instead of having the developer to choose what to write, whether to write a method or a class or so, have the compiler have the implementation, make these decisions, what we actually need to implement those features. And also we see that more and more systems become safe to critical. So we need a simple language and we need tools to analyze that simple language to ensure the correctness. So that's what we keep in mind when we work on fusion. Fusion is on GitHub. I don't give any tutorial in the language or so in this talk. This is all online, so I will just basically throw you in the water and let you learn to swim bringing fusion code in this talk. But I hope, I think you will do fine. Fusion is backed by a small company, Tokiba, and now to this talk. No, before I forget, for those who only came for the fusion stickers, I have some here, so you can maybe give them around. If you ever once can take one. So now, what I want to talk about here is basically three points. I start with explaining what algebraic effects are and how they are implemented or how they are used in fusion. Then I want to talk a bit about types and how types can be used as first class features and type values can be used in fusion. And then I bring these two together because that brings a big advantage when working with algebraic effects. So, what do we need effects for? Fusion, in fusion, a feature is a pure function, so there is no side effects, no mutation of data by default. And algebraic effects are used in fusion now to model all the non-functional effects like state changes, IO, any threat communication or mechanisms like exceptions. So, let me first define what are algebraic effects. And algebraic effect is actually a set of operations. You could think of operations like reading data, so performing some IO, getting the time or doing something like a panic, so causing an error in the application to stop or logging some data somewhere. Typically, these operations in an algebraic effect model some non-functional aspect that is kind of orthogonal to the actual computation of your function. These operations have basically two things that they can mainly do. They could either resume and produce a result like reading that is successful or they can abort which is like throwing an exception, you just get out of that, you don't get anything from this. And an effect can be implemented by different effect handlers. So, one effect type could have different implementations. And to run code that uses an effect, this code has to be executed while a corresponding handler for that effect is installed. Now, the effects allow static analysis of the code that we can analyze what effects any feature has. And we require that for all library code, the full set of effects is documented in the signature of those features. So, if effects that are not presented are unexpected are used, that would cause a compile time error. I start with a small example of a hello world, a hello world feature. We use this exclamation mark syntax to mark that this code actually uses an effect and the effect or requires an effect. And that is I O dot out in this case because the library function say requires that effect. And I run this code now, of course it prints hello world. And if I analyze the code for the effects that it has, I see that I O dot out is an effect required by this small example. Now, I want to run the same code, the hello world hasn't changed, using my own handler. So, I have defined a handler here, which is a feature inherited thing from can print and it really finds the print operation to print to I O error instead and to replace the exclamation mark by many exclamation marks. And now to run this, we need to first install this handler as the I O out handler. The I O out here is just a convenient function that installs the first handler and executes the code given in the lambda as a second argument. And when I run this now, of course, I see the print out is the modified string because we replace the exclamation mark here. And if I analyze this for effects, I now see this no longer depends on the I O out effect, but the I O error because we have kind of diverted the code to depend on the other effect. We could also implement a handler that doesn't do anything, then the hello world executed in that environment would not require any effect at all anymore. That much to effects. Now, let me talk about types as first class features in fusion. To make it easier for you to understand what's happening, I give first an example of generics in Java, where I have a generic method here that takes an argument A of any generic type T and prints out the value. Doing that in fusion, we have type parameters, which are actually at the same level as value parameters. So we have a function with two arguments, T, which is a type, and A, which is a value of that type. And this is not just syntactic sugar that this looks the same, but it's also internally the type parameters of our argument features just as the arguments itself. Of course, we can now, oops, I went a bit further than I wanted. We can now call this function with two different type parameters and two different value arguments and print these two values. That's pretty standard for generic for type parametric functions. Fusion uses a lot of type inferencing. So in such a case where the types are obvious from the arguments, they don't need to be given. So we have the rule that type parameters always have to precede the value arguments and they can be left out if they can be inferred. So the code can be written like this. Then next, we could constrain type parameters. So we could say in this case, we want a type that must be numeric. And if we have such a constraint, we could use operations that are only provided by the type, like the plus operator that is defined on numerics. And if we run this now, we can also output the double value, still pretty standard for generics. But what we can also do is we can use the type parameter itself and call features that the type parameter provides, like every type provides its name. So we can run this code and print those names. And we can go even further with that. And I want to show you in an implementation of a feature that calculates the sum of a list of some numeric elements. The implementation of that feature would distinguish the case of an empty list or a list consisting out of a head and a tail, where we can recursively calculate the sum. The question now is what do we do in the case of the empty list? In language like Java, we could have no way to produce any value here. What we can do is we can call a feature that is defined in the type numeric and redefined by all concrete implementations to provide the zero value for that actual numeric type. So numeric itself is defined as a feature with its corresponding type defining zero as an instance of exactly this type. And then something like an i32, 32-bit integer, defines an implementation of type.zero to return the integer zero. And we can now use that function to print the sums of different lists here. And when I do this, we have a list of floating point values, a list of fractions. We have an empty list of floating point values and an empty list of fractions, so we get the corresponding zero values from the types of the corresponding types. So that much to types. And now coming back to effects, I want to use these types and type parameters to give names to effects or to reference user-defined effects. And I'll give you an example using a code that creates a linked ring, so a ring structure. To create a ring structure with references, you need mutation because at some point you have to close the ring. So that code is mutable, it's not easily pure. Then, so we will see that this depends on the mutate effect. And then we want to reimplement this or extend this to use local mutable state or local mutability to make this function pure. So I start by code to create a ring that uses the mutate effect. You don't need to understand the whole code, the important thing is that every element in that ring has a pointer to the next element and there's a reference to the very last, because if you extend the ring, you have to update the next of the last element in the ring to point to the newly added element in the ring. And here, for next, we create a mutable value, which is done by a base library function mut, which used the mutate effect. And to update the next, we use this arrow operation to update that. Now we create a small demo, we create a ring with elements ABC and then we run 10 times through the ring to print them. So we do that, we see that it circles around in that ring. But if you now analyze this for effects, what we see is that we have a mutate effect used by the code. There's lots of other effects as well, the out effect, because we print something, but there's also error handling in the library code that shows up here. But what I'm interested in is here is now, this has the mutate effect, because the code mutates the next element while building the ring. And now we want to get rid of this mutability in the code, I know, I think I'll make it in five minutes. And the way to do this is we define a local instance of the mutate effect. And to do that, I first need a bit more space in the code. And I'll add a type parameter M of type mutate to the code here and also pass this on on calls and on types of ring used in here. And now when we create an instance of such a mutable reference to the next element, instead, we take the instance of the mutate effect M, which we got as a parameter here, from the current environment. The syntax we use in fusion there is type dot n, which is the effect from the environment, plus dot and the operation new create a new mutable variable. And now we can define our own mutate effect. Here mm is the local mutate effect defined here, which is just inheriting from mutate. And is nothing follows after the is, so it doesn't do anything special, it is just a new sub feature in inheriting from mutate. So it basically only has the purpose of giving a new name to this is my local mutate here. And now we can pass this sub instance of mutate or the sub type of mutate to the ring here, which means that all the mutable values that are created are created locally to the mm to our own mutate effect. Now we still have to create this effect and execute the code within the context of this effect, and this happens in the bottom here. So we create an instance of mm and use it to execute the demo code. And that means that the m dot f nth call here will then take the instance of mm from the current environment to create the new mutable value. And when we run the demo, the same output, if we analyze it for effects now, we see it's the same effect. Apart from the mutate is gone, because the mutate is completely local here. So we can create code that locally to perform some calculation creates mutable data and mutates data structures. But the result is a pure function anyway, because the mutation is only done locally. So I'm coming to the end. The fusion of status is still under developing. It's a very experimental language, but the language definition is slowly getting more stable. There's still a lot of work on the base library that is ongoing. The current implementation has two back ends. One is a very slow interpreter running on the JVM, and the other is a C back end, which also used the beam demo visor garbage collector, which we just learned about as a garbage collector right now, but I would like to have a precise garbage collector and add a lot there as well. And basic analysis tools like you've seen for the effects here are available. And yes, those who remember Ellie might wonder who is disturbing me now from while I'm working on this is Felix. That's it. That's coming to the end. So maybe one more sentence. I hope I could show you that algebraic effects and types as first class features are something that complements one another pretty well. It helps to create code, then encapsulates non-functional effects, and yeah, that makes it possible to work with this and work even with code that is not pure, but to manage this in a nice way. You find some links here to resources related to fusion. We are happy for everyone who gets involved. Please have a look. Join us. We are a small team currently from three working on this. We can, there should be more. Yeah. Thank you very much. Can I pick? Yeah. You think you were first? So earlier you said that a particular type can influence numeric, that all terminology you used, but is it a numeric interface? And then you were able to say A plus B. If you didn't say that influence numeric, what would happen if you tried to compile that program? The question was if a particular type would not implement numeric, and you would use the plus in there, what would happen then? You would get a compile time error. It's completely strict typing. So if you call a function that requires a numeric type parameter, and you call it with say a string, what string happens to have a plus, but not the numeric plus, you will get an error that type, the actual type parameter is not compatible to the type constrained in the call feature, so that will not be an example. You were converting the value to string in order to print it. Is the string operation implied to be present for every value? There's a two string operation in our any, which is the parent of any feature. So a two string is always available, yes. It's not very helpful if you don't define anything, because you just, it's a second, the next speaker setup, which I'm contributing to the language called NIM, which also have my effect types, and ad hoc, more important, generic call. One problem that I've seen in combining these features is that when you have generic call, you often don't, the concrete instantiations may trigger different effects. So how do you approach this, and syntactically or semi-events, semi-table language? The question was that actual code can actually trigger all sorts of different actual effects at runtime, so you could have, one example I think of, you could have a function converting an object to a string that maybe performs some logging, and some code printing that value would not expect that. My answer to that is, that must be part of the static analysis. We need to analyze the whole application and see what is happening there. Library functions can do this to a certain extent, but they cannot predict if you have a dynamic value coming in, what the actual type will be, so we need a whole program analysis in the end there. Do we have time for one more? Yeah, another approach to have pure functional function and side effects is, like Haskell can do this. So I find it really interesting that with this language, it's possible to get rid of the effect of the algebraic effect. Is that like a decision, or do other languages like Unison, for example, also use algebraic effects, also have these features, and isn't that also like kind of, is it like on purpose, or is it like, what are the pros and cons of it? So the question was, in Haskell you have monads, which have a similar role like the effects, but you have them always explicitly, you have to carry them around and mark them. And the answer is here, this is actually, it's on purpose, we don't want to have the hassle of wrapping everything into a monad and carrying it around all the time. So the idea is to get rid of this as much as possible without losing the information you get from the effects. Time's up. Okay. Thank you for all the questions.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.44, "text": " Okay. Thank you. It's great to be here for the first time. Really in person. I really", "tokens": [1033, 13, 1044, 291, 13, 467, 311, 869, 281, 312, 510, 337, 264, 700, 565, 13, 4083, 294, 954, 13, 286, 534], "temperature": 0.0, "avg_logprob": -0.3013955448450667, "compression_ratio": 1.54, "no_speech_prob": 0.3253483474254608}, {"id": 1, "seek": 0, "start": 11.44, "end": 12.44, "text": " feel.", "tokens": [841, 13], "temperature": 0.0, "avg_logprob": -0.3013955448450667, "compression_ratio": 1.54, "no_speech_prob": 0.3253483474254608}, {"id": 2, "seek": 0, "start": 12.44, "end": 15.76, "text": " Yes. You're a regular feature, actually.", "tokens": [1079, 13, 509, 434, 257, 3890, 4111, 11, 767, 13], "temperature": 0.0, "avg_logprob": -0.3013955448450667, "compression_ratio": 1.54, "no_speech_prob": 0.3253483474254608}, {"id": 3, "seek": 0, "start": 15.76, "end": 21.080000000000002, "text": " Oh, so far only online. It was so sad always, always in my small little room. So here I", "tokens": [876, 11, 370, 1400, 787, 2950, 13, 467, 390, 370, 4227, 1009, 11, 1009, 294, 452, 1359, 707, 1808, 13, 407, 510, 286], "temperature": 0.0, "avg_logprob": -0.3013955448450667, "compression_ratio": 1.54, "no_speech_prob": 0.3253483474254608}, {"id": 4, "seek": 0, "start": 21.080000000000002, "end": 27.92, "text": " am. Want to talk about fusion again like the last years. What I want to talk about here", "tokens": [669, 13, 11773, 281, 751, 466, 23100, 797, 411, 264, 1036, 924, 13, 708, 286, 528, 281, 751, 466, 510], "temperature": 0.0, "avg_logprob": -0.3013955448450667, "compression_ratio": 1.54, "no_speech_prob": 0.3253483474254608}, {"id": 5, "seek": 2792, "start": 27.92, "end": 33.1, "text": " is about algebraic effects and types and what has changed in the last year in that respect", "tokens": [307, 466, 21989, 299, 5065, 293, 3467, 293, 437, 575, 3105, 294, 264, 1036, 1064, 294, 300, 3104], "temperature": 0.0, "avg_logprob": -0.18830367956268654, "compression_ratio": 1.6108597285067874, "no_speech_prob": 3.266318890382536e-05}, {"id": 6, "seek": 2792, "start": 33.1, "end": 40.08, "text": " in the fusion language. Short background to me. I did a lot in compilers, mostly in the", "tokens": [294, 264, 23100, 2856, 13, 16881, 3678, 281, 385, 13, 286, 630, 257, 688, 294, 715, 388, 433, 11, 5240, 294, 264], "temperature": 0.0, "avg_logprob": -0.18830367956268654, "compression_ratio": 1.6108597285067874, "no_speech_prob": 3.266318890382536e-05}, {"id": 7, "seek": 2792, "start": 40.08, "end": 49.32000000000001, "text": " Java area in the past for about 30 years. And also did quite a bit on garbage collection.", "tokens": [10745, 1859, 294, 264, 1791, 337, 466, 2217, 924, 13, 400, 611, 630, 1596, 257, 857, 322, 14150, 5765, 13], "temperature": 0.0, "avg_logprob": -0.18830367956268654, "compression_ratio": 1.6108597285067874, "no_speech_prob": 3.266318890382536e-05}, {"id": 8, "seek": 2792, "start": 49.32000000000001, "end": 56.44, "text": " So I enjoyed the previous talks here quite a lot. But now to the fusion language, which", "tokens": [407, 286, 4626, 264, 3894, 6686, 510, 1596, 257, 688, 13, 583, 586, 281, 264, 23100, 2856, 11, 597], "temperature": 0.0, "avg_logprob": -0.18830367956268654, "compression_ratio": 1.6108597285067874, "no_speech_prob": 3.266318890382536e-05}, {"id": 9, "seek": 5644, "start": 56.44, "end": 63.12, "text": " is what I'm currently working on. And the main idea behind the fusion language is that", "tokens": [307, 437, 286, 478, 4362, 1364, 322, 13, 400, 264, 2135, 1558, 2261, 264, 23100, 2856, 307, 300], "temperature": 0.0, "avg_logprob": -0.13049916867856626, "compression_ratio": 1.7427184466019416, "no_speech_prob": 2.0134844817221165e-05}, {"id": 10, "seek": 5644, "start": 63.12, "end": 67.75999999999999, "text": " we see more and more language getting more and more overloaded with more and more features", "tokens": [321, 536, 544, 293, 544, 2856, 1242, 544, 293, 544, 28777, 292, 365, 544, 293, 544, 4122], "temperature": 0.0, "avg_logprob": -0.13049916867856626, "compression_ratio": 1.7427184466019416, "no_speech_prob": 2.0134844817221165e-05}, {"id": 11, "seek": 5644, "start": 67.75999999999999, "end": 73.72, "text": " and concepts and new things being introduced. While in fusion, we try to reduce this to", "tokens": [293, 10392, 293, 777, 721, 885, 7268, 13, 3987, 294, 23100, 11, 321, 853, 281, 5407, 341, 281], "temperature": 0.0, "avg_logprob": -0.13049916867856626, "compression_ratio": 1.7427184466019416, "no_speech_prob": 2.0134844817221165e-05}, {"id": 12, "seek": 5644, "start": 73.72, "end": 80.75999999999999, "text": " one single concept, which is a fusion feature. And that's basically an abstraction for things", "tokens": [472, 2167, 3410, 11, 597, 307, 257, 23100, 4111, 13, 400, 300, 311, 1936, 364, 37765, 337, 721], "temperature": 0.0, "avg_logprob": -0.13049916867856626, "compression_ratio": 1.7427184466019416, "no_speech_prob": 2.0134844817221165e-05}, {"id": 13, "seek": 8076, "start": 80.76, "end": 88.48, "text": " like classes, methods, interfaces, and so on. And instead of having the developer to", "tokens": [411, 5359, 11, 7150, 11, 28416, 11, 293, 370, 322, 13, 400, 2602, 295, 1419, 264, 10754, 281], "temperature": 0.0, "avg_logprob": -0.13729884825557112, "compression_ratio": 1.7184466019417475, "no_speech_prob": 2.7099251383333467e-05}, {"id": 14, "seek": 8076, "start": 88.48, "end": 94.56, "text": " choose what to write, whether to write a method or a class or so, have the compiler have the", "tokens": [2826, 437, 281, 2464, 11, 1968, 281, 2464, 257, 3170, 420, 257, 1508, 420, 370, 11, 362, 264, 31958, 362, 264], "temperature": 0.0, "avg_logprob": -0.13729884825557112, "compression_ratio": 1.7184466019417475, "no_speech_prob": 2.7099251383333467e-05}, {"id": 15, "seek": 8076, "start": 94.56, "end": 102.68, "text": " implementation, make these decisions, what we actually need to implement those features.", "tokens": [11420, 11, 652, 613, 5327, 11, 437, 321, 767, 643, 281, 4445, 729, 4122, 13], "temperature": 0.0, "avg_logprob": -0.13729884825557112, "compression_ratio": 1.7184466019417475, "no_speech_prob": 2.7099251383333467e-05}, {"id": 16, "seek": 8076, "start": 102.68, "end": 106.60000000000001, "text": " And also we see that more and more systems become safe to critical. So we need a simple", "tokens": [400, 611, 321, 536, 300, 544, 293, 544, 3652, 1813, 3273, 281, 4924, 13, 407, 321, 643, 257, 2199], "temperature": 0.0, "avg_logprob": -0.13729884825557112, "compression_ratio": 1.7184466019417475, "no_speech_prob": 2.7099251383333467e-05}, {"id": 17, "seek": 10660, "start": 106.6, "end": 111.44, "text": " language and we need tools to analyze that simple language to ensure the correctness.", "tokens": [2856, 293, 321, 643, 3873, 281, 12477, 300, 2199, 2856, 281, 5586, 264, 3006, 1287, 13], "temperature": 0.0, "avg_logprob": -0.12894230746151356, "compression_ratio": 1.6181818181818182, "no_speech_prob": 9.452123777009547e-05}, {"id": 18, "seek": 10660, "start": 111.44, "end": 117.6, "text": " So that's what we keep in mind when we work on fusion. Fusion is on GitHub. I don't give", "tokens": [407, 300, 311, 437, 321, 1066, 294, 1575, 562, 321, 589, 322, 23100, 13, 36721, 307, 322, 23331, 13, 286, 500, 380, 976], "temperature": 0.0, "avg_logprob": -0.12894230746151356, "compression_ratio": 1.6181818181818182, "no_speech_prob": 9.452123777009547e-05}, {"id": 19, "seek": 10660, "start": 117.6, "end": 123.52, "text": " any tutorial in the language or so in this talk. This is all online, so I will just basically", "tokens": [604, 7073, 294, 264, 2856, 420, 370, 294, 341, 751, 13, 639, 307, 439, 2950, 11, 370, 286, 486, 445, 1936], "temperature": 0.0, "avg_logprob": -0.12894230746151356, "compression_ratio": 1.6181818181818182, "no_speech_prob": 9.452123777009547e-05}, {"id": 20, "seek": 10660, "start": 123.52, "end": 129.35999999999999, "text": " throw you in the water and let you learn to swim bringing fusion code in this talk. But", "tokens": [3507, 291, 294, 264, 1281, 293, 718, 291, 1466, 281, 7110, 5062, 23100, 3089, 294, 341, 751, 13, 583], "temperature": 0.0, "avg_logprob": -0.12894230746151356, "compression_ratio": 1.6181818181818182, "no_speech_prob": 9.452123777009547e-05}, {"id": 21, "seek": 12936, "start": 129.36, "end": 138.88000000000002, "text": " I hope, I think you will do fine. Fusion is backed by a small company, Tokiba, and now", "tokens": [286, 1454, 11, 286, 519, 291, 486, 360, 2489, 13, 36721, 307, 20391, 538, 257, 1359, 2237, 11, 11036, 17036, 11, 293, 586], "temperature": 0.0, "avg_logprob": -0.20204923550287882, "compression_ratio": 1.5474137931034482, "no_speech_prob": 3.818505865638144e-05}, {"id": 22, "seek": 12936, "start": 138.88000000000002, "end": 145.52, "text": " to this talk. No, before I forget, for those who only came for the fusion stickers, I have", "tokens": [281, 341, 751, 13, 883, 11, 949, 286, 2870, 11, 337, 729, 567, 787, 1361, 337, 264, 23100, 21019, 11, 286, 362], "temperature": 0.0, "avg_logprob": -0.20204923550287882, "compression_ratio": 1.5474137931034482, "no_speech_prob": 3.818505865638144e-05}, {"id": 23, "seek": 12936, "start": 145.52, "end": 152.20000000000002, "text": " some here, so you can maybe give them around. If you ever once can take one. So now, what", "tokens": [512, 510, 11, 370, 291, 393, 1310, 976, 552, 926, 13, 759, 291, 1562, 1564, 393, 747, 472, 13, 407, 586, 11, 437], "temperature": 0.0, "avg_logprob": -0.20204923550287882, "compression_ratio": 1.5474137931034482, "no_speech_prob": 3.818505865638144e-05}, {"id": 24, "seek": 12936, "start": 152.20000000000002, "end": 157.24, "text": " I want to talk about here is basically three points. I start with explaining what algebraic", "tokens": [286, 528, 281, 751, 466, 510, 307, 1936, 1045, 2793, 13, 286, 722, 365, 13468, 437, 21989, 299], "temperature": 0.0, "avg_logprob": -0.20204923550287882, "compression_ratio": 1.5474137931034482, "no_speech_prob": 3.818505865638144e-05}, {"id": 25, "seek": 15724, "start": 157.24, "end": 164.12, "text": " effects are and how they are implemented or how they are used in fusion. Then I want to", "tokens": [5065, 366, 293, 577, 436, 366, 12270, 420, 577, 436, 366, 1143, 294, 23100, 13, 1396, 286, 528, 281], "temperature": 0.0, "avg_logprob": -0.10213793814182281, "compression_ratio": 1.69375, "no_speech_prob": 5.062677519163117e-05}, {"id": 26, "seek": 15724, "start": 164.12, "end": 169.8, "text": " talk a bit about types and how types can be used as first class features and type values", "tokens": [751, 257, 857, 466, 3467, 293, 577, 3467, 393, 312, 1143, 382, 700, 1508, 4122, 293, 2010, 4190], "temperature": 0.0, "avg_logprob": -0.10213793814182281, "compression_ratio": 1.69375, "no_speech_prob": 5.062677519163117e-05}, {"id": 27, "seek": 15724, "start": 169.8, "end": 175.20000000000002, "text": " can be used in fusion. And then I bring these two together because that brings a big advantage", "tokens": [393, 312, 1143, 294, 23100, 13, 400, 550, 286, 1565, 613, 732, 1214, 570, 300, 5607, 257, 955, 5002], "temperature": 0.0, "avg_logprob": -0.10213793814182281, "compression_ratio": 1.69375, "no_speech_prob": 5.062677519163117e-05}, {"id": 28, "seek": 17520, "start": 175.2, "end": 187.79999999999998, "text": " when working with algebraic effects. So, what do we need effects for? Fusion, in fusion,", "tokens": [562, 1364, 365, 21989, 299, 5065, 13, 407, 11, 437, 360, 321, 643, 5065, 337, 30, 36721, 11, 294, 23100, 11], "temperature": 0.0, "avg_logprob": -0.2281960447629293, "compression_ratio": 1.4206349206349207, "no_speech_prob": 1.5442323274328373e-05}, {"id": 29, "seek": 17520, "start": 187.79999999999998, "end": 198.35999999999999, "text": " a feature is a pure function, so there is no side effects, no mutation of data by default.", "tokens": [257, 4111, 307, 257, 6075, 2445, 11, 370, 456, 307, 572, 1252, 5065, 11, 572, 27960, 295, 1412, 538, 7576, 13], "temperature": 0.0, "avg_logprob": -0.2281960447629293, "compression_ratio": 1.4206349206349207, "no_speech_prob": 1.5442323274328373e-05}, {"id": 30, "seek": 19836, "start": 198.36, "end": 205.20000000000002, "text": " And algebraic effects are used in fusion now to model all the non-functional effects like", "tokens": [400, 21989, 299, 5065, 366, 1143, 294, 23100, 586, 281, 2316, 439, 264, 2107, 12, 22845, 304, 5065, 411], "temperature": 0.0, "avg_logprob": -0.174465330820235, "compression_ratio": 1.5789473684210527, "no_speech_prob": 7.4102936196140945e-06}, {"id": 31, "seek": 19836, "start": 205.20000000000002, "end": 213.56, "text": " state changes, IO, any threat communication or mechanisms like exceptions. So, let me", "tokens": [1785, 2962, 11, 39839, 11, 604, 4734, 6101, 420, 15902, 411, 22847, 13, 407, 11, 718, 385], "temperature": 0.0, "avg_logprob": -0.174465330820235, "compression_ratio": 1.5789473684210527, "no_speech_prob": 7.4102936196140945e-06}, {"id": 32, "seek": 19836, "start": 213.56, "end": 222.36, "text": " first define what are algebraic effects. And algebraic effect is actually a set of operations.", "tokens": [700, 6964, 437, 366, 21989, 299, 5065, 13, 400, 21989, 299, 1802, 307, 767, 257, 992, 295, 7705, 13], "temperature": 0.0, "avg_logprob": -0.174465330820235, "compression_ratio": 1.5789473684210527, "no_speech_prob": 7.4102936196140945e-06}, {"id": 33, "seek": 22236, "start": 222.36, "end": 229.72000000000003, "text": " You could think of operations like reading data, so performing some IO, getting the time", "tokens": [509, 727, 519, 295, 7705, 411, 3760, 1412, 11, 370, 10205, 512, 39839, 11, 1242, 264, 565], "temperature": 0.0, "avg_logprob": -0.11163524389266968, "compression_ratio": 1.7142857142857142, "no_speech_prob": 8.528294529241975e-06}, {"id": 34, "seek": 22236, "start": 229.72000000000003, "end": 235.28, "text": " or doing something like a panic, so causing an error in the application to stop or logging", "tokens": [420, 884, 746, 411, 257, 14783, 11, 370, 9853, 364, 6713, 294, 264, 3861, 281, 1590, 420, 27991], "temperature": 0.0, "avg_logprob": -0.11163524389266968, "compression_ratio": 1.7142857142857142, "no_speech_prob": 8.528294529241975e-06}, {"id": 35, "seek": 22236, "start": 235.28, "end": 244.68, "text": " some data somewhere. Typically, these operations in an algebraic effect model some non-functional", "tokens": [512, 1412, 4079, 13, 23129, 11, 613, 7705, 294, 364, 21989, 299, 1802, 2316, 512, 2107, 12, 22845, 304], "temperature": 0.0, "avg_logprob": -0.11163524389266968, "compression_ratio": 1.7142857142857142, "no_speech_prob": 8.528294529241975e-06}, {"id": 36, "seek": 22236, "start": 244.68, "end": 251.32000000000002, "text": " aspect that is kind of orthogonal to the actual computation of your function. These operations", "tokens": [4171, 300, 307, 733, 295, 41488, 281, 264, 3539, 24903, 295, 428, 2445, 13, 1981, 7705], "temperature": 0.0, "avg_logprob": -0.11163524389266968, "compression_ratio": 1.7142857142857142, "no_speech_prob": 8.528294529241975e-06}, {"id": 37, "seek": 25132, "start": 251.32, "end": 257.12, "text": " have basically two things that they can mainly do. They could either resume and produce a", "tokens": [362, 1936, 732, 721, 300, 436, 393, 8704, 360, 13, 814, 727, 2139, 15358, 293, 5258, 257], "temperature": 0.0, "avg_logprob": -0.13780690402519413, "compression_ratio": 1.6774193548387097, "no_speech_prob": 2.753177977865562e-05}, {"id": 38, "seek": 25132, "start": 257.12, "end": 263.36, "text": " result like reading that is successful or they can abort which is like throwing an exception,", "tokens": [1874, 411, 3760, 300, 307, 4406, 420, 436, 393, 38117, 597, 307, 411, 10238, 364, 11183, 11], "temperature": 0.0, "avg_logprob": -0.13780690402519413, "compression_ratio": 1.6774193548387097, "no_speech_prob": 2.753177977865562e-05}, {"id": 39, "seek": 25132, "start": 263.36, "end": 271.36, "text": " you just get out of that, you don't get anything from this. And an effect can be implemented", "tokens": [291, 445, 483, 484, 295, 300, 11, 291, 500, 380, 483, 1340, 490, 341, 13, 400, 364, 1802, 393, 312, 12270], "temperature": 0.0, "avg_logprob": -0.13780690402519413, "compression_ratio": 1.6774193548387097, "no_speech_prob": 2.753177977865562e-05}, {"id": 40, "seek": 25132, "start": 271.36, "end": 279.08, "text": " by different effect handlers. So, one effect type could have different implementations.", "tokens": [538, 819, 1802, 1011, 11977, 13, 407, 11, 472, 1802, 2010, 727, 362, 819, 4445, 763, 13], "temperature": 0.0, "avg_logprob": -0.13780690402519413, "compression_ratio": 1.6774193548387097, "no_speech_prob": 2.753177977865562e-05}, {"id": 41, "seek": 27908, "start": 279.08, "end": 288.84, "text": " And to run code that uses an effect, this code has to be executed while a corresponding", "tokens": [400, 281, 1190, 3089, 300, 4960, 364, 1802, 11, 341, 3089, 575, 281, 312, 17577, 1339, 257, 11760], "temperature": 0.0, "avg_logprob": -0.147364814107011, "compression_ratio": 1.408, "no_speech_prob": 1.078257537301397e-05}, {"id": 42, "seek": 27908, "start": 288.84, "end": 301.4, "text": " handler for that effect is installed. Now, the effects allow static analysis of the code", "tokens": [41967, 337, 300, 1802, 307, 8899, 13, 823, 11, 264, 5065, 2089, 13437, 5215, 295, 264, 3089], "temperature": 0.0, "avg_logprob": -0.147364814107011, "compression_ratio": 1.408, "no_speech_prob": 1.078257537301397e-05}, {"id": 43, "seek": 30140, "start": 301.4, "end": 312.59999999999997, "text": " that we can analyze what effects any feature has. And we require that for all library code,", "tokens": [300, 321, 393, 12477, 437, 5065, 604, 4111, 575, 13, 400, 321, 3651, 300, 337, 439, 6405, 3089, 11], "temperature": 0.0, "avg_logprob": -0.14301432332684916, "compression_ratio": 1.598802395209581, "no_speech_prob": 1.0951275726256426e-05}, {"id": 44, "seek": 30140, "start": 312.59999999999997, "end": 324.03999999999996, "text": " the full set of effects is documented in the signature of those features. So, if effects", "tokens": [264, 1577, 992, 295, 5065, 307, 23007, 294, 264, 13397, 295, 729, 4122, 13, 407, 11, 498, 5065], "temperature": 0.0, "avg_logprob": -0.14301432332684916, "compression_ratio": 1.598802395209581, "no_speech_prob": 1.0951275726256426e-05}, {"id": 45, "seek": 30140, "start": 324.03999999999996, "end": 330.44, "text": " that are not presented are unexpected are used, that would cause a compile time error.", "tokens": [300, 366, 406, 8212, 366, 13106, 366, 1143, 11, 300, 576, 3082, 257, 31413, 565, 6713, 13], "temperature": 0.0, "avg_logprob": -0.14301432332684916, "compression_ratio": 1.598802395209581, "no_speech_prob": 1.0951275726256426e-05}, {"id": 46, "seek": 33044, "start": 330.44, "end": 337.28, "text": " I start with a small example of a hello world, a hello world feature. We use this exclamation", "tokens": [286, 722, 365, 257, 1359, 1365, 295, 257, 7751, 1002, 11, 257, 7751, 1002, 4111, 13, 492, 764, 341, 1624, 43233], "temperature": 0.0, "avg_logprob": -0.20796643603931775, "compression_ratio": 1.7696078431372548, "no_speech_prob": 1.6962672816589475e-05}, {"id": 47, "seek": 33044, "start": 337.28, "end": 343.8, "text": " mark syntax to mark that this code actually uses an effect and the effect or requires", "tokens": [1491, 28431, 281, 1491, 300, 341, 3089, 767, 4960, 364, 1802, 293, 264, 1802, 420, 7029], "temperature": 0.0, "avg_logprob": -0.20796643603931775, "compression_ratio": 1.7696078431372548, "no_speech_prob": 1.6962672816589475e-05}, {"id": 48, "seek": 33044, "start": 343.8, "end": 350.4, "text": " an effect. And that is I O dot out in this case because the library function say requires", "tokens": [364, 1802, 13, 400, 300, 307, 286, 422, 5893, 484, 294, 341, 1389, 570, 264, 6405, 2445, 584, 7029], "temperature": 0.0, "avg_logprob": -0.20796643603931775, "compression_ratio": 1.7696078431372548, "no_speech_prob": 1.6962672816589475e-05}, {"id": 49, "seek": 33044, "start": 350.4, "end": 357.4, "text": " that effect. And I run this code now, of course it prints hello world. And if I analyze the", "tokens": [300, 1802, 13, 400, 286, 1190, 341, 3089, 586, 11, 295, 1164, 309, 22305, 7751, 1002, 13, 400, 498, 286, 12477, 264], "temperature": 0.0, "avg_logprob": -0.20796643603931775, "compression_ratio": 1.7696078431372548, "no_speech_prob": 1.6962672816589475e-05}, {"id": 50, "seek": 35740, "start": 357.4, "end": 366.32, "text": " code for the effects that it has, I see that I O dot out is an effect required by this", "tokens": [3089, 337, 264, 5065, 300, 309, 575, 11, 286, 536, 300, 286, 422, 5893, 484, 307, 364, 1802, 4739, 538, 341], "temperature": 0.0, "avg_logprob": -0.1296928950718471, "compression_ratio": 1.4748603351955307, "no_speech_prob": 1.696306026133243e-05}, {"id": 51, "seek": 35740, "start": 366.32, "end": 374.28, "text": " small example. Now, I want to run the same code, the hello world hasn't changed, using", "tokens": [1359, 1365, 13, 823, 11, 286, 528, 281, 1190, 264, 912, 3089, 11, 264, 7751, 1002, 6132, 380, 3105, 11, 1228], "temperature": 0.0, "avg_logprob": -0.1296928950718471, "compression_ratio": 1.4748603351955307, "no_speech_prob": 1.696306026133243e-05}, {"id": 52, "seek": 35740, "start": 374.28, "end": 384.12, "text": " my own handler. So, I have defined a handler here, which is a feature inherited thing from", "tokens": [452, 1065, 41967, 13, 407, 11, 286, 362, 7642, 257, 41967, 510, 11, 597, 307, 257, 4111, 27091, 551, 490], "temperature": 0.0, "avg_logprob": -0.1296928950718471, "compression_ratio": 1.4748603351955307, "no_speech_prob": 1.696306026133243e-05}, {"id": 53, "seek": 38412, "start": 384.12, "end": 393.24, "text": " can print and it really finds the print operation to print to I O error instead and to replace", "tokens": [393, 4482, 293, 309, 534, 10704, 264, 4482, 6916, 281, 4482, 281, 286, 422, 6713, 2602, 293, 281, 7406], "temperature": 0.0, "avg_logprob": -0.18030616816352396, "compression_ratio": 1.6488095238095237, "no_speech_prob": 2.6685076591093093e-05}, {"id": 54, "seek": 38412, "start": 393.24, "end": 400.36, "text": " the exclamation mark by many exclamation marks. And now to run this, we need to first install", "tokens": [264, 1624, 43233, 1491, 538, 867, 1624, 43233, 10640, 13, 400, 586, 281, 1190, 341, 11, 321, 643, 281, 700, 3625], "temperature": 0.0, "avg_logprob": -0.18030616816352396, "compression_ratio": 1.6488095238095237, "no_speech_prob": 2.6685076591093093e-05}, {"id": 55, "seek": 38412, "start": 400.36, "end": 407.8, "text": " this handler as the I O out handler. The I O out here is just a convenient function that", "tokens": [341, 41967, 382, 264, 286, 422, 484, 41967, 13, 440, 286, 422, 484, 510, 307, 445, 257, 10851, 2445, 300], "temperature": 0.0, "avg_logprob": -0.18030616816352396, "compression_ratio": 1.6488095238095237, "no_speech_prob": 2.6685076591093093e-05}, {"id": 56, "seek": 40780, "start": 407.8, "end": 416.40000000000003, "text": " installs the first handler and executes the code given in the lambda as a second argument.", "tokens": [3625, 82, 264, 700, 41967, 293, 4454, 1819, 264, 3089, 2212, 294, 264, 13607, 382, 257, 1150, 6770, 13], "temperature": 0.0, "avg_logprob": -0.14854120946192478, "compression_ratio": 1.6376146788990826, "no_speech_prob": 2.014265555771999e-05}, {"id": 57, "seek": 40780, "start": 416.40000000000003, "end": 422.84000000000003, "text": " And when I run this now, of course, I see the print out is the modified string because", "tokens": [400, 562, 286, 1190, 341, 586, 11, 295, 1164, 11, 286, 536, 264, 4482, 484, 307, 264, 15873, 6798, 570], "temperature": 0.0, "avg_logprob": -0.14854120946192478, "compression_ratio": 1.6376146788990826, "no_speech_prob": 2.014265555771999e-05}, {"id": 58, "seek": 40780, "start": 422.84000000000003, "end": 428.72, "text": " we replace the exclamation mark here. And if I analyze this for effects, I now see this", "tokens": [321, 7406, 264, 1624, 43233, 1491, 510, 13, 400, 498, 286, 12477, 341, 337, 5065, 11, 286, 586, 536, 341], "temperature": 0.0, "avg_logprob": -0.14854120946192478, "compression_ratio": 1.6376146788990826, "no_speech_prob": 2.014265555771999e-05}, {"id": 59, "seek": 40780, "start": 428.72, "end": 436.08000000000004, "text": " no longer depends on the I O out effect, but the I O error because we have kind of diverted", "tokens": [572, 2854, 5946, 322, 264, 286, 422, 484, 1802, 11, 457, 264, 286, 422, 6713, 570, 321, 362, 733, 295, 1026, 18537], "temperature": 0.0, "avg_logprob": -0.14854120946192478, "compression_ratio": 1.6376146788990826, "no_speech_prob": 2.014265555771999e-05}, {"id": 60, "seek": 43608, "start": 436.08, "end": 441.71999999999997, "text": " the code to depend on the other effect. We could also implement a handler that doesn't", "tokens": [264, 3089, 281, 5672, 322, 264, 661, 1802, 13, 492, 727, 611, 4445, 257, 41967, 300, 1177, 380], "temperature": 0.0, "avg_logprob": -0.14258007925064836, "compression_ratio": 1.4857142857142858, "no_speech_prob": 1.4969861695135478e-05}, {"id": 61, "seek": 43608, "start": 441.71999999999997, "end": 448.68, "text": " do anything, then the hello world executed in that environment would not require any", "tokens": [360, 1340, 11, 550, 264, 7751, 1002, 17577, 294, 300, 2823, 576, 406, 3651, 604], "temperature": 0.0, "avg_logprob": -0.14258007925064836, "compression_ratio": 1.4857142857142858, "no_speech_prob": 1.4969861695135478e-05}, {"id": 62, "seek": 43608, "start": 448.68, "end": 460.68, "text": " effect at all anymore. That much to effects. Now, let me talk about types as first class", "tokens": [1802, 412, 439, 3602, 13, 663, 709, 281, 5065, 13, 823, 11, 718, 385, 751, 466, 3467, 382, 700, 1508], "temperature": 0.0, "avg_logprob": -0.14258007925064836, "compression_ratio": 1.4857142857142858, "no_speech_prob": 1.4969861695135478e-05}, {"id": 63, "seek": 46068, "start": 460.68, "end": 467.96, "text": " features in fusion. To make it easier for you to understand what's happening, I give", "tokens": [4122, 294, 23100, 13, 1407, 652, 309, 3571, 337, 291, 281, 1223, 437, 311, 2737, 11, 286, 976], "temperature": 0.0, "avg_logprob": -0.15720203106219952, "compression_ratio": 1.4942528735632183, "no_speech_prob": 2.1111451133037917e-05}, {"id": 64, "seek": 46068, "start": 467.96, "end": 475.72, "text": " first an example of generics in Java, where I have a generic method here that takes an", "tokens": [700, 364, 1365, 295, 1337, 1167, 294, 10745, 11, 689, 286, 362, 257, 19577, 3170, 510, 300, 2516, 364], "temperature": 0.0, "avg_logprob": -0.15720203106219952, "compression_ratio": 1.4942528735632183, "no_speech_prob": 2.1111451133037917e-05}, {"id": 65, "seek": 46068, "start": 475.72, "end": 488.2, "text": " argument A of any generic type T and prints out the value. Doing that in fusion, we have", "tokens": [6770, 316, 295, 604, 19577, 2010, 314, 293, 22305, 484, 264, 2158, 13, 18496, 300, 294, 23100, 11, 321, 362], "temperature": 0.0, "avg_logprob": -0.15720203106219952, "compression_ratio": 1.4942528735632183, "no_speech_prob": 2.1111451133037917e-05}, {"id": 66, "seek": 48820, "start": 488.2, "end": 494.32, "text": " type parameters, which are actually at the same level as value parameters. So we have", "tokens": [2010, 9834, 11, 597, 366, 767, 412, 264, 912, 1496, 382, 2158, 9834, 13, 407, 321, 362], "temperature": 0.0, "avg_logprob": -0.13279219234690948, "compression_ratio": 1.5595238095238095, "no_speech_prob": 6.962065526749939e-06}, {"id": 67, "seek": 48820, "start": 494.32, "end": 502.84, "text": " a function with two arguments, T, which is a type, and A, which is a value of that type.", "tokens": [257, 2445, 365, 732, 12869, 11, 314, 11, 597, 307, 257, 2010, 11, 293, 316, 11, 597, 307, 257, 2158, 295, 300, 2010, 13], "temperature": 0.0, "avg_logprob": -0.13279219234690948, "compression_ratio": 1.5595238095238095, "no_speech_prob": 6.962065526749939e-06}, {"id": 68, "seek": 48820, "start": 502.84, "end": 507.56, "text": " And this is not just syntactic sugar that this looks the same, but it's also internally", "tokens": [400, 341, 307, 406, 445, 23980, 19892, 5076, 300, 341, 1542, 264, 912, 11, 457, 309, 311, 611, 19501], "temperature": 0.0, "avg_logprob": -0.13279219234690948, "compression_ratio": 1.5595238095238095, "no_speech_prob": 6.962065526749939e-06}, {"id": 69, "seek": 50756, "start": 507.56, "end": 523.52, "text": " the type parameters of our argument features just as the arguments itself. Of course, we", "tokens": [264, 2010, 9834, 295, 527, 6770, 4122, 445, 382, 264, 12869, 2564, 13, 2720, 1164, 11, 321], "temperature": 0.0, "avg_logprob": -0.24526788971640848, "compression_ratio": 1.380952380952381, "no_speech_prob": 1.0614588973112404e-05}, {"id": 70, "seek": 50756, "start": 523.52, "end": 533.8, "text": " can now, oops, I went a bit further than I wanted. We can now call this function with", "tokens": [393, 586, 11, 34166, 11, 286, 1437, 257, 857, 3052, 813, 286, 1415, 13, 492, 393, 586, 818, 341, 2445, 365], "temperature": 0.0, "avg_logprob": -0.24526788971640848, "compression_ratio": 1.380952380952381, "no_speech_prob": 1.0614588973112404e-05}, {"id": 71, "seek": 53380, "start": 533.8, "end": 543.8, "text": " two different type parameters and two different value arguments and print these two values.", "tokens": [732, 819, 2010, 9834, 293, 732, 819, 2158, 12869, 293, 4482, 613, 732, 4190, 13], "temperature": 0.0, "avg_logprob": -0.14403872654355807, "compression_ratio": 1.607361963190184, "no_speech_prob": 1.4284493772720452e-05}, {"id": 72, "seek": 53380, "start": 543.8, "end": 551.8, "text": " That's pretty standard for generic for type parametric functions. Fusion uses a lot of", "tokens": [663, 311, 1238, 3832, 337, 19577, 337, 2010, 6220, 17475, 6828, 13, 36721, 4960, 257, 688, 295], "temperature": 0.0, "avg_logprob": -0.14403872654355807, "compression_ratio": 1.607361963190184, "no_speech_prob": 1.4284493772720452e-05}, {"id": 73, "seek": 53380, "start": 551.8, "end": 559.7199999999999, "text": " type inferencing. So in such a case where the types are obvious from the arguments,", "tokens": [2010, 13596, 13644, 13, 407, 294, 1270, 257, 1389, 689, 264, 3467, 366, 6322, 490, 264, 12869, 11], "temperature": 0.0, "avg_logprob": -0.14403872654355807, "compression_ratio": 1.607361963190184, "no_speech_prob": 1.4284493772720452e-05}, {"id": 74, "seek": 55972, "start": 559.72, "end": 564.72, "text": " they don't need to be given. So we have the rule that type parameters always have to", "tokens": [436, 500, 380, 643, 281, 312, 2212, 13, 407, 321, 362, 264, 4978, 300, 2010, 9834, 1009, 362, 281], "temperature": 0.0, "avg_logprob": -0.12439223994379459, "compression_ratio": 1.7058823529411764, "no_speech_prob": 8.529895239917096e-06}, {"id": 75, "seek": 55972, "start": 564.72, "end": 571.96, "text": " precede the value arguments and they can be left out if they can be inferred. So the code", "tokens": [16969, 68, 264, 2158, 12869, 293, 436, 393, 312, 1411, 484, 498, 436, 393, 312, 13596, 986, 13, 407, 264, 3089], "temperature": 0.0, "avg_logprob": -0.12439223994379459, "compression_ratio": 1.7058823529411764, "no_speech_prob": 8.529895239917096e-06}, {"id": 76, "seek": 55972, "start": 571.96, "end": 579.32, "text": " can be written like this. Then next, we could constrain type parameters. So we could say", "tokens": [393, 312, 3720, 411, 341, 13, 1396, 958, 11, 321, 727, 1817, 7146, 2010, 9834, 13, 407, 321, 727, 584], "temperature": 0.0, "avg_logprob": -0.12439223994379459, "compression_ratio": 1.7058823529411764, "no_speech_prob": 8.529895239917096e-06}, {"id": 77, "seek": 55972, "start": 579.32, "end": 588.5600000000001, "text": " in this case, we want a type that must be numeric. And if we have such a constraint,", "tokens": [294, 341, 1389, 11, 321, 528, 257, 2010, 300, 1633, 312, 7866, 299, 13, 400, 498, 321, 362, 1270, 257, 25534, 11], "temperature": 0.0, "avg_logprob": -0.12439223994379459, "compression_ratio": 1.7058823529411764, "no_speech_prob": 8.529895239917096e-06}, {"id": 78, "seek": 58856, "start": 588.56, "end": 594.64, "text": " we could use operations that are only provided by the type, like the plus operator that is", "tokens": [321, 727, 764, 7705, 300, 366, 787, 5649, 538, 264, 2010, 11, 411, 264, 1804, 12973, 300, 307], "temperature": 0.0, "avg_logprob": -0.11084898780373965, "compression_ratio": 1.7860696517412935, "no_speech_prob": 1.2605574738699943e-05}, {"id": 79, "seek": 58856, "start": 594.64, "end": 602.0799999999999, "text": " defined on numerics. And if we run this now, we can also output the double value, still", "tokens": [7642, 322, 7866, 1167, 13, 400, 498, 321, 1190, 341, 586, 11, 321, 393, 611, 5598, 264, 3834, 2158, 11, 920], "temperature": 0.0, "avg_logprob": -0.11084898780373965, "compression_ratio": 1.7860696517412935, "no_speech_prob": 1.2605574738699943e-05}, {"id": 80, "seek": 58856, "start": 602.0799999999999, "end": 607.4399999999999, "text": " pretty standard for generics. But what we can also do is we can use the type parameter", "tokens": [1238, 3832, 337, 1337, 1167, 13, 583, 437, 321, 393, 611, 360, 307, 321, 393, 764, 264, 2010, 13075], "temperature": 0.0, "avg_logprob": -0.11084898780373965, "compression_ratio": 1.7860696517412935, "no_speech_prob": 1.2605574738699943e-05}, {"id": 81, "seek": 58856, "start": 607.4399999999999, "end": 613.92, "text": " itself and call features that the type parameter provides, like every type provides its name.", "tokens": [2564, 293, 818, 4122, 300, 264, 2010, 13075, 6417, 11, 411, 633, 2010, 6417, 1080, 1315, 13], "temperature": 0.0, "avg_logprob": -0.11084898780373965, "compression_ratio": 1.7860696517412935, "no_speech_prob": 1.2605574738699943e-05}, {"id": 82, "seek": 61392, "start": 613.92, "end": 629.68, "text": " So we can run this code and print those names. And we can go even further with that. And", "tokens": [407, 321, 393, 1190, 341, 3089, 293, 4482, 729, 5288, 13, 400, 321, 393, 352, 754, 3052, 365, 300, 13, 400], "temperature": 0.0, "avg_logprob": -0.07770630587702212, "compression_ratio": 1.3888888888888888, "no_speech_prob": 5.681874881702242e-06}, {"id": 83, "seek": 61392, "start": 629.68, "end": 636.3199999999999, "text": " I want to show you in an implementation of a feature that calculates the sum of a list", "tokens": [286, 528, 281, 855, 291, 294, 364, 11420, 295, 257, 4111, 300, 4322, 1024, 264, 2408, 295, 257, 1329], "temperature": 0.0, "avg_logprob": -0.07770630587702212, "compression_ratio": 1.3888888888888888, "no_speech_prob": 5.681874881702242e-06}, {"id": 84, "seek": 63632, "start": 636.32, "end": 645.24, "text": " of some numeric elements. The implementation of that feature would distinguish the case", "tokens": [295, 512, 7866, 299, 4959, 13, 440, 11420, 295, 300, 4111, 576, 20206, 264, 1389], "temperature": 0.0, "avg_logprob": -0.1169665630047138, "compression_ratio": 1.5748502994011977, "no_speech_prob": 2.211616447311826e-05}, {"id": 85, "seek": 63632, "start": 645.24, "end": 652.6, "text": " of an empty list or a list consisting out of a head and a tail, where we can recursively", "tokens": [295, 364, 6707, 1329, 420, 257, 1329, 33921, 484, 295, 257, 1378, 293, 257, 6838, 11, 689, 321, 393, 20560, 3413], "temperature": 0.0, "avg_logprob": -0.1169665630047138, "compression_ratio": 1.5748502994011977, "no_speech_prob": 2.211616447311826e-05}, {"id": 86, "seek": 63632, "start": 652.6, "end": 662.2800000000001, "text": " calculate the sum. The question now is what do we do in the case of the empty list? In", "tokens": [8873, 264, 2408, 13, 440, 1168, 586, 307, 437, 360, 321, 360, 294, 264, 1389, 295, 264, 6707, 1329, 30, 682], "temperature": 0.0, "avg_logprob": -0.1169665630047138, "compression_ratio": 1.5748502994011977, "no_speech_prob": 2.211616447311826e-05}, {"id": 87, "seek": 66228, "start": 662.28, "end": 670.36, "text": " language like Java, we could have no way to produce any value here. What we can do is", "tokens": [2856, 411, 10745, 11, 321, 727, 362, 572, 636, 281, 5258, 604, 2158, 510, 13, 708, 321, 393, 360, 307], "temperature": 0.0, "avg_logprob": -0.109301207615779, "compression_ratio": 1.5654761904761905, "no_speech_prob": 8.013191290956456e-06}, {"id": 88, "seek": 66228, "start": 670.36, "end": 680.9599999999999, "text": " we can call a feature that is defined in the type numeric and redefined by all concrete", "tokens": [321, 393, 818, 257, 4111, 300, 307, 7642, 294, 264, 2010, 7866, 299, 293, 38818, 2001, 538, 439, 9859], "temperature": 0.0, "avg_logprob": -0.109301207615779, "compression_ratio": 1.5654761904761905, "no_speech_prob": 8.013191290956456e-06}, {"id": 89, "seek": 66228, "start": 680.9599999999999, "end": 690.3199999999999, "text": " implementations to provide the zero value for that actual numeric type. So numeric itself", "tokens": [4445, 763, 281, 2893, 264, 4018, 2158, 337, 300, 3539, 7866, 299, 2010, 13, 407, 7866, 299, 2564], "temperature": 0.0, "avg_logprob": -0.109301207615779, "compression_ratio": 1.5654761904761905, "no_speech_prob": 8.013191290956456e-06}, {"id": 90, "seek": 69032, "start": 690.32, "end": 698.44, "text": " is defined as a feature with its corresponding type defining zero as an instance of exactly", "tokens": [307, 7642, 382, 257, 4111, 365, 1080, 11760, 2010, 17827, 4018, 382, 364, 5197, 295, 2293], "temperature": 0.0, "avg_logprob": -0.1094727667551192, "compression_ratio": 1.593939393939394, "no_speech_prob": 1.0127787390956655e-05}, {"id": 91, "seek": 69032, "start": 698.44, "end": 708.12, "text": " this type. And then something like an i32, 32-bit integer, defines an implementation", "tokens": [341, 2010, 13, 400, 550, 746, 411, 364, 741, 11440, 11, 8858, 12, 5260, 24922, 11, 23122, 364, 11420], "temperature": 0.0, "avg_logprob": -0.1094727667551192, "compression_ratio": 1.593939393939394, "no_speech_prob": 1.0127787390956655e-05}, {"id": 92, "seek": 69032, "start": 708.12, "end": 717.6800000000001, "text": " of type.zero to return the integer zero. And we can now use that function to print the", "tokens": [295, 2010, 13, 32226, 281, 2736, 264, 24922, 4018, 13, 400, 321, 393, 586, 764, 300, 2445, 281, 4482, 264], "temperature": 0.0, "avg_logprob": -0.1094727667551192, "compression_ratio": 1.593939393939394, "no_speech_prob": 1.0127787390956655e-05}, {"id": 93, "seek": 71768, "start": 717.68, "end": 726.9599999999999, "text": " sums of different lists here. And when I do this, we have a list of floating point values,", "tokens": [34499, 295, 819, 14511, 510, 13, 400, 562, 286, 360, 341, 11, 321, 362, 257, 1329, 295, 12607, 935, 4190, 11], "temperature": 0.0, "avg_logprob": -0.13341905200292195, "compression_ratio": 1.8344827586206895, "no_speech_prob": 1.0951678632409312e-05}, {"id": 94, "seek": 71768, "start": 726.9599999999999, "end": 731.9599999999999, "text": " a list of fractions. We have an empty list of floating point values and an empty list", "tokens": [257, 1329, 295, 36058, 13, 492, 362, 364, 6707, 1329, 295, 12607, 935, 4190, 293, 364, 6707, 1329], "temperature": 0.0, "avg_logprob": -0.13341905200292195, "compression_ratio": 1.8344827586206895, "no_speech_prob": 1.0951678632409312e-05}, {"id": 95, "seek": 71768, "start": 731.9599999999999, "end": 739.76, "text": " of fractions, so we get the corresponding zero values from the types of the corresponding", "tokens": [295, 36058, 11, 370, 321, 483, 264, 11760, 4018, 4190, 490, 264, 3467, 295, 264, 11760], "temperature": 0.0, "avg_logprob": -0.13341905200292195, "compression_ratio": 1.8344827586206895, "no_speech_prob": 1.0951678632409312e-05}, {"id": 96, "seek": 73976, "start": 739.76, "end": 752.56, "text": " types. So that much to types. And now coming back to effects, I want to use these types", "tokens": [3467, 13, 407, 300, 709, 281, 3467, 13, 400, 586, 1348, 646, 281, 5065, 11, 286, 528, 281, 764, 613, 3467], "temperature": 0.0, "avg_logprob": -0.2119912017475475, "compression_ratio": 1.4146341463414633, "no_speech_prob": 8.267197699751705e-06}, {"id": 97, "seek": 73976, "start": 752.56, "end": 763.6, "text": " and type parameters to give names to effects or to reference user-defined effects. And", "tokens": [293, 2010, 9834, 281, 976, 5288, 281, 5065, 420, 281, 6408, 4195, 12, 37716, 5065, 13, 400], "temperature": 0.0, "avg_logprob": -0.2119912017475475, "compression_ratio": 1.4146341463414633, "no_speech_prob": 8.267197699751705e-06}, {"id": 98, "seek": 76360, "start": 763.6, "end": 773.6, "text": " I'll give you an example using a code that creates a linked ring, so a ring structure.", "tokens": [286, 603, 976, 291, 364, 1365, 1228, 257, 3089, 300, 7829, 257, 9408, 4875, 11, 370, 257, 4875, 3877, 13], "temperature": 0.0, "avg_logprob": -0.1582548307335895, "compression_ratio": 1.5555555555555556, "no_speech_prob": 1.952354250533972e-05}, {"id": 99, "seek": 76360, "start": 773.6, "end": 778.88, "text": " To create a ring structure with references, you need mutation because at some point you", "tokens": [1407, 1884, 257, 4875, 3877, 365, 15400, 11, 291, 643, 27960, 570, 412, 512, 935, 291], "temperature": 0.0, "avg_logprob": -0.1582548307335895, "compression_ratio": 1.5555555555555556, "no_speech_prob": 1.952354250533972e-05}, {"id": 100, "seek": 76360, "start": 778.88, "end": 793.36, "text": " have to close the ring. So that code is mutable, it's not easily pure. Then, so we will see", "tokens": [362, 281, 1998, 264, 4875, 13, 407, 300, 3089, 307, 5839, 712, 11, 309, 311, 406, 3612, 6075, 13, 1396, 11, 370, 321, 486, 536], "temperature": 0.0, "avg_logprob": -0.1582548307335895, "compression_ratio": 1.5555555555555556, "no_speech_prob": 1.952354250533972e-05}, {"id": 101, "seek": 79336, "start": 793.36, "end": 801.0, "text": " that this depends on the mutate effect. And then we want to reimplement this or extend", "tokens": [300, 341, 5946, 322, 264, 5839, 473, 1802, 13, 400, 550, 321, 528, 281, 33433, 43704, 341, 420, 10101], "temperature": 0.0, "avg_logprob": -0.13271894174463608, "compression_ratio": 1.6167664670658684, "no_speech_prob": 1.0615206520014908e-05}, {"id": 102, "seek": 79336, "start": 801.0, "end": 812.48, "text": " this to use local mutable state or local mutability to make this function pure. So I start by", "tokens": [341, 281, 764, 2654, 5839, 712, 1785, 420, 2654, 5839, 2310, 281, 652, 341, 2445, 6075, 13, 407, 286, 722, 538], "temperature": 0.0, "avg_logprob": -0.13271894174463608, "compression_ratio": 1.6167664670658684, "no_speech_prob": 1.0615206520014908e-05}, {"id": 103, "seek": 79336, "start": 812.48, "end": 819.76, "text": " code to create a ring that uses the mutate effect. You don't need to understand the whole", "tokens": [3089, 281, 1884, 257, 4875, 300, 4960, 264, 5839, 473, 1802, 13, 509, 500, 380, 643, 281, 1223, 264, 1379], "temperature": 0.0, "avg_logprob": -0.13271894174463608, "compression_ratio": 1.6167664670658684, "no_speech_prob": 1.0615206520014908e-05}, {"id": 104, "seek": 81976, "start": 819.76, "end": 827.56, "text": " code, the important thing is that every element in that ring has a pointer to the next element", "tokens": [3089, 11, 264, 1021, 551, 307, 300, 633, 4478, 294, 300, 4875, 575, 257, 23918, 281, 264, 958, 4478], "temperature": 0.0, "avg_logprob": -0.12659069697062175, "compression_ratio": 1.8256410256410256, "no_speech_prob": 9.079624760488514e-06}, {"id": 105, "seek": 81976, "start": 827.56, "end": 831.64, "text": " and there's a reference to the very last, because if you extend the ring, you have to", "tokens": [293, 456, 311, 257, 6408, 281, 264, 588, 1036, 11, 570, 498, 291, 10101, 264, 4875, 11, 291, 362, 281], "temperature": 0.0, "avg_logprob": -0.12659069697062175, "compression_ratio": 1.8256410256410256, "no_speech_prob": 9.079624760488514e-06}, {"id": 106, "seek": 81976, "start": 831.64, "end": 837.96, "text": " update the next of the last element in the ring to point to the newly added element in", "tokens": [5623, 264, 958, 295, 264, 1036, 4478, 294, 264, 4875, 281, 935, 281, 264, 15109, 3869, 4478, 294], "temperature": 0.0, "avg_logprob": -0.12659069697062175, "compression_ratio": 1.8256410256410256, "no_speech_prob": 9.079624760488514e-06}, {"id": 107, "seek": 81976, "start": 837.96, "end": 847.56, "text": " the ring. And here, for next, we create a mutable value, which is done by a base library", "tokens": [264, 4875, 13, 400, 510, 11, 337, 958, 11, 321, 1884, 257, 5839, 712, 2158, 11, 597, 307, 1096, 538, 257, 3096, 6405], "temperature": 0.0, "avg_logprob": -0.12659069697062175, "compression_ratio": 1.8256410256410256, "no_speech_prob": 9.079624760488514e-06}, {"id": 108, "seek": 84756, "start": 847.56, "end": 853.16, "text": " function mut, which used the mutate effect. And to update the next, we use this arrow", "tokens": [2445, 5839, 11, 597, 1143, 264, 5839, 473, 1802, 13, 400, 281, 5623, 264, 958, 11, 321, 764, 341, 11610], "temperature": 0.0, "avg_logprob": -0.18088720085915555, "compression_ratio": 1.6570048309178744, "no_speech_prob": 1.1123779586341698e-05}, {"id": 109, "seek": 84756, "start": 853.16, "end": 859.7199999999999, "text": " operation to update that. Now we create a small demo, we create a ring with elements", "tokens": [6916, 281, 5623, 300, 13, 823, 321, 1884, 257, 1359, 10723, 11, 321, 1884, 257, 4875, 365, 4959], "temperature": 0.0, "avg_logprob": -0.18088720085915555, "compression_ratio": 1.6570048309178744, "no_speech_prob": 1.1123779586341698e-05}, {"id": 110, "seek": 84756, "start": 859.7199999999999, "end": 866.1999999999999, "text": " ABC and then we run 10 times through the ring to print them. So we do that, we see that", "tokens": [22342, 293, 550, 321, 1190, 1266, 1413, 807, 264, 4875, 281, 4482, 552, 13, 407, 321, 360, 300, 11, 321, 536, 300], "temperature": 0.0, "avg_logprob": -0.18088720085915555, "compression_ratio": 1.6570048309178744, "no_speech_prob": 1.1123779586341698e-05}, {"id": 111, "seek": 84756, "start": 866.1999999999999, "end": 872.9599999999999, "text": " it circles around in that ring. But if you now analyze this for effects, what we see", "tokens": [309, 13040, 926, 294, 300, 4875, 13, 583, 498, 291, 586, 12477, 341, 337, 5065, 11, 437, 321, 536], "temperature": 0.0, "avg_logprob": -0.18088720085915555, "compression_ratio": 1.6570048309178744, "no_speech_prob": 1.1123779586341698e-05}, {"id": 112, "seek": 87296, "start": 872.96, "end": 880.76, "text": " is that we have a mutate effect used by the code. There's lots of other effects as well,", "tokens": [307, 300, 321, 362, 257, 5839, 473, 1802, 1143, 538, 264, 3089, 13, 821, 311, 3195, 295, 661, 5065, 382, 731, 11], "temperature": 0.0, "avg_logprob": -0.1356668472290039, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.013109436433297e-06}, {"id": 113, "seek": 87296, "start": 880.76, "end": 885.24, "text": " the out effect, because we print something, but there's also error handling in the library", "tokens": [264, 484, 1802, 11, 570, 321, 4482, 746, 11, 457, 456, 311, 611, 6713, 13175, 294, 264, 6405], "temperature": 0.0, "avg_logprob": -0.1356668472290039, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.013109436433297e-06}, {"id": 114, "seek": 87296, "start": 885.24, "end": 890.36, "text": " code that shows up here. But what I'm interested in is here is now, this has the mutate effect,", "tokens": [3089, 300, 3110, 493, 510, 13, 583, 437, 286, 478, 3102, 294, 307, 510, 307, 586, 11, 341, 575, 264, 5839, 473, 1802, 11], "temperature": 0.0, "avg_logprob": -0.1356668472290039, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.013109436433297e-06}, {"id": 115, "seek": 87296, "start": 890.36, "end": 900.1600000000001, "text": " because the code mutates the next element while building the ring. And now we want to", "tokens": [570, 264, 3089, 5839, 1024, 264, 958, 4478, 1339, 2390, 264, 4875, 13, 400, 586, 321, 528, 281], "temperature": 0.0, "avg_logprob": -0.1356668472290039, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.013109436433297e-06}, {"id": 116, "seek": 90016, "start": 900.16, "end": 909.3199999999999, "text": " get rid of this mutability in the code, I know, I think I'll make it in five minutes.", "tokens": [483, 3973, 295, 341, 5839, 2310, 294, 264, 3089, 11, 286, 458, 11, 286, 519, 286, 603, 652, 309, 294, 1732, 2077, 13], "temperature": 0.0, "avg_logprob": -0.13406819182556945, "compression_ratio": 1.5739644970414202, "no_speech_prob": 3.023270983248949e-05}, {"id": 117, "seek": 90016, "start": 909.3199999999999, "end": 918.8399999999999, "text": " And the way to do this is we define a local instance of the mutate effect. And to do that,", "tokens": [400, 264, 636, 281, 360, 341, 307, 321, 6964, 257, 2654, 5197, 295, 264, 5839, 473, 1802, 13, 400, 281, 360, 300, 11], "temperature": 0.0, "avg_logprob": -0.13406819182556945, "compression_ratio": 1.5739644970414202, "no_speech_prob": 3.023270983248949e-05}, {"id": 118, "seek": 90016, "start": 918.8399999999999, "end": 928.12, "text": " I first need a bit more space in the code. And I'll add a type parameter M of type mutate", "tokens": [286, 700, 643, 257, 857, 544, 1901, 294, 264, 3089, 13, 400, 286, 603, 909, 257, 2010, 13075, 376, 295, 2010, 5839, 473], "temperature": 0.0, "avg_logprob": -0.13406819182556945, "compression_ratio": 1.5739644970414202, "no_speech_prob": 3.023270983248949e-05}, {"id": 119, "seek": 92812, "start": 928.12, "end": 940.76, "text": " to the code here and also pass this on on calls and on types of ring used in here. And", "tokens": [281, 264, 3089, 510, 293, 611, 1320, 341, 322, 322, 5498, 293, 322, 3467, 295, 4875, 1143, 294, 510, 13, 400], "temperature": 0.0, "avg_logprob": -0.19342728878589385, "compression_ratio": 1.4126984126984128, "no_speech_prob": 2.6271032766089775e-05}, {"id": 120, "seek": 92812, "start": 940.76, "end": 950.64, "text": " now when we create an instance of such a mutable reference to the next element, instead, we", "tokens": [586, 562, 321, 1884, 364, 5197, 295, 1270, 257, 5839, 712, 6408, 281, 264, 958, 4478, 11, 2602, 11, 321], "temperature": 0.0, "avg_logprob": -0.19342728878589385, "compression_ratio": 1.4126984126984128, "no_speech_prob": 2.6271032766089775e-05}, {"id": 121, "seek": 95064, "start": 950.64, "end": 958.4399999999999, "text": " take the instance of the mutate effect M, which we got as a parameter here, from the", "tokens": [747, 264, 5197, 295, 264, 5839, 473, 1802, 376, 11, 597, 321, 658, 382, 257, 13075, 510, 11, 490, 264], "temperature": 0.0, "avg_logprob": -0.19500769990863223, "compression_ratio": 1.612121212121212, "no_speech_prob": 3.534801726345904e-05}, {"id": 122, "seek": 95064, "start": 958.4399999999999, "end": 963.84, "text": " current environment. The syntax we use in fusion there is type dot n, which is the effect", "tokens": [2190, 2823, 13, 440, 28431, 321, 764, 294, 23100, 456, 307, 2010, 5893, 297, 11, 597, 307, 264, 1802], "temperature": 0.0, "avg_logprob": -0.19500769990863223, "compression_ratio": 1.612121212121212, "no_speech_prob": 3.534801726345904e-05}, {"id": 123, "seek": 95064, "start": 963.84, "end": 975.88, "text": " from the environment, plus dot and the operation new create a new mutable variable. And now", "tokens": [490, 264, 2823, 11, 1804, 5893, 293, 264, 6916, 777, 1884, 257, 777, 5839, 712, 7006, 13, 400, 586], "temperature": 0.0, "avg_logprob": -0.19500769990863223, "compression_ratio": 1.612121212121212, "no_speech_prob": 3.534801726345904e-05}, {"id": 124, "seek": 97588, "start": 975.88, "end": 984.04, "text": " we can define our own mutate effect. Here mm is the local mutate effect defined here,", "tokens": [321, 393, 6964, 527, 1065, 5839, 473, 1802, 13, 1692, 11169, 307, 264, 2654, 5839, 473, 1802, 7642, 510, 11], "temperature": 0.0, "avg_logprob": -0.14989569879347278, "compression_ratio": 1.7389162561576355, "no_speech_prob": 2.7531885280041024e-05}, {"id": 125, "seek": 97588, "start": 984.04, "end": 990.64, "text": " which is just inheriting from mutate. And is nothing follows after the is, so it doesn't", "tokens": [597, 307, 445, 9484, 1748, 490, 5839, 473, 13, 400, 307, 1825, 10002, 934, 264, 307, 11, 370, 309, 1177, 380], "temperature": 0.0, "avg_logprob": -0.14989569879347278, "compression_ratio": 1.7389162561576355, "no_speech_prob": 2.7531885280041024e-05}, {"id": 126, "seek": 97588, "start": 990.64, "end": 997.2, "text": " do anything special, it is just a new sub feature in inheriting from mutate. So it basically", "tokens": [360, 1340, 2121, 11, 309, 307, 445, 257, 777, 1422, 4111, 294, 9484, 1748, 490, 5839, 473, 13, 407, 309, 1936], "temperature": 0.0, "avg_logprob": -0.14989569879347278, "compression_ratio": 1.7389162561576355, "no_speech_prob": 2.7531885280041024e-05}, {"id": 127, "seek": 97588, "start": 997.2, "end": 1005.68, "text": " only has the purpose of giving a new name to this is my local mutate here. And now we", "tokens": [787, 575, 264, 4334, 295, 2902, 257, 777, 1315, 281, 341, 307, 452, 2654, 5839, 473, 510, 13, 400, 586, 321], "temperature": 0.0, "avg_logprob": -0.14989569879347278, "compression_ratio": 1.7389162561576355, "no_speech_prob": 2.7531885280041024e-05}, {"id": 128, "seek": 100568, "start": 1005.68, "end": 1018.56, "text": " can pass this sub instance of mutate or the sub type of mutate to the ring here, which", "tokens": [393, 1320, 341, 1422, 5197, 295, 5839, 473, 420, 264, 1422, 2010, 295, 5839, 473, 281, 264, 4875, 510, 11, 597], "temperature": 0.0, "avg_logprob": -0.14361729092068143, "compression_ratio": 1.5818181818181818, "no_speech_prob": 1.5444795280927792e-05}, {"id": 129, "seek": 100568, "start": 1018.56, "end": 1027.96, "text": " means that all the mutable values that are created are created locally to the mm to our", "tokens": [1355, 300, 439, 264, 5839, 712, 4190, 300, 366, 2942, 366, 2942, 16143, 281, 264, 11169, 281, 527], "temperature": 0.0, "avg_logprob": -0.14361729092068143, "compression_ratio": 1.5818181818181818, "no_speech_prob": 1.5444795280927792e-05}, {"id": 130, "seek": 102796, "start": 1027.96, "end": 1040.2, "text": " own mutate effect. Now we still have to create this effect and execute the code within the", "tokens": [1065, 5839, 473, 1802, 13, 823, 321, 920, 362, 281, 1884, 341, 1802, 293, 14483, 264, 3089, 1951, 264], "temperature": 0.0, "avg_logprob": -0.1380366425016033, "compression_ratio": 1.6883116883116882, "no_speech_prob": 1.0450992704136297e-05}, {"id": 131, "seek": 102796, "start": 1040.2, "end": 1044.16, "text": " context of this effect, and this happens in the bottom here. So we create an instance", "tokens": [4319, 295, 341, 1802, 11, 293, 341, 2314, 294, 264, 2767, 510, 13, 407, 321, 1884, 364, 5197], "temperature": 0.0, "avg_logprob": -0.1380366425016033, "compression_ratio": 1.6883116883116882, "no_speech_prob": 1.0450992704136297e-05}, {"id": 132, "seek": 102796, "start": 1044.16, "end": 1053.52, "text": " of mm and use it to execute the demo code. And that means that the m dot f nth call", "tokens": [295, 11169, 293, 764, 309, 281, 14483, 264, 10723, 3089, 13, 400, 300, 1355, 300, 264, 275, 5893, 283, 297, 392, 818], "temperature": 0.0, "avg_logprob": -0.1380366425016033, "compression_ratio": 1.6883116883116882, "no_speech_prob": 1.0450992704136297e-05}, {"id": 133, "seek": 105352, "start": 1053.52, "end": 1061.8, "text": " here will then take the instance of mm from the current environment to create the new", "tokens": [510, 486, 550, 747, 264, 5197, 295, 11169, 490, 264, 2190, 2823, 281, 1884, 264, 777], "temperature": 0.0, "avg_logprob": -0.1634850391121798, "compression_ratio": 1.6729857819905214, "no_speech_prob": 1.1124495358671993e-05}, {"id": 134, "seek": 105352, "start": 1061.8, "end": 1067.52, "text": " mutable value. And when we run the demo, the same output, if we analyze it for effects", "tokens": [5839, 712, 2158, 13, 400, 562, 321, 1190, 264, 10723, 11, 264, 912, 5598, 11, 498, 321, 12477, 309, 337, 5065], "temperature": 0.0, "avg_logprob": -0.1634850391121798, "compression_ratio": 1.6729857819905214, "no_speech_prob": 1.1124495358671993e-05}, {"id": 135, "seek": 105352, "start": 1067.52, "end": 1072.72, "text": " now, we see it's the same effect. Apart from the mutate is gone, because the mutate is", "tokens": [586, 11, 321, 536, 309, 311, 264, 912, 1802, 13, 24111, 490, 264, 5839, 473, 307, 2780, 11, 570, 264, 5839, 473, 307], "temperature": 0.0, "avg_logprob": -0.1634850391121798, "compression_ratio": 1.6729857819905214, "no_speech_prob": 1.1124495358671993e-05}, {"id": 136, "seek": 105352, "start": 1072.72, "end": 1081.36, "text": " completely local here. So we can create code that locally to perform some calculation creates", "tokens": [2584, 2654, 510, 13, 407, 321, 393, 1884, 3089, 300, 16143, 281, 2042, 512, 17108, 7829], "temperature": 0.0, "avg_logprob": -0.1634850391121798, "compression_ratio": 1.6729857819905214, "no_speech_prob": 1.1124495358671993e-05}, {"id": 137, "seek": 108136, "start": 1081.36, "end": 1088.3999999999999, "text": " mutable data and mutates data structures. But the result is a pure function anyway,", "tokens": [5839, 712, 1412, 293, 5839, 1024, 1412, 9227, 13, 583, 264, 1874, 307, 257, 6075, 2445, 4033, 11], "temperature": 0.0, "avg_logprob": -0.15754953026771545, "compression_ratio": 1.4918032786885247, "no_speech_prob": 1.749992043187376e-05}, {"id": 138, "seek": 108136, "start": 1088.3999999999999, "end": 1097.1999999999998, "text": " because the mutation is only done locally. So I'm coming to the end. The fusion of status", "tokens": [570, 264, 27960, 307, 787, 1096, 16143, 13, 407, 286, 478, 1348, 281, 264, 917, 13, 440, 23100, 295, 6558], "temperature": 0.0, "avg_logprob": -0.15754953026771545, "compression_ratio": 1.4918032786885247, "no_speech_prob": 1.749992043187376e-05}, {"id": 139, "seek": 108136, "start": 1097.1999999999998, "end": 1103.84, "text": " is still under developing. It's a very experimental language, but the language definition is slowly", "tokens": [307, 920, 833, 6416, 13, 467, 311, 257, 588, 17069, 2856, 11, 457, 264, 2856, 7123, 307, 5692], "temperature": 0.0, "avg_logprob": -0.15754953026771545, "compression_ratio": 1.4918032786885247, "no_speech_prob": 1.749992043187376e-05}, {"id": 140, "seek": 110384, "start": 1103.84, "end": 1112.72, "text": " getting more stable. There's still a lot of work on the base library that is ongoing.", "tokens": [1242, 544, 8351, 13, 821, 311, 920, 257, 688, 295, 589, 322, 264, 3096, 6405, 300, 307, 10452, 13], "temperature": 0.0, "avg_logprob": -0.1836852815416124, "compression_ratio": 1.5869565217391304, "no_speech_prob": 4.936625828122487e-06}, {"id": 141, "seek": 110384, "start": 1112.72, "end": 1117.72, "text": " The current implementation has two back ends. One is a very slow interpreter running on", "tokens": [440, 2190, 11420, 575, 732, 646, 5314, 13, 1485, 307, 257, 588, 2964, 34132, 2614, 322], "temperature": 0.0, "avg_logprob": -0.1836852815416124, "compression_ratio": 1.5869565217391304, "no_speech_prob": 4.936625828122487e-06}, {"id": 142, "seek": 110384, "start": 1117.72, "end": 1125.8, "text": " the JVM, and the other is a C back end, which also used the beam demo visor garbage collector,", "tokens": [264, 508, 53, 44, 11, 293, 264, 661, 307, 257, 383, 646, 917, 11, 597, 611, 1143, 264, 14269, 10723, 1452, 284, 14150, 23960, 11], "temperature": 0.0, "avg_logprob": -0.1836852815416124, "compression_ratio": 1.5869565217391304, "no_speech_prob": 4.936625828122487e-06}, {"id": 143, "seek": 110384, "start": 1125.8, "end": 1132.08, "text": " which we just learned about as a garbage collector right now, but I would like to have a precise", "tokens": [597, 321, 445, 3264, 466, 382, 257, 14150, 23960, 558, 586, 11, 457, 286, 576, 411, 281, 362, 257, 13600], "temperature": 0.0, "avg_logprob": -0.1836852815416124, "compression_ratio": 1.5869565217391304, "no_speech_prob": 4.936625828122487e-06}, {"id": 144, "seek": 113208, "start": 1132.08, "end": 1139.08, "text": " garbage collector and add a lot there as well. And basic analysis tools like you've seen", "tokens": [14150, 23960, 293, 909, 257, 688, 456, 382, 731, 13, 400, 3875, 5215, 3873, 411, 291, 600, 1612], "temperature": 0.0, "avg_logprob": -0.16251079738140106, "compression_ratio": 1.4555555555555555, "no_speech_prob": 1.861840792116709e-05}, {"id": 145, "seek": 113208, "start": 1139.08, "end": 1147.36, "text": " for the effects here are available. And yes, those who remember Ellie might wonder who", "tokens": [337, 264, 5065, 510, 366, 2435, 13, 400, 2086, 11, 729, 567, 1604, 27151, 1062, 2441, 567], "temperature": 0.0, "avg_logprob": -0.16251079738140106, "compression_ratio": 1.4555555555555555, "no_speech_prob": 1.861840792116709e-05}, {"id": 146, "seek": 113208, "start": 1147.36, "end": 1155.3999999999999, "text": " is disturbing me now from while I'm working on this is Felix. That's it. That's coming", "tokens": [307, 21903, 385, 586, 490, 1339, 286, 478, 1364, 322, 341, 307, 30169, 13, 663, 311, 309, 13, 663, 311, 1348], "temperature": 0.0, "avg_logprob": -0.16251079738140106, "compression_ratio": 1.4555555555555555, "no_speech_prob": 1.861840792116709e-05}, {"id": 147, "seek": 115540, "start": 1155.4, "end": 1165.52, "text": " to the end. So maybe one more sentence. I hope I could show you that algebraic effects", "tokens": [281, 264, 917, 13, 407, 1310, 472, 544, 8174, 13, 286, 1454, 286, 727, 855, 291, 300, 21989, 299, 5065], "temperature": 0.0, "avg_logprob": -0.16666305632818312, "compression_ratio": 1.353846153846154, "no_speech_prob": 9.222201697411947e-06}, {"id": 148, "seek": 115540, "start": 1165.52, "end": 1173.0, "text": " and types as first class features are something that complements one another pretty well.", "tokens": [293, 3467, 382, 700, 1508, 4122, 366, 746, 300, 715, 17988, 472, 1071, 1238, 731, 13], "temperature": 0.0, "avg_logprob": -0.16666305632818312, "compression_ratio": 1.353846153846154, "no_speech_prob": 9.222201697411947e-06}, {"id": 149, "seek": 117300, "start": 1173.0, "end": 1186.88, "text": " It helps to create code, then encapsulates non-functional effects, and yeah, that makes", "tokens": [467, 3665, 281, 1884, 3089, 11, 550, 38745, 26192, 2107, 12, 22845, 304, 5065, 11, 293, 1338, 11, 300, 1669], "temperature": 0.0, "avg_logprob": -0.15539955025288596, "compression_ratio": 1.4943181818181819, "no_speech_prob": 1.6184256310225464e-05}, {"id": 150, "seek": 117300, "start": 1186.88, "end": 1192.68, "text": " it possible to work with this and work even with code that is not pure, but to manage", "tokens": [309, 1944, 281, 589, 365, 341, 293, 589, 754, 365, 3089, 300, 307, 406, 6075, 11, 457, 281, 3067], "temperature": 0.0, "avg_logprob": -0.15539955025288596, "compression_ratio": 1.4943181818181819, "no_speech_prob": 1.6184256310225464e-05}, {"id": 151, "seek": 117300, "start": 1192.68, "end": 1201.36, "text": " this in a nice way. You find some links here to resources related to fusion. We are happy", "tokens": [341, 294, 257, 1481, 636, 13, 509, 915, 512, 6123, 510, 281, 3593, 4077, 281, 23100, 13, 492, 366, 2055], "temperature": 0.0, "avg_logprob": -0.15539955025288596, "compression_ratio": 1.4943181818181819, "no_speech_prob": 1.6184256310225464e-05}, {"id": 152, "seek": 120136, "start": 1201.36, "end": 1207.8, "text": " for everyone who gets involved. Please have a look. Join us. We are a small team currently", "tokens": [337, 1518, 567, 2170, 3288, 13, 2555, 362, 257, 574, 13, 19642, 505, 13, 492, 366, 257, 1359, 1469, 4362], "temperature": 0.0, "avg_logprob": -0.2659326309853412, "compression_ratio": 1.2962962962962963, "no_speech_prob": 0.0001585629943292588}, {"id": 153, "seek": 120136, "start": 1207.8, "end": 1218.8, "text": " from three working on this. We can, there should be more. Yeah. Thank you very much.", "tokens": [490, 1045, 1364, 322, 341, 13, 492, 393, 11, 456, 820, 312, 544, 13, 865, 13, 1044, 291, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.2659326309853412, "compression_ratio": 1.2962962962962963, "no_speech_prob": 0.0001585629943292588}, {"id": 154, "seek": 121880, "start": 1218.8, "end": 1233.8, "text": " Can I pick? Yeah. You think you were first? So earlier you said that a particular type", "tokens": [1664, 286, 1888, 30, 865, 13, 509, 519, 291, 645, 700, 30, 407, 3071, 291, 848, 300, 257, 1729, 2010], "temperature": 0.0, "avg_logprob": -0.45826729763759655, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.0006505298078991473}, {"id": 155, "seek": 121880, "start": 1233.8, "end": 1238.8, "text": " can influence numeric, that all terminology you used, but is it a numeric interface? And", "tokens": [393, 6503, 7866, 299, 11, 300, 439, 27575, 291, 1143, 11, 457, 307, 309, 257, 7866, 299, 9226, 30, 400], "temperature": 0.0, "avg_logprob": -0.45826729763759655, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.0006505298078991473}, {"id": 156, "seek": 121880, "start": 1238.8, "end": 1239.8, "text": " then you were able to say A plus B. If you didn't say that influence numeric, what would", "tokens": [550, 291, 645, 1075, 281, 584, 316, 1804, 363, 13, 759, 291, 994, 380, 584, 300, 6503, 7866, 299, 11, 437, 576], "temperature": 0.0, "avg_logprob": -0.45826729763759655, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.0006505298078991473}, {"id": 157, "seek": 121880, "start": 1239.8, "end": 1246.48, "text": " happen if you tried to compile that program? The question was if a particular type would", "tokens": [1051, 498, 291, 3031, 281, 31413, 300, 1461, 30, 440, 1168, 390, 498, 257, 1729, 2010, 576], "temperature": 0.0, "avg_logprob": -0.45826729763759655, "compression_ratio": 1.6418604651162791, "no_speech_prob": 0.0006505298078991473}, {"id": 158, "seek": 124648, "start": 1246.48, "end": 1252.24, "text": " not implement numeric, and you would use the plus in there, what would happen then?", "tokens": [406, 4445, 7866, 299, 11, 293, 291, 576, 764, 264, 1804, 294, 456, 11, 437, 576, 1051, 550, 30], "temperature": 0.0, "avg_logprob": -0.14503351148668225, "compression_ratio": 1.7, "no_speech_prob": 7.0261383370962e-05}, {"id": 159, "seek": 124648, "start": 1252.24, "end": 1257.64, "text": " You would get a compile time error. It's completely strict typing. So if you call a function that", "tokens": [509, 576, 483, 257, 31413, 565, 6713, 13, 467, 311, 2584, 10910, 18444, 13, 407, 498, 291, 818, 257, 2445, 300], "temperature": 0.0, "avg_logprob": -0.14503351148668225, "compression_ratio": 1.7, "no_speech_prob": 7.0261383370962e-05}, {"id": 160, "seek": 124648, "start": 1257.64, "end": 1263.6, "text": " requires a numeric type parameter, and you call it with say a string, what string happens", "tokens": [7029, 257, 7866, 299, 2010, 13075, 11, 293, 291, 818, 309, 365, 584, 257, 6798, 11, 437, 6798, 2314], "temperature": 0.0, "avg_logprob": -0.14503351148668225, "compression_ratio": 1.7, "no_speech_prob": 7.0261383370962e-05}, {"id": 161, "seek": 124648, "start": 1263.6, "end": 1270.84, "text": " to have a plus, but not the numeric plus, you will get an error that type, the actual", "tokens": [281, 362, 257, 1804, 11, 457, 406, 264, 7866, 299, 1804, 11, 291, 486, 483, 364, 6713, 300, 2010, 11, 264, 3539], "temperature": 0.0, "avg_logprob": -0.14503351148668225, "compression_ratio": 1.7, "no_speech_prob": 7.0261383370962e-05}, {"id": 162, "seek": 127084, "start": 1270.84, "end": 1276.6399999999999, "text": " type parameter is not compatible to the type constrained in the call feature, so that will", "tokens": [2010, 13075, 307, 406, 18218, 281, 264, 2010, 38901, 294, 264, 818, 4111, 11, 370, 300, 486], "temperature": 0.0, "avg_logprob": -0.28376682505888096, "compression_ratio": 1.6511627906976745, "no_speech_prob": 4.0663853724254295e-05}, {"id": 163, "seek": 127084, "start": 1276.6399999999999, "end": 1281.56, "text": " not be an example. You were converting the value to string in order to print it. Is", "tokens": [406, 312, 364, 1365, 13, 509, 645, 29942, 264, 2158, 281, 6798, 294, 1668, 281, 4482, 309, 13, 1119], "temperature": 0.0, "avg_logprob": -0.28376682505888096, "compression_ratio": 1.6511627906976745, "no_speech_prob": 4.0663853724254295e-05}, {"id": 164, "seek": 127084, "start": 1281.56, "end": 1290.08, "text": " the string operation implied to be present for every value? There's a two string operation", "tokens": [264, 6798, 6916, 32614, 281, 312, 1974, 337, 633, 2158, 30, 821, 311, 257, 732, 6798, 6916], "temperature": 0.0, "avg_logprob": -0.28376682505888096, "compression_ratio": 1.6511627906976745, "no_speech_prob": 4.0663853724254295e-05}, {"id": 165, "seek": 127084, "start": 1290.08, "end": 1298.24, "text": " in our any, which is the parent of any feature. So a two string is always available, yes.", "tokens": [294, 527, 604, 11, 597, 307, 264, 2596, 295, 604, 4111, 13, 407, 257, 732, 6798, 307, 1009, 2435, 11, 2086, 13], "temperature": 0.0, "avg_logprob": -0.28376682505888096, "compression_ratio": 1.6511627906976745, "no_speech_prob": 4.0663853724254295e-05}, {"id": 166, "seek": 129824, "start": 1298.24, "end": 1304.96, "text": " It's not very helpful if you don't define anything, because you just, it's a second,", "tokens": [467, 311, 406, 588, 4961, 498, 291, 500, 380, 6964, 1340, 11, 570, 291, 445, 11, 309, 311, 257, 1150, 11], "temperature": 0.0, "avg_logprob": -0.5375232053606698, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.0012000048300251365}, {"id": 167, "seek": 129824, "start": 1304.96, "end": 1309.36, "text": " the next speaker setup, which I'm contributing to the language called NIM, which also have", "tokens": [264, 958, 8145, 8657, 11, 597, 286, 478, 19270, 281, 264, 2856, 1219, 426, 6324, 11, 597, 611, 362], "temperature": 0.0, "avg_logprob": -0.5375232053606698, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.0012000048300251365}, {"id": 168, "seek": 129824, "start": 1309.36, "end": 1317.0, "text": " my effect types, and ad hoc, more important, generic call. One problem that I've seen in", "tokens": [452, 1802, 3467, 11, 293, 614, 16708, 11, 544, 1021, 11, 19577, 818, 13, 1485, 1154, 300, 286, 600, 1612, 294], "temperature": 0.0, "avg_logprob": -0.5375232053606698, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.0012000048300251365}, {"id": 169, "seek": 129824, "start": 1317.0, "end": 1322.92, "text": " combining these features is that when you have generic call, you often don't, the concrete", "tokens": [21928, 613, 4122, 307, 300, 562, 291, 362, 19577, 818, 11, 291, 2049, 500, 380, 11, 264, 9859], "temperature": 0.0, "avg_logprob": -0.5375232053606698, "compression_ratio": 1.5570175438596492, "no_speech_prob": 0.0012000048300251365}, {"id": 170, "seek": 132292, "start": 1322.92, "end": 1329.8400000000001, "text": " instantiations may trigger different effects. So how do you approach this, and syntactically", "tokens": [9836, 72, 763, 815, 7875, 819, 5065, 13, 407, 577, 360, 291, 3109, 341, 11, 293, 23980, 578, 984], "temperature": 0.0, "avg_logprob": -0.36689177013578866, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00011746239033527672}, {"id": 171, "seek": 132292, "start": 1329.8400000000001, "end": 1341.1200000000001, "text": " or semi-events, semi-table language? The question was that actual code can actually", "tokens": [420, 12909, 12, 13379, 791, 11, 12909, 12, 83, 712, 2856, 30, 440, 1168, 390, 300, 3539, 3089, 393, 767], "temperature": 0.0, "avg_logprob": -0.36689177013578866, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00011746239033527672}, {"id": 172, "seek": 132292, "start": 1341.1200000000001, "end": 1346.16, "text": " trigger all sorts of different actual effects at runtime, so you could have, one example", "tokens": [7875, 439, 7527, 295, 819, 3539, 5065, 412, 34474, 11, 370, 291, 727, 362, 11, 472, 1365], "temperature": 0.0, "avg_logprob": -0.36689177013578866, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00011746239033527672}, {"id": 173, "seek": 132292, "start": 1346.16, "end": 1352.0, "text": " I think of, you could have a function converting an object to a string that maybe performs", "tokens": [286, 519, 295, 11, 291, 727, 362, 257, 2445, 29942, 364, 2657, 281, 257, 6798, 300, 1310, 26213], "temperature": 0.0, "avg_logprob": -0.36689177013578866, "compression_ratio": 1.6181818181818182, "no_speech_prob": 0.00011746239033527672}, {"id": 174, "seek": 135200, "start": 1352.0, "end": 1359.4, "text": " some logging, and some code printing that value would not expect that. My answer to", "tokens": [512, 27991, 11, 293, 512, 3089, 14699, 300, 2158, 576, 406, 2066, 300, 13, 1222, 1867, 281], "temperature": 0.0, "avg_logprob": -0.12659698062472874, "compression_ratio": 1.6111111111111112, "no_speech_prob": 3.9437545638065785e-05}, {"id": 175, "seek": 135200, "start": 1359.4, "end": 1366.64, "text": " that is, that must be part of the static analysis. We need to analyze the whole application", "tokens": [300, 307, 11, 300, 1633, 312, 644, 295, 264, 13437, 5215, 13, 492, 643, 281, 12477, 264, 1379, 3861], "temperature": 0.0, "avg_logprob": -0.12659698062472874, "compression_ratio": 1.6111111111111112, "no_speech_prob": 3.9437545638065785e-05}, {"id": 176, "seek": 135200, "start": 1366.64, "end": 1372.44, "text": " and see what is happening there. Library functions can do this to a certain extent,", "tokens": [293, 536, 437, 307, 2737, 456, 13, 12806, 6828, 393, 360, 341, 281, 257, 1629, 8396, 11], "temperature": 0.0, "avg_logprob": -0.12659698062472874, "compression_ratio": 1.6111111111111112, "no_speech_prob": 3.9437545638065785e-05}, {"id": 177, "seek": 135200, "start": 1372.44, "end": 1378.08, "text": " but they cannot predict if you have a dynamic value coming in, what the actual type will", "tokens": [457, 436, 2644, 6069, 498, 291, 362, 257, 8546, 2158, 1348, 294, 11, 437, 264, 3539, 2010, 486], "temperature": 0.0, "avg_logprob": -0.12659698062472874, "compression_ratio": 1.6111111111111112, "no_speech_prob": 3.9437545638065785e-05}, {"id": 178, "seek": 137808, "start": 1378.08, "end": 1385.08, "text": " be, so we need a whole program analysis in the end there. Do we have time for one more?", "tokens": [312, 11, 370, 321, 643, 257, 1379, 1461, 5215, 294, 264, 917, 456, 13, 1144, 321, 362, 565, 337, 472, 544, 30], "temperature": 0.0, "avg_logprob": -0.27633967766394985, "compression_ratio": 1.0740740740740742, "no_speech_prob": 0.00014411100710276514}, {"id": 179, "seek": 138508, "start": 1385.08, "end": 1411.08, "text": " Yeah, another approach to have pure functional function and side effects is, like Haskell", "tokens": [865, 11, 1071, 3109, 281, 362, 6075, 11745, 2445, 293, 1252, 5065, 307, 11, 411, 8646, 43723], "temperature": 0.0, "avg_logprob": -0.6949245816185361, "compression_ratio": 1.1265822784810127, "no_speech_prob": 0.0110660120844841}, {"id": 180, "seek": 141108, "start": 1411.08, "end": 1418.08, "text": " can do this. So I find it really interesting that with this language, it's possible to", "tokens": [393, 360, 341, 13, 407, 286, 915, 309, 534, 1880, 300, 365, 341, 2856, 11, 309, 311, 1944, 281], "temperature": 0.0, "avg_logprob": -0.4804630078767475, "compression_ratio": 1.723809523809524, "no_speech_prob": 0.0043599363416433334}, {"id": 181, "seek": 141108, "start": 1418.08, "end": 1424.08, "text": " get rid of the effect of the algebraic effect. Is that like a decision, or do other languages", "tokens": [483, 3973, 295, 264, 1802, 295, 264, 21989, 299, 1802, 13, 1119, 300, 411, 257, 3537, 11, 420, 360, 661, 8650], "temperature": 0.0, "avg_logprob": -0.4804630078767475, "compression_ratio": 1.723809523809524, "no_speech_prob": 0.0043599363416433334}, {"id": 182, "seek": 141108, "start": 1424.08, "end": 1431.08, "text": " like Unison, for example, also use algebraic effects, also have these features, and isn't", "tokens": [411, 1156, 2770, 11, 337, 1365, 11, 611, 764, 21989, 299, 5065, 11, 611, 362, 613, 4122, 11, 293, 1943, 380], "temperature": 0.0, "avg_logprob": -0.4804630078767475, "compression_ratio": 1.723809523809524, "no_speech_prob": 0.0043599363416433334}, {"id": 183, "seek": 141108, "start": 1431.08, "end": 1437.08, "text": " that also like kind of, is it like on purpose, or is it like, what are the pros and cons of", "tokens": [300, 611, 411, 733, 295, 11, 307, 309, 411, 322, 4334, 11, 420, 307, 309, 411, 11, 437, 366, 264, 6267, 293, 1014, 295], "temperature": 0.0, "avg_logprob": -0.4804630078767475, "compression_ratio": 1.723809523809524, "no_speech_prob": 0.0043599363416433334}, {"id": 184, "seek": 143708, "start": 1437.08, "end": 1443.08, "text": " it? So the question was, in Haskell you have monads, which have a similar role like the", "tokens": [309, 30, 407, 264, 1168, 390, 11, 294, 8646, 43723, 291, 362, 1108, 5834, 11, 597, 362, 257, 2531, 3090, 411, 264], "temperature": 0.0, "avg_logprob": -0.1612076809531764, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.747676813276485e-05}, {"id": 185, "seek": 143708, "start": 1443.08, "end": 1448.08, "text": " effects, but you have them always explicitly, you have to carry them around and mark them.", "tokens": [5065, 11, 457, 291, 362, 552, 1009, 20803, 11, 291, 362, 281, 3985, 552, 926, 293, 1491, 552, 13], "temperature": 0.0, "avg_logprob": -0.1612076809531764, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.747676813276485e-05}, {"id": 186, "seek": 143708, "start": 1448.08, "end": 1453.58, "text": " And the answer is here, this is actually, it's on purpose, we don't want to have the hassle", "tokens": [400, 264, 1867, 307, 510, 11, 341, 307, 767, 11, 309, 311, 322, 4334, 11, 321, 500, 380, 528, 281, 362, 264, 39526], "temperature": 0.0, "avg_logprob": -0.1612076809531764, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.747676813276485e-05}, {"id": 187, "seek": 143708, "start": 1453.58, "end": 1462.08, "text": " of wrapping everything into a monad and carrying it around all the time. So the idea is to get", "tokens": [295, 21993, 1203, 666, 257, 1108, 345, 293, 9792, 309, 926, 439, 264, 565, 13, 407, 264, 1558, 307, 281, 483], "temperature": 0.0, "avg_logprob": -0.1612076809531764, "compression_ratio": 1.6294642857142858, "no_speech_prob": 9.747676813276485e-05}, {"id": 188, "seek": 146208, "start": 1462.08, "end": 1469.08, "text": " rid of this as much as possible without losing the information you get from the effects.", "tokens": [3973, 295, 341, 382, 709, 382, 1944, 1553, 7027, 264, 1589, 291, 483, 490, 264, 5065, 13], "temperature": 0.0, "avg_logprob": -0.16596635612281593, "compression_ratio": 1.2432432432432432, "no_speech_prob": 9.733012120705098e-05}, {"id": 189, "seek": 146208, "start": 1469.08, "end": 1471.08, "text": " Time's up.", "tokens": [6161, 311, 493, 13], "temperature": 0.0, "avg_logprob": -0.16596635612281593, "compression_ratio": 1.2432432432432432, "no_speech_prob": 9.733012120705098e-05}, {"id": 190, "seek": 147108, "start": 1471.08, "end": 1493.08, "text": " Okay. Thank you for all the questions.", "tokens": [50364, 1033, 13, 1044, 291, 337, 439, 264, 1651, 13, 51464], "temperature": 0.0, "avg_logprob": -0.30362367630004883, "compression_ratio": 0.8260869565217391, "no_speech_prob": 0.0012767085572704673}], "language": "en"}