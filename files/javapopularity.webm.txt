[00:00.000 --> 00:12.440]  Okay, so good morning and welcome. It is great to be here in person. Now, what I'm obviously
[00:12.440 --> 00:19.680]  going to talk about is the idea of why is Java as a platform and as a programming language
[00:19.680 --> 00:26.080]  still so popular even after nearly 30 years? Can you believe it's going to be 28 years
[00:26.080 --> 00:31.640]  in May since Java was first released? The first thing that we need to kind of think
[00:31.640 --> 00:36.880]  about when we're talking in this respect is what do we mean by popularity? Because there's
[00:36.880 --> 00:41.480]  many different ways of measuring popularity. If you think about something like music, you
[00:41.480 --> 00:46.520]  know, you can say Ed Sheeran, for example, is popular. And you can measure that popularity
[00:46.520 --> 00:52.680]  by saying he sells so many albums, he sells so many downloads, he can fill seats at stadiums
[00:52.680 --> 00:58.120]  when he plays live. So that's an easy way to measure popularity of something like that.
[00:58.120 --> 01:03.400]  But when it comes to programming languages, when it comes to platforms, how do you measure
[01:03.400 --> 01:09.360]  their popularity? Well, one way is at conferences like this. If you want to do a presentation
[01:09.360 --> 01:14.520]  on a particular platform, how many people are going to turn up to listen to you talk?
[01:14.520 --> 01:20.280]  But from a wider perspective, there are people who do surveys. And there's a couple that
[01:20.320 --> 01:27.160]  we look at on a fairly regular basis. So who's heard of the Tiobi Index? Okay, yeah, a lot
[01:27.160 --> 01:30.520]  of people have heard of the Tiobi Index. Now, this is kind of a weird one because Tiobi
[01:30.520 --> 01:36.440]  actually stands for the importance of being earnest. Why? I mean, why does that have anything
[01:36.440 --> 01:41.360]  to do with programming languages? But for some reason, that's what they call it. So the
[01:41.360 --> 01:47.000]  Tiobi Index is one that tracks how popular programming languages are by looking at things
[01:47.040 --> 01:52.200]  in terms of metrics, like the number of job opportunities that are being advertised, the
[01:52.200 --> 01:58.360]  number of GitHub projects, the number of questions that are posed on Stack Overflow, things like
[01:58.360 --> 02:04.480]  that. And what we've seen with Java is it has maintained a very consistent level of popularity.
[02:04.480 --> 02:12.680]  It's literally been in the top three for the last probably 10 or so years until January.
[02:12.680 --> 02:17.520]  This year, it dropped to fourth place, which is a bit of a surprise. But I don't think
[02:17.520 --> 02:21.600]  that that is really a trend that we're going to see continuing. It's not going to be slipping
[02:21.600 --> 02:26.200]  further and further down. Two reasons for that. First is if you look at the numbers
[02:26.200 --> 02:32.000]  that were in that survey, firstly, Java actually went up in terms of popularity. So even though
[02:32.000 --> 02:37.160]  it dropped in terms of its overall ranking, its popularity actually went up. And the second
[02:37.200 --> 02:43.400]  thing is that the one below it is actually seen sharp, and that has less than half the
[02:43.400 --> 02:48.160]  popularity level that Java does. So I think we're some way away from seeing Java losing
[02:48.160 --> 02:55.000]  its popularity. So let's talk about why Java is so popular. First thing we need to look
[02:55.000 --> 03:04.000]  at is why or what made Java popular in the first place. And if we go right back to 1995,
[03:04.680 --> 03:10.680]  I'm going to ask, anybody here remember the launch of Java? Anybody here? Okay, good,
[03:10.680 --> 03:16.800]  because there's a few old people in the audience. Excellent. And this was what really made Java
[03:16.800 --> 03:22.000]  something that people got excited about. This little dancing duke here, because essentially
[03:22.000 --> 03:29.000]  what you had before Java was web browsing that was static. So there was no way of including
[03:29.720 --> 03:35.240]  interesting functionality in a web page. I mean, again, I'm old enough to remember
[03:35.240 --> 03:40.920]  Mosaic. Anybody remember Mosaic? Oh, good. Okay, yes. Mosaic is a web browser. Now that
[03:40.920 --> 03:47.420]  was purely text. Even if you wanted to show an image, you had to fire up an external application
[03:47.420 --> 03:53.240]  to render the image. That's how basic it was. So when Netscape came along and they
[03:53.240 --> 03:58.840]  included Java into their browser, suddenly there was this wonderful way of programming
[03:58.880 --> 04:04.560]  things and including applets. So that really fired up Java. People got excited about the
[04:04.560 --> 04:10.720]  idea of right once, run anywhere. You could move your application from one platform to
[04:10.720 --> 04:17.720]  another without having to change the code, without having to recompile it. Now, to continue
[04:17.840 --> 04:23.280]  that popularity, one of the things that was a bit of a drawback, if you like, was that
[04:23.320 --> 04:29.680]  it was controlled by one company. It was Sun Microsystems and they sort of wanted to maintain
[04:29.680 --> 04:33.640]  control over Java because it was something they'd invested in and they wanted to try
[04:33.640 --> 04:39.400]  and make money from it, very logically. But people were sort of pushed for an open standard.
[04:39.400 --> 04:46.400]  People really wanted more openness around the whole idea of Java. So in 1999, we got
[04:46.520 --> 04:53.520]  the Java community process. Now, rather than having, like, ANSI or ECMA, drive the standard
[04:54.280 --> 04:59.280]  of Java, there was an open standard, but it was one that Sun still maintained a level
[04:59.280 --> 05:04.000]  of control over. But this was good because it maintained that popularity. And then the
[05:04.000 --> 05:11.000]  next thing in 1999 was also a shift in terms of how people use Java. Rather than applets,
[05:11.520 --> 05:16.260]  rather than desktop applications, which had been very exciting at the beginning, it turned
[05:16.280 --> 05:21.820]  out that wasn't really the best place to use Java. And what we've seen is the shift of
[05:21.820 --> 05:28.340]  Java onto the server side. That's where Java really hits its sweet spot. Server side applications,
[05:28.340 --> 05:34.180]  the ability to scale to internet workloads, the ability to deliver on those types of things.
[05:34.180 --> 05:39.540]  And we got Java EE, enterprise edition. We got serverless. We got EJBs, all those good
[05:39.540 --> 05:45.820]  things. And again, that sort of morphed as well. So we now see things like Spring, who
[05:45.860 --> 05:50.260]  here uses Spring? Okay, yeah, lots of people use Spring. So it's very, very popular as
[05:50.260 --> 05:55.980]  a framework for developing enterprise applications. And again, we've seen that sort of migration
[05:55.980 --> 06:02.980]  away from the JCP to the Eclipse Foundation for Java Enterprise Edition. And now we've
[06:03.540 --> 06:10.540]  got Jakarta EE. And then moving forward again, in terms of making and continuing to deliver
[06:11.180 --> 06:18.180]  on the popularity of Java, the thing that Sun did then was to say, okay, we'll actually
[06:18.180 --> 06:25.180]  open source the whole platform. This was really a push because Apache had the Harmony Project.
[06:25.180 --> 06:30.300]  There was IBM, who were very heavily involved in that. And they wanted to create an open
[06:30.300 --> 06:37.020]  source version of Java. Sun resisted the push to do that for quite a long time. But eventually
[06:37.040 --> 06:41.940]  they said, okay, there is going to be an open source Java. At some point, it might as well
[06:41.940 --> 06:48.660]  be ours. And they created open JDK. Now, initially in 2006, that was just the hotspot virtual
[06:48.660 --> 06:53.380]  machine and the Java compiler. There was a lot of due diligence needed to be done in
[06:53.380 --> 06:58.220]  order to actually ensure that they had the rights to open source all of the code that
[06:58.220 --> 07:02.380]  was included in the JDK. Because there was lots of stuff that had been contributed by
[07:02.420 --> 07:09.420]  other companies. So it wasn't till 2007. And in fact, it was JDK7 built with 31, which
[07:12.260 --> 07:17.180]  was the first that you could actually build completely from the open source in the open
[07:17.180 --> 07:24.180]  JDK. And what that's led to is a huge growth in terms of contributions from the community.
[07:26.860 --> 07:31.380]  This is the wonderful thing about this as a project. It hasn't just been Sun and then
[07:31.380 --> 07:37.700]  obviously Oracle once they acquired Sun Microsystems back in 2010. We've seen lots of companies
[07:37.700 --> 07:43.540]  contributing all sorts of engineering, all sorts of work to the open JDK project. And
[07:43.540 --> 07:47.100]  I've listed, you know, not all of the contributors here. This is just, you know, some of the
[07:47.100 --> 07:52.820]  bigger ones who add not just bug fixes, but new features as well. You know, we've seen
[07:52.820 --> 07:59.580]  things like Shenandoah from Red Hat. We've seen all sorts of different projects being
[07:59.620 --> 08:05.300]  added to the JDK, not just from Oracle. So this is really what's helped to drive that
[08:05.300 --> 08:11.100]  popularity is it's been open standard, it's been open source, and it's very popular on
[08:11.100 --> 08:18.100]  the server side. So what makes, what makes Java so popular today? Why are we still seeing
[08:18.740 --> 08:25.020]  Java's popularity? One of those things, and Hilton sort of mentioned this at the beginning,
[08:25.060 --> 08:31.060]  is the fact that we're now seeing Java evolving much more quickly. It used to be that we had
[08:31.060 --> 08:38.060]  two, three, even four years between releases of Java. And now, since JDK 9 back in 2017,
[08:39.660 --> 08:44.180]  we have two releases a year. That's really quite significant. So there's a lot more
[08:44.180 --> 08:49.420]  progress in terms of delivering on the new features that programmers want, developers
[08:49.460 --> 08:54.820]  want. In order to keep that language fresh, keep it appealing to developers so that they
[08:54.820 --> 08:59.620]  can continue to do the things that they want to do. And as the architectures shift, you
[08:59.620 --> 09:04.580]  know, to things like microservices, and that type of approach, the language needs to adapt
[09:04.580 --> 09:11.940]  to that. And we've seen that. We've seen over several releases a number of new features
[09:11.940 --> 09:17.780]  being added to the Java platform, to the Java language, which is keeping it fresh, and therefore
[09:17.800 --> 09:24.300]  driving its popularity even further, keeping it at that level. Obviously, JDK 8 introduced
[09:24.300 --> 09:29.660]  the idea of lambdas and streams, which gave us a way of doing functional programming in
[09:29.660 --> 09:35.660]  Java. And I think lots of people here would agree that JDK 8 was a big release. It was
[09:35.660 --> 09:39.180]  one where suddenly people went, oh, this is great. Now I can do all these cool things
[09:39.180 --> 09:46.180]  with streams and lambdas and stuff like that. JDK 9 introduced modularity, a bit of a divisive
[09:46.580 --> 09:53.580]  one in terms of a feature. Lots of people didn't really see the benefit of it directly.
[09:53.620 --> 09:57.940]  But what we have seen now that we are moving to microservices and we want to put things
[09:57.940 --> 10:04.140]  into containers, the ability to use modules, the ability to use JLink to create a runtime
[10:04.140 --> 10:10.700]  which is tailored specifically to your application is very powerful. It means we can reduce from
[10:10.740 --> 10:17.020]  sort of 300 megabytes as a Java runtime down to maybe 40 or 50 megabytes by only including
[10:17.020 --> 10:22.100]  modules that we need for our service. So that's a very powerful thing, even though it's not
[10:22.100 --> 10:28.820]  a language level thing. JDK 10, local variable type inference. So, you know, Java script's
[10:28.820 --> 10:33.300]  got it. It must be good. Let's add it to Java. Again, you know, it's one of those sort of
[10:33.300 --> 10:40.300]  minor features, but still something that people liked. Then in JDK 14, we got records. That's
[10:40.380 --> 10:46.380]  another big thing, I think, where people suddenly had the ability to create data types and rather
[10:46.380 --> 10:51.820]  than having lots of boilerplate code for all of the classes that just wrapped a few values,
[10:51.820 --> 10:56.540]  suddenly you could use a single line and define a record with a set of values that you want
[10:56.540 --> 11:02.620]  to store in there. Seal classes in JDK 15. Many people look at it and go, I don't get
[11:02.620 --> 11:08.140]  why I need seal classes, but when you start getting into pattern matching and the idea
[11:08.180 --> 11:14.780]  of switch using pattern matching and having exhaustiveness in that switch, then seal types
[11:14.780 --> 11:19.060]  do make a lot of sense. And pattern matching is really the kind of big thing that we've
[11:19.060 --> 11:23.660]  seen over the last few releases. Pattern matching, for instance, of pattern matching for switch,
[11:23.660 --> 11:28.300]  pattern matching for records, all of which is taking that sort of some of the rough edges
[11:28.300 --> 11:32.860]  off the language and just making it a little easier for developers and then maintaining
[11:32.860 --> 11:39.860]  that popularity. And in terms of some of the bigger features as well, OpenJDK is driving
[11:41.620 --> 11:47.460]  those projects. We've got things like AMBA, which is the whole idea of the small language
[11:47.460 --> 11:51.940]  features like records, like pattern matching and so on. But then there are other ones like
[11:51.940 --> 11:58.180]  Lume, that came in JDK 19 initially. We've seen some more stuff coming in JDK 20. That's
[11:58.220 --> 12:04.500]  another very exciting thing from the point of view of scalability of Java applications.
[12:04.500 --> 12:10.580]  If you have a server-side application that has lots of connections coming in simultaneously,
[12:10.580 --> 12:15.380]  but those connections are IO bound, meaning you have to wait a long time for something
[12:15.380 --> 12:20.700]  to happen in terms of IO, using virtual threads through Project Lume is going to increase
[12:20.700 --> 12:27.700]  the scalability of that application by orders of magnitude and make it much more performant.
[12:28.940 --> 12:33.940]  Project Panama, replacement for JNI. So now we have foreign function interfaces, foreign
[12:33.940 --> 12:39.620]  memory interfaces. Anybody here use JNI? A few people. I remember talking to one of
[12:39.620 --> 12:43.740]  the people who initially designed JNI and I said, it's always a little bit complicated
[12:43.740 --> 12:48.220]  to use that. You've got to do this like header files and then you've got to find the right
[12:48.220 --> 12:52.580]  libraries and stuff like that. He said, yes, we designed it that way. And I thought that's
[12:52.580 --> 12:56.940]  not really the idea, is it? You don't want to design something to be difficult to use.
[12:56.940 --> 13:03.700]  But that was their guiding principle. So Panama is about making that much easier. Valhalla,
[13:03.700 --> 13:09.940]  we haven't really seen much of that yet, but that's a bigger thing in terms of how to create
[13:09.940 --> 13:14.220]  a different way of doing things in the Java language from the point of view of storage.
[13:14.220 --> 13:20.540]  Things like value types and the ability to store a collection of primitives, rather than
[13:20.540 --> 13:26.820]  having an array list of ints where you have to use auto-boxing and unboxing to use the
[13:26.860 --> 13:32.180]  wrapper class and create specific object instances, what we'll now be able to do is have an array
[13:32.180 --> 13:38.140]  list of ints and actually store those primitives without boxing them. So that's again helping
[13:38.140 --> 13:43.580]  to deliver on performance and solving some of those small problems. And then we've got
[13:43.580 --> 13:48.180]  things around the idea of startup time for the JVM because of the fact you're using
[13:48.180 --> 13:52.460]  byte codes, you have to convert them into native instructions. That's always been a bit of
[13:52.460 --> 13:58.420]  an issue for the way the applications start. So we've got Java on crack, the idea of coordinated
[13:58.420 --> 14:03.220]  restore at checkpoints. You can freeze an application and then restart it. We've got
[14:03.220 --> 14:08.380]  Project Leiden, which is again looking at the startup time of Java applications, more
[14:08.380 --> 14:13.420]  related to some of the work that's happened in the Growl VM, where you have a native
[14:13.420 --> 14:19.060]  image and you compile for a specific platform rather than the right one that's run anywhere
[14:19.140 --> 14:25.740]  idea. Freedom to choose. Again, Hilton mentioned this at the beginning. This is one of the
[14:25.740 --> 14:31.060]  really powerful things about Java is that you have so many options, not just in terms
[14:31.060 --> 14:37.220]  of versions, but in terms of distributions. Open JDK gives you the source code and then
[14:37.220 --> 14:41.740]  lots of people have taken that, they built it and then they can provide that to you as
[14:41.740 --> 14:46.740]  a distribution. You can install it and then if you need support, if you need maintenance
[14:46.780 --> 14:50.740]  around that, you have lots of different options for that. So it's very important having that
[14:50.740 --> 14:57.740]  freedom. Last thing then, why will Java remain popular in the next 20 years, let's say? And
[15:00.220 --> 15:04.900]  I think there's several reasons for this. Java is open. The fact that we have an open
[15:04.900 --> 15:11.900]  standard, people can contribute to that, people can join the JCP, they can join the open JDK,
[15:11.900 --> 15:17.980]  open source. Java's continuing to evolve. It's not static. It's not stationary. We're
[15:17.980 --> 15:22.860]  seeing lots of different things happening to Java, which address the needs of developers
[15:22.860 --> 15:28.860]  and keeping it fresh, allowing people to suggest things in terms of new features and so on.
[15:28.860 --> 15:35.860]  Java performs. We have this idea of the virtual machine. We've seen how things like JIP compilation
[15:36.580 --> 15:41.140]  could improve performance over statically compiled code. And we're looking at how to
[15:41.180 --> 15:45.300]  take that even further, using different ways of doing static compilation, different ways
[15:45.300 --> 15:51.580]  of doing dynamic compilation and so on. Java gives you choice. As we saw on the previous
[15:51.580 --> 15:55.780]  slide, the fact that you have so many distributions to choose from, you have so many versions
[15:55.780 --> 16:01.660]  that you can choose from, gives you that choice. Java's community, the fact that we have so
[16:01.660 --> 16:06.500]  many people here on a Sunday, that always blows me away that I get to talk to people
[16:06.500 --> 16:12.180]  and they come in their time off to listen to things about Java. So the fact that there
[16:12.180 --> 16:18.980]  is this huge community around Java, interest in sharing people's experiences. And the last
[16:18.980 --> 16:23.500]  thing, Java gives you freedom. The freedom to choose, the freedom to do what you want
[16:23.500 --> 16:28.660]  to do. And so that's it. That's my 20 minutes of presentation. I think I just about managed
[16:28.660 --> 16:29.580]  to get it in there. So thank you.
