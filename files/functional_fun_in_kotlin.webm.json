{"text": " Thank you, everyone. It's so great being here. So I'm Simon and I'm a developer, a tech lead engineer at CBA Functional. And a little bit about myself. I've been doing Kotlin since 2015. I've been doing functional programming a bit longer than that. And, well, I'm really in love with both things. So we try to improve things as much as we can. And I'm also one of the lead maintainers of Aero, which is a functional library in Kotlin. So today I want to talk a little bit about functional programming in Kotlin. And there's three big topics that we often talk about, which are dependency injection, side effects, and typed errors. But I don't want to go into this comparing it to different languages like Haskell or Scala, because I only have 20 minutes of time, so I need to kind of, you know, pick my topics. So I want to talk about these three things. And I will maybe sometimes refer to some other things from other languages, but if you do not follow or know them, it's not really important. So first of all, dependency injection. I'm also not going to go into why we do dependency injection, but often when we are writing programs, you might have something like this where you have a database, where you can run some queries, you have a logger, where you can log some stuff. And then you need to now write a program that uses these two things to build some logic. So the most vanilla function that we can probably write in Kotlin might look something like this, where you have a fetch user function, it takes in an ID, it takes in both dependencies, we run some query, we make a log statement, and we return a value, right? So this is the most vanilla, pure functional signature function that we can write in Kotlin. But it's not really that great because if you want to write some other code using this function, we need to always wire and pass these parameters manually around. So you will see in your code that after a while, you're always manually passing all these parameters around and wiring all this stuff. It causes quite some boilerplate. And typically, it's not very interesting to read because we are really only interested in fetching the user with the ID, and all their stuff might be a little bit side tracking or making our code more complex. So for mentioning all the different kinds of techniques that you can do dependency injection I wanted to use or include this version is not the one that I'm going to recommend, but I'm going to cover it anyway. So for those that are not familiar with this pattern, you can write an extension function fetch user on a generic type that we call context. You can answer the context needs to extend both the database and the logger. And then inside of the method body, you again get access to the database methods and the logger methods. You can write the same function as well as before. But this is quite complex to read. It's a pattern that's probably very foreign to most people. And to actually call this method, you now have to create a type that extends both database and logger. So this is probably not a very ideal pattern to use to solve this problem. The cool thing, however, is that we can now define again the new function. And as you can see within the map function of the list, you don't have to pass the parameters around, but we have to define again an extension function on context which is constrained to having a database and a logger as a super type. So this is a bit complex. This is the solution that I do not recommend, but it works in Cullen today. So as you might have guessed, a really neat solution that is an upcoming feature in Cullen is called context receivers. And you can now annotate or mark your function with the context keyword. And you can say to call this function the context of the database and the logger need to be available. And you can only call this function with both of these types are available. And again, inside of the method body, that gives you access to the functions of the database and the logger because you have constrained your function to say this function can only be called when these types are available. So we get access to the query method and the log method. And to call this method or to make the context of the database and the logger concrete, we need to at some point in your program say, okay, I'm going to call this function with this instance of the database and with this instance of the logger. And as you can see here, this is valid Cullen in the current 1-8-0 and even in the 1-7 releases, this is valid Cullen, this is code you can write and compile today, albeit only for the GVM and you need to explicitly opt into the experimental features of context receivers. But this is a very neat solution because we didn't have to do this type dance with the extension function and the where constraints. We don't have to pass the parameters of the fetch user function, this is done automatically for us by the compiler. And this allows us to, in a very neat way, do dependency injection using context receivers. And of course, what we love about functional programming is we want everything to be available in the function signature. So here you can very clearly see in the function signature that the database and the logger are required for calling the fetch user function. So a different very hot topic within functional programming is side effects. So typically, in talking about functional program, you often say you don't want to do side effects, but we typically have to write side effects to call or write useful programs like we have to log something to the system, to the console or to a server or we need to call the database to, you know, interact with external systems. So we need side effects to write our programs, but what do we want to do? We want to track the effects to compile time, which means that you should not be allowed to nearly really call side effects wherever in your program without knowing about it. You want side effects to be composable in a safe manner and that allows you to reason about your code in a more clear way. Or it allows you to reason about where side effects happen in your program. So let's again take our two dependencies of the database and logger and here we are actually violating that rule because we are saying we have a regular function query and a regular function log and they are just performing some side effects underneath. So again, might have guessed we can mark these functions with suspend, which is a feature in the Kotlin language. And now these side effects can be compile time tracked. So what does that mean for these side effects to be compile time tracked? When now that we've marked these functions as suspend and we again take our previous method of fetch user, this function will no longer compile, right? So where the red lines are it will fail to compile. It will see a compiler matter saying the suspend function query and log should only be called from a coroutine or another suspend function. So since that the fetch user function was not marked as suspend, we cannot call this other suspend functions in the method body, right? So that is to say that our side effects that we now mark as suspend are now compile time tracked, right? So our compiler is now tracking for us that these functions can only be called from another coroutine or another function is marked as suspend. So simply by marking our fetch user function also as suspend, we propagate that, you know, the fetch user function is side effecting in its method body or in its function body. And now anybody that calls the fetch user function also needs to state that it performs some side effects. Some other languages, there's often used an IO type which appears in the return type and you can compare it to a callback. So for example in Java we often use callbacks for these kinds of operations, right? If you call the database often you have to provide a callback as we also saw in the previous talk and then the callback will say it will either result to the successful value of t or a failure of type trouble, right? And the suspend system does the same thing for us through a technique that is called continuation passing style. So the compiler automatically takes care of all the heavy lifting. So just to give you an example, if you would have to manually rewrite this function using callbacks and continuation, it would look like this. It's quite horrible. It's not nice to read because these are actually the only lines that we cared about. We saw that the code exploded to almost double in size. We have this nesting of callbacks. We get this tree hierarchy in our code. It's not nice to read and it really obscures about what we were actually doing in the code. So thanks to the calling compiler we get this super nice syntax and everything is extremely optimized in the runtime. So there's really not any penalties that we have to pay for this nice syntax. And you can do all this awesome stuff thanks to the calling compiler in a very efficient way. So really, really neat. And it's very similar in spirit to this context receiver that we already saw for DI. What is actually really neat about suspend in Cullen, and this is a solution that has not really been solved in any other language that I know about, is that we have this map function on our list. And the map function on our list is of course not suspending. It's a pure function. It goes over every value in the list and maps it from type A to type B. But we can call this suspend function inside as long as our fetch all function is also marked as suspend. So this constraint of side effects travels through this map function to the list. And the calling compiler is able to track where this is valid and I'm not going to go too deeply into what it is. In this case or in most cases because the map function is in line so the compiler knows that it can replace the code of the map function inside of the body of fetch all and that through this mechanism this constraint of side effecting is allowed to pass through. So the compiler takes care of all of this and we don't have to know or learn any new method names to combine suspend with any other code. So this is very neat. It allows us to combine these patterns in very elegant ways. And then another thing that we often care about in functional programming is typed errors. More specifically again we want to track at compile time what are some of the expected errors. And we will see in a little bit what I mean by expected errors. So this can be errors that you care about in your domain. Things that you can deal with that you can recover from. And you also want to track them at compile time as I mentioned before. We want all of these things to appear in our type signature. So in the case of our fetch user function we can very simply mark our user return type as nullable. So we add a question mark at the end and by that we can basically state that this fetch user function can be absent of results. So in some cases a user might not be found for the ID and in that case we can return null and this is in columnist type safe. But there is many, many more errors that we can encounter besides just saying okay there was no value available for what you were looking for. So instead of fetching a user let's try inserting a user and we're going to insert the user with a name and email. And we can now have an error that says okay this user is already available in the database. So the user already exists and we can now define an error which does not have to extend troble. So we have a simple data class that says here is the error for this name with this email address and in this case I've enhanced also the error with the underlying Postgres SQL error so that I don't induce any information because we don't want to discard any important information that you might need later on. But now we need to make this type appear in our type signature so a very traditional way of doing some functional programming is using the IDER type and you can then say there is results in either the user already exists or the valid user. But we've seen all these nice things in Kotlin. We've talked about suspend which allows us to do callback based programming without having to use callbacks. We have these context receivers that allow us to inject dependencies without having to manually wire it and don't have to explicitly pass them in the parameters of the function. I don't want to have this IDER in my return type. I want something more elegant, something that is very similar to the nullable type or the context receiver. So how can we do that? In Errol, a library that I'm working on, we have this type that we call race. And we can put the race also into the context receiver basically stating that this function has the capability of resulting in a user already exists error. And now we can see that in the return type we are simply returning a user. So we don't have a need anymore for the IDER wrapper. We are just stating in the context of our function that if you are calling this function you need to be aware that at some point a user already exists error might occur and you need to deal with it. Errol offers a bunch of very nice DSLs to, for example, wrap our query method and we can say, okay, I want to catch the Postgres SQL exception from our query statement. And in case of the Postgres SQL exception is a unique violation, so that means the user already exists in the database, I want to erase this error of the user already exists. So we can now erase this typed error into the context saying, okay, the user already exists so somebody needs to deal with that at a later point. And I'm also retrawing any other errors basically saying any other errors is something that I cannot recover from. It's something unexpected, something that you're not going to deal with at a later point in time. And what your criteria are for this are of course up to whoever writes the code or however you want to model your code. And then if you want to call this function, you can again provide the dependencies of database and logger and you can say at the edge of the world or wherever you want to need to call this function, run the effect, right? And this provides the context of arrays that we have before. And what is actually interesting here is Kotlin is able to infer all these types so we don't have to explicitly provide any type arguments because it knows the error that might occur is from the user already exists type. So here it knows that the error that we need to recover from is the user already exists. And then we can say, okay, fold over this method and either print the error or print the inserted user. Right? So this is a very simple example in the API that is available for this method which is much, much larger. And what is also neat what I really like about Kotlin is we have these special DSL sketch and arrays and they actually show up as special functions in the ID. So here the catch method and the erase method show up as pink stating that they are doing some special kind of DSL functionality that belongs to the erase capability in the context. So I mentioned the error in this last set of slides. We've typed error so what is the goal of error? It offers this DSL based functional programming style of dealing with things. And the goal of that is we want to get rid of a lot of complexity of functional programming, things like map, flat map, monotransformers, wrappers in the return types, etc. Right? And we do this so that we can provide an idiomatic Kotlin syntax for working with functional programming. And what is also really neat is it is actually Kotlin multipath from ready. So all the talks that we saw this morning, in all of those things you can also already use error in this style of programming. It offers a couple of more DSLs. For example, the Saga scope. So for people that are working with the Saga pattern on the backend, we saw that backend is an increasing industry in Kotlin. So when you're working with the Saga pattern, again, you don't want to have any return or wrappers in the return type. So we have the Saga DSL that allows you to wrap any action with a compensating action, meaning that if something goes wrong in the program, the compensating action will run compensating the action. Similarly for resource safety, we can say, okay, I'm going to install some resource and whenever you're done using the resource, you need to automatically call this release function with the log statement and the auto-closable function, which offers some special syntax for GVM functionality. So what do I love about functional programming in Kotlin? We can do it in a very elegant way using DSLs. And all of these DSLs are composable. So it means that you can nest these DSLs in a safe way. They will cooperate with each other. They will do the right thing. They're all type safe. And this offers you a very low threshold for getting into functional programming in Kotlin. You don't have to learn anything about map, flat map, special monads, monadransformers. All of these things are not needed because you can very elegantly nest and compose these DSLs together. Seems that I'm right on time. Just five minutes left for questions and thank you so much all for your attention.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 19.52, "text": " Thank you, everyone. It's so great being here. So I'm Simon and I'm a developer, a tech", "tokens": [50364, 1044, 291, 11, 1518, 13, 467, 311, 370, 869, 885, 510, 13, 407, 286, 478, 13193, 293, 286, 478, 257, 10754, 11, 257, 7553, 51340], "temperature": 0.0, "avg_logprob": -0.297028871682974, "compression_ratio": 1.2587412587412588, "no_speech_prob": 0.16954292356967926}, {"id": 1, "seek": 0, "start": 19.52, "end": 25.96, "text": " lead engineer at CBA Functional. And a little bit about myself. I've been doing Kotlin since", "tokens": [51340, 1477, 11403, 412, 383, 9295, 11166, 41048, 13, 400, 257, 707, 857, 466, 2059, 13, 286, 600, 668, 884, 30123, 5045, 1670, 51662], "temperature": 0.0, "avg_logprob": -0.297028871682974, "compression_ratio": 1.2587412587412588, "no_speech_prob": 0.16954292356967926}, {"id": 2, "seek": 2596, "start": 25.96, "end": 33.76, "text": " 2015. I've been doing functional programming a bit longer than that. And, well, I'm really", "tokens": [50364, 7546, 13, 286, 600, 668, 884, 11745, 9410, 257, 857, 2854, 813, 300, 13, 400, 11, 731, 11, 286, 478, 534, 50754], "temperature": 0.0, "avg_logprob": -0.16295321269701885, "compression_ratio": 1.6267281105990783, "no_speech_prob": 0.04232541099190712}, {"id": 3, "seek": 2596, "start": 33.76, "end": 41.4, "text": " in love with both things. So we try to improve things as much as we can. And I'm also one", "tokens": [50754, 294, 959, 365, 1293, 721, 13, 407, 321, 853, 281, 3470, 721, 382, 709, 382, 321, 393, 13, 400, 286, 478, 611, 472, 51136], "temperature": 0.0, "avg_logprob": -0.16295321269701885, "compression_ratio": 1.6267281105990783, "no_speech_prob": 0.04232541099190712}, {"id": 4, "seek": 2596, "start": 41.4, "end": 48.88, "text": " of the lead maintainers of Aero, which is a functional library in Kotlin. So today I", "tokens": [51136, 295, 264, 1477, 6909, 433, 295, 316, 2032, 11, 597, 307, 257, 11745, 6405, 294, 30123, 5045, 13, 407, 965, 286, 51510], "temperature": 0.0, "avg_logprob": -0.16295321269701885, "compression_ratio": 1.6267281105990783, "no_speech_prob": 0.04232541099190712}, {"id": 5, "seek": 2596, "start": 48.88, "end": 53.72, "text": " want to talk a little bit about functional programming in Kotlin. And there's three big", "tokens": [51510, 528, 281, 751, 257, 707, 857, 466, 11745, 9410, 294, 30123, 5045, 13, 400, 456, 311, 1045, 955, 51752], "temperature": 0.0, "avg_logprob": -0.16295321269701885, "compression_ratio": 1.6267281105990783, "no_speech_prob": 0.04232541099190712}, {"id": 6, "seek": 5372, "start": 53.72, "end": 60.24, "text": " topics that we often talk about, which are dependency injection, side effects, and typed", "tokens": [50364, 8378, 300, 321, 2049, 751, 466, 11, 597, 366, 33621, 22873, 11, 1252, 5065, 11, 293, 33941, 50690], "temperature": 0.0, "avg_logprob": -0.17323189196379288, "compression_ratio": 1.5040983606557377, "no_speech_prob": 0.06649674475193024}, {"id": 7, "seek": 5372, "start": 60.24, "end": 66.64, "text": " errors. But I don't want to go into this comparing it to different languages like Haskell or", "tokens": [50690, 13603, 13, 583, 286, 500, 380, 528, 281, 352, 666, 341, 15763, 309, 281, 819, 8650, 411, 8646, 43723, 420, 51010], "temperature": 0.0, "avg_logprob": -0.17323189196379288, "compression_ratio": 1.5040983606557377, "no_speech_prob": 0.06649674475193024}, {"id": 8, "seek": 5372, "start": 66.64, "end": 73.6, "text": " Scala, because I only have 20 minutes of time, so I need to kind of, you know, pick my topics.", "tokens": [51010, 2747, 5159, 11, 570, 286, 787, 362, 945, 2077, 295, 565, 11, 370, 286, 643, 281, 733, 295, 11, 291, 458, 11, 1888, 452, 8378, 13, 51358], "temperature": 0.0, "avg_logprob": -0.17323189196379288, "compression_ratio": 1.5040983606557377, "no_speech_prob": 0.06649674475193024}, {"id": 9, "seek": 5372, "start": 73.6, "end": 79.28, "text": " So I want to talk about these three things. And I will maybe sometimes refer to some other", "tokens": [51358, 407, 286, 528, 281, 751, 466, 613, 1045, 721, 13, 400, 286, 486, 1310, 2171, 2864, 281, 512, 661, 51642], "temperature": 0.0, "avg_logprob": -0.17323189196379288, "compression_ratio": 1.5040983606557377, "no_speech_prob": 0.06649674475193024}, {"id": 10, "seek": 7928, "start": 79.28, "end": 86.48, "text": " things from other languages, but if you do not follow or know them, it's not really important.", "tokens": [50364, 721, 490, 661, 8650, 11, 457, 498, 291, 360, 406, 1524, 420, 458, 552, 11, 309, 311, 406, 534, 1021, 13, 50724], "temperature": 0.0, "avg_logprob": -0.159452990481728, "compression_ratio": 1.768939393939394, "no_speech_prob": 0.01810949109494686}, {"id": 11, "seek": 7928, "start": 86.48, "end": 90.92, "text": " So first of all, dependency injection. I'm also not going to go into why we do dependency", "tokens": [50724, 407, 700, 295, 439, 11, 33621, 22873, 13, 286, 478, 611, 406, 516, 281, 352, 666, 983, 321, 360, 33621, 50946], "temperature": 0.0, "avg_logprob": -0.159452990481728, "compression_ratio": 1.768939393939394, "no_speech_prob": 0.01810949109494686}, {"id": 12, "seek": 7928, "start": 90.92, "end": 95.72, "text": " injection, but often when we are writing programs, you might have something like this where you", "tokens": [50946, 22873, 11, 457, 2049, 562, 321, 366, 3579, 4268, 11, 291, 1062, 362, 746, 411, 341, 689, 291, 51186], "temperature": 0.0, "avg_logprob": -0.159452990481728, "compression_ratio": 1.768939393939394, "no_speech_prob": 0.01810949109494686}, {"id": 13, "seek": 7928, "start": 95.72, "end": 100.0, "text": " have a database, where you can run some queries, you have a logger, where you can log some", "tokens": [51186, 362, 257, 8149, 11, 689, 291, 393, 1190, 512, 24109, 11, 291, 362, 257, 3565, 1321, 11, 689, 291, 393, 3565, 512, 51400], "temperature": 0.0, "avg_logprob": -0.159452990481728, "compression_ratio": 1.768939393939394, "no_speech_prob": 0.01810949109494686}, {"id": 14, "seek": 7928, "start": 100.0, "end": 105.76, "text": " stuff. And then you need to now write a program that uses these two things to build some logic.", "tokens": [51400, 1507, 13, 400, 550, 291, 643, 281, 586, 2464, 257, 1461, 300, 4960, 613, 732, 721, 281, 1322, 512, 9952, 13, 51688], "temperature": 0.0, "avg_logprob": -0.159452990481728, "compression_ratio": 1.768939393939394, "no_speech_prob": 0.01810949109494686}, {"id": 15, "seek": 10576, "start": 105.76, "end": 111.56, "text": " So the most vanilla function that we can probably write in Kotlin might look something", "tokens": [50364, 407, 264, 881, 17528, 2445, 300, 321, 393, 1391, 2464, 294, 30123, 5045, 1062, 574, 746, 50654], "temperature": 0.0, "avg_logprob": -0.14359151400052583, "compression_ratio": 1.6898148148148149, "no_speech_prob": 0.001923516858369112}, {"id": 16, "seek": 10576, "start": 111.56, "end": 117.84, "text": " like this, where you have a fetch user function, it takes in an ID, it takes in both dependencies,", "tokens": [50654, 411, 341, 11, 689, 291, 362, 257, 23673, 4195, 2445, 11, 309, 2516, 294, 364, 7348, 11, 309, 2516, 294, 1293, 36606, 11, 50968], "temperature": 0.0, "avg_logprob": -0.14359151400052583, "compression_ratio": 1.6898148148148149, "no_speech_prob": 0.001923516858369112}, {"id": 17, "seek": 10576, "start": 117.84, "end": 122.56, "text": " we run some query, we make a log statement, and we return a value, right? So this is the", "tokens": [50968, 321, 1190, 512, 14581, 11, 321, 652, 257, 3565, 5629, 11, 293, 321, 2736, 257, 2158, 11, 558, 30, 407, 341, 307, 264, 51204], "temperature": 0.0, "avg_logprob": -0.14359151400052583, "compression_ratio": 1.6898148148148149, "no_speech_prob": 0.001923516858369112}, {"id": 18, "seek": 10576, "start": 122.56, "end": 131.24, "text": " most vanilla, pure functional signature function that we can write in Kotlin. But it's not", "tokens": [51204, 881, 17528, 11, 6075, 11745, 13397, 2445, 300, 321, 393, 2464, 294, 30123, 5045, 13, 583, 309, 311, 406, 51638], "temperature": 0.0, "avg_logprob": -0.14359151400052583, "compression_ratio": 1.6898148148148149, "no_speech_prob": 0.001923516858369112}, {"id": 19, "seek": 13124, "start": 131.28, "end": 136.08, "text": " really that great because if you want to write some other code using this function, we need", "tokens": [50366, 534, 300, 869, 570, 498, 291, 528, 281, 2464, 512, 661, 3089, 1228, 341, 2445, 11, 321, 643, 50606], "temperature": 0.0, "avg_logprob": -0.19200647939549814, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.23008644580841064}, {"id": 20, "seek": 13124, "start": 136.08, "end": 142.28, "text": " to always wire and pass these parameters manually around. So you will see in your code that", "tokens": [50606, 281, 1009, 6234, 293, 1320, 613, 9834, 16945, 926, 13, 407, 291, 486, 536, 294, 428, 3089, 300, 50916], "temperature": 0.0, "avg_logprob": -0.19200647939549814, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.23008644580841064}, {"id": 21, "seek": 13124, "start": 142.28, "end": 147.20000000000002, "text": " after a while, you're always manually passing all these parameters around and wiring all", "tokens": [50916, 934, 257, 1339, 11, 291, 434, 1009, 16945, 8437, 439, 613, 9834, 926, 293, 27520, 439, 51162], "temperature": 0.0, "avg_logprob": -0.19200647939549814, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.23008644580841064}, {"id": 22, "seek": 13124, "start": 147.20000000000002, "end": 151.72, "text": " this stuff. It causes quite some boilerplate. And typically, it's not very interesting to", "tokens": [51162, 341, 1507, 13, 467, 7700, 1596, 512, 39228, 37008, 13, 400, 5850, 11, 309, 311, 406, 588, 1880, 281, 51388], "temperature": 0.0, "avg_logprob": -0.19200647939549814, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.23008644580841064}, {"id": 23, "seek": 13124, "start": 151.72, "end": 155.84, "text": " read because we are really only interested in fetching the user with the ID, and all", "tokens": [51388, 1401, 570, 321, 366, 534, 787, 3102, 294, 23673, 278, 264, 4195, 365, 264, 7348, 11, 293, 439, 51594], "temperature": 0.0, "avg_logprob": -0.19200647939549814, "compression_ratio": 1.7598425196850394, "no_speech_prob": 0.23008644580841064}, {"id": 24, "seek": 15584, "start": 155.84, "end": 166.8, "text": " their stuff might be a little bit side tracking or making our code more complex. So for mentioning", "tokens": [50364, 641, 1507, 1062, 312, 257, 707, 857, 1252, 11603, 420, 1455, 527, 3089, 544, 3997, 13, 407, 337, 18315, 50912], "temperature": 0.0, "avg_logprob": -0.1404172598597515, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.005030435975641012}, {"id": 25, "seek": 15584, "start": 166.8, "end": 171.96, "text": " all the different kinds of techniques that you can do dependency injection I wanted to", "tokens": [50912, 439, 264, 819, 3685, 295, 7512, 300, 291, 393, 360, 33621, 22873, 286, 1415, 281, 51170], "temperature": 0.0, "avg_logprob": -0.1404172598597515, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.005030435975641012}, {"id": 26, "seek": 15584, "start": 171.96, "end": 176.12, "text": " use or include this version is not the one that I'm going to recommend, but I'm going", "tokens": [51170, 764, 420, 4090, 341, 3037, 307, 406, 264, 472, 300, 286, 478, 516, 281, 2748, 11, 457, 286, 478, 516, 51378], "temperature": 0.0, "avg_logprob": -0.1404172598597515, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.005030435975641012}, {"id": 27, "seek": 15584, "start": 176.12, "end": 180.68, "text": " to cover it anyway. So for those that are not familiar with this pattern, you can write", "tokens": [51378, 281, 2060, 309, 4033, 13, 407, 337, 729, 300, 366, 406, 4963, 365, 341, 5102, 11, 291, 393, 2464, 51606], "temperature": 0.0, "avg_logprob": -0.1404172598597515, "compression_ratio": 1.6318181818181818, "no_speech_prob": 0.005030435975641012}, {"id": 28, "seek": 18068, "start": 180.68, "end": 187.20000000000002, "text": " an extension function fetch user on a generic type that we call context. You can answer the", "tokens": [50364, 364, 10320, 2445, 23673, 4195, 322, 257, 19577, 2010, 300, 321, 818, 4319, 13, 509, 393, 1867, 264, 50690], "temperature": 0.0, "avg_logprob": -0.20372029008536502, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.0021742256358265877}, {"id": 29, "seek": 18068, "start": 187.20000000000002, "end": 196.92000000000002, "text": " context needs to extend both the database and the logger. And then inside of the method", "tokens": [50690, 4319, 2203, 281, 10101, 1293, 264, 8149, 293, 264, 3565, 1321, 13, 400, 550, 1854, 295, 264, 3170, 51176], "temperature": 0.0, "avg_logprob": -0.20372029008536502, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.0021742256358265877}, {"id": 30, "seek": 18068, "start": 196.92000000000002, "end": 202.76000000000002, "text": " body, you again get access to the database methods and the logger methods. You can write", "tokens": [51176, 1772, 11, 291, 797, 483, 2105, 281, 264, 8149, 7150, 293, 264, 3565, 1321, 7150, 13, 509, 393, 2464, 51468], "temperature": 0.0, "avg_logprob": -0.20372029008536502, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.0021742256358265877}, {"id": 31, "seek": 18068, "start": 202.76000000000002, "end": 209.12, "text": " the same function as well as before. But this is quite complex to read. It's a pattern that's", "tokens": [51468, 264, 912, 2445, 382, 731, 382, 949, 13, 583, 341, 307, 1596, 3997, 281, 1401, 13, 467, 311, 257, 5102, 300, 311, 51786], "temperature": 0.0, "avg_logprob": -0.20372029008536502, "compression_ratio": 1.7156398104265402, "no_speech_prob": 0.0021742256358265877}, {"id": 32, "seek": 20912, "start": 209.16, "end": 214.48000000000002, "text": " probably very foreign to most people. And to actually call this method, you now have to", "tokens": [50366, 1391, 588, 5329, 281, 881, 561, 13, 400, 281, 767, 818, 341, 3170, 11, 291, 586, 362, 281, 50632], "temperature": 0.0, "avg_logprob": -0.13922553712671454, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.004526006989181042}, {"id": 33, "seek": 20912, "start": 214.48000000000002, "end": 221.72, "text": " create a type that extends both database and logger. So this is probably not a very ideal", "tokens": [50632, 1884, 257, 2010, 300, 26448, 1293, 8149, 293, 3565, 1321, 13, 407, 341, 307, 1391, 406, 257, 588, 7157, 50994], "temperature": 0.0, "avg_logprob": -0.13922553712671454, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.004526006989181042}, {"id": 34, "seek": 20912, "start": 221.72, "end": 229.72, "text": " pattern to use to solve this problem. The cool thing, however, is that we can now define", "tokens": [50994, 5102, 281, 764, 281, 5039, 341, 1154, 13, 440, 1627, 551, 11, 4461, 11, 307, 300, 321, 393, 586, 6964, 51394], "temperature": 0.0, "avg_logprob": -0.13922553712671454, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.004526006989181042}, {"id": 35, "seek": 20912, "start": 229.72, "end": 235.0, "text": " again the new function. And as you can see within the map function of the list, you don't", "tokens": [51394, 797, 264, 777, 2445, 13, 400, 382, 291, 393, 536, 1951, 264, 4471, 2445, 295, 264, 1329, 11, 291, 500, 380, 51658], "temperature": 0.0, "avg_logprob": -0.13922553712671454, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.004526006989181042}, {"id": 36, "seek": 23500, "start": 235.0, "end": 241.6, "text": " have to pass the parameters around, but we have to define again an extension function", "tokens": [50364, 362, 281, 1320, 264, 9834, 926, 11, 457, 321, 362, 281, 6964, 797, 364, 10320, 2445, 50694], "temperature": 0.0, "avg_logprob": -0.1909453223733341, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.0023783950600773096}, {"id": 37, "seek": 23500, "start": 241.6, "end": 249.72, "text": " on context which is constrained to having a database and a logger as a super type. So", "tokens": [50694, 322, 4319, 597, 307, 38901, 281, 1419, 257, 8149, 293, 257, 3565, 1321, 382, 257, 1687, 2010, 13, 407, 51100], "temperature": 0.0, "avg_logprob": -0.1909453223733341, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.0023783950600773096}, {"id": 38, "seek": 23500, "start": 249.72, "end": 255.16, "text": " this is a bit complex. This is the solution that I do not recommend, but it works in Cullen", "tokens": [51100, 341, 307, 257, 857, 3997, 13, 639, 307, 264, 3827, 300, 286, 360, 406, 2748, 11, 457, 309, 1985, 294, 383, 32516, 51372], "temperature": 0.0, "avg_logprob": -0.1909453223733341, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.0023783950600773096}, {"id": 39, "seek": 23500, "start": 255.16, "end": 264.28, "text": " today. So as you might have guessed, a really neat solution that is an upcoming feature", "tokens": [51372, 965, 13, 407, 382, 291, 1062, 362, 21852, 11, 257, 534, 10654, 3827, 300, 307, 364, 11500, 4111, 51828], "temperature": 0.0, "avg_logprob": -0.1909453223733341, "compression_ratio": 1.610091743119266, "no_speech_prob": 0.0023783950600773096}, {"id": 40, "seek": 26428, "start": 264.35999999999996, "end": 270.55999999999995, "text": " in Cullen is called context receivers. And you can now annotate or mark your function", "tokens": [50368, 294, 383, 32516, 307, 1219, 4319, 49196, 13, 400, 291, 393, 586, 25339, 473, 420, 1491, 428, 2445, 50678], "temperature": 0.0, "avg_logprob": -0.1553966999053955, "compression_ratio": 2.031390134529148, "no_speech_prob": 0.0021656889002770185}, {"id": 41, "seek": 26428, "start": 270.55999999999995, "end": 276.71999999999997, "text": " with the context keyword. And you can say to call this function the context of the database", "tokens": [50678, 365, 264, 4319, 20428, 13, 400, 291, 393, 584, 281, 818, 341, 2445, 264, 4319, 295, 264, 8149, 50986], "temperature": 0.0, "avg_logprob": -0.1553966999053955, "compression_ratio": 2.031390134529148, "no_speech_prob": 0.0021656889002770185}, {"id": 42, "seek": 26428, "start": 276.71999999999997, "end": 281.52, "text": " and the logger need to be available. And you can only call this function with both of these", "tokens": [50986, 293, 264, 3565, 1321, 643, 281, 312, 2435, 13, 400, 291, 393, 787, 818, 341, 2445, 365, 1293, 295, 613, 51226], "temperature": 0.0, "avg_logprob": -0.1553966999053955, "compression_ratio": 2.031390134529148, "no_speech_prob": 0.0021656889002770185}, {"id": 43, "seek": 26428, "start": 281.52, "end": 288.59999999999997, "text": " types are available. And again, inside of the method body, that gives you access to the", "tokens": [51226, 3467, 366, 2435, 13, 400, 797, 11, 1854, 295, 264, 3170, 1772, 11, 300, 2709, 291, 2105, 281, 264, 51580], "temperature": 0.0, "avg_logprob": -0.1553966999053955, "compression_ratio": 2.031390134529148, "no_speech_prob": 0.0021656889002770185}, {"id": 44, "seek": 26428, "start": 288.59999999999997, "end": 293.09999999999997, "text": " functions of the database and the logger because you have constrained your function to say this", "tokens": [51580, 6828, 295, 264, 8149, 293, 264, 3565, 1321, 570, 291, 362, 38901, 428, 2445, 281, 584, 341, 51805], "temperature": 0.0, "avg_logprob": -0.1553966999053955, "compression_ratio": 2.031390134529148, "no_speech_prob": 0.0021656889002770185}, {"id": 45, "seek": 29310, "start": 293.14000000000004, "end": 297.78000000000003, "text": " function can only be called when these types are available. So we get access to the query", "tokens": [50366, 2445, 393, 787, 312, 1219, 562, 613, 3467, 366, 2435, 13, 407, 321, 483, 2105, 281, 264, 14581, 50598], "temperature": 0.0, "avg_logprob": -0.16783781218947025, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0014804701786488295}, {"id": 46, "seek": 29310, "start": 297.78000000000003, "end": 305.78000000000003, "text": " method and the log method. And to call this method or to make the context of the database", "tokens": [50598, 3170, 293, 264, 3565, 3170, 13, 400, 281, 818, 341, 3170, 420, 281, 652, 264, 4319, 295, 264, 8149, 50998], "temperature": 0.0, "avg_logprob": -0.16783781218947025, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0014804701786488295}, {"id": 47, "seek": 29310, "start": 305.78000000000003, "end": 309.98, "text": " and the logger concrete, we need to at some point in your program say, okay, I'm going", "tokens": [50998, 293, 264, 3565, 1321, 9859, 11, 321, 643, 281, 412, 512, 935, 294, 428, 1461, 584, 11, 1392, 11, 286, 478, 516, 51208], "temperature": 0.0, "avg_logprob": -0.16783781218947025, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0014804701786488295}, {"id": 48, "seek": 29310, "start": 309.98, "end": 314.42, "text": " to call this function with this instance of the database and with this instance of the", "tokens": [51208, 281, 818, 341, 2445, 365, 341, 5197, 295, 264, 8149, 293, 365, 341, 5197, 295, 264, 51430], "temperature": 0.0, "avg_logprob": -0.16783781218947025, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0014804701786488295}, {"id": 49, "seek": 29310, "start": 314.42, "end": 320.98, "text": " logger. And as you can see here, this is valid Cullen in the current 1-8-0 and even in the", "tokens": [51430, 3565, 1321, 13, 400, 382, 291, 393, 536, 510, 11, 341, 307, 7363, 383, 32516, 294, 264, 2190, 502, 12, 23, 12, 15, 293, 754, 294, 264, 51758], "temperature": 0.0, "avg_logprob": -0.16783781218947025, "compression_ratio": 1.8271604938271604, "no_speech_prob": 0.0014804701786488295}, {"id": 50, "seek": 32098, "start": 321.02000000000004, "end": 326.74, "text": " 1-7 releases, this is valid Cullen, this is code you can write and compile today, albeit", "tokens": [50366, 502, 12, 22, 16952, 11, 341, 307, 7363, 383, 32516, 11, 341, 307, 3089, 291, 393, 2464, 293, 31413, 965, 11, 43654, 50652], "temperature": 0.0, "avg_logprob": -0.23602037651594296, "compression_ratio": 1.5955555555555556, "no_speech_prob": 0.008161765523254871}, {"id": 51, "seek": 32098, "start": 326.74, "end": 332.42, "text": " only for the GVM and you need to explicitly opt into the experimental features of context", "tokens": [50652, 787, 337, 264, 460, 53, 44, 293, 291, 643, 281, 20803, 2427, 666, 264, 17069, 4122, 295, 4319, 50936], "temperature": 0.0, "avg_logprob": -0.23602037651594296, "compression_ratio": 1.5955555555555556, "no_speech_prob": 0.008161765523254871}, {"id": 52, "seek": 32098, "start": 332.42, "end": 339.42, "text": " receivers. But this is a very neat solution because we didn't have to do this type dance", "tokens": [50936, 49196, 13, 583, 341, 307, 257, 588, 10654, 3827, 570, 321, 994, 380, 362, 281, 360, 341, 2010, 4489, 51286], "temperature": 0.0, "avg_logprob": -0.23602037651594296, "compression_ratio": 1.5955555555555556, "no_speech_prob": 0.008161765523254871}, {"id": 53, "seek": 32098, "start": 340.62, "end": 346.02000000000004, "text": " with the extension function and the where constraints. We don't have to pass the parameters", "tokens": [51346, 365, 264, 10320, 2445, 293, 264, 689, 18491, 13, 492, 500, 380, 362, 281, 1320, 264, 9834, 51616], "temperature": 0.0, "avg_logprob": -0.23602037651594296, "compression_ratio": 1.5955555555555556, "no_speech_prob": 0.008161765523254871}, {"id": 54, "seek": 34602, "start": 346.06, "end": 352.82, "text": " of the fetch user function, this is done automatically for us by the compiler. And this allows us", "tokens": [50366, 295, 264, 23673, 4195, 2445, 11, 341, 307, 1096, 6772, 337, 505, 538, 264, 31958, 13, 400, 341, 4045, 505, 50704], "temperature": 0.0, "avg_logprob": -0.16735191109739703, "compression_ratio": 1.6849315068493151, "no_speech_prob": 0.0012029779609292746}, {"id": 55, "seek": 34602, "start": 352.82, "end": 359.82, "text": " to, in a very neat way, do dependency injection using context receivers. And of course, what", "tokens": [50704, 281, 11, 294, 257, 588, 10654, 636, 11, 360, 33621, 22873, 1228, 4319, 49196, 13, 400, 295, 1164, 11, 437, 51054], "temperature": 0.0, "avg_logprob": -0.16735191109739703, "compression_ratio": 1.6849315068493151, "no_speech_prob": 0.0012029779609292746}, {"id": 56, "seek": 34602, "start": 360.46, "end": 365.02, "text": " we love about functional programming is we want everything to be available in the function", "tokens": [51086, 321, 959, 466, 11745, 9410, 307, 321, 528, 1203, 281, 312, 2435, 294, 264, 2445, 51314], "temperature": 0.0, "avg_logprob": -0.16735191109739703, "compression_ratio": 1.6849315068493151, "no_speech_prob": 0.0012029779609292746}, {"id": 57, "seek": 34602, "start": 365.02, "end": 369.7, "text": " signature. So here you can very clearly see in the function signature that the database", "tokens": [51314, 13397, 13, 407, 510, 291, 393, 588, 4448, 536, 294, 264, 2445, 13397, 300, 264, 8149, 51548], "temperature": 0.0, "avg_logprob": -0.16735191109739703, "compression_ratio": 1.6849315068493151, "no_speech_prob": 0.0012029779609292746}, {"id": 58, "seek": 36970, "start": 369.7, "end": 376.7, "text": " and the logger are required for calling the fetch user function. So a different very hot", "tokens": [50364, 293, 264, 3565, 1321, 366, 4739, 337, 5141, 264, 23673, 4195, 2445, 13, 407, 257, 819, 588, 2368, 50714], "temperature": 0.0, "avg_logprob": -0.18180026822877163, "compression_ratio": 1.8360655737704918, "no_speech_prob": 0.0007716207765042782}, {"id": 59, "seek": 36970, "start": 377.86, "end": 384.21999999999997, "text": " topic within functional programming is side effects. So typically, in talking about functional", "tokens": [50772, 4829, 1951, 11745, 9410, 307, 1252, 5065, 13, 407, 5850, 11, 294, 1417, 466, 11745, 51090], "temperature": 0.0, "avg_logprob": -0.18180026822877163, "compression_ratio": 1.8360655737704918, "no_speech_prob": 0.0007716207765042782}, {"id": 60, "seek": 36970, "start": 384.21999999999997, "end": 388.34, "text": " program, you often say you don't want to do side effects, but we typically have to write", "tokens": [51090, 1461, 11, 291, 2049, 584, 291, 500, 380, 528, 281, 360, 1252, 5065, 11, 457, 321, 5850, 362, 281, 2464, 51296], "temperature": 0.0, "avg_logprob": -0.18180026822877163, "compression_ratio": 1.8360655737704918, "no_speech_prob": 0.0007716207765042782}, {"id": 61, "seek": 36970, "start": 388.34, "end": 394.09999999999997, "text": " side effects to call or write useful programs like we have to log something to the system,", "tokens": [51296, 1252, 5065, 281, 818, 420, 2464, 4420, 4268, 411, 321, 362, 281, 3565, 746, 281, 264, 1185, 11, 51584], "temperature": 0.0, "avg_logprob": -0.18180026822877163, "compression_ratio": 1.8360655737704918, "no_speech_prob": 0.0007716207765042782}, {"id": 62, "seek": 36970, "start": 394.09999999999997, "end": 398.62, "text": " to the console or to a server or we need to call the database to, you know, interact", "tokens": [51584, 281, 264, 11076, 420, 281, 257, 7154, 420, 321, 643, 281, 818, 264, 8149, 281, 11, 291, 458, 11, 4648, 51810], "temperature": 0.0, "avg_logprob": -0.18180026822877163, "compression_ratio": 1.8360655737704918, "no_speech_prob": 0.0007716207765042782}, {"id": 63, "seek": 39862, "start": 398.66, "end": 404.22, "text": " with external systems. So we need side effects to write our programs, but what do we want", "tokens": [50366, 365, 8320, 3652, 13, 407, 321, 643, 1252, 5065, 281, 2464, 527, 4268, 11, 457, 437, 360, 321, 528, 50644], "temperature": 0.0, "avg_logprob": -0.12894942210270807, "compression_ratio": 1.8583333333333334, "no_speech_prob": 0.0038467934355139732}, {"id": 64, "seek": 39862, "start": 404.22, "end": 410.38, "text": " to do? We want to track the effects to compile time, which means that you should not be allowed", "tokens": [50644, 281, 360, 30, 492, 528, 281, 2837, 264, 5065, 281, 31413, 565, 11, 597, 1355, 300, 291, 820, 406, 312, 4350, 50952], "temperature": 0.0, "avg_logprob": -0.12894942210270807, "compression_ratio": 1.8583333333333334, "no_speech_prob": 0.0038467934355139732}, {"id": 65, "seek": 39862, "start": 410.38, "end": 416.38, "text": " to nearly really call side effects wherever in your program without knowing about it.", "tokens": [50952, 281, 6217, 534, 818, 1252, 5065, 8660, 294, 428, 1461, 1553, 5276, 466, 309, 13, 51252], "temperature": 0.0, "avg_logprob": -0.12894942210270807, "compression_ratio": 1.8583333333333334, "no_speech_prob": 0.0038467934355139732}, {"id": 66, "seek": 39862, "start": 416.38, "end": 421.22, "text": " You want side effects to be composable in a safe manner and that allows you to reason", "tokens": [51252, 509, 528, 1252, 5065, 281, 312, 10199, 712, 294, 257, 3273, 9060, 293, 300, 4045, 291, 281, 1778, 51494], "temperature": 0.0, "avg_logprob": -0.12894942210270807, "compression_ratio": 1.8583333333333334, "no_speech_prob": 0.0038467934355139732}, {"id": 67, "seek": 39862, "start": 421.22, "end": 427.98, "text": " about your code in a more clear way. Or it allows you to reason about where side effects", "tokens": [51494, 466, 428, 3089, 294, 257, 544, 1850, 636, 13, 1610, 309, 4045, 291, 281, 1778, 466, 689, 1252, 5065, 51832], "temperature": 0.0, "avg_logprob": -0.12894942210270807, "compression_ratio": 1.8583333333333334, "no_speech_prob": 0.0038467934355139732}, {"id": 68, "seek": 42798, "start": 428.02000000000004, "end": 435.02000000000004, "text": " happen in your program. So let's again take our two dependencies of the database and logger", "tokens": [50366, 1051, 294, 428, 1461, 13, 407, 718, 311, 797, 747, 527, 732, 36606, 295, 264, 8149, 293, 3565, 1321, 50716], "temperature": 0.0, "avg_logprob": -0.25480506420135496, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.00107713439501822}, {"id": 69, "seek": 42798, "start": 436.1, "end": 442.70000000000005, "text": " and here we are actually violating that rule because we are saying we have a regular function", "tokens": [50770, 293, 510, 321, 366, 767, 42201, 300, 4978, 570, 321, 366, 1566, 321, 362, 257, 3890, 2445, 51100], "temperature": 0.0, "avg_logprob": -0.25480506420135496, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.00107713439501822}, {"id": 70, "seek": 42798, "start": 442.70000000000005, "end": 449.14000000000004, "text": " query and a regular function log and they are just performing some side effects underneath.", "tokens": [51100, 14581, 293, 257, 3890, 2445, 3565, 293, 436, 366, 445, 10205, 512, 1252, 5065, 7223, 13, 51422], "temperature": 0.0, "avg_logprob": -0.25480506420135496, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.00107713439501822}, {"id": 71, "seek": 42798, "start": 449.14000000000004, "end": 455.58000000000004, "text": " So again, might have guessed we can mark these functions with suspend, which is a feature", "tokens": [51422, 407, 797, 11, 1062, 362, 21852, 321, 393, 1491, 613, 6828, 365, 42546, 11, 597, 307, 257, 4111, 51744], "temperature": 0.0, "avg_logprob": -0.25480506420135496, "compression_ratio": 1.6457399103139014, "no_speech_prob": 0.00107713439501822}, {"id": 72, "seek": 45558, "start": 455.58, "end": 460.53999999999996, "text": " in the Kotlin language. And now these side effects can be compile time tracked. So what", "tokens": [50364, 294, 264, 30123, 5045, 2856, 13, 400, 586, 613, 1252, 5065, 393, 312, 31413, 565, 31703, 13, 407, 437, 50612], "temperature": 0.0, "avg_logprob": -0.22436875104904175, "compression_ratio": 1.7659574468085106, "no_speech_prob": 0.00113017694093287}, {"id": 73, "seek": 45558, "start": 460.53999999999996, "end": 466.82, "text": " does that mean for these side effects to be compile time tracked?", "tokens": [50612, 775, 300, 914, 337, 613, 1252, 5065, 281, 312, 31413, 565, 31703, 30, 50926], "temperature": 0.0, "avg_logprob": -0.22436875104904175, "compression_ratio": 1.7659574468085106, "no_speech_prob": 0.00113017694093287}, {"id": 74, "seek": 45558, "start": 466.82, "end": 470.7, "text": " When now that we've marked these functions as suspend and we again take our previous", "tokens": [50926, 1133, 586, 300, 321, 600, 12658, 613, 6828, 382, 42546, 293, 321, 797, 747, 527, 3894, 51120], "temperature": 0.0, "avg_logprob": -0.22436875104904175, "compression_ratio": 1.7659574468085106, "no_speech_prob": 0.00113017694093287}, {"id": 75, "seek": 45558, "start": 470.7, "end": 476.5, "text": " method of fetch user, this function will no longer compile, right? So where the red lines", "tokens": [51120, 3170, 295, 23673, 4195, 11, 341, 2445, 486, 572, 2854, 31413, 11, 558, 30, 407, 689, 264, 2182, 3876, 51410], "temperature": 0.0, "avg_logprob": -0.22436875104904175, "compression_ratio": 1.7659574468085106, "no_speech_prob": 0.00113017694093287}, {"id": 76, "seek": 45558, "start": 476.5, "end": 480.62, "text": " are it will fail to compile. It will see a compiler matter saying the suspend function", "tokens": [51410, 366, 309, 486, 3061, 281, 31413, 13, 467, 486, 536, 257, 31958, 1871, 1566, 264, 42546, 2445, 51616], "temperature": 0.0, "avg_logprob": -0.22436875104904175, "compression_ratio": 1.7659574468085106, "no_speech_prob": 0.00113017694093287}, {"id": 77, "seek": 48062, "start": 480.62, "end": 486.86, "text": " query and log should only be called from a coroutine or another suspend function. So", "tokens": [50364, 14581, 293, 3565, 820, 787, 312, 1219, 490, 257, 1181, 45075, 420, 1071, 42546, 2445, 13, 407, 50676], "temperature": 0.0, "avg_logprob": -0.1341674518585205, "compression_ratio": 2.0, "no_speech_prob": 0.005039414390921593}, {"id": 78, "seek": 48062, "start": 486.86, "end": 491.58, "text": " since that the fetch user function was not marked as suspend, we cannot call this other", "tokens": [50676, 1670, 300, 264, 23673, 4195, 2445, 390, 406, 12658, 382, 42546, 11, 321, 2644, 818, 341, 661, 50912], "temperature": 0.0, "avg_logprob": -0.1341674518585205, "compression_ratio": 2.0, "no_speech_prob": 0.005039414390921593}, {"id": 79, "seek": 48062, "start": 491.58, "end": 497.74, "text": " suspend functions in the method body, right? So that is to say that our side effects that", "tokens": [50912, 42546, 6828, 294, 264, 3170, 1772, 11, 558, 30, 407, 300, 307, 281, 584, 300, 527, 1252, 5065, 300, 51220], "temperature": 0.0, "avg_logprob": -0.1341674518585205, "compression_ratio": 2.0, "no_speech_prob": 0.005039414390921593}, {"id": 80, "seek": 48062, "start": 497.74, "end": 502.7, "text": " we now mark as suspend are now compile time tracked, right? So our compiler is now tracking", "tokens": [51220, 321, 586, 1491, 382, 42546, 366, 586, 31413, 565, 31703, 11, 558, 30, 407, 527, 31958, 307, 586, 11603, 51468], "temperature": 0.0, "avg_logprob": -0.1341674518585205, "compression_ratio": 2.0, "no_speech_prob": 0.005039414390921593}, {"id": 81, "seek": 48062, "start": 502.7, "end": 507.54, "text": " for us that these functions can only be called from another coroutine or another function", "tokens": [51468, 337, 505, 300, 613, 6828, 393, 787, 312, 1219, 490, 1071, 1181, 45075, 420, 1071, 2445, 51710], "temperature": 0.0, "avg_logprob": -0.1341674518585205, "compression_ratio": 2.0, "no_speech_prob": 0.005039414390921593}, {"id": 82, "seek": 50754, "start": 507.54, "end": 514.54, "text": " is marked as suspend. So simply by marking our fetch user function", "tokens": [50364, 307, 12658, 382, 42546, 13, 407, 2935, 538, 25482, 527, 23673, 4195, 2445, 50714], "temperature": 0.0, "avg_logprob": -0.1964207887649536, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.012599109672009945}, {"id": 83, "seek": 50754, "start": 514.54, "end": 520.46, "text": " also as suspend, we propagate that, you know, the fetch user function is side effecting", "tokens": [50714, 611, 382, 42546, 11, 321, 48256, 300, 11, 291, 458, 11, 264, 23673, 4195, 2445, 307, 1252, 1802, 278, 51010], "temperature": 0.0, "avg_logprob": -0.1964207887649536, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.012599109672009945}, {"id": 84, "seek": 50754, "start": 520.46, "end": 524.9, "text": " in its method body or in its function body. And now anybody that calls the fetch user", "tokens": [51010, 294, 1080, 3170, 1772, 420, 294, 1080, 2445, 1772, 13, 400, 586, 4472, 300, 5498, 264, 23673, 4195, 51232], "temperature": 0.0, "avg_logprob": -0.1964207887649536, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.012599109672009945}, {"id": 85, "seek": 50754, "start": 524.9, "end": 530.58, "text": " function also needs to state that it performs some side effects.", "tokens": [51232, 2445, 611, 2203, 281, 1785, 300, 309, 26213, 512, 1252, 5065, 13, 51516], "temperature": 0.0, "avg_logprob": -0.1964207887649536, "compression_ratio": 1.7941176470588236, "no_speech_prob": 0.012599109672009945}, {"id": 86, "seek": 53058, "start": 530.62, "end": 538.34, "text": " Some other languages, there's often used an IO type which appears in the return type", "tokens": [50366, 2188, 661, 8650, 11, 456, 311, 2049, 1143, 364, 39839, 2010, 597, 7038, 294, 264, 2736, 2010, 50752], "temperature": 0.0, "avg_logprob": -0.16563816728263064, "compression_ratio": 1.6604651162790698, "no_speech_prob": 0.41598281264305115}, {"id": 87, "seek": 53058, "start": 538.34, "end": 544.94, "text": " and you can compare it to a callback. So for example in Java we often use callbacks for", "tokens": [50752, 293, 291, 393, 6794, 309, 281, 257, 818, 3207, 13, 407, 337, 1365, 294, 10745, 321, 2049, 764, 818, 17758, 337, 51082], "temperature": 0.0, "avg_logprob": -0.16563816728263064, "compression_ratio": 1.6604651162790698, "no_speech_prob": 0.41598281264305115}, {"id": 88, "seek": 53058, "start": 544.94, "end": 550.0200000000001, "text": " these kinds of operations, right? If you call the database often you have to provide a callback", "tokens": [51082, 613, 3685, 295, 7705, 11, 558, 30, 759, 291, 818, 264, 8149, 2049, 291, 362, 281, 2893, 257, 818, 3207, 51336], "temperature": 0.0, "avg_logprob": -0.16563816728263064, "compression_ratio": 1.6604651162790698, "no_speech_prob": 0.41598281264305115}, {"id": 89, "seek": 53058, "start": 550.0200000000001, "end": 556.26, "text": " as we also saw in the previous talk and then the callback will say it will either result", "tokens": [51336, 382, 321, 611, 1866, 294, 264, 3894, 751, 293, 550, 264, 818, 3207, 486, 584, 309, 486, 2139, 1874, 51648], "temperature": 0.0, "avg_logprob": -0.16563816728263064, "compression_ratio": 1.6604651162790698, "no_speech_prob": 0.41598281264305115}, {"id": 90, "seek": 55626, "start": 556.26, "end": 563.18, "text": " to the successful value of t or a failure of type trouble, right? And the suspend system", "tokens": [50364, 281, 264, 4406, 2158, 295, 256, 420, 257, 7763, 295, 2010, 5253, 11, 558, 30, 400, 264, 42546, 1185, 50710], "temperature": 0.0, "avg_logprob": -0.18604431396875626, "compression_ratio": 1.5936073059360731, "no_speech_prob": 0.004627922084182501}, {"id": 91, "seek": 55626, "start": 563.18, "end": 567.62, "text": " does the same thing for us through a technique that is called continuation passing style.", "tokens": [50710, 775, 264, 912, 551, 337, 505, 807, 257, 6532, 300, 307, 1219, 29357, 8437, 3758, 13, 50932], "temperature": 0.0, "avg_logprob": -0.18604431396875626, "compression_ratio": 1.5936073059360731, "no_speech_prob": 0.004627922084182501}, {"id": 92, "seek": 55626, "start": 567.62, "end": 574.22, "text": " So the compiler automatically takes care of all the heavy lifting. So just to give you", "tokens": [50932, 407, 264, 31958, 6772, 2516, 1127, 295, 439, 264, 4676, 15798, 13, 407, 445, 281, 976, 291, 51262], "temperature": 0.0, "avg_logprob": -0.18604431396875626, "compression_ratio": 1.5936073059360731, "no_speech_prob": 0.004627922084182501}, {"id": 93, "seek": 55626, "start": 574.22, "end": 579.54, "text": " an example, if you would have to manually rewrite this function using callbacks and", "tokens": [51262, 364, 1365, 11, 498, 291, 576, 362, 281, 16945, 28132, 341, 2445, 1228, 818, 17758, 293, 51528], "temperature": 0.0, "avg_logprob": -0.18604431396875626, "compression_ratio": 1.5936073059360731, "no_speech_prob": 0.004627922084182501}, {"id": 94, "seek": 57954, "start": 579.54, "end": 586.4599999999999, "text": " continuation, it would look like this. It's quite horrible. It's not nice to read because", "tokens": [50364, 29357, 11, 309, 576, 574, 411, 341, 13, 467, 311, 1596, 9263, 13, 467, 311, 406, 1481, 281, 1401, 570, 50710], "temperature": 0.0, "avg_logprob": -0.16251860724555123, "compression_ratio": 1.7628458498023716, "no_speech_prob": 0.28993961215019226}, {"id": 95, "seek": 57954, "start": 586.4599999999999, "end": 590.8199999999999, "text": " these are actually the only lines that we cared about. We saw that the code exploded", "tokens": [50710, 613, 366, 767, 264, 787, 3876, 300, 321, 19779, 466, 13, 492, 1866, 300, 264, 3089, 27049, 50928], "temperature": 0.0, "avg_logprob": -0.16251860724555123, "compression_ratio": 1.7628458498023716, "no_speech_prob": 0.28993961215019226}, {"id": 96, "seek": 57954, "start": 590.8199999999999, "end": 596.18, "text": " to almost double in size. We have this nesting of callbacks. We get this tree hierarchy in", "tokens": [50928, 281, 1920, 3834, 294, 2744, 13, 492, 362, 341, 297, 8714, 295, 818, 17758, 13, 492, 483, 341, 4230, 22333, 294, 51196], "temperature": 0.0, "avg_logprob": -0.16251860724555123, "compression_ratio": 1.7628458498023716, "no_speech_prob": 0.28993961215019226}, {"id": 97, "seek": 57954, "start": 596.18, "end": 601.8199999999999, "text": " our code. It's not nice to read and it really obscures about what we were actually doing", "tokens": [51196, 527, 3089, 13, 467, 311, 406, 1481, 281, 1401, 293, 309, 534, 22082, 1303, 466, 437, 321, 645, 767, 884, 51478], "temperature": 0.0, "avg_logprob": -0.16251860724555123, "compression_ratio": 1.7628458498023716, "no_speech_prob": 0.28993961215019226}, {"id": 98, "seek": 57954, "start": 601.8199999999999, "end": 608.5, "text": " in the code. So thanks to the calling compiler we get this super nice syntax and everything", "tokens": [51478, 294, 264, 3089, 13, 407, 3231, 281, 264, 5141, 31958, 321, 483, 341, 1687, 1481, 28431, 293, 1203, 51812], "temperature": 0.0, "avg_logprob": -0.16251860724555123, "compression_ratio": 1.7628458498023716, "no_speech_prob": 0.28993961215019226}, {"id": 99, "seek": 60850, "start": 608.5, "end": 613.5, "text": " is extremely optimized in the runtime. So there's really not any penalties that we have", "tokens": [50364, 307, 4664, 26941, 294, 264, 34474, 13, 407, 456, 311, 534, 406, 604, 35389, 300, 321, 362, 50614], "temperature": 0.0, "avg_logprob": -0.1631169261702572, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.009439125657081604}, {"id": 100, "seek": 60850, "start": 613.5, "end": 619.58, "text": " to pay for this nice syntax. And you can do all this awesome stuff thanks to the calling", "tokens": [50614, 281, 1689, 337, 341, 1481, 28431, 13, 400, 291, 393, 360, 439, 341, 3476, 1507, 3231, 281, 264, 5141, 50918], "temperature": 0.0, "avg_logprob": -0.1631169261702572, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.009439125657081604}, {"id": 101, "seek": 60850, "start": 619.58, "end": 625.58, "text": " compiler in a very efficient way. So really, really neat. And it's very similar in spirit", "tokens": [50918, 31958, 294, 257, 588, 7148, 636, 13, 407, 534, 11, 534, 10654, 13, 400, 309, 311, 588, 2531, 294, 3797, 51218], "temperature": 0.0, "avg_logprob": -0.1631169261702572, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.009439125657081604}, {"id": 102, "seek": 60850, "start": 625.58, "end": 634.58, "text": " to this context receiver that we already saw for DI. What is actually really neat about", "tokens": [51218, 281, 341, 4319, 20086, 300, 321, 1217, 1866, 337, 11953, 13, 708, 307, 767, 534, 10654, 466, 51668], "temperature": 0.0, "avg_logprob": -0.1631169261702572, "compression_ratio": 1.6090909090909091, "no_speech_prob": 0.009439125657081604}, {"id": 103, "seek": 63458, "start": 634.58, "end": 640.6600000000001, "text": " suspend in Cullen, and this is a solution that has not really been solved in any other", "tokens": [50364, 42546, 294, 383, 32516, 11, 293, 341, 307, 257, 3827, 300, 575, 406, 534, 668, 13041, 294, 604, 661, 50668], "temperature": 0.0, "avg_logprob": -0.13472733290299124, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.022225813940167427}, {"id": 104, "seek": 63458, "start": 640.6600000000001, "end": 645.94, "text": " language that I know about, is that we have this map function on our list. And the map", "tokens": [50668, 2856, 300, 286, 458, 466, 11, 307, 300, 321, 362, 341, 4471, 2445, 322, 527, 1329, 13, 400, 264, 4471, 50932], "temperature": 0.0, "avg_logprob": -0.13472733290299124, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.022225813940167427}, {"id": 105, "seek": 63458, "start": 645.94, "end": 652.6600000000001, "text": " function on our list is of course not suspending. It's a pure function. It goes over every value", "tokens": [50932, 2445, 322, 527, 1329, 307, 295, 1164, 406, 6535, 2029, 13, 467, 311, 257, 6075, 2445, 13, 467, 1709, 670, 633, 2158, 51268], "temperature": 0.0, "avg_logprob": -0.13472733290299124, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.022225813940167427}, {"id": 106, "seek": 63458, "start": 652.6600000000001, "end": 659.5400000000001, "text": " in the list and maps it from type A to type B. But we can call this suspend function inside", "tokens": [51268, 294, 264, 1329, 293, 11317, 309, 490, 2010, 316, 281, 2010, 363, 13, 583, 321, 393, 818, 341, 42546, 2445, 1854, 51612], "temperature": 0.0, "avg_logprob": -0.13472733290299124, "compression_ratio": 1.748792270531401, "no_speech_prob": 0.022225813940167427}, {"id": 107, "seek": 65954, "start": 659.54, "end": 665.88, "text": " as long as our fetch all function is also marked as suspend. So this constraint of side", "tokens": [50364, 382, 938, 382, 527, 23673, 439, 2445, 307, 611, 12658, 382, 42546, 13, 407, 341, 25534, 295, 1252, 50681], "temperature": 0.0, "avg_logprob": -0.1560431199915269, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.0755917951464653}, {"id": 108, "seek": 65954, "start": 665.88, "end": 671.9, "text": " effects travels through this map function to the list. And the calling compiler is able", "tokens": [50681, 5065, 19863, 807, 341, 4471, 2445, 281, 264, 1329, 13, 400, 264, 5141, 31958, 307, 1075, 50982], "temperature": 0.0, "avg_logprob": -0.1560431199915269, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.0755917951464653}, {"id": 109, "seek": 65954, "start": 671.9, "end": 677.74, "text": " to track where this is valid and I'm not going to go too deeply into what it is. In this", "tokens": [50982, 281, 2837, 689, 341, 307, 7363, 293, 286, 478, 406, 516, 281, 352, 886, 8760, 666, 437, 309, 307, 13, 682, 341, 51274], "temperature": 0.0, "avg_logprob": -0.1560431199915269, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.0755917951464653}, {"id": 110, "seek": 65954, "start": 677.74, "end": 683.9399999999999, "text": " case or in most cases because the map function is in line so the compiler knows that it can", "tokens": [51274, 1389, 420, 294, 881, 3331, 570, 264, 4471, 2445, 307, 294, 1622, 370, 264, 31958, 3255, 300, 309, 393, 51584], "temperature": 0.0, "avg_logprob": -0.1560431199915269, "compression_ratio": 1.655813953488372, "no_speech_prob": 0.0755917951464653}, {"id": 111, "seek": 68394, "start": 683.94, "end": 690.22, "text": " replace the code of the map function inside of the body of fetch all and that through", "tokens": [50364, 7406, 264, 3089, 295, 264, 4471, 2445, 1854, 295, 264, 1772, 295, 23673, 439, 293, 300, 807, 50678], "temperature": 0.0, "avg_logprob": -0.12209880919683547, "compression_ratio": 1.6790697674418604, "no_speech_prob": 0.004855347331613302}, {"id": 112, "seek": 68394, "start": 690.22, "end": 696.5400000000001, "text": " this mechanism this constraint of side effecting is allowed to pass through. So the compiler", "tokens": [50678, 341, 7513, 341, 25534, 295, 1252, 1802, 278, 307, 4350, 281, 1320, 807, 13, 407, 264, 31958, 50994], "temperature": 0.0, "avg_logprob": -0.12209880919683547, "compression_ratio": 1.6790697674418604, "no_speech_prob": 0.004855347331613302}, {"id": 113, "seek": 68394, "start": 696.5400000000001, "end": 702.82, "text": " takes care of all of this and we don't have to know or learn any new method names to combine", "tokens": [50994, 2516, 1127, 295, 439, 295, 341, 293, 321, 500, 380, 362, 281, 458, 420, 1466, 604, 777, 3170, 5288, 281, 10432, 51308], "temperature": 0.0, "avg_logprob": -0.12209880919683547, "compression_ratio": 1.6790697674418604, "no_speech_prob": 0.004855347331613302}, {"id": 114, "seek": 68394, "start": 702.82, "end": 708.7, "text": " suspend with any other code. So this is very neat. It allows us to combine these patterns", "tokens": [51308, 42546, 365, 604, 661, 3089, 13, 407, 341, 307, 588, 10654, 13, 467, 4045, 505, 281, 10432, 613, 8294, 51602], "temperature": 0.0, "avg_logprob": -0.12209880919683547, "compression_ratio": 1.6790697674418604, "no_speech_prob": 0.004855347331613302}, {"id": 115, "seek": 70870, "start": 708.7, "end": 718.0600000000001, "text": " in very elegant ways. And then another thing that we often care about in functional programming", "tokens": [50364, 294, 588, 21117, 2098, 13, 400, 550, 1071, 551, 300, 321, 2049, 1127, 466, 294, 11745, 9410, 50832], "temperature": 0.0, "avg_logprob": -0.16984051924485427, "compression_ratio": 1.8786610878661087, "no_speech_prob": 0.026029326021671295}, {"id": 116, "seek": 70870, "start": 718.0600000000001, "end": 723.5, "text": " is typed errors. More specifically again we want to track at compile time what are some", "tokens": [50832, 307, 33941, 13603, 13, 5048, 4682, 797, 321, 528, 281, 2837, 412, 31413, 565, 437, 366, 512, 51104], "temperature": 0.0, "avg_logprob": -0.16984051924485427, "compression_ratio": 1.8786610878661087, "no_speech_prob": 0.026029326021671295}, {"id": 117, "seek": 70870, "start": 723.5, "end": 729.0200000000001, "text": " of the expected errors. And we will see in a little bit what I mean by expected errors.", "tokens": [51104, 295, 264, 5176, 13603, 13, 400, 321, 486, 536, 294, 257, 707, 857, 437, 286, 914, 538, 5176, 13603, 13, 51380], "temperature": 0.0, "avg_logprob": -0.16984051924485427, "compression_ratio": 1.8786610878661087, "no_speech_prob": 0.026029326021671295}, {"id": 118, "seek": 70870, "start": 729.0200000000001, "end": 732.98, "text": " So this can be errors that you care about in your domain. Things that you can deal with", "tokens": [51380, 407, 341, 393, 312, 13603, 300, 291, 1127, 466, 294, 428, 9274, 13, 9514, 300, 291, 393, 2028, 365, 51578], "temperature": 0.0, "avg_logprob": -0.16984051924485427, "compression_ratio": 1.8786610878661087, "no_speech_prob": 0.026029326021671295}, {"id": 119, "seek": 70870, "start": 732.98, "end": 737.7, "text": " that you can recover from. And you also want to track them at compile time as I mentioned", "tokens": [51578, 300, 291, 393, 8114, 490, 13, 400, 291, 611, 528, 281, 2837, 552, 412, 31413, 565, 382, 286, 2835, 51814], "temperature": 0.0, "avg_logprob": -0.16984051924485427, "compression_ratio": 1.8786610878661087, "no_speech_prob": 0.026029326021671295}, {"id": 120, "seek": 73770, "start": 737.7, "end": 746.5, "text": " before. We want all of these things to appear in our type signature. So in the case of our", "tokens": [50364, 949, 13, 492, 528, 439, 295, 613, 721, 281, 4204, 294, 527, 2010, 13397, 13, 407, 294, 264, 1389, 295, 527, 50804], "temperature": 0.0, "avg_logprob": -0.1797531106498804, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.02491355501115322}, {"id": 121, "seek": 73770, "start": 746.5, "end": 752.6600000000001, "text": " fetch user function we can very simply mark our user return type as nullable. So we add", "tokens": [50804, 23673, 4195, 2445, 321, 393, 588, 2935, 1491, 527, 4195, 2736, 2010, 382, 18184, 712, 13, 407, 321, 909, 51112], "temperature": 0.0, "avg_logprob": -0.1797531106498804, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.02491355501115322}, {"id": 122, "seek": 73770, "start": 752.6600000000001, "end": 759.26, "text": " a question mark at the end and by that we can basically state that this fetch user function", "tokens": [51112, 257, 1168, 1491, 412, 264, 917, 293, 538, 300, 321, 393, 1936, 1785, 300, 341, 23673, 4195, 2445, 51442], "temperature": 0.0, "avg_logprob": -0.1797531106498804, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.02491355501115322}, {"id": 123, "seek": 73770, "start": 759.26, "end": 766.22, "text": " can be absent of results. So in some cases a user might not be found for the ID and in", "tokens": [51442, 393, 312, 25185, 295, 3542, 13, 407, 294, 512, 3331, 257, 4195, 1062, 406, 312, 1352, 337, 264, 7348, 293, 294, 51790], "temperature": 0.0, "avg_logprob": -0.1797531106498804, "compression_ratio": 1.708133971291866, "no_speech_prob": 0.02491355501115322}, {"id": 124, "seek": 76622, "start": 766.22, "end": 772.58, "text": " that case we can return null and this is in columnist type safe. But there is many, many", "tokens": [50364, 300, 1389, 321, 393, 2736, 18184, 293, 341, 307, 294, 7738, 468, 2010, 3273, 13, 583, 456, 307, 867, 11, 867, 50682], "temperature": 0.0, "avg_logprob": -0.20986920937724496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.004307273775339127}, {"id": 125, "seek": 76622, "start": 772.58, "end": 779.5400000000001, "text": " more errors that we can encounter besides just saying okay there was no value available", "tokens": [50682, 544, 13603, 300, 321, 393, 8593, 11868, 445, 1566, 1392, 456, 390, 572, 2158, 2435, 51030], "temperature": 0.0, "avg_logprob": -0.20986920937724496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.004307273775339127}, {"id": 126, "seek": 76622, "start": 779.5400000000001, "end": 786.0600000000001, "text": " for what you were looking for. So instead of fetching a user let's try inserting a user", "tokens": [51030, 337, 437, 291, 645, 1237, 337, 13, 407, 2602, 295, 23673, 278, 257, 4195, 718, 311, 853, 46567, 257, 4195, 51356], "temperature": 0.0, "avg_logprob": -0.20986920937724496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.004307273775339127}, {"id": 127, "seek": 76622, "start": 786.0600000000001, "end": 791.58, "text": " and we're going to insert the user with a name and email. And we can now have an error", "tokens": [51356, 293, 321, 434, 516, 281, 8969, 264, 4195, 365, 257, 1315, 293, 3796, 13, 400, 321, 393, 586, 362, 364, 6713, 51632], "temperature": 0.0, "avg_logprob": -0.20986920937724496, "compression_ratio": 1.6175115207373272, "no_speech_prob": 0.004307273775339127}, {"id": 128, "seek": 79158, "start": 791.58, "end": 797.86, "text": " that says okay this user is already available in the database. So the user already exists", "tokens": [50364, 300, 1619, 1392, 341, 4195, 307, 1217, 2435, 294, 264, 8149, 13, 407, 264, 4195, 1217, 8198, 50678], "temperature": 0.0, "avg_logprob": -0.18542865304385914, "compression_ratio": 1.6635514018691588, "no_speech_prob": 0.005364252720028162}, {"id": 129, "seek": 79158, "start": 797.86, "end": 804.22, "text": " and we can now define an error which does not have to extend troble. So we have a simple", "tokens": [50678, 293, 321, 393, 586, 6964, 364, 6713, 597, 775, 406, 362, 281, 10101, 4495, 638, 13, 407, 321, 362, 257, 2199, 50996], "temperature": 0.0, "avg_logprob": -0.18542865304385914, "compression_ratio": 1.6635514018691588, "no_speech_prob": 0.005364252720028162}, {"id": 130, "seek": 79158, "start": 804.22, "end": 809.74, "text": " data class that says here is the error for this name with this email address and in this", "tokens": [50996, 1412, 1508, 300, 1619, 510, 307, 264, 6713, 337, 341, 1315, 365, 341, 3796, 2985, 293, 294, 341, 51272], "temperature": 0.0, "avg_logprob": -0.18542865304385914, "compression_ratio": 1.6635514018691588, "no_speech_prob": 0.005364252720028162}, {"id": 131, "seek": 79158, "start": 809.74, "end": 817.38, "text": " case I've enhanced also the error with the underlying Postgres SQL error so that I don't", "tokens": [51272, 1389, 286, 600, 21191, 611, 264, 6713, 365, 264, 14217, 10223, 45189, 19200, 6713, 370, 300, 286, 500, 380, 51654], "temperature": 0.0, "avg_logprob": -0.18542865304385914, "compression_ratio": 1.6635514018691588, "no_speech_prob": 0.005364252720028162}, {"id": 132, "seek": 81738, "start": 817.38, "end": 822.22, "text": " induce any information because we don't want to discard any important information that", "tokens": [50364, 41263, 604, 1589, 570, 321, 500, 380, 528, 281, 31597, 604, 1021, 1589, 300, 50606], "temperature": 0.0, "avg_logprob": -0.24365579629246192, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.0983998030424118}, {"id": 133, "seek": 81738, "start": 822.22, "end": 827.7, "text": " you might need later on. But now we need to make this type appear in our type signature", "tokens": [50606, 291, 1062, 643, 1780, 322, 13, 583, 586, 321, 643, 281, 652, 341, 2010, 4204, 294, 527, 2010, 13397, 50880], "temperature": 0.0, "avg_logprob": -0.24365579629246192, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.0983998030424118}, {"id": 134, "seek": 81738, "start": 827.7, "end": 836.38, "text": " so a very traditional way of doing some functional programming is using the IDER type and you", "tokens": [50880, 370, 257, 588, 5164, 636, 295, 884, 512, 11745, 9410, 307, 1228, 264, 7348, 1598, 2010, 293, 291, 51314], "temperature": 0.0, "avg_logprob": -0.24365579629246192, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.0983998030424118}, {"id": 135, "seek": 81738, "start": 836.38, "end": 841.18, "text": " can then say there is results in either the user already exists or the valid user. But", "tokens": [51314, 393, 550, 584, 456, 307, 3542, 294, 2139, 264, 4195, 1217, 8198, 420, 264, 7363, 4195, 13, 583, 51554], "temperature": 0.0, "avg_logprob": -0.24365579629246192, "compression_ratio": 1.6359447004608294, "no_speech_prob": 0.0983998030424118}, {"id": 136, "seek": 84118, "start": 841.18, "end": 848.0999999999999, "text": " we've seen all these nice things in Kotlin. We've talked about suspend which allows us", "tokens": [50364, 321, 600, 1612, 439, 613, 1481, 721, 294, 30123, 5045, 13, 492, 600, 2825, 466, 42546, 597, 4045, 505, 50710], "temperature": 0.0, "avg_logprob": -0.17141923786681376, "compression_ratio": 1.679245283018868, "no_speech_prob": 0.015350643545389175}, {"id": 137, "seek": 84118, "start": 848.0999999999999, "end": 855.14, "text": " to do callback based programming without having to use callbacks. We have these context receivers", "tokens": [50710, 281, 360, 818, 3207, 2361, 9410, 1553, 1419, 281, 764, 818, 17758, 13, 492, 362, 613, 4319, 49196, 51062], "temperature": 0.0, "avg_logprob": -0.17141923786681376, "compression_ratio": 1.679245283018868, "no_speech_prob": 0.015350643545389175}, {"id": 138, "seek": 84118, "start": 855.14, "end": 861.8599999999999, "text": " that allow us to inject dependencies without having to manually wire it and don't have", "tokens": [51062, 300, 2089, 505, 281, 10711, 36606, 1553, 1419, 281, 16945, 6234, 309, 293, 500, 380, 362, 51398], "temperature": 0.0, "avg_logprob": -0.17141923786681376, "compression_ratio": 1.679245283018868, "no_speech_prob": 0.015350643545389175}, {"id": 139, "seek": 84118, "start": 861.8599999999999, "end": 866.62, "text": " to explicitly pass them in the parameters of the function. I don't want to have this", "tokens": [51398, 281, 20803, 1320, 552, 294, 264, 9834, 295, 264, 2445, 13, 286, 500, 380, 528, 281, 362, 341, 51636], "temperature": 0.0, "avg_logprob": -0.17141923786681376, "compression_ratio": 1.679245283018868, "no_speech_prob": 0.015350643545389175}, {"id": 140, "seek": 86662, "start": 866.62, "end": 871.34, "text": " IDER in my return type. I want something more elegant, something that is very similar to", "tokens": [50364, 7348, 1598, 294, 452, 2736, 2010, 13, 286, 528, 746, 544, 21117, 11, 746, 300, 307, 588, 2531, 281, 50600], "temperature": 0.0, "avg_logprob": -0.1675548553466797, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.0011071654735133052}, {"id": 141, "seek": 86662, "start": 871.34, "end": 879.78, "text": " the nullable type or the context receiver. So how can we do that? In Errol, a library", "tokens": [50600, 264, 18184, 712, 2010, 420, 264, 4319, 20086, 13, 407, 577, 393, 321, 360, 300, 30, 682, 3300, 6623, 11, 257, 6405, 51022], "temperature": 0.0, "avg_logprob": -0.1675548553466797, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.0011071654735133052}, {"id": 142, "seek": 86662, "start": 879.78, "end": 887.82, "text": " that I'm working on, we have this type that we call race. And we can put the race also", "tokens": [51022, 300, 286, 478, 1364, 322, 11, 321, 362, 341, 2010, 300, 321, 818, 4569, 13, 400, 321, 393, 829, 264, 4569, 611, 51424], "temperature": 0.0, "avg_logprob": -0.1675548553466797, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.0011071654735133052}, {"id": 143, "seek": 86662, "start": 887.82, "end": 894.1800000000001, "text": " into the context receiver basically stating that this function has the capability of resulting", "tokens": [51424, 666, 264, 4319, 20086, 1936, 26688, 300, 341, 2445, 575, 264, 13759, 295, 16505, 51742], "temperature": 0.0, "avg_logprob": -0.1675548553466797, "compression_ratio": 1.6255707762557077, "no_speech_prob": 0.0011071654735133052}, {"id": 144, "seek": 89418, "start": 894.18, "end": 899.18, "text": " in a user already exists error. And now we can see that in the return type we are simply", "tokens": [50364, 294, 257, 4195, 1217, 8198, 6713, 13, 400, 586, 321, 393, 536, 300, 294, 264, 2736, 2010, 321, 366, 2935, 50614], "temperature": 0.0, "avg_logprob": -0.15247988968752743, "compression_ratio": 1.7095238095238094, "no_speech_prob": 0.012940633110702038}, {"id": 145, "seek": 89418, "start": 899.18, "end": 905.78, "text": " returning a user. So we don't have a need anymore for the IDER wrapper. We are just stating", "tokens": [50614, 12678, 257, 4195, 13, 407, 321, 500, 380, 362, 257, 643, 3602, 337, 264, 7348, 1598, 46906, 13, 492, 366, 445, 26688, 50944], "temperature": 0.0, "avg_logprob": -0.15247988968752743, "compression_ratio": 1.7095238095238094, "no_speech_prob": 0.012940633110702038}, {"id": 146, "seek": 89418, "start": 905.78, "end": 910.6999999999999, "text": " in the context of our function that if you are calling this function you need to be aware", "tokens": [50944, 294, 264, 4319, 295, 527, 2445, 300, 498, 291, 366, 5141, 341, 2445, 291, 643, 281, 312, 3650, 51190], "temperature": 0.0, "avg_logprob": -0.15247988968752743, "compression_ratio": 1.7095238095238094, "no_speech_prob": 0.012940633110702038}, {"id": 147, "seek": 89418, "start": 910.6999999999999, "end": 918.9799999999999, "text": " that at some point a user already exists error might occur and you need to deal with it.", "tokens": [51190, 300, 412, 512, 935, 257, 4195, 1217, 8198, 6713, 1062, 5160, 293, 291, 643, 281, 2028, 365, 309, 13, 51604], "temperature": 0.0, "avg_logprob": -0.15247988968752743, "compression_ratio": 1.7095238095238094, "no_speech_prob": 0.012940633110702038}, {"id": 148, "seek": 91898, "start": 919.98, "end": 926.58, "text": " Errol offers a bunch of very nice DSLs to, for example, wrap our query method and we", "tokens": [50414, 3300, 6623, 7736, 257, 3840, 295, 588, 1481, 15816, 43, 82, 281, 11, 337, 1365, 11, 7019, 527, 14581, 3170, 293, 321, 50744], "temperature": 0.0, "avg_logprob": -0.2363074692812833, "compression_ratio": 1.6650485436893203, "no_speech_prob": 0.019446931779384613}, {"id": 149, "seek": 91898, "start": 926.58, "end": 934.54, "text": " can say, okay, I want to catch the Postgres SQL exception from our query statement. And", "tokens": [50744, 393, 584, 11, 1392, 11, 286, 528, 281, 3745, 264, 10223, 45189, 19200, 11183, 490, 527, 14581, 5629, 13, 400, 51142], "temperature": 0.0, "avg_logprob": -0.2363074692812833, "compression_ratio": 1.6650485436893203, "no_speech_prob": 0.019446931779384613}, {"id": 150, "seek": 91898, "start": 934.54, "end": 938.5, "text": " in case of the Postgres SQL exception is a unique violation, so that means the user", "tokens": [51142, 294, 1389, 295, 264, 10223, 45189, 19200, 11183, 307, 257, 3845, 22840, 11, 370, 300, 1355, 264, 4195, 51340], "temperature": 0.0, "avg_logprob": -0.2363074692812833, "compression_ratio": 1.6650485436893203, "no_speech_prob": 0.019446931779384613}, {"id": 151, "seek": 91898, "start": 938.5, "end": 945.3000000000001, "text": " already exists in the database, I want to erase this error of the user already exists.", "tokens": [51340, 1217, 8198, 294, 264, 8149, 11, 286, 528, 281, 23525, 341, 6713, 295, 264, 4195, 1217, 8198, 13, 51680], "temperature": 0.0, "avg_logprob": -0.2363074692812833, "compression_ratio": 1.6650485436893203, "no_speech_prob": 0.019446931779384613}, {"id": 152, "seek": 94530, "start": 946.02, "end": 952.8199999999999, "text": " So we can now erase this typed error into the context saying, okay, the user already exists", "tokens": [50400, 407, 321, 393, 586, 23525, 341, 33941, 6713, 666, 264, 4319, 1566, 11, 1392, 11, 264, 4195, 1217, 8198, 50740], "temperature": 0.0, "avg_logprob": -0.20840913195942723, "compression_ratio": 1.7658536585365854, "no_speech_prob": 0.003970787860453129}, {"id": 153, "seek": 94530, "start": 952.8199999999999, "end": 958.78, "text": " so somebody needs to deal with that at a later point. And I'm also retrawing any other errors", "tokens": [50740, 370, 2618, 2203, 281, 2028, 365, 300, 412, 257, 1780, 935, 13, 400, 286, 478, 611, 1533, 5131, 278, 604, 661, 13603, 51038], "temperature": 0.0, "avg_logprob": -0.20840913195942723, "compression_ratio": 1.7658536585365854, "no_speech_prob": 0.003970787860453129}, {"id": 154, "seek": 94530, "start": 958.78, "end": 964.3, "text": " basically saying any other errors is something that I cannot recover from. It's something", "tokens": [51038, 1936, 1566, 604, 661, 13603, 307, 746, 300, 286, 2644, 8114, 490, 13, 467, 311, 746, 51314], "temperature": 0.0, "avg_logprob": -0.20840913195942723, "compression_ratio": 1.7658536585365854, "no_speech_prob": 0.003970787860453129}, {"id": 155, "seek": 94530, "start": 964.3, "end": 969.42, "text": " unexpected, something that you're not going to deal with at a later point in time. And", "tokens": [51314, 13106, 11, 746, 300, 291, 434, 406, 516, 281, 2028, 365, 412, 257, 1780, 935, 294, 565, 13, 400, 51570], "temperature": 0.0, "avg_logprob": -0.20840913195942723, "compression_ratio": 1.7658536585365854, "no_speech_prob": 0.003970787860453129}, {"id": 156, "seek": 96942, "start": 969.42, "end": 976.3399999999999, "text": " what your criteria are for this are of course up to whoever writes the code or however you", "tokens": [50364, 437, 428, 11101, 366, 337, 341, 366, 295, 1164, 493, 281, 11387, 13657, 264, 3089, 420, 4461, 291, 50710], "temperature": 0.0, "avg_logprob": -0.166455104433257, "compression_ratio": 1.8258706467661692, "no_speech_prob": 0.005601737182587385}, {"id": 157, "seek": 96942, "start": 976.3399999999999, "end": 985.26, "text": " want to model your code. And then if you want to call this function, you can again provide", "tokens": [50710, 528, 281, 2316, 428, 3089, 13, 400, 550, 498, 291, 528, 281, 818, 341, 2445, 11, 291, 393, 797, 2893, 51156], "temperature": 0.0, "avg_logprob": -0.166455104433257, "compression_ratio": 1.8258706467661692, "no_speech_prob": 0.005601737182587385}, {"id": 158, "seek": 96942, "start": 985.26, "end": 989.5, "text": " the dependencies of database and logger and you can say at the edge of the world or wherever", "tokens": [51156, 264, 36606, 295, 8149, 293, 3565, 1321, 293, 291, 393, 584, 412, 264, 4691, 295, 264, 1002, 420, 8660, 51368], "temperature": 0.0, "avg_logprob": -0.166455104433257, "compression_ratio": 1.8258706467661692, "no_speech_prob": 0.005601737182587385}, {"id": 159, "seek": 96942, "start": 989.5, "end": 996.86, "text": " you want to need to call this function, run the effect, right? And this provides the context", "tokens": [51368, 291, 528, 281, 643, 281, 818, 341, 2445, 11, 1190, 264, 1802, 11, 558, 30, 400, 341, 6417, 264, 4319, 51736], "temperature": 0.0, "avg_logprob": -0.166455104433257, "compression_ratio": 1.8258706467661692, "no_speech_prob": 0.005601737182587385}, {"id": 160, "seek": 99686, "start": 996.86, "end": 1002.94, "text": " of arrays that we have before. And what is actually interesting here is Kotlin is able", "tokens": [50364, 295, 41011, 300, 321, 362, 949, 13, 400, 437, 307, 767, 1880, 510, 307, 30123, 5045, 307, 1075, 50668], "temperature": 0.0, "avg_logprob": -0.1512110721634095, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.006175781600177288}, {"id": 161, "seek": 99686, "start": 1002.94, "end": 1008.46, "text": " to infer all these types so we don't have to explicitly provide any type arguments because", "tokens": [50668, 281, 13596, 439, 613, 3467, 370, 321, 500, 380, 362, 281, 20803, 2893, 604, 2010, 12869, 570, 50944], "temperature": 0.0, "avg_logprob": -0.1512110721634095, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.006175781600177288}, {"id": 162, "seek": 99686, "start": 1008.46, "end": 1015.54, "text": " it knows the error that might occur is from the user already exists type. So here it knows", "tokens": [50944, 309, 3255, 264, 6713, 300, 1062, 5160, 307, 490, 264, 4195, 1217, 8198, 2010, 13, 407, 510, 309, 3255, 51298], "temperature": 0.0, "avg_logprob": -0.1512110721634095, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.006175781600177288}, {"id": 163, "seek": 99686, "start": 1015.54, "end": 1020.22, "text": " that the error that we need to recover from is the user already exists. And then we can", "tokens": [51298, 300, 264, 6713, 300, 321, 643, 281, 8114, 490, 307, 264, 4195, 1217, 8198, 13, 400, 550, 321, 393, 51532], "temperature": 0.0, "avg_logprob": -0.1512110721634095, "compression_ratio": 1.7198067632850242, "no_speech_prob": 0.006175781600177288}, {"id": 164, "seek": 102022, "start": 1020.22, "end": 1026.7, "text": " say, okay, fold over this method and either print the error or print the inserted user.", "tokens": [50364, 584, 11, 1392, 11, 4860, 670, 341, 3170, 293, 2139, 4482, 264, 6713, 420, 4482, 264, 27992, 4195, 13, 50688], "temperature": 0.0, "avg_logprob": -0.24062707289209906, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.022488506510853767}, {"id": 165, "seek": 102022, "start": 1026.7, "end": 1032.82, "text": " Right? So this is a very simple example in the API that is available for this method which", "tokens": [50688, 1779, 30, 407, 341, 307, 257, 588, 2199, 1365, 294, 264, 9362, 300, 307, 2435, 337, 341, 3170, 597, 50994], "temperature": 0.0, "avg_logprob": -0.24062707289209906, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.022488506510853767}, {"id": 166, "seek": 102022, "start": 1032.82, "end": 1038.22, "text": " is much, much larger. And what is also neat what I really like about Kotlin is we have", "tokens": [50994, 307, 709, 11, 709, 4833, 13, 400, 437, 307, 611, 10654, 437, 286, 534, 411, 466, 30123, 5045, 307, 321, 362, 51264], "temperature": 0.0, "avg_logprob": -0.24062707289209906, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.022488506510853767}, {"id": 167, "seek": 102022, "start": 1038.22, "end": 1044.26, "text": " these special DSL sketch and arrays and they actually show up as special functions in the", "tokens": [51264, 613, 2121, 15816, 43, 12325, 293, 41011, 293, 436, 767, 855, 493, 382, 2121, 6828, 294, 264, 51566], "temperature": 0.0, "avg_logprob": -0.24062707289209906, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.022488506510853767}, {"id": 168, "seek": 102022, "start": 1044.26, "end": 1048.98, "text": " ID. So here the catch method and the erase method show up as pink stating that they", "tokens": [51566, 7348, 13, 407, 510, 264, 3745, 3170, 293, 264, 23525, 3170, 855, 493, 382, 7022, 26688, 300, 436, 51802], "temperature": 0.0, "avg_logprob": -0.24062707289209906, "compression_ratio": 1.7283464566929134, "no_speech_prob": 0.022488506510853767}, {"id": 169, "seek": 104898, "start": 1048.98, "end": 1054.82, "text": " are doing some special kind of DSL functionality that belongs to the erase capability in the", "tokens": [50364, 366, 884, 512, 2121, 733, 295, 15816, 43, 14980, 300, 12953, 281, 264, 23525, 13759, 294, 264, 50656], "temperature": 0.0, "avg_logprob": -0.19454475851619946, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.0008483869023621082}, {"id": 170, "seek": 104898, "start": 1054.82, "end": 1062.14, "text": " context. So I mentioned the error in this last set of slides. We've typed error so what", "tokens": [50656, 4319, 13, 407, 286, 2835, 264, 6713, 294, 341, 1036, 992, 295, 9788, 13, 492, 600, 33941, 6713, 370, 437, 51022], "temperature": 0.0, "avg_logprob": -0.19454475851619946, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.0008483869023621082}, {"id": 171, "seek": 104898, "start": 1062.14, "end": 1070.58, "text": " is the goal of error? It offers this DSL based functional programming style of dealing with", "tokens": [51022, 307, 264, 3387, 295, 6713, 30, 467, 7736, 341, 15816, 43, 2361, 11745, 9410, 3758, 295, 6260, 365, 51444], "temperature": 0.0, "avg_logprob": -0.19454475851619946, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.0008483869023621082}, {"id": 172, "seek": 104898, "start": 1070.58, "end": 1074.78, "text": " things. And the goal of that is we want to get rid of a lot of complexity of functional", "tokens": [51444, 721, 13, 400, 264, 3387, 295, 300, 307, 321, 528, 281, 483, 3973, 295, 257, 688, 295, 14024, 295, 11745, 51654], "temperature": 0.0, "avg_logprob": -0.19454475851619946, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.0008483869023621082}, {"id": 173, "seek": 107478, "start": 1074.78, "end": 1082.1, "text": " programming, things like map, flat map, monotransformers, wrappers in the return types, etc. Right?", "tokens": [50364, 9410, 11, 721, 411, 4471, 11, 4962, 4471, 11, 1108, 310, 25392, 837, 433, 11, 7843, 15226, 294, 264, 2736, 3467, 11, 5183, 13, 1779, 30, 50730], "temperature": 0.0, "avg_logprob": -0.1834717001966251, "compression_ratio": 1.6576576576576576, "no_speech_prob": 0.062368035316467285}, {"id": 174, "seek": 107478, "start": 1082.1, "end": 1087.26, "text": " And we do this so that we can provide an idiomatic Kotlin syntax for working with functional", "tokens": [50730, 400, 321, 360, 341, 370, 300, 321, 393, 2893, 364, 18014, 13143, 30123, 5045, 28431, 337, 1364, 365, 11745, 50988], "temperature": 0.0, "avg_logprob": -0.1834717001966251, "compression_ratio": 1.6576576576576576, "no_speech_prob": 0.062368035316467285}, {"id": 175, "seek": 107478, "start": 1087.26, "end": 1091.82, "text": " programming. And what is also really neat is it is actually Kotlin multipath from ready.", "tokens": [50988, 9410, 13, 400, 437, 307, 611, 534, 10654, 307, 309, 307, 767, 30123, 5045, 3311, 998, 490, 1919, 13, 51216], "temperature": 0.0, "avg_logprob": -0.1834717001966251, "compression_ratio": 1.6576576576576576, "no_speech_prob": 0.062368035316467285}, {"id": 176, "seek": 107478, "start": 1091.82, "end": 1096.78, "text": " So all the talks that we saw this morning, in all of those things you can also already", "tokens": [51216, 407, 439, 264, 6686, 300, 321, 1866, 341, 2446, 11, 294, 439, 295, 729, 721, 291, 393, 611, 1217, 51464], "temperature": 0.0, "avg_logprob": -0.1834717001966251, "compression_ratio": 1.6576576576576576, "no_speech_prob": 0.062368035316467285}, {"id": 177, "seek": 109678, "start": 1096.78, "end": 1105.34, "text": " use error in this style of programming. It offers a couple of more DSLs. For example,", "tokens": [50364, 764, 6713, 294, 341, 3758, 295, 9410, 13, 467, 7736, 257, 1916, 295, 544, 15816, 43, 82, 13, 1171, 1365, 11, 50792], "temperature": 0.0, "avg_logprob": -0.21518886500391468, "compression_ratio": 1.778225806451613, "no_speech_prob": 0.19562438130378723}, {"id": 178, "seek": 109678, "start": 1105.34, "end": 1110.1, "text": " the Saga scope. So for people that are working with the Saga pattern on the backend, we saw", "tokens": [50792, 264, 318, 9286, 11923, 13, 407, 337, 561, 300, 366, 1364, 365, 264, 318, 9286, 5102, 322, 264, 38087, 11, 321, 1866, 51030], "temperature": 0.0, "avg_logprob": -0.21518886500391468, "compression_ratio": 1.778225806451613, "no_speech_prob": 0.19562438130378723}, {"id": 179, "seek": 109678, "start": 1110.1, "end": 1116.98, "text": " that backend is an increasing industry in Kotlin. So when you're working with the Saga", "tokens": [51030, 300, 38087, 307, 364, 5662, 3518, 294, 30123, 5045, 13, 407, 562, 291, 434, 1364, 365, 264, 318, 9286, 51374], "temperature": 0.0, "avg_logprob": -0.21518886500391468, "compression_ratio": 1.778225806451613, "no_speech_prob": 0.19562438130378723}, {"id": 180, "seek": 109678, "start": 1116.98, "end": 1121.82, "text": " pattern, again, you don't want to have any return or wrappers in the return type. So", "tokens": [51374, 5102, 11, 797, 11, 291, 500, 380, 528, 281, 362, 604, 2736, 420, 7843, 15226, 294, 264, 2736, 2010, 13, 407, 51616], "temperature": 0.0, "avg_logprob": -0.21518886500391468, "compression_ratio": 1.778225806451613, "no_speech_prob": 0.19562438130378723}, {"id": 181, "seek": 109678, "start": 1121.82, "end": 1126.54, "text": " we have the Saga DSL that allows you to wrap any action with a compensating action, meaning", "tokens": [51616, 321, 362, 264, 318, 9286, 15816, 43, 300, 4045, 291, 281, 7019, 604, 3069, 365, 257, 11598, 990, 3069, 11, 3620, 51852], "temperature": 0.0, "avg_logprob": -0.21518886500391468, "compression_ratio": 1.778225806451613, "no_speech_prob": 0.19562438130378723}, {"id": 182, "seek": 112654, "start": 1126.54, "end": 1132.1599999999999, "text": " that if something goes wrong in the program, the compensating action will run compensating", "tokens": [50364, 300, 498, 746, 1709, 2085, 294, 264, 1461, 11, 264, 11598, 990, 3069, 486, 1190, 11598, 990, 50645], "temperature": 0.0, "avg_logprob": -0.16893930788393374, "compression_ratio": 1.7, "no_speech_prob": 0.003401506459340453}, {"id": 183, "seek": 112654, "start": 1132.1599999999999, "end": 1139.94, "text": " the action. Similarly for resource safety, we can say, okay, I'm going to install some", "tokens": [50645, 264, 3069, 13, 13157, 337, 7684, 4514, 11, 321, 393, 584, 11, 1392, 11, 286, 478, 516, 281, 3625, 512, 51034], "temperature": 0.0, "avg_logprob": -0.16893930788393374, "compression_ratio": 1.7, "no_speech_prob": 0.003401506459340453}, {"id": 184, "seek": 112654, "start": 1139.94, "end": 1144.6599999999999, "text": " resource and whenever you're done using the resource, you need to automatically call this", "tokens": [51034, 7684, 293, 5699, 291, 434, 1096, 1228, 264, 7684, 11, 291, 643, 281, 6772, 818, 341, 51270], "temperature": 0.0, "avg_logprob": -0.16893930788393374, "compression_ratio": 1.7, "no_speech_prob": 0.003401506459340453}, {"id": 185, "seek": 112654, "start": 1144.6599999999999, "end": 1150.26, "text": " release function with the log statement and the auto-closable function, which offers some", "tokens": [51270, 4374, 2445, 365, 264, 3565, 5629, 293, 264, 8399, 12, 3474, 329, 712, 2445, 11, 597, 7736, 512, 51550], "temperature": 0.0, "avg_logprob": -0.16893930788393374, "compression_ratio": 1.7, "no_speech_prob": 0.003401506459340453}, {"id": 186, "seek": 115026, "start": 1150.26, "end": 1158.78, "text": " special syntax for GVM functionality. So what do I love about functional programming", "tokens": [50364, 2121, 28431, 337, 460, 53, 44, 14980, 13, 407, 437, 360, 286, 959, 466, 11745, 9410, 50790], "temperature": 0.0, "avg_logprob": -0.1486757479215923, "compression_ratio": 1.6018518518518519, "no_speech_prob": 0.05818992853164673}, {"id": 187, "seek": 115026, "start": 1158.78, "end": 1165.3799999999999, "text": " in Kotlin? We can do it in a very elegant way using DSLs. And all of these DSLs are", "tokens": [50790, 294, 30123, 5045, 30, 492, 393, 360, 309, 294, 257, 588, 21117, 636, 1228, 15816, 43, 82, 13, 400, 439, 295, 613, 15816, 43, 82, 366, 51120], "temperature": 0.0, "avg_logprob": -0.1486757479215923, "compression_ratio": 1.6018518518518519, "no_speech_prob": 0.05818992853164673}, {"id": 188, "seek": 115026, "start": 1165.3799999999999, "end": 1171.58, "text": " composable. So it means that you can nest these DSLs in a safe way. They will cooperate", "tokens": [51120, 10199, 712, 13, 407, 309, 1355, 300, 291, 393, 15646, 613, 15816, 43, 82, 294, 257, 3273, 636, 13, 814, 486, 26667, 51430], "temperature": 0.0, "avg_logprob": -0.1486757479215923, "compression_ratio": 1.6018518518518519, "no_speech_prob": 0.05818992853164673}, {"id": 189, "seek": 115026, "start": 1171.58, "end": 1176.22, "text": " with each other. They will do the right thing. They're all type safe. And this offers you", "tokens": [51430, 365, 1184, 661, 13, 814, 486, 360, 264, 558, 551, 13, 814, 434, 439, 2010, 3273, 13, 400, 341, 7736, 291, 51662], "temperature": 0.0, "avg_logprob": -0.1486757479215923, "compression_ratio": 1.6018518518518519, "no_speech_prob": 0.05818992853164673}, {"id": 190, "seek": 117622, "start": 1176.22, "end": 1181.26, "text": " a very low threshold for getting into functional programming in Kotlin. You don't have to learn", "tokens": [50364, 257, 588, 2295, 14678, 337, 1242, 666, 11745, 9410, 294, 30123, 5045, 13, 509, 500, 380, 362, 281, 1466, 50616], "temperature": 0.0, "avg_logprob": -0.1677117402526154, "compression_ratio": 1.4978723404255319, "no_speech_prob": 0.022176610305905342}, {"id": 191, "seek": 117622, "start": 1181.26, "end": 1186.58, "text": " anything about map, flat map, special monads, monadransformers. All of these things are", "tokens": [50616, 1340, 466, 4471, 11, 4962, 4471, 11, 2121, 1108, 5834, 11, 1108, 345, 25392, 837, 433, 13, 1057, 295, 613, 721, 366, 50882], "temperature": 0.0, "avg_logprob": -0.1677117402526154, "compression_ratio": 1.4978723404255319, "no_speech_prob": 0.022176610305905342}, {"id": 192, "seek": 117622, "start": 1186.58, "end": 1194.9, "text": " not needed because you can very elegantly nest and compose these DSLs together. Seems", "tokens": [50882, 406, 2978, 570, 291, 393, 588, 14459, 3627, 15646, 293, 35925, 613, 15816, 43, 82, 1214, 13, 22524, 51298], "temperature": 0.0, "avg_logprob": -0.1677117402526154, "compression_ratio": 1.4978723404255319, "no_speech_prob": 0.022176610305905342}, {"id": 193, "seek": 117622, "start": 1194.9, "end": 1200.8600000000001, "text": " that I'm right on time. Just five minutes left for questions and thank you so much", "tokens": [51298, 300, 286, 478, 558, 322, 565, 13, 1449, 1732, 2077, 1411, 337, 1651, 293, 1309, 291, 370, 709, 51596], "temperature": 0.0, "avg_logprob": -0.1677117402526154, "compression_ratio": 1.4978723404255319, "no_speech_prob": 0.022176610305905342}, {"id": 194, "seek": 120086, "start": 1200.86, "end": 1201.78, "text": " all for your attention.", "tokens": [50364, 439, 337, 428, 3202, 13, 50410], "temperature": 0.0, "avg_logprob": -0.5081716179847717, "compression_ratio": 0.7419354838709677, "no_speech_prob": 0.5805147290229797}], "language": "en"}