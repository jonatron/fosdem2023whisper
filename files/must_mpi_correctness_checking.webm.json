{"text": " Okay, we're good to get started with one more MPI talk, but I think a very different one compared to the others. Hopefully. Compiler-added MPI correctness check. Yeah. Thank you. So my name is Alexander H\u00fcck, and today I'm going to talk about basically the dynamic MPI correctness tool, which is called MUST. And in particular, I'm going to talk about the compiler extension, which is called Type Art, which is supposed to help with MPI type correctness checking. And first of all, as we heard before, the message-passing interface is the defector standard of distributed computations in the HPC world, right? And it defines a large set of communication routines and other stuff, and it's also designed for a heterogeneous cluster system where you have different platforms that communicate and compute something. However, in that sense, it's also very low-level interface where you have to specify a lot of stuff manually, and you can expect only a little error checking in general from the library itself. So the user is required for the simple MPI send operation to specify the data, which is transferred as a typeless void buffer. The user has to specify its data length of the buffer and the user and the type manually, and also the message envelope, so the destination of the message and the communicate and stuff like that has to be specified manually. So there's a lot of opportunity to commit a mistake, basically. And this is quite a question to you guys, if you look at this small code, try to figure out how many errors you can spot in this small example. And just try to look at every corner, basically. And while I'm talking, I can also spoiler you that I'm going to show you every issue in this small example in a couple of seconds, so to speak. When I first looked at it, my colleague Joachim showed me I couldn't find the most simple one that was a bit crazy to me. Sometimes you don't see the forest in front of the trees. OK, so the most basic one, we don't call MPI in it, right? That's usually in MPI applications. That's the very first call you're supposed to do, where you initialize the MPI environment. And then likewise, if you look at the end of the program, we do not call MPI finalize. So those are two simple mistakes. But then in total, we have eight issues. I don't know how many you found. And I'm also not going to talk about each one of them, but it's quite easy to, if you look at each individual issue, to kind of guess that it can happen to you also. And those are the pointers where they are. And in particular, I want to talk about the receive-receive deadlock, where, for instance, two process weights on each other without being able to continue. You can argue that all those issues, except maybe the deadlock, could be found by the MPI library itself. But typically on HPC systems, the library does not do any checking for performance reasons. That's why many of these issues will not be, will cause maybe crashes for unknown reasons or just produce some strange results. Well, that's why the dynamic MPI correctness tool must was developed in the past, which is a tool that during runtime checks for issues and produces such reports where it finds some issues. And this is a report of the deadlock we have seen in the example code, where the message itself just describes there's a deadlock. In the bottom left, you can see a wait for graph, which just shows you which rank waits for another rank causing the deadlock. This helps you to kind of see where the deadlock occurs and why it occurs. And also, must can produce so-called call stack information, where you can see, beginning from main of the program to the basically origin of the deadlock, but this was omitted now. Okay. So, to facilitate correctness checking for MPI, must uses a so-called distributed agent-based analysis, which means that you have your normal MPI application with four ranks, four processes that communicate as you would expect as the user wrote it. But must will also create a analysis network, which helps you to do local analysis, it helps you to do distributed analysis. If you think about a deadlock, you need information for more than one process to figure out that there occurred a deadlock in your program. So must creates that completely transparent to the user, so you would use MPI comworld and any other communicator as normal, must takes care of creating such a network. And also, what's maybe the focus of the talk today is the local analysis, where we look at process local checks. If you think about MPI type correctness of a send operation, you can do a lot of stuff locally, or I should do a lot of stuff locally, and this is the focus. So, MPI type correctness, we focus basically on the buffer and the user-specified length and the user-specified MPI data type today. Must can already detect mismatches of, for instance, the send and receive communication pair, where must basically creates a so-called type map, it looks at the user-specified buffer size and the user-specified data type, and compares it to the corresponding receive operation. If there is a mismatch, obviously, there is going to be an issue, and must creates a report about that. This also, of course, works for collective communications, where you can make sure that all ranks call, for instance, a broadcast operation with the same data type. However, since must only intercepts MPI calls in general, it cannot look behind a device, like it cannot look what happens in user space, you know. So, we cannot reason about the type of the Void buffer data, and this is why we were motivated to create the tool type art, which is something that helps with basically figuring out what the memory allocation is that you put into your MPI calls. So, if you look at this small example on the right side, completely processed locally, there might be some memory allocation in that example, it's a double buffer that was allocated by Melloc, let's say, and the question now becomes, how can we make sure that data, the data buffer, which is a Void buffer, fits the user-specified buffer size, so is it of length buffer size, and it also should be compatible with the MPI float type, and of course, we can already see that double and MPI float, there's a type mismatch, but must cannot answer such a question without further tooling, because it just intercepts MPI calls. Okay, so to just show you that it's not an academic example, there's two well-known HPC benchmark codes, which have some issues, so one was reported in the past by others, where there's a broadcast operation, it uses a big end, which is an alias for a 64-bit data type, however, the user-specified MPI end, which is a 32-bit data type for the broadcast operation, so there's an obvious mismatch, that could be a problem, likely, and also for milk, there's an all-reduced operation, where the user's passed in a struct with two float members, and it's interpreted as a float array of size two, which is B9, to be honest, but that could be a portability issue in the future, maybe, you know, depending on the platform, maybe there's padding, or whatnot, and maybe it's an illegal operation, so this could also be an issue in the future. Well, from a high-level point of view, how it does must work, well, you have your MPI application, and during runtime, it intercepts all the MPI calls, and collects all the states that it's needed for deadlock detection, and so on, and we added type art, which looks at all those allocations that are passed to MPI calls for those local analysis of buffers, which is the compiler extension based on LLVM, so you compile your code with our extension, and the extension instruments all allocations, be it stack, be it heap, which are related to MPI calls, and we also provide a runtime, so during runtime, we get callbacks of the target application, all allocations, all free operations, so we have a state of the allocation of the memory, basically, in a target code. We also, of course, look at the allocations and pass out their type, so simple case is buffer, A is a double type, more complex cases would be structs or classes, we pass the serialized type information to our runtime, which then enables, of course, must to make queries, so for instance, for an MPI center operation, we give the type art runtime the buffer, the typeless buffer, and the runtime would return all the necessary type information to ensure type correctness of those buffer handles. This is the whole high level process behind it. And then if you take a look at an example of a memory allocation, C is a small heap allocation of a float array, this all happens in LLVM IR, I'm just showing C like code to make it easier to understand, we would add such a type art alloc callback, which where we need the data pointer, of course, and then we need a so called type ID, it's just a representation of what we allocated, that is later used for type checking, and of course we need the dynamic length of the allocated array to reason about where we are in the memory space, so to speak. Once we handle stack and global allocations, for stack allocations, of course, we have to respect the automatic scope dependent lifetime properties, and for global we just register once and then it exists at our runtime for the whole program duration. And of course, for performance reasons, you can imagine that the less callbacks the better, hence we try to filter out allocations where we can prove that they are never part of an MPI call and just never instrument those. This is basically possible on LLVM IR by data flow analysis, so in the function foo we have two stack allocations and then we try to follow the data flow where we can see that A is passed to bar, and inside bar there's never any MPI call, so we can just say, okay, we do not need to instrument this, this is discarded. Likewise for foo bar, we can see that B is passed, if it's in another translation unit we would need to have a whole program view of the program, which we support, but other tools have to create such a call graph with those required information. Anyways, so also if we had this view, we can see foo bar also does not call MPI, so both stack allocations don't need to be instrumented, which helps a lot with the performance. Okay, so the type ID which is passed to the runtime for identification works as follows, built-in types are obviously known a priori, so we know the type layout, float is 4 bytes, double is 8 bytes, depending on platform of course, for user defined types, which means structs, classes and so on, we basically serialize it to a YAML file and the corresponding type ID of course, so we can match those during runtime, where we have the extent how many members offsets, byte offsets basically from the beginning of the struct, and also the subtypes are listed, which can then be used for making type queries about the layout and stuff like that. And then of course, must needs to have some API to figure out type correctness, and this is provided by our runtime, which has quite a few API functions, the most basic one would be this type out get type where you put in the MPI buffer handle, and what we put out is the type ID and the error length, and then you can use the type ID subsequently, for instance in this call where you put in the type ID and you get out the struct layout I just mentioned earlier, and this way you kind of can assemble some iterative type checking which is done in must. And then putting it all together, if you want to use our tooling, you would need to first of all compile your program with our provided compiler wrapper, which is a batch script and does the bookkeeping require to introduce the instrumentation, the type out stuff, so you exchange your compiler, that's the first step, it's optional, you don't have to do it if you don't need this local type out checking, and then you would also need to replace your MPI exec or MPI run depending on the system with the must run, which also does some bookkeeping for must to execute the target code appropriately, spawn all the analysis agent based networking and so on, and then the program runs as normal and must output file is generated with all issues found during execution of your program, and as a side note maybe, as I said must does this agent based network and in the most simple case for the distributed analysis, there's an additional process needed for the deadlock detection and so on, so for SLAM or whatnot you need to allocate an additional process, however you don't need to specify it in the must run stuff, it happens automatically in the background, alright, so that's it, if you look now at what the impact is of our tooling, well that's quite dependent as I kind of alluded to, how many callbacks you have, how many memory allocations you actually have to track, and how good we are at filtering them, so here's two examples, Lulech and Tachyon, which are again quite well known HPC benchmarking codes, and Lulech is quite favorable for our presentation because there's not many callbacks and hence our runtime impact is like quite non-existent so to speak, where you can see that this is compared to vanilla without any instrumentation without our tooling, type art almost has no impact, and then with type art analysis enabled has almost no additional impact, for Tachyon the picture looks quite different as you can see, there's an overhead factor of about three using when you introduce type art, this is because there's a lot of stack allocations that cannot filter, so we track a lot of stack allocations and the runtime impact is quite high, and this is reflected by those runtime and static instrumentation numbers, so first of all the buff table here shows you during compilation what we instrument, so you can see that there's some heap free operations that we find an instrument, there's some stack allocations and globals that we instrument, well of course those numbers do not represent the runtime numbers because heap and free operations sometimes are written in a way that they are like centralized in a program, that's why those numbers are not as high as you would expect, for stack allocations we find 54 and out of those 54 we can filter for Lulish at least 21%, and globals are much easier to follow along the data flow in LLVM IR so we can filter much more and much more effectively, well going to the runtime numbers which means that those are basically the number of callbacks that happen during our benchmarking, we can already see that the high overhead of which we observed in Tachyon is to be explained by the almost 80 million stack allocation callbacks basically that we have to track during runtime, which is a lot of context switching and so on, which is not good for the runtime, alright so this is already my conclusion, what we have done is basically with type art must can now check all phases of the MPI communication with respect to type correctness, so the first phase that must can already do is this one, which is basically the message transfer, this is checked against, however there is also the phase of message assembly, right where you go kind of from the user process into the MPI process and you have to check this, and of course if you think about it you would also have to kind of check the message disassembly where you go from the received data to your user program again, so type art enables these kind of local checks to ensure type correctness, thank you very much. Any questions? Yeah so I really like to talk, I thought it was really interesting, so one thing I wanted to ask was how does one get must, like how do they install it, is it available for distribution package managers or is it more that you have to compile it yourself? Good question, I think you have to compile it yourself, even on our HPC system so, but it's not that tedious to compile I think, maybe I'm biased, but just go to the website and there's a zip file, it includes every dependency that you need and I think the documentation is quite straightforward, you need of course maybe open MPI installed, but not much more to be honest and then you should be good to go, yeah, I think it's CMAC based, I don't know if you have problems with that, but yeah, it should be straightforward to try it out. Thank you, another question there on my way. So on the type analysis that you do, I mean if you look at malloc and it has like a type cast then you know what the type is, but if it doesn't have a type cast, if you malloc into a void pointer and if the amount of bytes you are allocating comes from some constant or macro or some argument, how far do you follow and if you can't see it, do you have a warning, do you crash? That's a good question and that's basically a fundamental problem, right, so we have to have some expectations of the program, right, so our expectation is that the malloc calls are typed, otherwise we would just track it as a chunk of bytes and I think our analysis is quite forgiving, so we would just look at okay this is a chunk of bytes, it fits you know the buffer and this is fine. Yes, you kind of lose that, right, if you just know it's a chunk of bytes then you kind of lose the alignment checks because you could, if you have like say you malloc is struct and then you do some pointer magic for your MPI buffer and you point between members in the padding area, only if type art knows about the malloc struct, it can of course warn that you are doing some illegal memory operations, if we just see a void pointer due to the type plus malloc then we have lost basically, anyone else, do you have any thoughts on using Rust which is a way more memory safe language than C and C plus pluses, have you looked at it? Not really, not yet, for now we have so much to do with the C and C plus words to support typing better, to get more robustness and so on and not yet to be honest. Maybe all that work becomes irrelevant if Rust gets popular enough. I think in general maybe I'm completely like a newbie when it comes to Rust, I think the MPI support itself is still in the works, I read some papers about like generating bindings for MPI which are inherently type safe, not sure how that goes. I think everyone will be happy if Rust or some other type safe language becomes more used by people and this kind of work is irrelevant, but while people still use C plus pluses, this is very relevant. That pays my bills. Thank you very much. Thank you.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 10.0, "text": " Okay, we're good to get started with one more MPI talk, but I think a very different one", "tokens": [1033, 11, 321, 434, 665, 281, 483, 1409, 365, 472, 544, 14146, 40, 751, 11, 457, 286, 519, 257, 588, 819, 472], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 1, "seek": 0, "start": 10.0, "end": 11.0, "text": " compared to the others.", "tokens": [5347, 281, 264, 2357, 13], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 2, "seek": 0, "start": 11.0, "end": 12.0, "text": " Hopefully.", "tokens": [10429, 13], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 3, "seek": 0, "start": 12.0, "end": 13.72, "text": " Compiler-added MPI correctness check.", "tokens": [6620, 5441, 12, 345, 9207, 14146, 40, 3006, 1287, 1520, 13], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 4, "seek": 0, "start": 13.72, "end": 14.72, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 5, "seek": 0, "start": 14.72, "end": 15.72, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 6, "seek": 0, "start": 15.72, "end": 21.12, "text": " So my name is Alexander H\u00fcck, and today I'm going to talk about basically the dynamic", "tokens": [407, 452, 1315, 307, 14845, 389, 6536, 11, 293, 965, 286, 478, 516, 281, 751, 466, 1936, 264, 8546], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 7, "seek": 0, "start": 21.12, "end": 23.68, "text": " MPI correctness tool, which is called MUST.", "tokens": [14146, 40, 3006, 1287, 2290, 11, 597, 307, 1219, 376, 21536, 13], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 8, "seek": 0, "start": 23.68, "end": 28.2, "text": " And in particular, I'm going to talk about the compiler extension, which is called Type", "tokens": [400, 294, 1729, 11, 286, 478, 516, 281, 751, 466, 264, 31958, 10320, 11, 597, 307, 1219, 15576], "temperature": 0.0, "avg_logprob": -0.2671839730781421, "compression_ratio": 1.588, "no_speech_prob": 0.0709003433585167}, {"id": 9, "seek": 2820, "start": 28.2, "end": 34.8, "text": " Art, which is supposed to help with MPI type correctness checking.", "tokens": [5735, 11, 597, 307, 3442, 281, 854, 365, 14146, 40, 2010, 3006, 1287, 8568, 13], "temperature": 0.0, "avg_logprob": -0.11344952332346063, "compression_ratio": 1.4805825242718447, "no_speech_prob": 2.8323582228040323e-05}, {"id": 10, "seek": 2820, "start": 34.8, "end": 41.480000000000004, "text": " And first of all, as we heard before, the message-passing interface is the defector", "tokens": [400, 700, 295, 439, 11, 382, 321, 2198, 949, 11, 264, 3636, 12, 9216, 278, 9226, 307, 264, 16445, 284], "temperature": 0.0, "avg_logprob": -0.11344952332346063, "compression_ratio": 1.4805825242718447, "no_speech_prob": 2.8323582228040323e-05}, {"id": 11, "seek": 2820, "start": 41.480000000000004, "end": 46.44, "text": " standard of distributed computations in the HPC world, right?", "tokens": [3832, 295, 12631, 2807, 763, 294, 264, 12557, 34, 1002, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.11344952332346063, "compression_ratio": 1.4805825242718447, "no_speech_prob": 2.8323582228040323e-05}, {"id": 12, "seek": 2820, "start": 46.44, "end": 52.96, "text": " And it defines a large set of communication routines and other stuff, and it's also designed", "tokens": [400, 309, 23122, 257, 2416, 992, 295, 6101, 33827, 293, 661, 1507, 11, 293, 309, 311, 611, 4761], "temperature": 0.0, "avg_logprob": -0.11344952332346063, "compression_ratio": 1.4805825242718447, "no_speech_prob": 2.8323582228040323e-05}, {"id": 13, "seek": 5296, "start": 52.96, "end": 59.4, "text": " for a heterogeneous cluster system where you have different platforms that communicate", "tokens": [337, 257, 20789, 31112, 13630, 1185, 689, 291, 362, 819, 9473, 300, 7890], "temperature": 0.0, "avg_logprob": -0.14291507932874892, "compression_ratio": 1.583673469387755, "no_speech_prob": 2.3842454538680613e-05}, {"id": 14, "seek": 5296, "start": 59.4, "end": 61.4, "text": " and compute something.", "tokens": [293, 14722, 746, 13], "temperature": 0.0, "avg_logprob": -0.14291507932874892, "compression_ratio": 1.583673469387755, "no_speech_prob": 2.3842454538680613e-05}, {"id": 15, "seek": 5296, "start": 61.4, "end": 67.64, "text": " However, in that sense, it's also very low-level interface where you have to specify a lot", "tokens": [2908, 11, 294, 300, 2020, 11, 309, 311, 611, 588, 2295, 12, 12418, 9226, 689, 291, 362, 281, 16500, 257, 688], "temperature": 0.0, "avg_logprob": -0.14291507932874892, "compression_ratio": 1.583673469387755, "no_speech_prob": 2.3842454538680613e-05}, {"id": 16, "seek": 5296, "start": 67.64, "end": 73.4, "text": " of stuff manually, and you can expect only a little error checking in general from the", "tokens": [295, 1507, 16945, 11, 293, 291, 393, 2066, 787, 257, 707, 6713, 8568, 294, 2674, 490, 264], "temperature": 0.0, "avg_logprob": -0.14291507932874892, "compression_ratio": 1.583673469387755, "no_speech_prob": 2.3842454538680613e-05}, {"id": 17, "seek": 5296, "start": 73.4, "end": 74.88, "text": " library itself.", "tokens": [6405, 2564, 13], "temperature": 0.0, "avg_logprob": -0.14291507932874892, "compression_ratio": 1.583673469387755, "no_speech_prob": 2.3842454538680613e-05}, {"id": 18, "seek": 5296, "start": 74.88, "end": 82.0, "text": " So the user is required for the simple MPI send operation to specify the data, which", "tokens": [407, 264, 4195, 307, 4739, 337, 264, 2199, 14146, 40, 2845, 6916, 281, 16500, 264, 1412, 11, 597], "temperature": 0.0, "avg_logprob": -0.14291507932874892, "compression_ratio": 1.583673469387755, "no_speech_prob": 2.3842454538680613e-05}, {"id": 19, "seek": 8200, "start": 82.0, "end": 85.12, "text": " is transferred as a typeless void buffer.", "tokens": [307, 15809, 382, 257, 2010, 1832, 22009, 21762, 13], "temperature": 0.0, "avg_logprob": -0.1762988657890996, "compression_ratio": 1.71875, "no_speech_prob": 2.10446505661821e-05}, {"id": 20, "seek": 8200, "start": 85.12, "end": 92.48, "text": " The user has to specify its data length of the buffer and the user and the type manually,", "tokens": [440, 4195, 575, 281, 16500, 1080, 1412, 4641, 295, 264, 21762, 293, 264, 4195, 293, 264, 2010, 16945, 11], "temperature": 0.0, "avg_logprob": -0.1762988657890996, "compression_ratio": 1.71875, "no_speech_prob": 2.10446505661821e-05}, {"id": 21, "seek": 8200, "start": 92.48, "end": 97.8, "text": " and also the message envelope, so the destination of the message and the communicate and stuff", "tokens": [293, 611, 264, 3636, 19989, 11, 370, 264, 12236, 295, 264, 3636, 293, 264, 7890, 293, 1507], "temperature": 0.0, "avg_logprob": -0.1762988657890996, "compression_ratio": 1.71875, "no_speech_prob": 2.10446505661821e-05}, {"id": 22, "seek": 8200, "start": 97.8, "end": 99.64, "text": " like that has to be specified manually.", "tokens": [411, 300, 575, 281, 312, 22206, 16945, 13], "temperature": 0.0, "avg_logprob": -0.1762988657890996, "compression_ratio": 1.71875, "no_speech_prob": 2.10446505661821e-05}, {"id": 23, "seek": 8200, "start": 99.64, "end": 105.03999999999999, "text": " So there's a lot of opportunity to commit a mistake, basically.", "tokens": [407, 456, 311, 257, 688, 295, 2650, 281, 5599, 257, 6146, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.1762988657890996, "compression_ratio": 1.71875, "no_speech_prob": 2.10446505661821e-05}, {"id": 24, "seek": 10504, "start": 105.04, "end": 113.56, "text": " And this is quite a question to you guys, if you look at this small code, try to figure", "tokens": [400, 341, 307, 1596, 257, 1168, 281, 291, 1074, 11, 498, 291, 574, 412, 341, 1359, 3089, 11, 853, 281, 2573], "temperature": 0.0, "avg_logprob": -0.1537079553346376, "compression_ratio": 1.5649717514124293, "no_speech_prob": 2.872374352591578e-05}, {"id": 25, "seek": 10504, "start": 113.56, "end": 118.04, "text": " out how many errors you can spot in this small example.", "tokens": [484, 577, 867, 13603, 291, 393, 4008, 294, 341, 1359, 1365, 13], "temperature": 0.0, "avg_logprob": -0.1537079553346376, "compression_ratio": 1.5649717514124293, "no_speech_prob": 2.872374352591578e-05}, {"id": 26, "seek": 10504, "start": 118.04, "end": 122.96000000000001, "text": " And just try to look at every corner, basically.", "tokens": [400, 445, 853, 281, 574, 412, 633, 4538, 11, 1936, 13], "temperature": 0.0, "avg_logprob": -0.1537079553346376, "compression_ratio": 1.5649717514124293, "no_speech_prob": 2.872374352591578e-05}, {"id": 27, "seek": 10504, "start": 122.96000000000001, "end": 128.64000000000001, "text": " And while I'm talking, I can also spoiler you that I'm going to show you every issue", "tokens": [400, 1339, 286, 478, 1417, 11, 286, 393, 611, 26927, 291, 300, 286, 478, 516, 281, 855, 291, 633, 2734], "temperature": 0.0, "avg_logprob": -0.1537079553346376, "compression_ratio": 1.5649717514124293, "no_speech_prob": 2.872374352591578e-05}, {"id": 28, "seek": 12864, "start": 128.64, "end": 136.76, "text": " in this small example in a couple of seconds, so to speak.", "tokens": [294, 341, 1359, 1365, 294, 257, 1916, 295, 3949, 11, 370, 281, 1710, 13], "temperature": 0.0, "avg_logprob": -0.14641144026571246, "compression_ratio": 1.4, "no_speech_prob": 1.7723154087434523e-05}, {"id": 29, "seek": 12864, "start": 136.76, "end": 141.83999999999997, "text": " When I first looked at it, my colleague Joachim showed me I couldn't find the most simple", "tokens": [1133, 286, 700, 2956, 412, 309, 11, 452, 13532, 3139, 608, 332, 4712, 385, 286, 2809, 380, 915, 264, 881, 2199], "temperature": 0.0, "avg_logprob": -0.14641144026571246, "compression_ratio": 1.4, "no_speech_prob": 1.7723154087434523e-05}, {"id": 30, "seek": 12864, "start": 141.83999999999997, "end": 146.76, "text": " one that was a bit crazy to me.", "tokens": [472, 300, 390, 257, 857, 3219, 281, 385, 13], "temperature": 0.0, "avg_logprob": -0.14641144026571246, "compression_ratio": 1.4, "no_speech_prob": 1.7723154087434523e-05}, {"id": 31, "seek": 12864, "start": 146.76, "end": 153.44, "text": " Sometimes you don't see the forest in front of the trees.", "tokens": [4803, 291, 500, 380, 536, 264, 6719, 294, 1868, 295, 264, 5852, 13], "temperature": 0.0, "avg_logprob": -0.14641144026571246, "compression_ratio": 1.4, "no_speech_prob": 1.7723154087434523e-05}, {"id": 32, "seek": 15344, "start": 153.44, "end": 158.48, "text": " OK, so the most basic one, we don't call MPI in it, right?", "tokens": [2264, 11, 370, 264, 881, 3875, 472, 11, 321, 500, 380, 818, 14146, 40, 294, 309, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 33, "seek": 15344, "start": 158.48, "end": 160.84, "text": " That's usually in MPI applications.", "tokens": [663, 311, 2673, 294, 14146, 40, 5821, 13], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 34, "seek": 15344, "start": 160.84, "end": 166.72, "text": " That's the very first call you're supposed to do, where you initialize the MPI environment.", "tokens": [663, 311, 264, 588, 700, 818, 291, 434, 3442, 281, 360, 11, 689, 291, 5883, 1125, 264, 14146, 40, 2823, 13], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 35, "seek": 15344, "start": 166.72, "end": 171.16, "text": " And then likewise, if you look at the end of the program, we do not call MPI finalize.", "tokens": [400, 550, 32407, 11, 498, 291, 574, 412, 264, 917, 295, 264, 1461, 11, 321, 360, 406, 818, 14146, 40, 2572, 1125, 13], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 36, "seek": 15344, "start": 171.16, "end": 174.07999999999998, "text": " So those are two simple mistakes.", "tokens": [407, 729, 366, 732, 2199, 8038, 13], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 37, "seek": 15344, "start": 174.07999999999998, "end": 177.07999999999998, "text": " But then in total, we have eight issues.", "tokens": [583, 550, 294, 3217, 11, 321, 362, 3180, 2663, 13], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 38, "seek": 15344, "start": 177.07999999999998, "end": 178.96, "text": " I don't know how many you found.", "tokens": [286, 500, 380, 458, 577, 867, 291, 1352, 13], "temperature": 0.0, "avg_logprob": -0.17234346507924847, "compression_ratio": 1.5679012345679013, "no_speech_prob": 8.847589197102934e-05}, {"id": 39, "seek": 17896, "start": 178.96, "end": 186.32000000000002, "text": " And I'm also not going to talk about each one of them, but it's quite easy to, if you", "tokens": [400, 286, 478, 611, 406, 516, 281, 751, 466, 1184, 472, 295, 552, 11, 457, 309, 311, 1596, 1858, 281, 11, 498, 291], "temperature": 0.0, "avg_logprob": -0.15632723768552145, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.00011548891052370891}, {"id": 40, "seek": 17896, "start": 186.32000000000002, "end": 193.72, "text": " look at each individual issue, to kind of guess that it can happen to you also.", "tokens": [574, 412, 1184, 2609, 2734, 11, 281, 733, 295, 2041, 300, 309, 393, 1051, 281, 291, 611, 13], "temperature": 0.0, "avg_logprob": -0.15632723768552145, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.00011548891052370891}, {"id": 41, "seek": 17896, "start": 193.72, "end": 197.0, "text": " And those are the pointers where they are.", "tokens": [400, 729, 366, 264, 44548, 689, 436, 366, 13], "temperature": 0.0, "avg_logprob": -0.15632723768552145, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.00011548891052370891}, {"id": 42, "seek": 17896, "start": 197.0, "end": 202.88, "text": " And in particular, I want to talk about the receive-receive deadlock, where, for instance,", "tokens": [400, 294, 1729, 11, 286, 528, 281, 751, 466, 264, 4774, 12, 44209, 488, 3116, 4102, 11, 689, 11, 337, 5197, 11], "temperature": 0.0, "avg_logprob": -0.15632723768552145, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.00011548891052370891}, {"id": 43, "seek": 17896, "start": 202.88, "end": 208.92000000000002, "text": " two process weights on each other without being able to continue.", "tokens": [732, 1399, 17443, 322, 1184, 661, 1553, 885, 1075, 281, 2354, 13], "temperature": 0.0, "avg_logprob": -0.15632723768552145, "compression_ratio": 1.6222222222222222, "no_speech_prob": 0.00011548891052370891}, {"id": 44, "seek": 20892, "start": 208.92, "end": 213.23999999999998, "text": " You can argue that all those issues, except maybe the deadlock, could be found by the", "tokens": [509, 393, 9695, 300, 439, 729, 2663, 11, 3993, 1310, 264, 3116, 4102, 11, 727, 312, 1352, 538, 264], "temperature": 0.0, "avg_logprob": -0.1500995128969603, "compression_ratio": 1.5046296296296295, "no_speech_prob": 1.2787286323145963e-05}, {"id": 45, "seek": 20892, "start": 213.23999999999998, "end": 214.55999999999997, "text": " MPI library itself.", "tokens": [14146, 40, 6405, 2564, 13], "temperature": 0.0, "avg_logprob": -0.1500995128969603, "compression_ratio": 1.5046296296296295, "no_speech_prob": 1.2787286323145963e-05}, {"id": 46, "seek": 20892, "start": 214.55999999999997, "end": 221.11999999999998, "text": " But typically on HPC systems, the library does not do any checking for performance reasons.", "tokens": [583, 5850, 322, 12557, 34, 3652, 11, 264, 6405, 775, 406, 360, 604, 8568, 337, 3389, 4112, 13], "temperature": 0.0, "avg_logprob": -0.1500995128969603, "compression_ratio": 1.5046296296296295, "no_speech_prob": 1.2787286323145963e-05}, {"id": 47, "seek": 20892, "start": 221.11999999999998, "end": 228.79999999999998, "text": " That's why many of these issues will not be, will cause maybe crashes for unknown reasons", "tokens": [663, 311, 983, 867, 295, 613, 2663, 486, 406, 312, 11, 486, 3082, 1310, 28642, 337, 9841, 4112], "temperature": 0.0, "avg_logprob": -0.1500995128969603, "compression_ratio": 1.5046296296296295, "no_speech_prob": 1.2787286323145963e-05}, {"id": 48, "seek": 20892, "start": 228.79999999999998, "end": 233.16, "text": " or just produce some strange results.", "tokens": [420, 445, 5258, 512, 5861, 3542, 13], "temperature": 0.0, "avg_logprob": -0.1500995128969603, "compression_ratio": 1.5046296296296295, "no_speech_prob": 1.2787286323145963e-05}, {"id": 49, "seek": 23316, "start": 233.16, "end": 241.28, "text": " Well, that's why the dynamic MPI correctness tool must was developed in the past, which", "tokens": [1042, 11, 300, 311, 983, 264, 8546, 14146, 40, 3006, 1287, 2290, 1633, 390, 4743, 294, 264, 1791, 11, 597], "temperature": 0.0, "avg_logprob": -0.14329882860183715, "compression_ratio": 1.5384615384615385, "no_speech_prob": 4.525338226812892e-05}, {"id": 50, "seek": 23316, "start": 241.28, "end": 249.04, "text": " is a tool that during runtime checks for issues and produces such reports where it finds some", "tokens": [307, 257, 2290, 300, 1830, 34474, 13834, 337, 2663, 293, 14725, 1270, 7122, 689, 309, 10704, 512], "temperature": 0.0, "avg_logprob": -0.14329882860183715, "compression_ratio": 1.5384615384615385, "no_speech_prob": 4.525338226812892e-05}, {"id": 51, "seek": 23316, "start": 249.04, "end": 250.04, "text": " issues.", "tokens": [2663, 13], "temperature": 0.0, "avg_logprob": -0.14329882860183715, "compression_ratio": 1.5384615384615385, "no_speech_prob": 4.525338226812892e-05}, {"id": 52, "seek": 23316, "start": 250.04, "end": 256.2, "text": " And this is a report of the deadlock we have seen in the example code, where the message", "tokens": [400, 341, 307, 257, 2275, 295, 264, 3116, 4102, 321, 362, 1612, 294, 264, 1365, 3089, 11, 689, 264, 3636], "temperature": 0.0, "avg_logprob": -0.14329882860183715, "compression_ratio": 1.5384615384615385, "no_speech_prob": 4.525338226812892e-05}, {"id": 53, "seek": 23316, "start": 256.2, "end": 258.32, "text": " itself just describes there's a deadlock.", "tokens": [2564, 445, 15626, 456, 311, 257, 3116, 4102, 13], "temperature": 0.0, "avg_logprob": -0.14329882860183715, "compression_ratio": 1.5384615384615385, "no_speech_prob": 4.525338226812892e-05}, {"id": 54, "seek": 25832, "start": 258.32, "end": 266.2, "text": " In the bottom left, you can see a wait for graph, which just shows you which rank waits", "tokens": [682, 264, 2767, 1411, 11, 291, 393, 536, 257, 1699, 337, 4295, 11, 597, 445, 3110, 291, 597, 6181, 40597], "temperature": 0.0, "avg_logprob": -0.18314638653317014, "compression_ratio": 1.598901098901099, "no_speech_prob": 4.444094520295039e-05}, {"id": 55, "seek": 25832, "start": 266.2, "end": 271.44, "text": " for another rank causing the deadlock.", "tokens": [337, 1071, 6181, 9853, 264, 3116, 4102, 13], "temperature": 0.0, "avg_logprob": -0.18314638653317014, "compression_ratio": 1.598901098901099, "no_speech_prob": 4.444094520295039e-05}, {"id": 56, "seek": 25832, "start": 271.44, "end": 277.64, "text": " This helps you to kind of see where the deadlock occurs and why it occurs.", "tokens": [639, 3665, 291, 281, 733, 295, 536, 689, 264, 3116, 4102, 11843, 293, 983, 309, 11843, 13], "temperature": 0.0, "avg_logprob": -0.18314638653317014, "compression_ratio": 1.598901098901099, "no_speech_prob": 4.444094520295039e-05}, {"id": 57, "seek": 25832, "start": 277.64, "end": 283.68, "text": " And also, must can produce so-called call stack information, where you can see, beginning", "tokens": [400, 611, 11, 1633, 393, 5258, 370, 12, 11880, 818, 8630, 1589, 11, 689, 291, 393, 536, 11, 2863], "temperature": 0.0, "avg_logprob": -0.18314638653317014, "compression_ratio": 1.598901098901099, "no_speech_prob": 4.444094520295039e-05}, {"id": 58, "seek": 28368, "start": 283.68, "end": 289.92, "text": " from main of the program to the basically origin of the deadlock, but this was omitted", "tokens": [490, 2135, 295, 264, 1461, 281, 264, 1936, 4957, 295, 264, 3116, 4102, 11, 457, 341, 390, 3406, 3944], "temperature": 0.0, "avg_logprob": -0.19480963186784225, "compression_ratio": 1.524229074889868, "no_speech_prob": 1.517941927886568e-05}, {"id": 59, "seek": 28368, "start": 289.92, "end": 290.92, "text": " now.", "tokens": [586, 13], "temperature": 0.0, "avg_logprob": -0.19480963186784225, "compression_ratio": 1.524229074889868, "no_speech_prob": 1.517941927886568e-05}, {"id": 60, "seek": 28368, "start": 290.92, "end": 291.92, "text": " Okay.", "tokens": [1033, 13], "temperature": 0.0, "avg_logprob": -0.19480963186784225, "compression_ratio": 1.524229074889868, "no_speech_prob": 1.517941927886568e-05}, {"id": 61, "seek": 28368, "start": 291.92, "end": 300.16, "text": " So, to facilitate correctness checking for MPI, must uses a so-called distributed", "tokens": [407, 11, 281, 20207, 3006, 1287, 8568, 337, 14146, 40, 11, 1633, 4960, 257, 370, 12, 11880, 12631], "temperature": 0.0, "avg_logprob": -0.19480963186784225, "compression_ratio": 1.524229074889868, "no_speech_prob": 1.517941927886568e-05}, {"id": 62, "seek": 28368, "start": 300.16, "end": 304.24, "text": " agent-based analysis, which means that you have your normal MPI application with four", "tokens": [9461, 12, 6032, 5215, 11, 597, 1355, 300, 291, 362, 428, 2710, 14146, 40, 3861, 365, 1451], "temperature": 0.0, "avg_logprob": -0.19480963186784225, "compression_ratio": 1.524229074889868, "no_speech_prob": 1.517941927886568e-05}, {"id": 63, "seek": 28368, "start": 304.24, "end": 310.32, "text": " ranks, four processes that communicate as you would expect as the user wrote it.", "tokens": [21406, 11, 1451, 7555, 300, 7890, 382, 291, 576, 2066, 382, 264, 4195, 4114, 309, 13], "temperature": 0.0, "avg_logprob": -0.19480963186784225, "compression_ratio": 1.524229074889868, "no_speech_prob": 1.517941927886568e-05}, {"id": 64, "seek": 31032, "start": 310.32, "end": 317.48, "text": " But must will also create a analysis network, which helps you to do local analysis, it helps", "tokens": [583, 1633, 486, 611, 1884, 257, 5215, 3209, 11, 597, 3665, 291, 281, 360, 2654, 5215, 11, 309, 3665], "temperature": 0.0, "avg_logprob": -0.19135867739186704, "compression_ratio": 1.7182539682539681, "no_speech_prob": 2.1379655663622543e-05}, {"id": 65, "seek": 31032, "start": 317.48, "end": 318.92, "text": " you to do distributed analysis.", "tokens": [291, 281, 360, 12631, 5215, 13], "temperature": 0.0, "avg_logprob": -0.19135867739186704, "compression_ratio": 1.7182539682539681, "no_speech_prob": 2.1379655663622543e-05}, {"id": 66, "seek": 31032, "start": 318.92, "end": 323.92, "text": " If you think about a deadlock, you need information for more than one process to figure out that", "tokens": [759, 291, 519, 466, 257, 3116, 4102, 11, 291, 643, 1589, 337, 544, 813, 472, 1399, 281, 2573, 484, 300], "temperature": 0.0, "avg_logprob": -0.19135867739186704, "compression_ratio": 1.7182539682539681, "no_speech_prob": 2.1379655663622543e-05}, {"id": 67, "seek": 31032, "start": 323.92, "end": 326.4, "text": " there occurred a deadlock in your program.", "tokens": [456, 11068, 257, 3116, 4102, 294, 428, 1461, 13], "temperature": 0.0, "avg_logprob": -0.19135867739186704, "compression_ratio": 1.7182539682539681, "no_speech_prob": 2.1379655663622543e-05}, {"id": 68, "seek": 31032, "start": 326.4, "end": 333.52, "text": " So must creates that completely transparent to the user, so you would use MPI comworld", "tokens": [407, 1633, 7829, 300, 2584, 12737, 281, 264, 4195, 11, 370, 291, 576, 764, 14146, 40, 395, 13217], "temperature": 0.0, "avg_logprob": -0.19135867739186704, "compression_ratio": 1.7182539682539681, "no_speech_prob": 2.1379655663622543e-05}, {"id": 69, "seek": 31032, "start": 333.52, "end": 339.12, "text": " and any other communicator as normal, must takes care of creating such a network.", "tokens": [293, 604, 661, 3363, 1639, 382, 2710, 11, 1633, 2516, 1127, 295, 4084, 1270, 257, 3209, 13], "temperature": 0.0, "avg_logprob": -0.19135867739186704, "compression_ratio": 1.7182539682539681, "no_speech_prob": 2.1379655663622543e-05}, {"id": 70, "seek": 33912, "start": 339.12, "end": 347.48, "text": " And also, what's maybe the focus of the talk today is the local analysis, where we look", "tokens": [400, 611, 11, 437, 311, 1310, 264, 1879, 295, 264, 751, 965, 307, 264, 2654, 5215, 11, 689, 321, 574], "temperature": 0.0, "avg_logprob": -0.1845400674002511, "compression_ratio": 1.7095238095238094, "no_speech_prob": 1.4697530787088908e-05}, {"id": 71, "seek": 33912, "start": 347.48, "end": 349.96, "text": " at process local checks.", "tokens": [412, 1399, 2654, 13834, 13], "temperature": 0.0, "avg_logprob": -0.1845400674002511, "compression_ratio": 1.7095238095238094, "no_speech_prob": 1.4697530787088908e-05}, {"id": 72, "seek": 33912, "start": 349.96, "end": 354.76, "text": " If you think about MPI type correctness of a send operation, you can do a lot of stuff", "tokens": [759, 291, 519, 466, 14146, 40, 2010, 3006, 1287, 295, 257, 2845, 6916, 11, 291, 393, 360, 257, 688, 295, 1507], "temperature": 0.0, "avg_logprob": -0.1845400674002511, "compression_ratio": 1.7095238095238094, "no_speech_prob": 1.4697530787088908e-05}, {"id": 73, "seek": 33912, "start": 354.76, "end": 360.24, "text": " locally, or I should do a lot of stuff locally, and this is the focus.", "tokens": [16143, 11, 420, 286, 820, 360, 257, 688, 295, 1507, 16143, 11, 293, 341, 307, 264, 1879, 13], "temperature": 0.0, "avg_logprob": -0.1845400674002511, "compression_ratio": 1.7095238095238094, "no_speech_prob": 1.4697530787088908e-05}, {"id": 74, "seek": 33912, "start": 360.24, "end": 366.2, "text": " So, MPI type correctness, we focus basically on the buffer and the user-specified length", "tokens": [407, 11, 14146, 40, 2010, 3006, 1287, 11, 321, 1879, 1936, 322, 264, 21762, 293, 264, 4195, 12, 7053, 66, 2587, 4641], "temperature": 0.0, "avg_logprob": -0.1845400674002511, "compression_ratio": 1.7095238095238094, "no_speech_prob": 1.4697530787088908e-05}, {"id": 75, "seek": 36620, "start": 366.2, "end": 372.4, "text": " and the user-specified MPI data type today.", "tokens": [293, 264, 4195, 12, 7053, 66, 2587, 14146, 40, 1412, 2010, 965, 13], "temperature": 0.0, "avg_logprob": -0.13472862243652345, "compression_ratio": 1.6546391752577319, "no_speech_prob": 3.92774491047021e-05}, {"id": 76, "seek": 36620, "start": 372.4, "end": 377.96, "text": " Must can already detect mismatches of, for instance, the send and receive communication", "tokens": [13252, 393, 1217, 5531, 23220, 852, 279, 295, 11, 337, 5197, 11, 264, 2845, 293, 4774, 6101], "temperature": 0.0, "avg_logprob": -0.13472862243652345, "compression_ratio": 1.6546391752577319, "no_speech_prob": 3.92774491047021e-05}, {"id": 77, "seek": 36620, "start": 377.96, "end": 386.08, "text": " pair, where must basically creates a so-called type map, it looks at the user-specified", "tokens": [6119, 11, 689, 1633, 1936, 7829, 257, 370, 12, 11880, 2010, 4471, 11, 309, 1542, 412, 264, 4195, 12, 7053, 66, 2587], "temperature": 0.0, "avg_logprob": -0.13472862243652345, "compression_ratio": 1.6546391752577319, "no_speech_prob": 3.92774491047021e-05}, {"id": 78, "seek": 36620, "start": 386.08, "end": 390.59999999999997, "text": " buffer size and the user-specified data type, and compares it to the corresponding receive", "tokens": [21762, 2744, 293, 264, 4195, 12, 7053, 66, 2587, 1412, 2010, 11, 293, 38334, 309, 281, 264, 11760, 4774], "temperature": 0.0, "avg_logprob": -0.13472862243652345, "compression_ratio": 1.6546391752577319, "no_speech_prob": 3.92774491047021e-05}, {"id": 79, "seek": 36620, "start": 390.59999999999997, "end": 391.59999999999997, "text": " operation.", "tokens": [6916, 13], "temperature": 0.0, "avg_logprob": -0.13472862243652345, "compression_ratio": 1.6546391752577319, "no_speech_prob": 3.92774491047021e-05}, {"id": 80, "seek": 39160, "start": 391.6, "end": 398.32000000000005, "text": " If there is a mismatch, obviously, there is going to be an issue, and must creates a report", "tokens": [759, 456, 307, 257, 23220, 852, 11, 2745, 11, 456, 307, 516, 281, 312, 364, 2734, 11, 293, 1633, 7829, 257, 2275], "temperature": 0.0, "avg_logprob": -0.24298535693775525, "compression_ratio": 1.5350877192982457, "no_speech_prob": 9.977383160730824e-05}, {"id": 81, "seek": 39160, "start": 398.32000000000005, "end": 400.32000000000005, "text": " about that.", "tokens": [466, 300, 13], "temperature": 0.0, "avg_logprob": -0.24298535693775525, "compression_ratio": 1.5350877192982457, "no_speech_prob": 9.977383160730824e-05}, {"id": 82, "seek": 39160, "start": 400.32000000000005, "end": 404.36, "text": " This also, of course, works for collective communications, where you can make sure that", "tokens": [639, 611, 11, 295, 1164, 11, 1985, 337, 12590, 15163, 11, 689, 291, 393, 652, 988, 300], "temperature": 0.0, "avg_logprob": -0.24298535693775525, "compression_ratio": 1.5350877192982457, "no_speech_prob": 9.977383160730824e-05}, {"id": 83, "seek": 39160, "start": 404.36, "end": 413.0, "text": " all ranks call, for instance, a broadcast operation with the same data type.", "tokens": [439, 21406, 818, 11, 337, 5197, 11, 257, 9975, 6916, 365, 264, 912, 1412, 2010, 13], "temperature": 0.0, "avg_logprob": -0.24298535693775525, "compression_ratio": 1.5350877192982457, "no_speech_prob": 9.977383160730824e-05}, {"id": 84, "seek": 39160, "start": 413.0, "end": 421.32000000000005, "text": " However, since must only intercepts MPI calls in general, it cannot look behind a", "tokens": [2908, 11, 1670, 1633, 787, 24700, 82, 14146, 40, 5498, 294, 2674, 11, 309, 2644, 574, 2261, 257], "temperature": 0.0, "avg_logprob": -0.24298535693775525, "compression_ratio": 1.5350877192982457, "no_speech_prob": 9.977383160730824e-05}, {"id": 85, "seek": 42132, "start": 421.32, "end": 426.15999999999997, "text": " device, like it cannot look what happens in user space, you know.", "tokens": [4302, 11, 411, 309, 2644, 574, 437, 2314, 294, 4195, 1901, 11, 291, 458, 13], "temperature": 0.0, "avg_logprob": -0.28146778453480115, "compression_ratio": 1.5245098039215685, "no_speech_prob": 7.320103759411722e-05}, {"id": 86, "seek": 42132, "start": 426.15999999999997, "end": 433.64, "text": " So, we cannot reason about the type of the Void buffer data, and this is why we were", "tokens": [407, 11, 321, 2644, 1778, 466, 264, 2010, 295, 264, 7518, 327, 21762, 1412, 11, 293, 341, 307, 983, 321, 645], "temperature": 0.0, "avg_logprob": -0.28146778453480115, "compression_ratio": 1.5245098039215685, "no_speech_prob": 7.320103759411722e-05}, {"id": 87, "seek": 42132, "start": 433.64, "end": 443.08, "text": " motivated to create the tool type art, which is something that helps with basically figuring", "tokens": [14515, 281, 1884, 264, 2290, 2010, 1523, 11, 597, 307, 746, 300, 3665, 365, 1936, 15213], "temperature": 0.0, "avg_logprob": -0.28146778453480115, "compression_ratio": 1.5245098039215685, "no_speech_prob": 7.320103759411722e-05}, {"id": 88, "seek": 42132, "start": 443.08, "end": 446.96, "text": " out what the memory allocation is that you put into your MPI calls.", "tokens": [484, 437, 264, 4675, 27599, 307, 300, 291, 829, 666, 428, 14146, 40, 5498, 13], "temperature": 0.0, "avg_logprob": -0.28146778453480115, "compression_ratio": 1.5245098039215685, "no_speech_prob": 7.320103759411722e-05}, {"id": 89, "seek": 44696, "start": 446.96, "end": 453.44, "text": " So, if you look at this small example on the right side, completely processed locally,", "tokens": [407, 11, 498, 291, 574, 412, 341, 1359, 1365, 322, 264, 558, 1252, 11, 2584, 18846, 16143, 11], "temperature": 0.0, "avg_logprob": -0.16384332738024124, "compression_ratio": 1.6435185185185186, "no_speech_prob": 2.1066311091999523e-05}, {"id": 90, "seek": 44696, "start": 453.44, "end": 458.03999999999996, "text": " there might be some memory allocation in that example, it's a double buffer that was allocated", "tokens": [456, 1062, 312, 512, 4675, 27599, 294, 300, 1365, 11, 309, 311, 257, 3834, 21762, 300, 390, 29772], "temperature": 0.0, "avg_logprob": -0.16384332738024124, "compression_ratio": 1.6435185185185186, "no_speech_prob": 2.1066311091999523e-05}, {"id": 91, "seek": 44696, "start": 458.03999999999996, "end": 467.24, "text": " by Melloc, let's say, and the question now becomes, how can we make sure that data, the", "tokens": [538, 376, 898, 905, 11, 718, 311, 584, 11, 293, 264, 1168, 586, 3643, 11, 577, 393, 321, 652, 988, 300, 1412, 11, 264], "temperature": 0.0, "avg_logprob": -0.16384332738024124, "compression_ratio": 1.6435185185185186, "no_speech_prob": 2.1066311091999523e-05}, {"id": 92, "seek": 44696, "start": 467.24, "end": 472.76, "text": " data buffer, which is a Void buffer, fits the user-specified buffer size, so is it of", "tokens": [1412, 21762, 11, 597, 307, 257, 7518, 327, 21762, 11, 9001, 264, 4195, 12, 7053, 66, 2587, 21762, 2744, 11, 370, 307, 309, 295], "temperature": 0.0, "avg_logprob": -0.16384332738024124, "compression_ratio": 1.6435185185185186, "no_speech_prob": 2.1066311091999523e-05}, {"id": 93, "seek": 47276, "start": 472.76, "end": 478.59999999999997, "text": " length buffer size, and it also should be compatible with the MPI float type, and of", "tokens": [4641, 21762, 2744, 11, 293, 309, 611, 820, 312, 18218, 365, 264, 14146, 40, 15706, 2010, 11, 293, 295], "temperature": 0.0, "avg_logprob": -0.15496570131053095, "compression_ratio": 1.5550660792951543, "no_speech_prob": 3.260318044340238e-05}, {"id": 94, "seek": 47276, "start": 478.59999999999997, "end": 484.71999999999997, "text": " course, we can already see that double and MPI float, there's a type mismatch, but must", "tokens": [1164, 11, 321, 393, 1217, 536, 300, 3834, 293, 14146, 40, 15706, 11, 456, 311, 257, 2010, 23220, 852, 11, 457, 1633], "temperature": 0.0, "avg_logprob": -0.15496570131053095, "compression_ratio": 1.5550660792951543, "no_speech_prob": 3.260318044340238e-05}, {"id": 95, "seek": 47276, "start": 484.71999999999997, "end": 492.88, "text": " cannot answer such a question without further tooling, because it just intercepts MPI calls.", "tokens": [2644, 1867, 1270, 257, 1168, 1553, 3052, 46593, 11, 570, 309, 445, 24700, 82, 14146, 40, 5498, 13], "temperature": 0.0, "avg_logprob": -0.15496570131053095, "compression_ratio": 1.5550660792951543, "no_speech_prob": 3.260318044340238e-05}, {"id": 96, "seek": 47276, "start": 492.88, "end": 499.2, "text": " Okay, so to just show you that it's not an academic example, there's two well-known HPC", "tokens": [1033, 11, 370, 281, 445, 855, 291, 300, 309, 311, 406, 364, 7778, 1365, 11, 456, 311, 732, 731, 12, 6861, 12557, 34], "temperature": 0.0, "avg_logprob": -0.15496570131053095, "compression_ratio": 1.5550660792951543, "no_speech_prob": 3.260318044340238e-05}, {"id": 97, "seek": 49920, "start": 499.2, "end": 506.59999999999997, "text": " benchmark codes, which have some issues, so one was reported in the past by others, where", "tokens": [18927, 14211, 11, 597, 362, 512, 2663, 11, 370, 472, 390, 7055, 294, 264, 1791, 538, 2357, 11, 689], "temperature": 0.0, "avg_logprob": -0.181121732674393, "compression_ratio": 1.6757990867579908, "no_speech_prob": 4.672491559176706e-05}, {"id": 98, "seek": 49920, "start": 506.59999999999997, "end": 511.88, "text": " there's a broadcast operation, it uses a big end, which is an alias for a 64-bit data type,", "tokens": [456, 311, 257, 9975, 6916, 11, 309, 4960, 257, 955, 917, 11, 597, 307, 364, 419, 4609, 337, 257, 12145, 12, 5260, 1412, 2010, 11], "temperature": 0.0, "avg_logprob": -0.181121732674393, "compression_ratio": 1.6757990867579908, "no_speech_prob": 4.672491559176706e-05}, {"id": 99, "seek": 49920, "start": 511.88, "end": 518.64, "text": " however, the user-specified MPI end, which is a 32-bit data type for the broadcast operation,", "tokens": [4461, 11, 264, 4195, 12, 7053, 66, 2587, 14146, 40, 917, 11, 597, 307, 257, 8858, 12, 5260, 1412, 2010, 337, 264, 9975, 6916, 11], "temperature": 0.0, "avg_logprob": -0.181121732674393, "compression_ratio": 1.6757990867579908, "no_speech_prob": 4.672491559176706e-05}, {"id": 100, "seek": 49920, "start": 518.64, "end": 525.08, "text": " so there's an obvious mismatch, that could be a problem, likely, and also for milk, there's", "tokens": [370, 456, 311, 364, 6322, 23220, 852, 11, 300, 727, 312, 257, 1154, 11, 3700, 11, 293, 611, 337, 5392, 11, 456, 311], "temperature": 0.0, "avg_logprob": -0.181121732674393, "compression_ratio": 1.6757990867579908, "no_speech_prob": 4.672491559176706e-05}, {"id": 101, "seek": 52508, "start": 525.08, "end": 532.0, "text": " an all-reduced operation, where the user's passed in a struct with two float members,", "tokens": [364, 439, 12, 265, 769, 1232, 6916, 11, 689, 264, 4195, 311, 4678, 294, 257, 6594, 365, 732, 15706, 2679, 11], "temperature": 0.0, "avg_logprob": -0.194761479942544, "compression_ratio": 1.68, "no_speech_prob": 2.9228491257526912e-05}, {"id": 102, "seek": 52508, "start": 532.0, "end": 538.84, "text": " and it's interpreted as a float array of size two, which is B9, to be honest, but that could", "tokens": [293, 309, 311, 26749, 382, 257, 15706, 10225, 295, 2744, 732, 11, 597, 307, 363, 24, 11, 281, 312, 3245, 11, 457, 300, 727], "temperature": 0.0, "avg_logprob": -0.194761479942544, "compression_ratio": 1.68, "no_speech_prob": 2.9228491257526912e-05}, {"id": 103, "seek": 52508, "start": 538.84, "end": 543.0400000000001, "text": " be a portability issue in the future, maybe, you know, depending on the platform, maybe", "tokens": [312, 257, 2436, 2310, 2734, 294, 264, 2027, 11, 1310, 11, 291, 458, 11, 5413, 322, 264, 3663, 11, 1310], "temperature": 0.0, "avg_logprob": -0.194761479942544, "compression_ratio": 1.68, "no_speech_prob": 2.9228491257526912e-05}, {"id": 104, "seek": 52508, "start": 543.0400000000001, "end": 547.48, "text": " there's padding, or whatnot, and maybe it's an illegal operation, so this could also be", "tokens": [456, 311, 39562, 11, 420, 25882, 11, 293, 1310, 309, 311, 364, 11905, 6916, 11, 370, 341, 727, 611, 312], "temperature": 0.0, "avg_logprob": -0.194761479942544, "compression_ratio": 1.68, "no_speech_prob": 2.9228491257526912e-05}, {"id": 105, "seek": 52508, "start": 547.48, "end": 549.76, "text": " an issue in the future.", "tokens": [364, 2734, 294, 264, 2027, 13], "temperature": 0.0, "avg_logprob": -0.194761479942544, "compression_ratio": 1.68, "no_speech_prob": 2.9228491257526912e-05}, {"id": 106, "seek": 54976, "start": 549.76, "end": 556.36, "text": " Well, from a high-level point of view, how it does must work, well, you have your MPI", "tokens": [1042, 11, 490, 257, 1090, 12, 12418, 935, 295, 1910, 11, 577, 309, 775, 1633, 589, 11, 731, 11, 291, 362, 428, 14146, 40], "temperature": 0.0, "avg_logprob": -0.15154666900634767, "compression_ratio": 1.6527777777777777, "no_speech_prob": 5.125380994286388e-05}, {"id": 107, "seek": 54976, "start": 556.36, "end": 562.12, "text": " application, and during runtime, it intercepts all the MPI calls, and collects all the states", "tokens": [3861, 11, 293, 1830, 34474, 11, 309, 24700, 82, 439, 264, 14146, 40, 5498, 11, 293, 39897, 439, 264, 4368], "temperature": 0.0, "avg_logprob": -0.15154666900634767, "compression_ratio": 1.6527777777777777, "no_speech_prob": 5.125380994286388e-05}, {"id": 108, "seek": 54976, "start": 562.12, "end": 569.88, "text": " that it's needed for deadlock detection, and so on, and we added type art, which looks", "tokens": [300, 309, 311, 2978, 337, 3116, 4102, 17784, 11, 293, 370, 322, 11, 293, 321, 3869, 2010, 1523, 11, 597, 1542], "temperature": 0.0, "avg_logprob": -0.15154666900634767, "compression_ratio": 1.6527777777777777, "no_speech_prob": 5.125380994286388e-05}, {"id": 109, "seek": 54976, "start": 569.88, "end": 575.56, "text": " at all those allocations that are passed to MPI calls for those local analysis of buffers,", "tokens": [412, 439, 729, 12660, 763, 300, 366, 4678, 281, 14146, 40, 5498, 337, 729, 2654, 5215, 295, 9204, 433, 11], "temperature": 0.0, "avg_logprob": -0.15154666900634767, "compression_ratio": 1.6527777777777777, "no_speech_prob": 5.125380994286388e-05}, {"id": 110, "seek": 57556, "start": 575.56, "end": 583.3199999999999, "text": " which is the compiler extension based on LLVM, so you compile your code with our extension,", "tokens": [597, 307, 264, 31958, 10320, 2361, 322, 441, 43, 53, 44, 11, 370, 291, 31413, 428, 3089, 365, 527, 10320, 11], "temperature": 0.0, "avg_logprob": -0.09994799226194948, "compression_ratio": 1.775609756097561, "no_speech_prob": 2.4568309527239762e-05}, {"id": 111, "seek": 57556, "start": 583.3199999999999, "end": 588.8, "text": " and the extension instruments all allocations, be it stack, be it heap, which are related", "tokens": [293, 264, 10320, 12190, 439, 12660, 763, 11, 312, 309, 8630, 11, 312, 309, 33591, 11, 597, 366, 4077], "temperature": 0.0, "avg_logprob": -0.09994799226194948, "compression_ratio": 1.775609756097561, "no_speech_prob": 2.4568309527239762e-05}, {"id": 112, "seek": 57556, "start": 588.8, "end": 596.0799999999999, "text": " to MPI calls, and we also provide a runtime, so during runtime, we get callbacks of the", "tokens": [281, 14146, 40, 5498, 11, 293, 321, 611, 2893, 257, 34474, 11, 370, 1830, 34474, 11, 321, 483, 818, 17758, 295, 264], "temperature": 0.0, "avg_logprob": -0.09994799226194948, "compression_ratio": 1.775609756097561, "no_speech_prob": 2.4568309527239762e-05}, {"id": 113, "seek": 57556, "start": 596.0799999999999, "end": 602.0, "text": " target application, all allocations, all free operations, so we have a state of the allocation", "tokens": [3779, 3861, 11, 439, 12660, 763, 11, 439, 1737, 7705, 11, 370, 321, 362, 257, 1785, 295, 264, 27599], "temperature": 0.0, "avg_logprob": -0.09994799226194948, "compression_ratio": 1.775609756097561, "no_speech_prob": 2.4568309527239762e-05}, {"id": 114, "seek": 60200, "start": 602.0, "end": 605.96, "text": " of the memory, basically, in a target code.", "tokens": [295, 264, 4675, 11, 1936, 11, 294, 257, 3779, 3089, 13], "temperature": 0.0, "avg_logprob": -0.1683988391228442, "compression_ratio": 1.6571428571428573, "no_speech_prob": 1.4713996279169805e-05}, {"id": 115, "seek": 60200, "start": 605.96, "end": 611.16, "text": " We also, of course, look at the allocations and pass out their type, so simple case is", "tokens": [492, 611, 11, 295, 1164, 11, 574, 412, 264, 12660, 763, 293, 1320, 484, 641, 2010, 11, 370, 2199, 1389, 307], "temperature": 0.0, "avg_logprob": -0.1683988391228442, "compression_ratio": 1.6571428571428573, "no_speech_prob": 1.4713996279169805e-05}, {"id": 116, "seek": 60200, "start": 611.16, "end": 617.52, "text": " buffer, A is a double type, more complex cases would be structs or classes, we pass the serialized", "tokens": [21762, 11, 316, 307, 257, 3834, 2010, 11, 544, 3997, 3331, 576, 312, 6594, 82, 420, 5359, 11, 321, 1320, 264, 17436, 1602], "temperature": 0.0, "avg_logprob": -0.1683988391228442, "compression_ratio": 1.6571428571428573, "no_speech_prob": 1.4713996279169805e-05}, {"id": 117, "seek": 60200, "start": 617.52, "end": 623.2, "text": " type information to our runtime, which then enables, of course, must to make queries,", "tokens": [2010, 1589, 281, 527, 34474, 11, 597, 550, 17077, 11, 295, 1164, 11, 1633, 281, 652, 24109, 11], "temperature": 0.0, "avg_logprob": -0.1683988391228442, "compression_ratio": 1.6571428571428573, "no_speech_prob": 1.4713996279169805e-05}, {"id": 118, "seek": 60200, "start": 623.2, "end": 629.32, "text": " so for instance, for an MPI center operation, we give the type art runtime the buffer, the", "tokens": [370, 337, 5197, 11, 337, 364, 14146, 40, 3056, 6916, 11, 321, 976, 264, 2010, 1523, 34474, 264, 21762, 11, 264], "temperature": 0.0, "avg_logprob": -0.1683988391228442, "compression_ratio": 1.6571428571428573, "no_speech_prob": 1.4713996279169805e-05}, {"id": 119, "seek": 62932, "start": 629.32, "end": 633.96, "text": " typeless buffer, and the runtime would return all the necessary type information to ensure", "tokens": [2010, 1832, 21762, 11, 293, 264, 34474, 576, 2736, 439, 264, 4818, 2010, 1589, 281, 5586], "temperature": 0.0, "avg_logprob": -0.18432447645399305, "compression_ratio": 1.5258620689655173, "no_speech_prob": 1.1104685654572677e-05}, {"id": 120, "seek": 62932, "start": 633.96, "end": 638.12, "text": " type correctness of those buffer handles.", "tokens": [2010, 3006, 1287, 295, 729, 21762, 18722, 13], "temperature": 0.0, "avg_logprob": -0.18432447645399305, "compression_ratio": 1.5258620689655173, "no_speech_prob": 1.1104685654572677e-05}, {"id": 121, "seek": 62932, "start": 638.12, "end": 640.96, "text": " This is the whole high level process behind it.", "tokens": [639, 307, 264, 1379, 1090, 1496, 1399, 2261, 309, 13], "temperature": 0.0, "avg_logprob": -0.18432447645399305, "compression_ratio": 1.5258620689655173, "no_speech_prob": 1.1104685654572677e-05}, {"id": 122, "seek": 62932, "start": 640.96, "end": 649.44, "text": " And then if you take a look at an example of a memory allocation, C is a small heap", "tokens": [400, 550, 498, 291, 747, 257, 574, 412, 364, 1365, 295, 257, 4675, 27599, 11, 383, 307, 257, 1359, 33591], "temperature": 0.0, "avg_logprob": -0.18432447645399305, "compression_ratio": 1.5258620689655173, "no_speech_prob": 1.1104685654572677e-05}, {"id": 123, "seek": 62932, "start": 649.44, "end": 656.2800000000001, "text": " allocation of a float array, this all happens in LLVM IR, I'm just showing C like code to", "tokens": [27599, 295, 257, 15706, 10225, 11, 341, 439, 2314, 294, 441, 43, 53, 44, 16486, 11, 286, 478, 445, 4099, 383, 411, 3089, 281], "temperature": 0.0, "avg_logprob": -0.18432447645399305, "compression_ratio": 1.5258620689655173, "no_speech_prob": 1.1104685654572677e-05}, {"id": 124, "seek": 65628, "start": 656.28, "end": 663.8399999999999, "text": " make it easier to understand, we would add such a type art alloc callback, which where", "tokens": [652, 309, 3571, 281, 1223, 11, 321, 576, 909, 1270, 257, 2010, 1523, 12660, 818, 3207, 11, 597, 689], "temperature": 0.0, "avg_logprob": -0.16945095472438362, "compression_ratio": 1.7045454545454546, "no_speech_prob": 1.536226955067832e-05}, {"id": 125, "seek": 65628, "start": 663.8399999999999, "end": 670.12, "text": " we need the data pointer, of course, and then we need a so called type ID, it's just a representation", "tokens": [321, 643, 264, 1412, 23918, 11, 295, 1164, 11, 293, 550, 321, 643, 257, 370, 1219, 2010, 7348, 11, 309, 311, 445, 257, 10290], "temperature": 0.0, "avg_logprob": -0.16945095472438362, "compression_ratio": 1.7045454545454546, "no_speech_prob": 1.536226955067832e-05}, {"id": 126, "seek": 65628, "start": 670.12, "end": 676.4399999999999, "text": " of what we allocated, that is later used for type checking, and of course we need the dynamic", "tokens": [295, 437, 321, 29772, 11, 300, 307, 1780, 1143, 337, 2010, 8568, 11, 293, 295, 1164, 321, 643, 264, 8546], "temperature": 0.0, "avg_logprob": -0.16945095472438362, "compression_ratio": 1.7045454545454546, "no_speech_prob": 1.536226955067832e-05}, {"id": 127, "seek": 65628, "start": 676.4399999999999, "end": 683.52, "text": " length of the allocated array to reason about where we are in the memory space, so to speak.", "tokens": [4641, 295, 264, 29772, 10225, 281, 1778, 466, 689, 321, 366, 294, 264, 4675, 1901, 11, 370, 281, 1710, 13], "temperature": 0.0, "avg_logprob": -0.16945095472438362, "compression_ratio": 1.7045454545454546, "no_speech_prob": 1.536226955067832e-05}, {"id": 128, "seek": 68352, "start": 683.52, "end": 688.56, "text": " Once we handle stack and global allocations, for stack allocations, of course, we have", "tokens": [3443, 321, 4813, 8630, 293, 4338, 12660, 763, 11, 337, 8630, 12660, 763, 11, 295, 1164, 11, 321, 362], "temperature": 0.0, "avg_logprob": -0.18715463365827287, "compression_ratio": 1.7704918032786885, "no_speech_prob": 5.359805436455645e-05}, {"id": 129, "seek": 68352, "start": 688.56, "end": 694.04, "text": " to respect the automatic scope dependent lifetime properties, and for global we just register", "tokens": [281, 3104, 264, 12509, 11923, 12334, 11364, 7221, 11, 293, 337, 4338, 321, 445, 7280], "temperature": 0.0, "avg_logprob": -0.18715463365827287, "compression_ratio": 1.7704918032786885, "no_speech_prob": 5.359805436455645e-05}, {"id": 130, "seek": 68352, "start": 694.04, "end": 700.0, "text": " once and then it exists at our runtime for the whole program duration.", "tokens": [1564, 293, 550, 309, 8198, 412, 527, 34474, 337, 264, 1379, 1461, 16365, 13], "temperature": 0.0, "avg_logprob": -0.18715463365827287, "compression_ratio": 1.7704918032786885, "no_speech_prob": 5.359805436455645e-05}, {"id": 131, "seek": 68352, "start": 700.0, "end": 705.92, "text": " And of course, for performance reasons, you can imagine that the less callbacks the better,", "tokens": [400, 295, 1164, 11, 337, 3389, 4112, 11, 291, 393, 3811, 300, 264, 1570, 818, 17758, 264, 1101, 11], "temperature": 0.0, "avg_logprob": -0.18715463365827287, "compression_ratio": 1.7704918032786885, "no_speech_prob": 5.359805436455645e-05}, {"id": 132, "seek": 68352, "start": 705.92, "end": 710.24, "text": " hence we try to filter out allocations where we can prove that they are never part of an", "tokens": [16678, 321, 853, 281, 6608, 484, 12660, 763, 689, 321, 393, 7081, 300, 436, 366, 1128, 644, 295, 364], "temperature": 0.0, "avg_logprob": -0.18715463365827287, "compression_ratio": 1.7704918032786885, "no_speech_prob": 5.359805436455645e-05}, {"id": 133, "seek": 71024, "start": 710.24, "end": 716.84, "text": " MPI call and just never instrument those.", "tokens": [14146, 40, 818, 293, 445, 1128, 7198, 729, 13], "temperature": 0.0, "avg_logprob": -0.18061166398980644, "compression_ratio": 1.5358851674641147, "no_speech_prob": 7.926578109618276e-05}, {"id": 134, "seek": 71024, "start": 716.84, "end": 726.16, "text": " This is basically possible on LLVM IR by data flow analysis, so in the function foo we have", "tokens": [639, 307, 1936, 1944, 322, 441, 43, 53, 44, 16486, 538, 1412, 3095, 5215, 11, 370, 294, 264, 2445, 726, 78, 321, 362], "temperature": 0.0, "avg_logprob": -0.18061166398980644, "compression_ratio": 1.5358851674641147, "no_speech_prob": 7.926578109618276e-05}, {"id": 135, "seek": 71024, "start": 726.16, "end": 731.04, "text": " two stack allocations and then we try to follow the data flow where we can see that A is passed", "tokens": [732, 8630, 12660, 763, 293, 550, 321, 853, 281, 1524, 264, 1412, 3095, 689, 321, 393, 536, 300, 316, 307, 4678], "temperature": 0.0, "avg_logprob": -0.18061166398980644, "compression_ratio": 1.5358851674641147, "no_speech_prob": 7.926578109618276e-05}, {"id": 136, "seek": 71024, "start": 731.04, "end": 737.48, "text": " to bar, and inside bar there's never any MPI call, so we can just say, okay, we do not need", "tokens": [281, 2159, 11, 293, 1854, 2159, 456, 311, 1128, 604, 14146, 40, 818, 11, 370, 321, 393, 445, 584, 11, 1392, 11, 321, 360, 406, 643], "temperature": 0.0, "avg_logprob": -0.18061166398980644, "compression_ratio": 1.5358851674641147, "no_speech_prob": 7.926578109618276e-05}, {"id": 137, "seek": 73748, "start": 737.48, "end": 741.52, "text": " to instrument this, this is discarded.", "tokens": [281, 7198, 341, 11, 341, 307, 45469, 13], "temperature": 0.0, "avg_logprob": -0.18862716244979644, "compression_ratio": 1.5106382978723405, "no_speech_prob": 3.681343514472246e-05}, {"id": 138, "seek": 73748, "start": 741.52, "end": 748.16, "text": " Likewise for foo bar, we can see that B is passed, if it's in another translation unit", "tokens": [30269, 337, 726, 78, 2159, 11, 321, 393, 536, 300, 363, 307, 4678, 11, 498, 309, 311, 294, 1071, 12853, 4985], "temperature": 0.0, "avg_logprob": -0.18862716244979644, "compression_ratio": 1.5106382978723405, "no_speech_prob": 3.681343514472246e-05}, {"id": 139, "seek": 73748, "start": 748.16, "end": 756.28, "text": " we would need to have a whole program view of the program, which we support, but other", "tokens": [321, 576, 643, 281, 362, 257, 1379, 1461, 1910, 295, 264, 1461, 11, 597, 321, 1406, 11, 457, 661], "temperature": 0.0, "avg_logprob": -0.18862716244979644, "compression_ratio": 1.5106382978723405, "no_speech_prob": 3.681343514472246e-05}, {"id": 140, "seek": 73748, "start": 756.28, "end": 761.12, "text": " tools have to create such a call graph with those required information.", "tokens": [3873, 362, 281, 1884, 1270, 257, 818, 4295, 365, 729, 4739, 1589, 13], "temperature": 0.0, "avg_logprob": -0.18862716244979644, "compression_ratio": 1.5106382978723405, "no_speech_prob": 3.681343514472246e-05}, {"id": 141, "seek": 76112, "start": 761.12, "end": 768.72, "text": " Anyways, so also if we had this view, we can see foo bar also does not call MPI, so both", "tokens": [15585, 11, 370, 611, 498, 321, 632, 341, 1910, 11, 321, 393, 536, 726, 78, 2159, 611, 775, 406, 818, 14146, 40, 11, 370, 1293], "temperature": 0.0, "avg_logprob": -0.22584796704744037, "compression_ratio": 1.5321888412017168, "no_speech_prob": 5.5034779506968334e-06}, {"id": 142, "seek": 76112, "start": 768.72, "end": 774.24, "text": " stack allocations don't need to be instrumented, which helps a lot with the performance.", "tokens": [8630, 12660, 763, 500, 380, 643, 281, 312, 7198, 292, 11, 597, 3665, 257, 688, 365, 264, 3389, 13], "temperature": 0.0, "avg_logprob": -0.22584796704744037, "compression_ratio": 1.5321888412017168, "no_speech_prob": 5.5034779506968334e-06}, {"id": 143, "seek": 76112, "start": 774.24, "end": 784.4, "text": " Okay, so the type ID which is passed to the runtime for identification works as follows,", "tokens": [1033, 11, 370, 264, 2010, 7348, 597, 307, 4678, 281, 264, 34474, 337, 22065, 1985, 382, 10002, 11], "temperature": 0.0, "avg_logprob": -0.22584796704744037, "compression_ratio": 1.5321888412017168, "no_speech_prob": 5.5034779506968334e-06}, {"id": 144, "seek": 76112, "start": 784.4, "end": 790.0, "text": " built-in types are obviously known a priori, so we know the type layout, float is 4 bytes,", "tokens": [3094, 12, 259, 3467, 366, 2745, 2570, 257, 4059, 72, 11, 370, 321, 458, 264, 2010, 13333, 11, 15706, 307, 1017, 36088, 11], "temperature": 0.0, "avg_logprob": -0.22584796704744037, "compression_ratio": 1.5321888412017168, "no_speech_prob": 5.5034779506968334e-06}, {"id": 145, "seek": 79000, "start": 790.0, "end": 795.32, "text": " double is 8 bytes, depending on platform of course, for user defined types, which means", "tokens": [3834, 307, 1649, 36088, 11, 5413, 322, 3663, 295, 1164, 11, 337, 4195, 7642, 3467, 11, 597, 1355], "temperature": 0.0, "avg_logprob": -0.1878164681521329, "compression_ratio": 1.5964125560538116, "no_speech_prob": 1.8012164218816906e-05}, {"id": 146, "seek": 79000, "start": 795.32, "end": 804.16, "text": " structs, classes and so on, we basically serialize it to a YAML file and the corresponding type", "tokens": [6594, 82, 11, 5359, 293, 370, 322, 11, 321, 1936, 17436, 1125, 309, 281, 257, 398, 2865, 43, 3991, 293, 264, 11760, 2010], "temperature": 0.0, "avg_logprob": -0.1878164681521329, "compression_ratio": 1.5964125560538116, "no_speech_prob": 1.8012164218816906e-05}, {"id": 147, "seek": 79000, "start": 804.16, "end": 810.56, "text": " ID of course, so we can match those during runtime, where we have the extent how many", "tokens": [7348, 295, 1164, 11, 370, 321, 393, 2995, 729, 1830, 34474, 11, 689, 321, 362, 264, 8396, 577, 867], "temperature": 0.0, "avg_logprob": -0.1878164681521329, "compression_ratio": 1.5964125560538116, "no_speech_prob": 1.8012164218816906e-05}, {"id": 148, "seek": 79000, "start": 810.56, "end": 816.36, "text": " members offsets, byte offsets basically from the beginning of the struct, and also the", "tokens": [2679, 39457, 1385, 11, 40846, 39457, 1385, 1936, 490, 264, 2863, 295, 264, 6594, 11, 293, 611, 264], "temperature": 0.0, "avg_logprob": -0.1878164681521329, "compression_ratio": 1.5964125560538116, "no_speech_prob": 1.8012164218816906e-05}, {"id": 149, "seek": 81636, "start": 816.36, "end": 824.0, "text": " subtypes are listed, which can then be used for making type queries about the layout and", "tokens": [1422, 874, 5190, 366, 10052, 11, 597, 393, 550, 312, 1143, 337, 1455, 2010, 24109, 466, 264, 13333, 293], "temperature": 0.0, "avg_logprob": -0.1668108171886868, "compression_ratio": 1.4791666666666667, "no_speech_prob": 2.7479161872179247e-05}, {"id": 150, "seek": 81636, "start": 824.0, "end": 828.52, "text": " stuff like that.", "tokens": [1507, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.1668108171886868, "compression_ratio": 1.4791666666666667, "no_speech_prob": 2.7479161872179247e-05}, {"id": 151, "seek": 81636, "start": 828.52, "end": 834.84, "text": " And then of course, must needs to have some API to figure out type correctness, and this", "tokens": [400, 550, 295, 1164, 11, 1633, 2203, 281, 362, 512, 9362, 281, 2573, 484, 2010, 3006, 1287, 11, 293, 341], "temperature": 0.0, "avg_logprob": -0.1668108171886868, "compression_ratio": 1.4791666666666667, "no_speech_prob": 2.7479161872179247e-05}, {"id": 152, "seek": 81636, "start": 834.84, "end": 845.08, "text": " is provided by our runtime, which has quite a few API functions, the most basic one would", "tokens": [307, 5649, 538, 527, 34474, 11, 597, 575, 1596, 257, 1326, 9362, 6828, 11, 264, 881, 3875, 472, 576], "temperature": 0.0, "avg_logprob": -0.1668108171886868, "compression_ratio": 1.4791666666666667, "no_speech_prob": 2.7479161872179247e-05}, {"id": 153, "seek": 84508, "start": 845.08, "end": 852.2800000000001, "text": " be this type out get type where you put in the MPI buffer handle, and what we put out", "tokens": [312, 341, 2010, 484, 483, 2010, 689, 291, 829, 294, 264, 14146, 40, 21762, 4813, 11, 293, 437, 321, 829, 484], "temperature": 0.0, "avg_logprob": -0.17951886407260237, "compression_ratio": 1.7376237623762376, "no_speech_prob": 4.452276698430069e-05}, {"id": 154, "seek": 84508, "start": 852.2800000000001, "end": 858.0, "text": " is the type ID and the error length, and then you can use the type ID subsequently, for", "tokens": [307, 264, 2010, 7348, 293, 264, 6713, 4641, 11, 293, 550, 291, 393, 764, 264, 2010, 7348, 26514, 11, 337], "temperature": 0.0, "avg_logprob": -0.17951886407260237, "compression_ratio": 1.7376237623762376, "no_speech_prob": 4.452276698430069e-05}, {"id": 155, "seek": 84508, "start": 858.0, "end": 863.2800000000001, "text": " instance in this call where you put in the type ID and you get out the struct layout", "tokens": [5197, 294, 341, 818, 689, 291, 829, 294, 264, 2010, 7348, 293, 291, 483, 484, 264, 6594, 13333], "temperature": 0.0, "avg_logprob": -0.17951886407260237, "compression_ratio": 1.7376237623762376, "no_speech_prob": 4.452276698430069e-05}, {"id": 156, "seek": 84508, "start": 863.2800000000001, "end": 873.44, "text": " I just mentioned earlier, and this way you kind of can assemble some iterative type checking", "tokens": [286, 445, 2835, 3071, 11, 293, 341, 636, 291, 733, 295, 393, 22364, 512, 17138, 1166, 2010, 8568], "temperature": 0.0, "avg_logprob": -0.17951886407260237, "compression_ratio": 1.7376237623762376, "no_speech_prob": 4.452276698430069e-05}, {"id": 157, "seek": 87344, "start": 873.44, "end": 878.6400000000001, "text": " which is done in must.", "tokens": [597, 307, 1096, 294, 1633, 13], "temperature": 0.0, "avg_logprob": -0.16720435278756277, "compression_ratio": 1.5675675675675675, "no_speech_prob": 2.2408285076380707e-05}, {"id": 158, "seek": 87344, "start": 878.6400000000001, "end": 886.5200000000001, "text": " And then putting it all together, if you want to use our tooling, you would need to first", "tokens": [400, 550, 3372, 309, 439, 1214, 11, 498, 291, 528, 281, 764, 527, 46593, 11, 291, 576, 643, 281, 700], "temperature": 0.0, "avg_logprob": -0.16720435278756277, "compression_ratio": 1.5675675675675675, "no_speech_prob": 2.2408285076380707e-05}, {"id": 159, "seek": 87344, "start": 886.5200000000001, "end": 895.5200000000001, "text": " of all compile your program with our provided compiler wrapper, which is a batch script and", "tokens": [295, 439, 31413, 428, 1461, 365, 527, 5649, 31958, 46906, 11, 597, 307, 257, 15245, 5755, 293], "temperature": 0.0, "avg_logprob": -0.16720435278756277, "compression_ratio": 1.5675675675675675, "no_speech_prob": 2.2408285076380707e-05}, {"id": 160, "seek": 87344, "start": 895.5200000000001, "end": 900.9200000000001, "text": " does the bookkeeping require to introduce the instrumentation, the type out stuff, so", "tokens": [775, 264, 1446, 25769, 3651, 281, 5366, 264, 7198, 399, 11, 264, 2010, 484, 1507, 11, 370], "temperature": 0.0, "avg_logprob": -0.16720435278756277, "compression_ratio": 1.5675675675675675, "no_speech_prob": 2.2408285076380707e-05}, {"id": 161, "seek": 90092, "start": 900.92, "end": 904.88, "text": " you exchange your compiler, that's the first step, it's optional, you don't have to do", "tokens": [291, 7742, 428, 31958, 11, 300, 311, 264, 700, 1823, 11, 309, 311, 17312, 11, 291, 500, 380, 362, 281, 360], "temperature": 0.0, "avg_logprob": -0.15906007554796006, "compression_ratio": 1.6025641025641026, "no_speech_prob": 2.0425752154551446e-05}, {"id": 162, "seek": 90092, "start": 904.88, "end": 911.64, "text": " it if you don't need this local type out checking, and then you would also need to replace your", "tokens": [309, 498, 291, 500, 380, 643, 341, 2654, 2010, 484, 8568, 11, 293, 550, 291, 576, 611, 643, 281, 7406, 428], "temperature": 0.0, "avg_logprob": -0.15906007554796006, "compression_ratio": 1.6025641025641026, "no_speech_prob": 2.0425752154551446e-05}, {"id": 163, "seek": 90092, "start": 911.64, "end": 918.24, "text": " MPI exec or MPI run depending on the system with the must run, which also does some bookkeeping", "tokens": [14146, 40, 4454, 420, 14146, 40, 1190, 5413, 322, 264, 1185, 365, 264, 1633, 1190, 11, 597, 611, 775, 512, 1446, 25769], "temperature": 0.0, "avg_logprob": -0.15906007554796006, "compression_ratio": 1.6025641025641026, "no_speech_prob": 2.0425752154551446e-05}, {"id": 164, "seek": 90092, "start": 918.24, "end": 927.68, "text": " for must to execute the target code appropriately, spawn all the analysis agent based networking", "tokens": [337, 1633, 281, 14483, 264, 3779, 3089, 23505, 11, 17088, 439, 264, 5215, 9461, 2361, 17985], "temperature": 0.0, "avg_logprob": -0.15906007554796006, "compression_ratio": 1.6025641025641026, "no_speech_prob": 2.0425752154551446e-05}, {"id": 165, "seek": 92768, "start": 927.68, "end": 935.76, "text": " and so on, and then the program runs as normal and must output file is generated with all", "tokens": [293, 370, 322, 11, 293, 550, 264, 1461, 6676, 382, 2710, 293, 1633, 5598, 3991, 307, 10833, 365, 439], "temperature": 0.0, "avg_logprob": -0.21056040595559514, "compression_ratio": 1.6061946902654867, "no_speech_prob": 2.9672946766368113e-05}, {"id": 166, "seek": 92768, "start": 935.76, "end": 945.0799999999999, "text": " issues found during execution of your program, and as a side note maybe, as I said must does", "tokens": [2663, 1352, 1830, 15058, 295, 428, 1461, 11, 293, 382, 257, 1252, 3637, 1310, 11, 382, 286, 848, 1633, 775], "temperature": 0.0, "avg_logprob": -0.21056040595559514, "compression_ratio": 1.6061946902654867, "no_speech_prob": 2.9672946766368113e-05}, {"id": 167, "seek": 92768, "start": 945.0799999999999, "end": 949.4799999999999, "text": " this agent based network and in the most simple case for the distributed analysis, there's", "tokens": [341, 9461, 2361, 3209, 293, 294, 264, 881, 2199, 1389, 337, 264, 12631, 5215, 11, 456, 311], "temperature": 0.0, "avg_logprob": -0.21056040595559514, "compression_ratio": 1.6061946902654867, "no_speech_prob": 2.9672946766368113e-05}, {"id": 168, "seek": 92768, "start": 949.4799999999999, "end": 957.3199999999999, "text": " an additional process needed for the deadlock detection and so on, so for SLAM or whatnot", "tokens": [364, 4497, 1399, 2978, 337, 264, 3116, 4102, 17784, 293, 370, 322, 11, 370, 337, 22999, 2865, 420, 25882], "temperature": 0.0, "avg_logprob": -0.21056040595559514, "compression_ratio": 1.6061946902654867, "no_speech_prob": 2.9672946766368113e-05}, {"id": 169, "seek": 95732, "start": 957.32, "end": 963.84, "text": " you need to allocate an additional process, however you don't need to specify it in the", "tokens": [291, 643, 281, 35713, 364, 4497, 1399, 11, 4461, 291, 500, 380, 643, 281, 16500, 309, 294, 264], "temperature": 0.0, "avg_logprob": -0.14428537032183478, "compression_ratio": 1.6367924528301887, "no_speech_prob": 3.0054688977543265e-05}, {"id": 170, "seek": 95732, "start": 963.84, "end": 971.1600000000001, "text": " must run stuff, it happens automatically in the background, alright, so that's it, if", "tokens": [1633, 1190, 1507, 11, 309, 2314, 6772, 294, 264, 3678, 11, 5845, 11, 370, 300, 311, 309, 11, 498], "temperature": 0.0, "avg_logprob": -0.14428537032183478, "compression_ratio": 1.6367924528301887, "no_speech_prob": 3.0054688977543265e-05}, {"id": 171, "seek": 95732, "start": 971.1600000000001, "end": 977.6, "text": " you look now at what the impact is of our tooling, well that's quite dependent as I", "tokens": [291, 574, 586, 412, 437, 264, 2712, 307, 295, 527, 46593, 11, 731, 300, 311, 1596, 12334, 382, 286], "temperature": 0.0, "avg_logprob": -0.14428537032183478, "compression_ratio": 1.6367924528301887, "no_speech_prob": 3.0054688977543265e-05}, {"id": 172, "seek": 95732, "start": 977.6, "end": 983.0, "text": " kind of alluded to, how many callbacks you have, how many memory allocations you actually", "tokens": [733, 295, 33919, 281, 11, 577, 867, 818, 17758, 291, 362, 11, 577, 867, 4675, 12660, 763, 291, 767], "temperature": 0.0, "avg_logprob": -0.14428537032183478, "compression_ratio": 1.6367924528301887, "no_speech_prob": 3.0054688977543265e-05}, {"id": 173, "seek": 98300, "start": 983.0, "end": 989.52, "text": " have to track, and how good we are at filtering them, so here's two examples, Lulech and", "tokens": [362, 281, 2837, 11, 293, 577, 665, 321, 366, 412, 30822, 552, 11, 370, 510, 311, 732, 5110, 11, 441, 2271, 339, 293], "temperature": 0.0, "avg_logprob": -0.20687410105829654, "compression_ratio": 1.4385026737967914, "no_speech_prob": 2.7037516701966524e-05}, {"id": 174, "seek": 98300, "start": 989.52, "end": 996.72, "text": " Tachyon, which are again quite well known HPC benchmarking codes, and Lulech is quite", "tokens": [314, 608, 20808, 11, 597, 366, 797, 1596, 731, 2570, 12557, 34, 18927, 278, 14211, 11, 293, 441, 2271, 339, 307, 1596], "temperature": 0.0, "avg_logprob": -0.20687410105829654, "compression_ratio": 1.4385026737967914, "no_speech_prob": 2.7037516701966524e-05}, {"id": 175, "seek": 98300, "start": 996.72, "end": 1004.52, "text": " favorable for our presentation because there's not many callbacks and hence our runtime impact", "tokens": [29557, 337, 527, 5860, 570, 456, 311, 406, 867, 818, 17758, 293, 16678, 527, 34474, 2712], "temperature": 0.0, "avg_logprob": -0.20687410105829654, "compression_ratio": 1.4385026737967914, "no_speech_prob": 2.7037516701966524e-05}, {"id": 176, "seek": 100452, "start": 1004.52, "end": 1013.1999999999999, "text": " is like quite non-existent so to speak, where you can see that this is compared to vanilla", "tokens": [307, 411, 1596, 2107, 12, 18217, 317, 370, 281, 1710, 11, 689, 291, 393, 536, 300, 341, 307, 5347, 281, 17528], "temperature": 0.0, "avg_logprob": -0.21062127626859226, "compression_ratio": 1.576271186440678, "no_speech_prob": 1.2367818271741271e-05}, {"id": 177, "seek": 100452, "start": 1013.1999999999999, "end": 1020.92, "text": " without any instrumentation without our tooling, type art almost has no impact, and then with", "tokens": [1553, 604, 7198, 399, 1553, 527, 46593, 11, 2010, 1523, 1920, 575, 572, 2712, 11, 293, 550, 365], "temperature": 0.0, "avg_logprob": -0.21062127626859226, "compression_ratio": 1.576271186440678, "no_speech_prob": 1.2367818271741271e-05}, {"id": 178, "seek": 100452, "start": 1020.92, "end": 1029.2, "text": " type art analysis enabled has almost no additional impact, for Tachyon the picture looks quite", "tokens": [2010, 1523, 5215, 15172, 575, 1920, 572, 4497, 2712, 11, 337, 314, 608, 20808, 264, 3036, 1542, 1596], "temperature": 0.0, "avg_logprob": -0.21062127626859226, "compression_ratio": 1.576271186440678, "no_speech_prob": 1.2367818271741271e-05}, {"id": 179, "seek": 102920, "start": 1029.2, "end": 1035.1200000000001, "text": " different as you can see, there's an overhead factor of about three using when you introduce", "tokens": [819, 382, 291, 393, 536, 11, 456, 311, 364, 19922, 5952, 295, 466, 1045, 1228, 562, 291, 5366], "temperature": 0.0, "avg_logprob": -0.12365685190473284, "compression_ratio": 1.7355769230769231, "no_speech_prob": 1.54092485900037e-05}, {"id": 180, "seek": 102920, "start": 1035.1200000000001, "end": 1041.8400000000001, "text": " type art, this is because there's a lot of stack allocations that cannot filter, so we", "tokens": [2010, 1523, 11, 341, 307, 570, 456, 311, 257, 688, 295, 8630, 12660, 763, 300, 2644, 6608, 11, 370, 321], "temperature": 0.0, "avg_logprob": -0.12365685190473284, "compression_ratio": 1.7355769230769231, "no_speech_prob": 1.54092485900037e-05}, {"id": 181, "seek": 102920, "start": 1041.8400000000001, "end": 1049.1200000000001, "text": " track a lot of stack allocations and the runtime impact is quite high, and this is reflected", "tokens": [2837, 257, 688, 295, 8630, 12660, 763, 293, 264, 34474, 2712, 307, 1596, 1090, 11, 293, 341, 307, 15502], "temperature": 0.0, "avg_logprob": -0.12365685190473284, "compression_ratio": 1.7355769230769231, "no_speech_prob": 1.54092485900037e-05}, {"id": 182, "seek": 102920, "start": 1049.1200000000001, "end": 1056.4, "text": " by those runtime and static instrumentation numbers, so first of all the buff table here", "tokens": [538, 729, 34474, 293, 13437, 7198, 399, 3547, 11, 370, 700, 295, 439, 264, 9204, 3199, 510], "temperature": 0.0, "avg_logprob": -0.12365685190473284, "compression_ratio": 1.7355769230769231, "no_speech_prob": 1.54092485900037e-05}, {"id": 183, "seek": 105640, "start": 1056.4, "end": 1063.96, "text": " shows you during compilation what we instrument, so you can see that there's some heap free", "tokens": [3110, 291, 1830, 40261, 437, 321, 7198, 11, 370, 291, 393, 536, 300, 456, 311, 512, 33591, 1737], "temperature": 0.0, "avg_logprob": -0.18522869913201584, "compression_ratio": 1.8307692307692307, "no_speech_prob": 5.189508738112636e-05}, {"id": 184, "seek": 105640, "start": 1063.96, "end": 1069.0400000000002, "text": " operations that we find an instrument, there's some stack allocations and globals that we", "tokens": [7705, 300, 321, 915, 364, 7198, 11, 456, 311, 512, 8630, 12660, 763, 293, 16125, 1124, 300, 321], "temperature": 0.0, "avg_logprob": -0.18522869913201584, "compression_ratio": 1.8307692307692307, "no_speech_prob": 5.189508738112636e-05}, {"id": 185, "seek": 105640, "start": 1069.0400000000002, "end": 1077.0, "text": " instrument, well of course those numbers do not represent the runtime numbers because", "tokens": [7198, 11, 731, 295, 1164, 729, 3547, 360, 406, 2906, 264, 34474, 3547, 570], "temperature": 0.0, "avg_logprob": -0.18522869913201584, "compression_ratio": 1.8307692307692307, "no_speech_prob": 5.189508738112636e-05}, {"id": 186, "seek": 105640, "start": 1077.0, "end": 1082.8400000000001, "text": " heap and free operations sometimes are written in a way that they are like centralized in", "tokens": [33591, 293, 1737, 7705, 2171, 366, 3720, 294, 257, 636, 300, 436, 366, 411, 32395, 294], "temperature": 0.0, "avg_logprob": -0.18522869913201584, "compression_ratio": 1.8307692307692307, "no_speech_prob": 5.189508738112636e-05}, {"id": 187, "seek": 108284, "start": 1082.84, "end": 1093.1599999999999, "text": " a program, that's why those numbers are not as high as you would expect, for stack allocations", "tokens": [257, 1461, 11, 300, 311, 983, 729, 3547, 366, 406, 382, 1090, 382, 291, 576, 2066, 11, 337, 8630, 12660, 763], "temperature": 0.0, "avg_logprob": -0.18666368982066278, "compression_ratio": 1.587719298245614, "no_speech_prob": 4.306616392568685e-05}, {"id": 188, "seek": 108284, "start": 1093.1599999999999, "end": 1100.48, "text": " we find 54 and out of those 54 we can filter for Lulish at least 21%, and globals are much", "tokens": [321, 915, 20793, 293, 484, 295, 729, 20793, 321, 393, 6608, 337, 441, 425, 742, 412, 1935, 5080, 8923, 293, 16125, 1124, 366, 709], "temperature": 0.0, "avg_logprob": -0.18666368982066278, "compression_ratio": 1.587719298245614, "no_speech_prob": 4.306616392568685e-05}, {"id": 189, "seek": 108284, "start": 1100.48, "end": 1105.04, "text": " easier to follow along the data flow in LLVM IR so we can filter much more and much more", "tokens": [3571, 281, 1524, 2051, 264, 1412, 3095, 294, 441, 43, 53, 44, 16486, 370, 321, 393, 6608, 709, 544, 293, 709, 544], "temperature": 0.0, "avg_logprob": -0.18666368982066278, "compression_ratio": 1.587719298245614, "no_speech_prob": 4.306616392568685e-05}, {"id": 190, "seek": 108284, "start": 1105.04, "end": 1112.6799999999998, "text": " effectively, well going to the runtime numbers which means that those are basically the", "tokens": [8659, 11, 731, 516, 281, 264, 34474, 3547, 597, 1355, 300, 729, 366, 1936, 264], "temperature": 0.0, "avg_logprob": -0.18666368982066278, "compression_ratio": 1.587719298245614, "no_speech_prob": 4.306616392568685e-05}, {"id": 191, "seek": 111268, "start": 1112.68, "end": 1120.4, "text": " number of callbacks that happen during our benchmarking, we can already see that the", "tokens": [1230, 295, 818, 17758, 300, 1051, 1830, 527, 18927, 278, 11, 321, 393, 1217, 536, 300, 264], "temperature": 0.0, "avg_logprob": -0.1440221010628393, "compression_ratio": 1.5176470588235293, "no_speech_prob": 8.488733146805316e-05}, {"id": 192, "seek": 111268, "start": 1120.4, "end": 1130.3600000000001, "text": " high overhead of which we observed in Tachyon is to be explained by the almost 80 million", "tokens": [1090, 19922, 295, 597, 321, 13095, 294, 314, 608, 20808, 307, 281, 312, 8825, 538, 264, 1920, 4688, 2459], "temperature": 0.0, "avg_logprob": -0.1440221010628393, "compression_ratio": 1.5176470588235293, "no_speech_prob": 8.488733146805316e-05}, {"id": 193, "seek": 111268, "start": 1130.3600000000001, "end": 1134.76, "text": " stack allocation callbacks basically that we have to track during runtime, which is", "tokens": [8630, 27599, 818, 17758, 1936, 300, 321, 362, 281, 2837, 1830, 34474, 11, 597, 307], "temperature": 0.0, "avg_logprob": -0.1440221010628393, "compression_ratio": 1.5176470588235293, "no_speech_prob": 8.488733146805316e-05}, {"id": 194, "seek": 113476, "start": 1134.76, "end": 1145.0, "text": " a lot of context switching and so on, which is not good for the runtime, alright so this", "tokens": [257, 688, 295, 4319, 16493, 293, 370, 322, 11, 597, 307, 406, 665, 337, 264, 34474, 11, 5845, 370, 341], "temperature": 0.0, "avg_logprob": -0.12979430030373967, "compression_ratio": 1.691588785046729, "no_speech_prob": 2.3134569346439093e-05}, {"id": 195, "seek": 113476, "start": 1145.0, "end": 1152.08, "text": " is already my conclusion, what we have done is basically with type art must can now check", "tokens": [307, 1217, 452, 10063, 11, 437, 321, 362, 1096, 307, 1936, 365, 2010, 1523, 1633, 393, 586, 1520], "temperature": 0.0, "avg_logprob": -0.12979430030373967, "compression_ratio": 1.691588785046729, "no_speech_prob": 2.3134569346439093e-05}, {"id": 196, "seek": 113476, "start": 1152.08, "end": 1158.8799999999999, "text": " all phases of the MPI communication with respect to type correctness, so the first phase that", "tokens": [439, 18764, 295, 264, 14146, 40, 6101, 365, 3104, 281, 2010, 3006, 1287, 11, 370, 264, 700, 5574, 300], "temperature": 0.0, "avg_logprob": -0.12979430030373967, "compression_ratio": 1.691588785046729, "no_speech_prob": 2.3134569346439093e-05}, {"id": 197, "seek": 113476, "start": 1158.8799999999999, "end": 1164.36, "text": " must can already do is this one, which is basically the message transfer, this is checked", "tokens": [1633, 393, 1217, 360, 307, 341, 472, 11, 597, 307, 1936, 264, 3636, 5003, 11, 341, 307, 10033], "temperature": 0.0, "avg_logprob": -0.12979430030373967, "compression_ratio": 1.691588785046729, "no_speech_prob": 2.3134569346439093e-05}, {"id": 198, "seek": 116436, "start": 1164.36, "end": 1169.32, "text": " against, however there is also the phase of message assembly, right where you go kind", "tokens": [1970, 11, 4461, 456, 307, 611, 264, 5574, 295, 3636, 12103, 11, 558, 689, 291, 352, 733], "temperature": 0.0, "avg_logprob": -0.14268332435971215, "compression_ratio": 1.763819095477387, "no_speech_prob": 4.581969551509246e-05}, {"id": 199, "seek": 116436, "start": 1169.32, "end": 1176.1999999999998, "text": " of from the user process into the MPI process and you have to check this, and of course", "tokens": [295, 490, 264, 4195, 1399, 666, 264, 14146, 40, 1399, 293, 291, 362, 281, 1520, 341, 11, 293, 295, 1164], "temperature": 0.0, "avg_logprob": -0.14268332435971215, "compression_ratio": 1.763819095477387, "no_speech_prob": 4.581969551509246e-05}, {"id": 200, "seek": 116436, "start": 1176.1999999999998, "end": 1180.76, "text": " if you think about it you would also have to kind of check the message disassembly where", "tokens": [498, 291, 519, 466, 309, 291, 576, 611, 362, 281, 733, 295, 1520, 264, 3636, 717, 29386, 356, 689], "temperature": 0.0, "avg_logprob": -0.14268332435971215, "compression_ratio": 1.763819095477387, "no_speech_prob": 4.581969551509246e-05}, {"id": 201, "seek": 116436, "start": 1180.76, "end": 1191.1599999999999, "text": " you go from the received data to your user program again, so type art enables these kind", "tokens": [291, 352, 490, 264, 4613, 1412, 281, 428, 4195, 1461, 797, 11, 370, 2010, 1523, 17077, 613, 733], "temperature": 0.0, "avg_logprob": -0.14268332435971215, "compression_ratio": 1.763819095477387, "no_speech_prob": 4.581969551509246e-05}, {"id": 202, "seek": 119116, "start": 1191.16, "end": 1205.64, "text": " of local checks to ensure type correctness, thank you very much.", "tokens": [295, 2654, 13834, 281, 5586, 2010, 3006, 1287, 11, 1309, 291, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.3104687001970079, "compression_ratio": 1.0, "no_speech_prob": 0.0008767624967731535}, {"id": 203, "seek": 120564, "start": 1205.64, "end": 1222.72, "text": " Any questions?", "tokens": [2639, 1651, 30], "temperature": 0.0, "avg_logprob": -0.2909220991463497, "compression_ratio": 1.1428571428571428, "no_speech_prob": 0.0003717030631378293}, {"id": 204, "seek": 120564, "start": 1222.72, "end": 1227.4, "text": " Yeah so I really like to talk, I thought it was really interesting, so one thing I wanted", "tokens": [865, 370, 286, 534, 411, 281, 751, 11, 286, 1194, 309, 390, 534, 1880, 11, 370, 472, 551, 286, 1415], "temperature": 0.0, "avg_logprob": -0.2909220991463497, "compression_ratio": 1.1428571428571428, "no_speech_prob": 0.0003717030631378293}, {"id": 205, "seek": 122740, "start": 1227.4, "end": 1236.8000000000002, "text": " to ask was how does one get must, like how do they install it, is it available for distribution", "tokens": [281, 1029, 390, 577, 775, 472, 483, 1633, 11, 411, 577, 360, 436, 3625, 309, 11, 307, 309, 2435, 337, 7316], "temperature": 0.0, "avg_logprob": -0.19499116656423984, "compression_ratio": 1.6568627450980393, "no_speech_prob": 9.848666377365589e-05}, {"id": 206, "seek": 122740, "start": 1236.8000000000002, "end": 1240.52, "text": " package managers or is it more that you have to compile it yourself?", "tokens": [7372, 14084, 420, 307, 309, 544, 300, 291, 362, 281, 31413, 309, 1803, 30], "temperature": 0.0, "avg_logprob": -0.19499116656423984, "compression_ratio": 1.6568627450980393, "no_speech_prob": 9.848666377365589e-05}, {"id": 207, "seek": 122740, "start": 1240.52, "end": 1248.0800000000002, "text": " Good question, I think you have to compile it yourself, even on our HPC system so, but", "tokens": [2205, 1168, 11, 286, 519, 291, 362, 281, 31413, 309, 1803, 11, 754, 322, 527, 12557, 34, 1185, 370, 11, 457], "temperature": 0.0, "avg_logprob": -0.19499116656423984, "compression_ratio": 1.6568627450980393, "no_speech_prob": 9.848666377365589e-05}, {"id": 208, "seek": 122740, "start": 1248.0800000000002, "end": 1256.2800000000002, "text": " it's not that tedious to compile I think, maybe I'm biased, but just go to the website", "tokens": [309, 311, 406, 300, 38284, 281, 31413, 286, 519, 11, 1310, 286, 478, 28035, 11, 457, 445, 352, 281, 264, 3144], "temperature": 0.0, "avg_logprob": -0.19499116656423984, "compression_ratio": 1.6568627450980393, "no_speech_prob": 9.848666377365589e-05}, {"id": 209, "seek": 125628, "start": 1256.28, "end": 1263.6399999999999, "text": " and there's a zip file, it includes every dependency that you need and I think the documentation", "tokens": [293, 456, 311, 257, 20730, 3991, 11, 309, 5974, 633, 33621, 300, 291, 643, 293, 286, 519, 264, 14333], "temperature": 0.0, "avg_logprob": -0.20336974185446036, "compression_ratio": 1.5851528384279476, "no_speech_prob": 0.00016935443272814155}, {"id": 210, "seek": 125628, "start": 1263.6399999999999, "end": 1269.68, "text": " is quite straightforward, you need of course maybe open MPI installed, but not much more", "tokens": [307, 1596, 15325, 11, 291, 643, 295, 1164, 1310, 1269, 14146, 40, 8899, 11, 457, 406, 709, 544], "temperature": 0.0, "avg_logprob": -0.20336974185446036, "compression_ratio": 1.5851528384279476, "no_speech_prob": 0.00016935443272814155}, {"id": 211, "seek": 125628, "start": 1269.68, "end": 1276.04, "text": " to be honest and then you should be good to go, yeah, I think it's CMAC based, I don't", "tokens": [281, 312, 3245, 293, 550, 291, 820, 312, 665, 281, 352, 11, 1338, 11, 286, 519, 309, 311, 20424, 4378, 2361, 11, 286, 500, 380], "temperature": 0.0, "avg_logprob": -0.20336974185446036, "compression_ratio": 1.5851528384279476, "no_speech_prob": 0.00016935443272814155}, {"id": 212, "seek": 125628, "start": 1276.04, "end": 1282.84, "text": " know if you have problems with that, but yeah, it should be straightforward to try it out.", "tokens": [458, 498, 291, 362, 2740, 365, 300, 11, 457, 1338, 11, 309, 820, 312, 15325, 281, 853, 309, 484, 13], "temperature": 0.0, "avg_logprob": -0.20336974185446036, "compression_ratio": 1.5851528384279476, "no_speech_prob": 0.00016935443272814155}, {"id": 213, "seek": 128284, "start": 1282.84, "end": 1298.4399999999998, "text": " Thank you, another question there on my way.", "tokens": [1044, 291, 11, 1071, 1168, 456, 322, 452, 636, 13], "temperature": 0.0, "avg_logprob": -0.19626712799072266, "compression_ratio": 1.5492957746478873, "no_speech_prob": 0.0038627826143056154}, {"id": 214, "seek": 128284, "start": 1298.4399999999998, "end": 1305.48, "text": " So on the type analysis that you do, I mean if you look at malloc and it has like a type", "tokens": [407, 322, 264, 2010, 5215, 300, 291, 360, 11, 286, 914, 498, 291, 574, 412, 16026, 905, 293, 309, 575, 411, 257, 2010], "temperature": 0.0, "avg_logprob": -0.19626712799072266, "compression_ratio": 1.5492957746478873, "no_speech_prob": 0.0038627826143056154}, {"id": 215, "seek": 128284, "start": 1305.48, "end": 1309.48, "text": " cast then you know what the type is, but if it doesn't have a type cast, if you malloc", "tokens": [4193, 550, 291, 458, 437, 264, 2010, 307, 11, 457, 498, 309, 1177, 380, 362, 257, 2010, 4193, 11, 498, 291, 16026, 905], "temperature": 0.0, "avg_logprob": -0.19626712799072266, "compression_ratio": 1.5492957746478873, "no_speech_prob": 0.0038627826143056154}, {"id": 216, "seek": 130948, "start": 1309.48, "end": 1313.84, "text": " into a void pointer and if the amount of bytes you are allocating comes from some constant", "tokens": [666, 257, 22009, 23918, 293, 498, 264, 2372, 295, 36088, 291, 366, 12660, 990, 1487, 490, 512, 5754], "temperature": 0.0, "avg_logprob": -0.15742419163386026, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.00010000489419326186}, {"id": 217, "seek": 130948, "start": 1313.84, "end": 1319.48, "text": " or macro or some argument, how far do you follow and if you can't see it, do you have", "tokens": [420, 18887, 420, 512, 6770, 11, 577, 1400, 360, 291, 1524, 293, 498, 291, 393, 380, 536, 309, 11, 360, 291, 362], "temperature": 0.0, "avg_logprob": -0.15742419163386026, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.00010000489419326186}, {"id": 218, "seek": 130948, "start": 1319.48, "end": 1323.04, "text": " a warning, do you crash?", "tokens": [257, 9164, 11, 360, 291, 8252, 30], "temperature": 0.0, "avg_logprob": -0.15742419163386026, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.00010000489419326186}, {"id": 219, "seek": 130948, "start": 1323.04, "end": 1328.44, "text": " That's a good question and that's basically a fundamental problem, right, so we have to", "tokens": [663, 311, 257, 665, 1168, 293, 300, 311, 1936, 257, 8088, 1154, 11, 558, 11, 370, 321, 362, 281], "temperature": 0.0, "avg_logprob": -0.15742419163386026, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.00010000489419326186}, {"id": 220, "seek": 130948, "start": 1328.44, "end": 1336.32, "text": " have some expectations of the program, right, so our expectation is that the malloc calls", "tokens": [362, 512, 9843, 295, 264, 1461, 11, 558, 11, 370, 527, 14334, 307, 300, 264, 16026, 905, 5498], "temperature": 0.0, "avg_logprob": -0.15742419163386026, "compression_ratio": 1.7149321266968325, "no_speech_prob": 0.00010000489419326186}, {"id": 221, "seek": 133632, "start": 1336.32, "end": 1349.08, "text": " are typed, otherwise we would just track it as a chunk of bytes and I think our analysis", "tokens": [366, 33941, 11, 5911, 321, 576, 445, 2837, 309, 382, 257, 16635, 295, 36088, 293, 286, 519, 527, 5215], "temperature": 0.0, "avg_logprob": -0.20923965317862375, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.00042047142051160336}, {"id": 222, "seek": 133632, "start": 1349.08, "end": 1357.96, "text": " is quite forgiving, so we would just look at okay this is a chunk of bytes, it fits you", "tokens": [307, 1596, 37701, 11, 370, 321, 576, 445, 574, 412, 1392, 341, 307, 257, 16635, 295, 36088, 11, 309, 9001, 291], "temperature": 0.0, "avg_logprob": -0.20923965317862375, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.00042047142051160336}, {"id": 223, "seek": 133632, "start": 1357.96, "end": 1360.52, "text": " know the buffer and this is fine.", "tokens": [458, 264, 21762, 293, 341, 307, 2489, 13], "temperature": 0.0, "avg_logprob": -0.20923965317862375, "compression_ratio": 1.5555555555555556, "no_speech_prob": 0.00042047142051160336}, {"id": 224, "seek": 136052, "start": 1360.52, "end": 1373.36, "text": " Yes, you kind of lose that, right, if you just know it's a chunk of bytes then you kind", "tokens": [1079, 11, 291, 733, 295, 3624, 300, 11, 558, 11, 498, 291, 445, 458, 309, 311, 257, 16635, 295, 36088, 550, 291, 733], "temperature": 0.0, "avg_logprob": -0.22719666537116556, "compression_ratio": 1.5497076023391814, "no_speech_prob": 0.0003568811807781458}, {"id": 225, "seek": 136052, "start": 1373.36, "end": 1380.8799999999999, "text": " of lose the alignment checks because you could, if you have like say you malloc is struct", "tokens": [295, 3624, 264, 18515, 13834, 570, 291, 727, 11, 498, 291, 362, 411, 584, 291, 16026, 905, 307, 6594], "temperature": 0.0, "avg_logprob": -0.22719666537116556, "compression_ratio": 1.5497076023391814, "no_speech_prob": 0.0003568811807781458}, {"id": 226, "seek": 136052, "start": 1380.8799999999999, "end": 1387.72, "text": " and then you do some pointer magic for your MPI buffer and you point between members in", "tokens": [293, 550, 291, 360, 512, 23918, 5585, 337, 428, 14146, 40, 21762, 293, 291, 935, 1296, 2679, 294], "temperature": 0.0, "avg_logprob": -0.22719666537116556, "compression_ratio": 1.5497076023391814, "no_speech_prob": 0.0003568811807781458}, {"id": 227, "seek": 138772, "start": 1387.72, "end": 1396.84, "text": " the padding area, only if type art knows about the malloc struct, it can of course warn that", "tokens": [264, 39562, 1859, 11, 787, 498, 2010, 1523, 3255, 466, 264, 16026, 905, 6594, 11, 309, 393, 295, 1164, 12286, 300], "temperature": 0.0, "avg_logprob": -0.193657750668733, "compression_ratio": 1.4045801526717556, "no_speech_prob": 0.00019579834770411253}, {"id": 228, "seek": 138772, "start": 1396.84, "end": 1403.04, "text": " you are doing some illegal memory operations, if we just see a void pointer due to the type", "tokens": [291, 366, 884, 512, 11905, 4675, 7705, 11, 498, 321, 445, 536, 257, 22009, 23918, 3462, 281, 264, 2010], "temperature": 0.0, "avg_logprob": -0.193657750668733, "compression_ratio": 1.4045801526717556, "no_speech_prob": 0.00019579834770411253}, {"id": 229, "seek": 140304, "start": 1403.04, "end": 1418.56, "text": " plus malloc then we have lost basically, anyone else, do you have any thoughts on using Rust", "tokens": [1804, 16026, 905, 550, 321, 362, 2731, 1936, 11, 2878, 1646, 11, 360, 291, 362, 604, 4598, 322, 1228, 34952], "temperature": 0.0, "avg_logprob": -0.3000785708427429, "compression_ratio": 1.368421052631579, "no_speech_prob": 0.00015595344302710146}, {"id": 230, "seek": 140304, "start": 1418.56, "end": 1424.6, "text": " which is a way more memory safe language than C and C plus pluses, have you looked at it?", "tokens": [597, 307, 257, 636, 544, 4675, 3273, 2856, 813, 383, 293, 383, 1804, 1804, 279, 11, 362, 291, 2956, 412, 309, 30], "temperature": 0.0, "avg_logprob": -0.3000785708427429, "compression_ratio": 1.368421052631579, "no_speech_prob": 0.00015595344302710146}, {"id": 231, "seek": 142460, "start": 1424.6, "end": 1433.9199999999998, "text": " Not really, not yet, for now we have so much to do with the C and C plus words to support", "tokens": [1726, 534, 11, 406, 1939, 11, 337, 586, 321, 362, 370, 709, 281, 360, 365, 264, 383, 293, 383, 1804, 2283, 281, 1406], "temperature": 0.0, "avg_logprob": -0.1997424080258324, "compression_ratio": 1.5165876777251184, "no_speech_prob": 0.00011122116120532155}, {"id": 232, "seek": 142460, "start": 1433.9199999999998, "end": 1441.9199999999998, "text": " typing better, to get more robustness and so on and not yet to be honest.", "tokens": [18444, 1101, 11, 281, 483, 544, 13956, 1287, 293, 370, 322, 293, 406, 1939, 281, 312, 3245, 13], "temperature": 0.0, "avg_logprob": -0.1997424080258324, "compression_ratio": 1.5165876777251184, "no_speech_prob": 0.00011122116120532155}, {"id": 233, "seek": 142460, "start": 1441.9199999999998, "end": 1444.9199999999998, "text": " Maybe all that work becomes irrelevant if Rust gets popular enough.", "tokens": [2704, 439, 300, 589, 3643, 28682, 498, 34952, 2170, 3743, 1547, 13], "temperature": 0.0, "avg_logprob": -0.1997424080258324, "compression_ratio": 1.5165876777251184, "no_speech_prob": 0.00011122116120532155}, {"id": 234, "seek": 142460, "start": 1444.9199999999998, "end": 1452.28, "text": " I think in general maybe I'm completely like a newbie when it comes to Rust, I think the", "tokens": [286, 519, 294, 2674, 1310, 286, 478, 2584, 411, 257, 777, 7392, 562, 309, 1487, 281, 34952, 11, 286, 519, 264], "temperature": 0.0, "avg_logprob": -0.1997424080258324, "compression_ratio": 1.5165876777251184, "no_speech_prob": 0.00011122116120532155}, {"id": 235, "seek": 145228, "start": 1452.28, "end": 1460.36, "text": " MPI support itself is still in the works, I read some papers about like generating bindings", "tokens": [14146, 40, 1406, 2564, 307, 920, 294, 264, 1985, 11, 286, 1401, 512, 10577, 466, 411, 17746, 14786, 1109], "temperature": 0.0, "avg_logprob": -0.1367623312719937, "compression_ratio": 1.411764705882353, "no_speech_prob": 0.0008553701918572187}, {"id": 236, "seek": 145228, "start": 1460.36, "end": 1470.36, "text": " for MPI which are inherently type safe, not sure how that goes.", "tokens": [337, 14146, 40, 597, 366, 27993, 2010, 3273, 11, 406, 988, 577, 300, 1709, 13], "temperature": 0.0, "avg_logprob": -0.1367623312719937, "compression_ratio": 1.411764705882353, "no_speech_prob": 0.0008553701918572187}, {"id": 237, "seek": 145228, "start": 1470.36, "end": 1476.3, "text": " I think everyone will be happy if Rust or some other type safe language becomes more", "tokens": [286, 519, 1518, 486, 312, 2055, 498, 34952, 420, 512, 661, 2010, 3273, 2856, 3643, 544], "temperature": 0.0, "avg_logprob": -0.1367623312719937, "compression_ratio": 1.411764705882353, "no_speech_prob": 0.0008553701918572187}, {"id": 238, "seek": 147630, "start": 1476.3, "end": 1483.08, "text": " used by people and this kind of work is irrelevant, but while people still use C plus pluses,", "tokens": [1143, 538, 561, 293, 341, 733, 295, 589, 307, 28682, 11, 457, 1339, 561, 920, 764, 383, 1804, 1804, 279, 11], "temperature": 0.0, "avg_logprob": -0.3230775833129883, "compression_ratio": 1.423728813559322, "no_speech_prob": 0.0018633371219038963}, {"id": 239, "seek": 147630, "start": 1483.08, "end": 1484.8, "text": " this is very relevant.", "tokens": [341, 307, 588, 7340, 13], "temperature": 0.0, "avg_logprob": -0.3230775833129883, "compression_ratio": 1.423728813559322, "no_speech_prob": 0.0018633371219038963}, {"id": 240, "seek": 147630, "start": 1484.8, "end": 1489.72, "text": " That pays my bills.", "tokens": [663, 10604, 452, 12433, 13], "temperature": 0.0, "avg_logprob": -0.3230775833129883, "compression_ratio": 1.423728813559322, "no_speech_prob": 0.0018633371219038963}, {"id": 241, "seek": 147630, "start": 1489.72, "end": 1490.72, "text": " Thank you very much.", "tokens": [1044, 291, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.3230775833129883, "compression_ratio": 1.423728813559322, "no_speech_prob": 0.0018633371219038963}, {"id": 242, "seek": 149072, "start": 1490.72, "end": 1507.76, "text": " Thank you.", "tokens": [1044, 291, 13], "temperature": 0.0, "avg_logprob": -0.879896981375558, "compression_ratio": 0.5555555555555556, "no_speech_prob": 0.00014720525359734893}], "language": "en"}