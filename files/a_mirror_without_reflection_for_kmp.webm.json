{"text": " Hey, everyone. Thank you for joining me. I'm Solomon Briss and this is A Mirror Without Reflection for Cartoon Multi-Platform. So, without further ado, let's go into the subject and define what is reflection. Reflection is a feature that allows an executing Java program to examine or introspect upon itself and manipulate internal properties of the program. For example, it's possible for a Java class to obtain the name of all of its members. This definition is extracted from the Java documentation and it explains that reflection basically allows a program to introspect upon itself and look at its own method and properties. For example, in this code, I simply print every field and method that a class is declaring as accessible. And so, this is possible thanks to these class objects that the Java runtime gives me and it allows me to access all fields, methods, properties, and everything that defines this class. Now, that's not the only thing Java reflection can do. Java reflection can also provide proxies. So, for example, here, I create a simple printer and proxy. So, here, I create a proxy by saying, okay, here's a class. Here's its class loader. Here's a class. It's not really a class. It's an interface. So, here's an interface. And what I'm asking the runtime to do is to give me an object that implements this interface and delegates every call to this lambda. So, basically, I'm creating an implementation of an interface at runtime. And this is how you can use it. As you can see, it's pretty simple. All you have to do is call this create proxy method and then you'll have an interface, an implementation of the interface created at runtime. So, this talk is going to be about a lot of definitions because we are going to have multiple pieces of the puzzle. So, the first piece of the puzzle was, of course, reflection. Let's go into Kotlin multiplatform. Maybe let's not go into Kotlin multiplatform because you've just seen an entire presentation about what is Kotlin multiplatform and how it works. So, I'm not going to go into details about what is Kotlin multiplatform and how it works, but I'm simply going to say that Kotlin multiplatform is a way to compile Kotlin code for different targets, namely JVM and Android on one side, JavaScript on another side, and finally Kotlin native on the last side. Kotlin native encompasses iOS and also other less interesting targets. Let's face it, Kotlin native exists for the sole purpose of iOS. So, while Kotlin JVM supports reflection, Kotlin JS and Kotlin native do not. What is important to understand in this sentence is that reflection is not a feature of Kotlin JVM. It's a feature of the JVM that Kotlin uses and builds upon with its own reflection library, but basically it's a feature of the JVM. It's not a feature of the Kotlin language. As such, it is not provided in Kotlin JS and in Kotlin native. So, Kotlin multiplatform being the center of Kotlin JVM, Kotlin JS and Kotlin native, hence, do not support reflection. So, we need to get together and find another way of doing what we usually do with reflection. Maybe if we go back to the definition of what reflection is, we can single out this word. Reflection is a feature that allows an executing Java program. So, what this means is that reflection is a runtime feature. And we all know that what we cannot do at runtime, let's do at compile time. What can go wrong, right? So, to do that at compile time, what reflection does at runtime, we need to add several other pieces of our puzzle. Kotlin Poets is a Kotlin and Java API for generating Kotlin source files. So, what you could do is generate Kotlin source files by hand with templates and fill yourself like the vibe of the PHP 2000 error where everything was done with templating or you could use a type API that will build the Kotlin file for you. So, I strongly encourage you to not generate your Kotlin source files by hand and use an API such as Kotlin Poets. And here, for example, it's very simple. I create a new function called hello. I declare that it takes a name argument and I add the statement println hello name. So, it generates basically this function. Okay. So, that's a very important piece of our puzzle but that's by far not the most complicated one. So, the next piece of our puzzle is KSP. And KSP stands for Kerbal Space Program. It's a very good video game and the goal of this video game is to build a rocket and explore space. It's an exploration game. So, it's purposefully undocumented. So, there's no manual for discovery and that's the entire game. You need to build your rocket, send your Kerbal to space and see what happened. So, the game is heavily based on trial and error. Not all Kerbal will survive the journey. You will send them to space and not all Kerbal will come back. But when you do build a rocket and a space station in orbit, you feel a great sense of accomplishment. And as it happens, KSP also stands for Kotlin Symbol Processing API. The goal is to build a compiler processor, a compiler code processor and it is very, very lightly documented. Let's be honest, there is no manual for its discovery. You will use trial and error and you will scream at your screen, yelling at your frustration. Using KSP is a very good exercise in managing your frustration because of its light documentation. But when you finally achieve a functional Kotlin Symbol processor, you will, just like in the KSP video game, feel a great sense of accomplishment. So, let's see all our pieces of the puzzle. We use KSP to instrument codes at compile time. We use Kotlin Poets to generate codes at compile time. And we use Kotlin Multiplatform to compile everything for all targets that Kotlin Multiplatform supports. So, the idea here is not to allow a code to introspect upon itself at runtime, but to generate the information your code needs at compile time. It is a lot more optimized, of course, because you don't have to introspect all the code and all the information you need are generated for you at compile time, but it is, of course, a lot more complicated. So, how do you create a mirror generator? So, a mirror is a class that contains reflection information of another class. So, how would you create a mirror generator? Well, creating a symbol processor in KSP is not that complicated. What you need to do is create a symbol processor class that takes a code generator and a logger as a constructor input. And you will use those to, well, generate code and log when things go right or wrong. And then you can get, you can find all symbols that are annotated by a specific annotation and then simply see what type of symbol that is, and then you can continue to instrument the code starting with this. So, as you can see here, for example, look at if the symbol annotated is a property or maybe it's just a property setter because you can, in Kotlin, annotate, get and set properties methods or maybe it's a function declaration or maybe it's a class declaration and there are a lot of other things available. What's interesting in KSP and what I'm not showing here in code is that you could ask KSP to give you all symbols that are of a simple, of a declaring interface, for example, that are implementing an interface. You don't have, just like APT, you don't have to use annotations. Annotations are a very valid means of conveying the information that the code will be instrumented. But you could with KSP say, okay, give me all symbols, all classes that implement this interface, for example, or give me all codes to these methods or these kind of things. And then what you need to do after you have instrumented the code is to generate your file, the Kotlin source file that you will generate. And the good news is that Kotlin Poet does support KSP. So you don't have to write a facade between the KSP code generator and the KSP code generator. Kotlin Poet does support KSP. So it's, as you can see, pretty easy to write your very own code generator with KSP. And then what you need to do is to add your symbol processor to Kotlin, to your Kotlin compilation tool chain with Gradle. And as you can see, it's pretty simple, just apply the plugin. Now, the KSP plugins is versioned using its own version number and the Kotlin version number. For example, here, it's version 109 of the Kotlin symbol processor of KSP and it's version 1810 of the Kotlin language. And at the moment, because the Kotlin compiler plugin API keeps changing and is not stable and is not documented, KSP depends on a very specific version of the Kotlin language. So you need to upgrade KSP with the same Kotlin version that you need to upgrade Kotlin. And that's kind of a bummer because you need to wait when a new Kotlin language comes up, you need to wait for KSP to be compatible with this new version, even for minor version. If you use the wrong minor version, KSP will warn you that it is not compatible with this minor version. And once again, that's because the Kotlin compiler plugin API isn't stable and that KSP is using internal function and features of the Kotlin compiler plugin. Then, of course, you probably need to add your own runtime because when you generate code, you will probably need to provide with the generated code a runtime of your own. And then you need to declare that your KSP code processor will run on this code. Now, as you can see, it is declared differently than with regular Kotlin dependencies because at the moment, KSP doesn't interact with the Kotlin Gradle compiler with the Kotlin Gradle DSL. So you have to use this word, KSP common main metadata configuration in Gradle dependencies. So what can you do with this technology? Well, for the last two years, I have been developing an example because it was needed for the company I worked at and that was mocking. So what we have here is a class that works with Kotlin multi-platform test and that works with all targets of Kotlin and that generates mocks at compile time because mocking in, for example, mock K or with mockito, mocking uses the proxy reflection feature of the JVM which does not exist in Kotlin multi-platform. So, for example, here we say we want a view that will be mocked. So view is an interface and it will be generated by the mock AMP compiler plugin. We want a fake and a fake is a data class and we want a data class that filled with fake values, empty string, zeroed integers and all those kind of stuff. We want a controller that uses both a fake and a mock. We want to define the behavior of our mock. For example, here I say that in the interface view in my mock, in my view mock, if I call view.render with any argument it will return true and I want to be able to verify that a mocked has been called with a specific data in this instance model. So all that and all that DSL is possible thanks to KSP and Kotlin Poets and the ability to generate code at compile time. So what was previously unavailable to Kotlin multi-platform because reflection wasn't available is now available thanks to code generation. And by the way, if you're interested in this in mocking for Kotlin multi-platform you can use mock AMP which is a library that we built with Deezer and this library, this testing library is used in production meaning in test production at Deezer, almost all the multi-platform tests at Deezer uses this mock AMP library that we developed together. So there's a problem with KSP. If we go back to the example I just gave you, this method uses this inject mocks function, this class uses inject mocks. And the fact is that inject mocks is precisely the function that is generated for this class. Because this class, we can see here, because this class has atmock annotated properties and at fake annotated properties, then an inject mocks function will be generated by the mock AMP compiler plug-in slash symbol processor. And when you load the project, the Deezer project or any project that uses this system, well, inject mock is an error because it hasn't been generated yet. So idea will show you an error saying, okay, this function just doesn't exist. I don't know what you are talking about. So you need to either build the project or you need to say to, you need to say to Gradle to generate and run KSP. And at the moment, there is no way around that. And that's because KSP has a very important limitation. It treats the source code it is instrumenting as read only. There is no way with KSP to add properties or to modify a symbol that you are instrumenting. So this my test class, there's no way with KSP that I can add a property or I can add an annotation and all that. And since there is no reflection in Kotlin multiplatform, there is no way to find a class that exists, but there's no class dot with name. So that means that you need in your code to use the code that is generated and that code doesn't exist unless you generate it. And that's a small price to pay to use KSP. So why would you use KSP as opposed to writing a full-fledged Kotlin compiler plugin? First and foremost because KSP provides a kind of stable API. The API changes, but it follows a depreciation cycle. And the API of KSP is supposed to be public, so they treat it with respect of a public API. And also because when you use KSP, you don't have to write a compiler plugin. Writing a compiler plugin with Kotlin just not only means that you will have to understand the inner components of the Kotlin compiler, which are absolutely not documented. KSP is a little bit documented. The Kotlin compiler internals are just not documented, but it also means that you will have to handle compiler integration and gradle integration. So you will have to add your own gradle plugin, you will have to add your own compiler plugin, and it becomes a very complicated endeavor. And finally, because for code-generating use cases, KSP remains a lot simpler than writing a compiler plugin, which once again is done completely in the dark. You won't have any support if you try to write your own compiler plugin. So using KSP, KSP is still a very, very important tool in the grand open source library of Kotlin multiplatform project. A lot of Kotlin multiplatform libraries use KSP now, and I encourage you to contribute to that grand library. And that's it for me. Just want to say that I represent here coding coders. We are certified for our Kotlin training, so if you want Kotlin multiplatform training, be sure to contact us. We have lots of libraries that are open source. Romain with the next talk is going to present you another one of them, and we like to do our open source work with Kotlin multiplatform for every target. It can compile too. So whether you want to contribute to Kotlin multiplatform libraries or learn how to use Kotlin multiplatform, be sure to contact us. Thank you very much. Thank you again. We have time for one question. If someone has a question, raise your hand. Shout it, and you have to repeat the question. Yes, so you've decided to write your own library. There was any way of making Mokey to work with yours, but if you were, is that possible? So the question is, rather than using, rather than creating a whole new library for marking a Kotlin multiplatform, is there a way to put Mokey to Kotlin multiplatform? And the answer is definitely no. Mokey to uses a lot of reflection, just not just for proxy, but for object generation and for verification, and it instruments the runtime heavily. And since there is no runtime, there is no JVM runtime in Kotlin multiplatform, there is no way to port Mokey to Kotlin multiplatform. Now, what we've tried to do with Mokey and P is to emulate the same API that Mokey provides so that when you use Mokey and P, you're at home, you're using an API that is really close, but there's no way to port Mokey to itself. Thank you very much, and have a nice first time.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.68, "text": " Hey, everyone. Thank you for joining me. I'm Solomon Briss and this is A Mirror Without", "tokens": [1911, 11, 1518, 13, 1044, 291, 337, 5549, 385, 13, 286, 478, 32209, 1603, 891, 293, 341, 307, 316, 34452, 9129], "temperature": 0.0, "avg_logprob": -0.26641116422765393, "compression_ratio": 1.3862433862433863, "no_speech_prob": 0.20974622666835785}, {"id": 1, "seek": 0, "start": 11.68, "end": 17.64, "text": " Reflection for Cartoon Multi-Platform. So, without further ado, let's go into the subject", "tokens": [16957, 5450, 337, 22478, 4106, 29238, 12, 47, 14087, 837, 13, 407, 11, 1553, 3052, 22450, 11, 718, 311, 352, 666, 264, 3983], "temperature": 0.0, "avg_logprob": -0.26641116422765393, "compression_ratio": 1.3862433862433863, "no_speech_prob": 0.20974622666835785}, {"id": 2, "seek": 0, "start": 17.64, "end": 25.52, "text": " and define what is reflection. Reflection is a feature that allows an executing Java", "tokens": [293, 6964, 437, 307, 12914, 13, 16957, 5450, 307, 257, 4111, 300, 4045, 364, 32368, 10745], "temperature": 0.0, "avg_logprob": -0.26641116422765393, "compression_ratio": 1.3862433862433863, "no_speech_prob": 0.20974622666835785}, {"id": 3, "seek": 2552, "start": 25.52, "end": 30.68, "text": " program to examine or introspect upon itself and manipulate internal properties of the", "tokens": [1461, 281, 17496, 420, 560, 28713, 3564, 2564, 293, 20459, 6920, 7221, 295, 264], "temperature": 0.0, "avg_logprob": -0.1422856648763021, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.0013037825701758265}, {"id": 4, "seek": 2552, "start": 30.68, "end": 36.08, "text": " program. For example, it's possible for a Java class to obtain the name of all of its", "tokens": [1461, 13, 1171, 1365, 11, 309, 311, 1944, 337, 257, 10745, 1508, 281, 12701, 264, 1315, 295, 439, 295, 1080], "temperature": 0.0, "avg_logprob": -0.1422856648763021, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.0013037825701758265}, {"id": 5, "seek": 2552, "start": 36.08, "end": 44.879999999999995, "text": " members. This definition is extracted from the Java documentation and it explains that", "tokens": [2679, 13, 639, 7123, 307, 34086, 490, 264, 10745, 14333, 293, 309, 13948, 300], "temperature": 0.0, "avg_logprob": -0.1422856648763021, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.0013037825701758265}, {"id": 6, "seek": 2552, "start": 44.879999999999995, "end": 54.08, "text": " reflection basically allows a program to introspect upon itself and look at its own method and", "tokens": [12914, 1936, 4045, 257, 1461, 281, 560, 28713, 3564, 2564, 293, 574, 412, 1080, 1065, 3170, 293], "temperature": 0.0, "avg_logprob": -0.1422856648763021, "compression_ratio": 1.6619718309859155, "no_speech_prob": 0.0013037825701758265}, {"id": 7, "seek": 5408, "start": 54.08, "end": 65.24, "text": " properties. For example, in this code, I simply print every field and method that a class", "tokens": [7221, 13, 1171, 1365, 11, 294, 341, 3089, 11, 286, 2935, 4482, 633, 2519, 293, 3170, 300, 257, 1508], "temperature": 0.0, "avg_logprob": -0.12901460556756883, "compression_ratio": 1.372093023255814, "no_speech_prob": 0.0002797903143800795}, {"id": 8, "seek": 5408, "start": 65.24, "end": 75.96, "text": " is declaring as accessible. And so, this is possible thanks to these class objects that", "tokens": [307, 40374, 382, 9515, 13, 400, 370, 11, 341, 307, 1944, 3231, 281, 613, 1508, 6565, 300], "temperature": 0.0, "avg_logprob": -0.12901460556756883, "compression_ratio": 1.372093023255814, "no_speech_prob": 0.0002797903143800795}, {"id": 9, "seek": 7596, "start": 75.96, "end": 88.6, "text": " the Java runtime gives me and it allows me to access all fields, methods, properties,", "tokens": [264, 10745, 34474, 2709, 385, 293, 309, 4045, 385, 281, 2105, 439, 7909, 11, 7150, 11, 7221, 11], "temperature": 0.0, "avg_logprob": -0.13085758324825403, "compression_ratio": 1.5470588235294118, "no_speech_prob": 0.00024334856425412}, {"id": 10, "seek": 7596, "start": 88.6, "end": 96.39999999999999, "text": " and everything that defines this class. Now, that's not the only thing Java reflection", "tokens": [293, 1203, 300, 23122, 341, 1508, 13, 823, 11, 300, 311, 406, 264, 787, 551, 10745, 12914], "temperature": 0.0, "avg_logprob": -0.13085758324825403, "compression_ratio": 1.5470588235294118, "no_speech_prob": 0.00024334856425412}, {"id": 11, "seek": 7596, "start": 96.39999999999999, "end": 104.52, "text": " can do. Java reflection can also provide proxies. So, for example, here, I create a simple", "tokens": [393, 360, 13, 10745, 12914, 393, 611, 2893, 447, 87, 530, 13, 407, 11, 337, 1365, 11, 510, 11, 286, 1884, 257, 2199], "temperature": 0.0, "avg_logprob": -0.13085758324825403, "compression_ratio": 1.5470588235294118, "no_speech_prob": 0.00024334856425412}, {"id": 12, "seek": 10452, "start": 104.52, "end": 115.92, "text": " printer and proxy. So, here, I create a proxy by saying, okay, here's a class. Here's its", "tokens": [16671, 293, 29690, 13, 407, 11, 510, 11, 286, 1884, 257, 29690, 538, 1566, 11, 1392, 11, 510, 311, 257, 1508, 13, 1692, 311, 1080], "temperature": 0.0, "avg_logprob": -0.14669518531123293, "compression_ratio": 1.6521739130434783, "no_speech_prob": 9.32788971113041e-05}, {"id": 13, "seek": 10452, "start": 115.92, "end": 120.84, "text": " class loader. Here's a class. It's not really a class. It's an interface. So, here's an", "tokens": [1508, 3677, 260, 13, 1692, 311, 257, 1508, 13, 467, 311, 406, 534, 257, 1508, 13, 467, 311, 364, 9226, 13, 407, 11, 510, 311, 364], "temperature": 0.0, "avg_logprob": -0.14669518531123293, "compression_ratio": 1.6521739130434783, "no_speech_prob": 9.32788971113041e-05}, {"id": 14, "seek": 10452, "start": 120.84, "end": 129.48, "text": " interface. And what I'm asking the runtime to do is to give me an object that implements", "tokens": [9226, 13, 400, 437, 286, 478, 3365, 264, 34474, 281, 360, 307, 281, 976, 385, 364, 2657, 300, 704, 17988], "temperature": 0.0, "avg_logprob": -0.14669518531123293, "compression_ratio": 1.6521739130434783, "no_speech_prob": 9.32788971113041e-05}, {"id": 15, "seek": 12948, "start": 129.48, "end": 137.51999999999998, "text": " this interface and delegates every call to this lambda. So, basically, I'm creating an", "tokens": [341, 9226, 293, 45756, 633, 818, 281, 341, 13607, 13, 407, 11, 1936, 11, 286, 478, 4084, 364], "temperature": 0.0, "avg_logprob": -0.10397686591515175, "compression_ratio": 1.5176470588235293, "no_speech_prob": 0.000192456558579579}, {"id": 16, "seek": 12948, "start": 137.51999999999998, "end": 145.39999999999998, "text": " implementation of an interface at runtime. And this is how you can use it. As you can", "tokens": [11420, 295, 364, 9226, 412, 34474, 13, 400, 341, 307, 577, 291, 393, 764, 309, 13, 1018, 291, 393], "temperature": 0.0, "avg_logprob": -0.10397686591515175, "compression_ratio": 1.5176470588235293, "no_speech_prob": 0.000192456558579579}, {"id": 17, "seek": 12948, "start": 145.39999999999998, "end": 153.6, "text": " see, it's pretty simple. All you have to do is call this create proxy method and then", "tokens": [536, 11, 309, 311, 1238, 2199, 13, 1057, 291, 362, 281, 360, 307, 818, 341, 1884, 29690, 3170, 293, 550], "temperature": 0.0, "avg_logprob": -0.10397686591515175, "compression_ratio": 1.5176470588235293, "no_speech_prob": 0.000192456558579579}, {"id": 18, "seek": 15360, "start": 153.6, "end": 161.07999999999998, "text": " you'll have an interface, an implementation of the interface created at runtime. So, this", "tokens": [291, 603, 362, 364, 9226, 11, 364, 11420, 295, 264, 9226, 2942, 412, 34474, 13, 407, 11, 341], "temperature": 0.0, "avg_logprob": -0.143229859598567, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.684022885863669e-05}, {"id": 19, "seek": 15360, "start": 161.07999999999998, "end": 169.4, "text": " talk is going to be about a lot of definitions because we are going to have multiple pieces", "tokens": [751, 307, 516, 281, 312, 466, 257, 688, 295, 21988, 570, 321, 366, 516, 281, 362, 3866, 3755], "temperature": 0.0, "avg_logprob": -0.143229859598567, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.684022885863669e-05}, {"id": 20, "seek": 15360, "start": 169.4, "end": 175.92, "text": " of the puzzle. So, the first piece of the puzzle was, of course, reflection. Let's go", "tokens": [295, 264, 12805, 13, 407, 11, 264, 700, 2522, 295, 264, 12805, 390, 11, 295, 1164, 11, 12914, 13, 961, 311, 352], "temperature": 0.0, "avg_logprob": -0.143229859598567, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.684022885863669e-05}, {"id": 21, "seek": 15360, "start": 175.92, "end": 182.24, "text": " into Kotlin multiplatform. Maybe let's not go into Kotlin multiplatform because you've", "tokens": [666, 30123, 5045, 12788, 267, 837, 13, 2704, 718, 311, 406, 352, 666, 30123, 5045, 12788, 267, 837, 570, 291, 600], "temperature": 0.0, "avg_logprob": -0.143229859598567, "compression_ratio": 1.7611940298507462, "no_speech_prob": 3.684022885863669e-05}, {"id": 22, "seek": 18224, "start": 182.24, "end": 187.96, "text": " just seen an entire presentation about what is Kotlin multiplatform and how it works. So,", "tokens": [445, 1612, 364, 2302, 5860, 466, 437, 307, 30123, 5045, 12788, 267, 837, 293, 577, 309, 1985, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.11670399716025905, "compression_ratio": 1.7815533980582525, "no_speech_prob": 0.0001196140656247735}, {"id": 23, "seek": 18224, "start": 187.96, "end": 193.76000000000002, "text": " I'm not going to go into details about what is Kotlin multiplatform and how it works, but", "tokens": [286, 478, 406, 516, 281, 352, 666, 4365, 466, 437, 307, 30123, 5045, 12788, 267, 837, 293, 577, 309, 1985, 11, 457], "temperature": 0.0, "avg_logprob": -0.11670399716025905, "compression_ratio": 1.7815533980582525, "no_speech_prob": 0.0001196140656247735}, {"id": 24, "seek": 18224, "start": 193.76000000000002, "end": 201.32000000000002, "text": " I'm simply going to say that Kotlin multiplatform is a way to compile Kotlin code for different", "tokens": [286, 478, 2935, 516, 281, 584, 300, 30123, 5045, 12788, 267, 837, 307, 257, 636, 281, 31413, 30123, 5045, 3089, 337, 819], "temperature": 0.0, "avg_logprob": -0.11670399716025905, "compression_ratio": 1.7815533980582525, "no_speech_prob": 0.0001196140656247735}, {"id": 25, "seek": 18224, "start": 201.32000000000002, "end": 209.72, "text": " targets, namely JVM and Android on one side, JavaScript on another side, and finally Kotlin", "tokens": [12911, 11, 20926, 508, 53, 44, 293, 8853, 322, 472, 1252, 11, 15778, 322, 1071, 1252, 11, 293, 2721, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.11670399716025905, "compression_ratio": 1.7815533980582525, "no_speech_prob": 0.0001196140656247735}, {"id": 26, "seek": 20972, "start": 209.72, "end": 220.52, "text": " native on the last side. Kotlin native encompasses iOS and also other less interesting targets.", "tokens": [8470, 322, 264, 1036, 1252, 13, 30123, 5045, 8470, 49866, 17430, 293, 611, 661, 1570, 1880, 12911, 13], "temperature": 0.0, "avg_logprob": -0.13357731875251322, "compression_ratio": 1.5789473684210527, "no_speech_prob": 0.00020447809947654605}, {"id": 27, "seek": 20972, "start": 220.52, "end": 227.4, "text": " Let's face it, Kotlin native exists for the sole purpose of iOS. So, while Kotlin JVM", "tokens": [961, 311, 1851, 309, 11, 30123, 5045, 8470, 8198, 337, 264, 12321, 4334, 295, 17430, 13, 407, 11, 1339, 30123, 5045, 508, 53, 44], "temperature": 0.0, "avg_logprob": -0.13357731875251322, "compression_ratio": 1.5789473684210527, "no_speech_prob": 0.00020447809947654605}, {"id": 28, "seek": 20972, "start": 227.4, "end": 232.4, "text": " supports reflection, Kotlin JS and Kotlin native do not. What is important to understand", "tokens": [9346, 12914, 11, 30123, 5045, 33063, 293, 30123, 5045, 8470, 360, 406, 13, 708, 307, 1021, 281, 1223], "temperature": 0.0, "avg_logprob": -0.13357731875251322, "compression_ratio": 1.5789473684210527, "no_speech_prob": 0.00020447809947654605}, {"id": 29, "seek": 23240, "start": 232.4, "end": 239.76000000000002, "text": " in this sentence is that reflection is not a feature of Kotlin JVM. It's a feature of", "tokens": [294, 341, 8174, 307, 300, 12914, 307, 406, 257, 4111, 295, 30123, 5045, 508, 53, 44, 13, 467, 311, 257, 4111, 295], "temperature": 0.0, "avg_logprob": -0.13637357009084602, "compression_ratio": 1.7236842105263157, "no_speech_prob": 2.2097647160990164e-05}, {"id": 30, "seek": 23240, "start": 239.76000000000002, "end": 248.68, "text": " the JVM that Kotlin uses and builds upon with its own reflection library, but basically", "tokens": [264, 508, 53, 44, 300, 30123, 5045, 4960, 293, 15182, 3564, 365, 1080, 1065, 12914, 6405, 11, 457, 1936], "temperature": 0.0, "avg_logprob": -0.13637357009084602, "compression_ratio": 1.7236842105263157, "no_speech_prob": 2.2097647160990164e-05}, {"id": 31, "seek": 23240, "start": 248.68, "end": 254.72, "text": " it's a feature of the JVM. It's not a feature of the Kotlin language. As such, it is not", "tokens": [309, 311, 257, 4111, 295, 264, 508, 53, 44, 13, 467, 311, 406, 257, 4111, 295, 264, 30123, 5045, 2856, 13, 1018, 1270, 11, 309, 307, 406], "temperature": 0.0, "avg_logprob": -0.13637357009084602, "compression_ratio": 1.7236842105263157, "no_speech_prob": 2.2097647160990164e-05}, {"id": 32, "seek": 25472, "start": 254.72, "end": 262.84, "text": " provided in Kotlin JS and in Kotlin native. So, Kotlin multiplatform being the center", "tokens": [5649, 294, 30123, 5045, 33063, 293, 294, 30123, 5045, 8470, 13, 407, 11, 30123, 5045, 12788, 267, 837, 885, 264, 3056], "temperature": 0.0, "avg_logprob": -0.1295701118364726, "compression_ratio": 1.6625, "no_speech_prob": 4.6112214477034286e-05}, {"id": 33, "seek": 25472, "start": 262.84, "end": 273.84, "text": " of Kotlin JVM, Kotlin JS and Kotlin native, hence, do not support reflection. So, we need", "tokens": [295, 30123, 5045, 508, 53, 44, 11, 30123, 5045, 33063, 293, 30123, 5045, 8470, 11, 16678, 11, 360, 406, 1406, 12914, 13, 407, 11, 321, 643], "temperature": 0.0, "avg_logprob": -0.1295701118364726, "compression_ratio": 1.6625, "no_speech_prob": 4.6112214477034286e-05}, {"id": 34, "seek": 25472, "start": 273.84, "end": 283.68, "text": " to get together and find another way of doing what we usually do with reflection. Maybe if", "tokens": [281, 483, 1214, 293, 915, 1071, 636, 295, 884, 437, 321, 2673, 360, 365, 12914, 13, 2704, 498], "temperature": 0.0, "avg_logprob": -0.1295701118364726, "compression_ratio": 1.6625, "no_speech_prob": 4.6112214477034286e-05}, {"id": 35, "seek": 28368, "start": 283.68, "end": 295.36, "text": " we go back to the definition of what reflection is, we can single out this word. Reflection", "tokens": [321, 352, 646, 281, 264, 7123, 295, 437, 12914, 307, 11, 321, 393, 2167, 484, 341, 1349, 13, 16957, 5450], "temperature": 0.0, "avg_logprob": -0.10537552477708503, "compression_ratio": 1.6280487804878048, "no_speech_prob": 4.900321800960228e-05}, {"id": 36, "seek": 28368, "start": 295.36, "end": 302.68, "text": " is a feature that allows an executing Java program. So, what this means is that reflection", "tokens": [307, 257, 4111, 300, 4045, 364, 32368, 10745, 1461, 13, 407, 11, 437, 341, 1355, 307, 300, 12914], "temperature": 0.0, "avg_logprob": -0.10537552477708503, "compression_ratio": 1.6280487804878048, "no_speech_prob": 4.900321800960228e-05}, {"id": 37, "seek": 28368, "start": 302.68, "end": 310.8, "text": " is a runtime feature. And we all know that what we cannot do at runtime, let's do at", "tokens": [307, 257, 34474, 4111, 13, 400, 321, 439, 458, 300, 437, 321, 2644, 360, 412, 34474, 11, 718, 311, 360, 412], "temperature": 0.0, "avg_logprob": -0.10537552477708503, "compression_ratio": 1.6280487804878048, "no_speech_prob": 4.900321800960228e-05}, {"id": 38, "seek": 31080, "start": 310.8, "end": 318.56, "text": " compile time. What can go wrong, right? So, to do that at compile time, what reflection", "tokens": [31413, 565, 13, 708, 393, 352, 2085, 11, 558, 30, 407, 11, 281, 360, 300, 412, 31413, 565, 11, 437, 12914], "temperature": 0.0, "avg_logprob": -0.08744030528598362, "compression_ratio": 1.542857142857143, "no_speech_prob": 2.680815669009462e-05}, {"id": 39, "seek": 31080, "start": 318.56, "end": 327.68, "text": " does at runtime, we need to add several other pieces of our puzzle. Kotlin Poets is a Kotlin", "tokens": [775, 412, 34474, 11, 321, 643, 281, 909, 2940, 661, 3755, 295, 527, 12805, 13, 30123, 5045, 6165, 1385, 307, 257, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.08744030528598362, "compression_ratio": 1.542857142857143, "no_speech_prob": 2.680815669009462e-05}, {"id": 40, "seek": 31080, "start": 327.68, "end": 336.88, "text": " and Java API for generating Kotlin source files. So, what you could do is generate Kotlin", "tokens": [293, 10745, 9362, 337, 17746, 30123, 5045, 4009, 7098, 13, 407, 11, 437, 291, 727, 360, 307, 8460, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.08744030528598362, "compression_ratio": 1.542857142857143, "no_speech_prob": 2.680815669009462e-05}, {"id": 41, "seek": 33688, "start": 336.88, "end": 347.52, "text": " source files by hand with templates and fill yourself like the vibe of the PHP 2000 error", "tokens": [4009, 7098, 538, 1011, 365, 21165, 293, 2836, 1803, 411, 264, 14606, 295, 264, 47298, 8132, 6713], "temperature": 0.0, "avg_logprob": -0.11770461097596184, "compression_ratio": 1.4835164835164836, "no_speech_prob": 7.449308759532869e-05}, {"id": 42, "seek": 33688, "start": 347.52, "end": 355.6, "text": " where everything was done with templating or you could use a type API that will build", "tokens": [689, 1203, 390, 1096, 365, 9100, 990, 420, 291, 727, 764, 257, 2010, 9362, 300, 486, 1322], "temperature": 0.0, "avg_logprob": -0.11770461097596184, "compression_ratio": 1.4835164835164836, "no_speech_prob": 7.449308759532869e-05}, {"id": 43, "seek": 33688, "start": 355.6, "end": 361.44, "text": " the Kotlin file for you. So, I strongly encourage you to not generate your Kotlin source files", "tokens": [264, 30123, 5045, 3991, 337, 291, 13, 407, 11, 286, 10613, 5373, 291, 281, 406, 8460, 428, 30123, 5045, 4009, 7098], "temperature": 0.0, "avg_logprob": -0.11770461097596184, "compression_ratio": 1.4835164835164836, "no_speech_prob": 7.449308759532869e-05}, {"id": 44, "seek": 36144, "start": 361.44, "end": 368.68, "text": " by hand and use an API such as Kotlin Poets. And here, for example, it's very simple. I", "tokens": [538, 1011, 293, 764, 364, 9362, 1270, 382, 30123, 5045, 6165, 1385, 13, 400, 510, 11, 337, 1365, 11, 309, 311, 588, 2199, 13, 286], "temperature": 0.0, "avg_logprob": -0.15636846463974208, "compression_ratio": 1.4696132596685083, "no_speech_prob": 0.00011982530122622848}, {"id": 45, "seek": 36144, "start": 368.68, "end": 375.64, "text": " create a new function called hello. I declare that it takes a name argument and I add the", "tokens": [1884, 257, 777, 2445, 1219, 7751, 13, 286, 19710, 300, 309, 2516, 257, 1315, 6770, 293, 286, 909, 264], "temperature": 0.0, "avg_logprob": -0.15636846463974208, "compression_ratio": 1.4696132596685083, "no_speech_prob": 0.00011982530122622848}, {"id": 46, "seek": 36144, "start": 375.64, "end": 384.76, "text": " statement println hello name. So, it generates basically this function. Okay. So, that's", "tokens": [5629, 4482, 75, 77, 7751, 1315, 13, 407, 11, 309, 23815, 1936, 341, 2445, 13, 1033, 13, 407, 11, 300, 311], "temperature": 0.0, "avg_logprob": -0.15636846463974208, "compression_ratio": 1.4696132596685083, "no_speech_prob": 0.00011982530122622848}, {"id": 47, "seek": 38476, "start": 384.76, "end": 395.84, "text": " a very important piece of our puzzle but that's by far not the most complicated one. So, the", "tokens": [257, 588, 1021, 2522, 295, 527, 12805, 457, 300, 311, 538, 1400, 406, 264, 881, 6179, 472, 13, 407, 11, 264], "temperature": 0.0, "avg_logprob": -0.12266712972562607, "compression_ratio": 1.5397727272727273, "no_speech_prob": 0.0002245590731035918}, {"id": 48, "seek": 38476, "start": 395.84, "end": 404.96, "text": " next piece of our puzzle is KSP. And KSP stands for Kerbal Space Program. It's a very good", "tokens": [958, 2522, 295, 527, 12805, 307, 591, 27921, 13, 400, 591, 27921, 7382, 337, 20706, 2645, 8705, 8338, 13, 467, 311, 257, 588, 665], "temperature": 0.0, "avg_logprob": -0.12266712972562607, "compression_ratio": 1.5397727272727273, "no_speech_prob": 0.0002245590731035918}, {"id": 49, "seek": 38476, "start": 404.96, "end": 413.48, "text": " video game and the goal of this video game is to build a rocket and explore space. It's", "tokens": [960, 1216, 293, 264, 3387, 295, 341, 960, 1216, 307, 281, 1322, 257, 13012, 293, 6839, 1901, 13, 467, 311], "temperature": 0.0, "avg_logprob": -0.12266712972562607, "compression_ratio": 1.5397727272727273, "no_speech_prob": 0.0002245590731035918}, {"id": 50, "seek": 41348, "start": 413.48, "end": 420.32, "text": " an exploration game. So, it's purposefully undocumented. So, there's no manual for discovery", "tokens": [364, 16197, 1216, 13, 407, 11, 309, 311, 4334, 2277, 40472, 13, 407, 11, 456, 311, 572, 9688, 337, 12114], "temperature": 0.0, "avg_logprob": -0.13226913369220236, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.000770257378462702}, {"id": 51, "seek": 41348, "start": 420.32, "end": 425.32, "text": " and that's the entire game. You need to build your rocket, send your Kerbal to space and", "tokens": [293, 300, 311, 264, 2302, 1216, 13, 509, 643, 281, 1322, 428, 13012, 11, 2845, 428, 20706, 2645, 281, 1901, 293], "temperature": 0.0, "avg_logprob": -0.13226913369220236, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.000770257378462702}, {"id": 52, "seek": 41348, "start": 425.32, "end": 432.56, "text": " see what happened. So, the game is heavily based on trial and error. Not all Kerbal will", "tokens": [536, 437, 2011, 13, 407, 11, 264, 1216, 307, 10950, 2361, 322, 7308, 293, 6713, 13, 1726, 439, 20706, 2645, 486], "temperature": 0.0, "avg_logprob": -0.13226913369220236, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.000770257378462702}, {"id": 53, "seek": 41348, "start": 432.56, "end": 440.36, "text": " survive the journey. You will send them to space and not all Kerbal will come back. But", "tokens": [7867, 264, 4671, 13, 509, 486, 2845, 552, 281, 1901, 293, 406, 439, 20706, 2645, 486, 808, 646, 13, 583], "temperature": 0.0, "avg_logprob": -0.13226913369220236, "compression_ratio": 1.6651162790697673, "no_speech_prob": 0.000770257378462702}, {"id": 54, "seek": 44036, "start": 440.36, "end": 447.96000000000004, "text": " when you do build a rocket and a space station in orbit, you feel a great sense of accomplishment.", "tokens": [562, 291, 360, 1322, 257, 13012, 293, 257, 1901, 5214, 294, 13991, 11, 291, 841, 257, 869, 2020, 295, 29144, 13], "temperature": 0.0, "avg_logprob": -0.13539232334620516, "compression_ratio": 1.4816753926701571, "no_speech_prob": 0.0002397422940703109}, {"id": 55, "seek": 44036, "start": 447.96000000000004, "end": 455.92, "text": " And as it happens, KSP also stands for Kotlin Symbol Processing API. The goal is to build", "tokens": [400, 382, 309, 2314, 11, 591, 27921, 611, 7382, 337, 30123, 5045, 3902, 5612, 31093, 278, 9362, 13, 440, 3387, 307, 281, 1322], "temperature": 0.0, "avg_logprob": -0.13539232334620516, "compression_ratio": 1.4816753926701571, "no_speech_prob": 0.0002397422940703109}, {"id": 56, "seek": 44036, "start": 455.92, "end": 465.92, "text": " a compiler processor, a compiler code processor and it is very, very lightly documented. Let's", "tokens": [257, 31958, 15321, 11, 257, 31958, 3089, 15321, 293, 309, 307, 588, 11, 588, 16695, 23007, 13, 961, 311], "temperature": 0.0, "avg_logprob": -0.13539232334620516, "compression_ratio": 1.4816753926701571, "no_speech_prob": 0.0002397422940703109}, {"id": 57, "seek": 46592, "start": 465.92, "end": 475.04, "text": " be honest, there is no manual for its discovery. You will use trial and error and you will", "tokens": [312, 3245, 11, 456, 307, 572, 9688, 337, 1080, 12114, 13, 509, 486, 764, 7308, 293, 6713, 293, 291, 486], "temperature": 0.0, "avg_logprob": -0.15202637324257504, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0003514723794069141}, {"id": 58, "seek": 46592, "start": 475.04, "end": 483.32, "text": " scream at your screen, yelling at your frustration. Using KSP is a very good exercise in managing", "tokens": [7291, 412, 428, 2568, 11, 18381, 412, 428, 20491, 13, 11142, 591, 27921, 307, 257, 588, 665, 5380, 294, 11642], "temperature": 0.0, "avg_logprob": -0.15202637324257504, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0003514723794069141}, {"id": 59, "seek": 46592, "start": 483.32, "end": 495.72, "text": " your frustration because of its light documentation. But when you finally achieve a functional", "tokens": [428, 20491, 570, 295, 1080, 1442, 14333, 13, 583, 562, 291, 2721, 4584, 257, 11745], "temperature": 0.0, "avg_logprob": -0.15202637324257504, "compression_ratio": 1.546448087431694, "no_speech_prob": 0.0003514723794069141}, {"id": 60, "seek": 49572, "start": 495.72, "end": 502.96000000000004, "text": " Kotlin Symbol processor, you will, just like in the KSP video game, feel a great sense", "tokens": [30123, 5045, 3902, 5612, 15321, 11, 291, 486, 11, 445, 411, 294, 264, 591, 27921, 960, 1216, 11, 841, 257, 869, 2020], "temperature": 0.0, "avg_logprob": -0.133544492049956, "compression_ratio": 1.5146198830409356, "no_speech_prob": 0.00012773831258527935}, {"id": 61, "seek": 49572, "start": 502.96000000000004, "end": 511.88000000000005, "text": " of accomplishment. So, let's see all our pieces of the puzzle. We use KSP to instrument", "tokens": [295, 29144, 13, 407, 11, 718, 311, 536, 439, 527, 3755, 295, 264, 12805, 13, 492, 764, 591, 27921, 281, 7198], "temperature": 0.0, "avg_logprob": -0.133544492049956, "compression_ratio": 1.5146198830409356, "no_speech_prob": 0.00012773831258527935}, {"id": 62, "seek": 49572, "start": 511.88000000000005, "end": 520.0, "text": " codes at compile time. We use Kotlin Poets to generate codes at compile time. And we", "tokens": [14211, 412, 31413, 565, 13, 492, 764, 30123, 5045, 6165, 1385, 281, 8460, 14211, 412, 31413, 565, 13, 400, 321], "temperature": 0.0, "avg_logprob": -0.133544492049956, "compression_ratio": 1.5146198830409356, "no_speech_prob": 0.00012773831258527935}, {"id": 63, "seek": 52000, "start": 520.0, "end": 525.88, "text": " use Kotlin Multiplatform to compile everything for all targets that Kotlin Multiplatform", "tokens": [764, 30123, 5045, 29238, 39975, 837, 281, 31413, 1203, 337, 439, 12911, 300, 30123, 5045, 29238, 39975, 837], "temperature": 0.0, "avg_logprob": -0.13128392262892288, "compression_ratio": 1.7251184834123223, "no_speech_prob": 0.0001679059350863099}, {"id": 64, "seek": 52000, "start": 525.88, "end": 535.36, "text": " supports. So, the idea here is not to allow a code to introspect upon itself at runtime,", "tokens": [9346, 13, 407, 11, 264, 1558, 510, 307, 406, 281, 2089, 257, 3089, 281, 560, 28713, 3564, 2564, 412, 34474, 11], "temperature": 0.0, "avg_logprob": -0.13128392262892288, "compression_ratio": 1.7251184834123223, "no_speech_prob": 0.0001679059350863099}, {"id": 65, "seek": 52000, "start": 535.36, "end": 545.04, "text": " but to generate the information your code needs at compile time. It is a lot more optimized,", "tokens": [457, 281, 8460, 264, 1589, 428, 3089, 2203, 412, 31413, 565, 13, 467, 307, 257, 688, 544, 26941, 11], "temperature": 0.0, "avg_logprob": -0.13128392262892288, "compression_ratio": 1.7251184834123223, "no_speech_prob": 0.0001679059350863099}, {"id": 66, "seek": 52000, "start": 545.04, "end": 549.6, "text": " of course, because you don't have to introspect all the code and all the information you need", "tokens": [295, 1164, 11, 570, 291, 500, 380, 362, 281, 560, 28713, 439, 264, 3089, 293, 439, 264, 1589, 291, 643], "temperature": 0.0, "avg_logprob": -0.13128392262892288, "compression_ratio": 1.7251184834123223, "no_speech_prob": 0.0001679059350863099}, {"id": 67, "seek": 54960, "start": 549.6, "end": 555.76, "text": " are generated for you at compile time, but it is, of course, a lot more complicated.", "tokens": [366, 10833, 337, 291, 412, 31413, 565, 11, 457, 309, 307, 11, 295, 1164, 11, 257, 688, 544, 6179, 13], "temperature": 0.0, "avg_logprob": -0.11079147367766409, "compression_ratio": 1.6878980891719746, "no_speech_prob": 5.2212020818842575e-05}, {"id": 68, "seek": 54960, "start": 555.76, "end": 567.9200000000001, "text": " So, how do you create a mirror generator? So, a mirror is a class that contains reflection", "tokens": [407, 11, 577, 360, 291, 1884, 257, 8013, 19265, 30, 407, 11, 257, 8013, 307, 257, 1508, 300, 8306, 12914], "temperature": 0.0, "avg_logprob": -0.11079147367766409, "compression_ratio": 1.6878980891719746, "no_speech_prob": 5.2212020818842575e-05}, {"id": 69, "seek": 54960, "start": 567.9200000000001, "end": 573.6, "text": " information of another class. So, how would you create a mirror generator? Well, creating", "tokens": [1589, 295, 1071, 1508, 13, 407, 11, 577, 576, 291, 1884, 257, 8013, 19265, 30, 1042, 11, 4084], "temperature": 0.0, "avg_logprob": -0.11079147367766409, "compression_ratio": 1.6878980891719746, "no_speech_prob": 5.2212020818842575e-05}, {"id": 70, "seek": 57360, "start": 573.6, "end": 584.6800000000001, "text": " a symbol processor in KSP is not that complicated. What you need to do is create a symbol processor", "tokens": [257, 5986, 15321, 294, 591, 27921, 307, 406, 300, 6179, 13, 708, 291, 643, 281, 360, 307, 1884, 257, 5986, 15321], "temperature": 0.0, "avg_logprob": -0.14287537716804666, "compression_ratio": 1.4511278195488722, "no_speech_prob": 1.4995483070379123e-05}, {"id": 71, "seek": 57360, "start": 584.6800000000001, "end": 595.08, "text": " class that takes a code generator and a logger as a constructor input. And you will use those", "tokens": [1508, 300, 2516, 257, 3089, 19265, 293, 257, 3565, 1321, 382, 257, 47479, 4846, 13, 400, 291, 486, 764, 729], "temperature": 0.0, "avg_logprob": -0.14287537716804666, "compression_ratio": 1.4511278195488722, "no_speech_prob": 1.4995483070379123e-05}, {"id": 72, "seek": 59508, "start": 595.08, "end": 604.0400000000001, "text": " to, well, generate code and log when things go right or wrong. And then you can get, you", "tokens": [281, 11, 731, 11, 8460, 3089, 293, 3565, 562, 721, 352, 558, 420, 2085, 13, 400, 550, 291, 393, 483, 11, 291], "temperature": 0.0, "avg_logprob": -0.15445049225337923, "compression_ratio": 1.6149068322981366, "no_speech_prob": 0.00011178068234585226}, {"id": 73, "seek": 59508, "start": 604.0400000000001, "end": 613.4000000000001, "text": " can find all symbols that are annotated by a specific annotation and then simply see", "tokens": [393, 915, 439, 16944, 300, 366, 25339, 770, 538, 257, 2685, 48654, 293, 550, 2935, 536], "temperature": 0.0, "avg_logprob": -0.15445049225337923, "compression_ratio": 1.6149068322981366, "no_speech_prob": 0.00011178068234585226}, {"id": 74, "seek": 59508, "start": 613.4000000000001, "end": 620.5200000000001, "text": " what type of symbol that is, and then you can continue to instrument the code starting", "tokens": [437, 2010, 295, 5986, 300, 307, 11, 293, 550, 291, 393, 2354, 281, 7198, 264, 3089, 2891], "temperature": 0.0, "avg_logprob": -0.15445049225337923, "compression_ratio": 1.6149068322981366, "no_speech_prob": 0.00011178068234585226}, {"id": 75, "seek": 62052, "start": 620.52, "end": 628.4399999999999, "text": " with this. So, as you can see here, for example, look at if the symbol annotated is a property", "tokens": [365, 341, 13, 407, 11, 382, 291, 393, 536, 510, 11, 337, 1365, 11, 574, 412, 498, 264, 5986, 25339, 770, 307, 257, 4707], "temperature": 0.0, "avg_logprob": -0.16085321609288045, "compression_ratio": 1.7239263803680982, "no_speech_prob": 0.000102963276731316}, {"id": 76, "seek": 62052, "start": 628.4399999999999, "end": 635.4, "text": " or maybe it's just a property setter because you can, in Kotlin, annotate, get and set properties", "tokens": [420, 1310, 309, 311, 445, 257, 4707, 992, 391, 570, 291, 393, 11, 294, 30123, 5045, 11, 25339, 473, 11, 483, 293, 992, 7221], "temperature": 0.0, "avg_logprob": -0.16085321609288045, "compression_ratio": 1.7239263803680982, "no_speech_prob": 0.000102963276731316}, {"id": 77, "seek": 62052, "start": 635.4, "end": 645.3199999999999, "text": " methods or maybe it's a function declaration or maybe it's a class declaration and there", "tokens": [7150, 420, 1310, 309, 311, 257, 2445, 27606, 420, 1310, 309, 311, 257, 1508, 27606, 293, 456], "temperature": 0.0, "avg_logprob": -0.16085321609288045, "compression_ratio": 1.7239263803680982, "no_speech_prob": 0.000102963276731316}, {"id": 78, "seek": 64532, "start": 645.32, "end": 656.24, "text": " are a lot of other things available. What's interesting in KSP and what I'm not showing", "tokens": [366, 257, 688, 295, 661, 721, 2435, 13, 708, 311, 1880, 294, 591, 27921, 293, 437, 286, 478, 406, 4099], "temperature": 0.0, "avg_logprob": -0.12575684202478288, "compression_ratio": 1.303030303030303, "no_speech_prob": 5.931675696047023e-05}, {"id": 79, "seek": 64532, "start": 656.24, "end": 669.9200000000001, "text": " here in code is that you could ask KSP to give you all symbols that are of a simple,", "tokens": [510, 294, 3089, 307, 300, 291, 727, 1029, 591, 27921, 281, 976, 291, 439, 16944, 300, 366, 295, 257, 2199, 11], "temperature": 0.0, "avg_logprob": -0.12575684202478288, "compression_ratio": 1.303030303030303, "no_speech_prob": 5.931675696047023e-05}, {"id": 80, "seek": 66992, "start": 669.92, "end": 675.52, "text": " of a declaring interface, for example, that are implementing an interface. You don't have,", "tokens": [295, 257, 40374, 9226, 11, 337, 1365, 11, 300, 366, 18114, 364, 9226, 13, 509, 500, 380, 362, 11], "temperature": 0.0, "avg_logprob": -0.11628375182280669, "compression_ratio": 1.5080213903743316, "no_speech_prob": 9.51508991420269e-05}, {"id": 81, "seek": 66992, "start": 675.52, "end": 686.88, "text": " just like APT, you don't have to use annotations. Annotations are a very valid means of conveying", "tokens": [445, 411, 5372, 51, 11, 291, 500, 380, 362, 281, 764, 25339, 763, 13, 1107, 2247, 763, 366, 257, 588, 7363, 1355, 295, 18053, 1840], "temperature": 0.0, "avg_logprob": -0.11628375182280669, "compression_ratio": 1.5080213903743316, "no_speech_prob": 9.51508991420269e-05}, {"id": 82, "seek": 66992, "start": 686.88, "end": 693.4, "text": " the information that the code will be instrumented. But you could with KSP say, okay, give me", "tokens": [264, 1589, 300, 264, 3089, 486, 312, 7198, 292, 13, 583, 291, 727, 365, 591, 27921, 584, 11, 1392, 11, 976, 385], "temperature": 0.0, "avg_logprob": -0.11628375182280669, "compression_ratio": 1.5080213903743316, "no_speech_prob": 9.51508991420269e-05}, {"id": 83, "seek": 69340, "start": 693.4, "end": 700.9599999999999, "text": " all symbols, all classes that implement this interface, for example, or give me all codes", "tokens": [439, 16944, 11, 439, 5359, 300, 4445, 341, 9226, 11, 337, 1365, 11, 420, 976, 385, 439, 14211], "temperature": 0.0, "avg_logprob": -0.13366192106216673, "compression_ratio": 1.5853658536585367, "no_speech_prob": 0.00012567758676595986}, {"id": 84, "seek": 69340, "start": 700.9599999999999, "end": 709.68, "text": " to these methods or these kind of things. And then what you need to do after you have", "tokens": [281, 613, 7150, 420, 613, 733, 295, 721, 13, 400, 550, 437, 291, 643, 281, 360, 934, 291, 362], "temperature": 0.0, "avg_logprob": -0.13366192106216673, "compression_ratio": 1.5853658536585367, "no_speech_prob": 0.00012567758676595986}, {"id": 85, "seek": 69340, "start": 709.68, "end": 718.12, "text": " instrumented the code is to generate your file, the Kotlin source file that you will", "tokens": [7198, 292, 264, 3089, 307, 281, 8460, 428, 3991, 11, 264, 30123, 5045, 4009, 3991, 300, 291, 486], "temperature": 0.0, "avg_logprob": -0.13366192106216673, "compression_ratio": 1.5853658536585367, "no_speech_prob": 0.00012567758676595986}, {"id": 86, "seek": 71812, "start": 718.12, "end": 732.24, "text": " generate. And the good news is that Kotlin Poet does support KSP. So you don't have to", "tokens": [8460, 13, 400, 264, 665, 2583, 307, 300, 30123, 5045, 6165, 302, 775, 1406, 591, 27921, 13, 407, 291, 500, 380, 362, 281], "temperature": 0.0, "avg_logprob": -0.1492037582397461, "compression_ratio": 1.5128205128205128, "no_speech_prob": 9.372951899422333e-05}, {"id": 87, "seek": 71812, "start": 732.24, "end": 741.96, "text": " write a facade between the KSP code generator and the KSP code generator. Kotlin Poet does", "tokens": [2464, 257, 46261, 1296, 264, 591, 27921, 3089, 19265, 293, 264, 591, 27921, 3089, 19265, 13, 30123, 5045, 6165, 302, 775], "temperature": 0.0, "avg_logprob": -0.1492037582397461, "compression_ratio": 1.5128205128205128, "no_speech_prob": 9.372951899422333e-05}, {"id": 88, "seek": 74196, "start": 741.96, "end": 750.12, "text": " support KSP. So it's, as you can see, pretty easy to write your very own code generator", "tokens": [1406, 591, 27921, 13, 407, 309, 311, 11, 382, 291, 393, 536, 11, 1238, 1858, 281, 2464, 428, 588, 1065, 3089, 19265], "temperature": 0.0, "avg_logprob": -0.15236096768765836, "compression_ratio": 1.5406976744186047, "no_speech_prob": 6.060505620553158e-05}, {"id": 89, "seek": 74196, "start": 750.12, "end": 764.72, "text": " with KSP. And then what you need to do is to add your symbol processor to Kotlin, to", "tokens": [365, 591, 27921, 13, 400, 550, 437, 291, 643, 281, 360, 307, 281, 909, 428, 5986, 15321, 281, 30123, 5045, 11, 281], "temperature": 0.0, "avg_logprob": -0.15236096768765836, "compression_ratio": 1.5406976744186047, "no_speech_prob": 6.060505620553158e-05}, {"id": 90, "seek": 74196, "start": 764.72, "end": 771.72, "text": " your Kotlin compilation tool chain with Gradle. And as you can see, it's pretty simple, just", "tokens": [428, 30123, 5045, 40261, 2290, 5021, 365, 16710, 306, 13, 400, 382, 291, 393, 536, 11, 309, 311, 1238, 2199, 11, 445], "temperature": 0.0, "avg_logprob": -0.15236096768765836, "compression_ratio": 1.5406976744186047, "no_speech_prob": 6.060505620553158e-05}, {"id": 91, "seek": 77172, "start": 771.72, "end": 783.64, "text": " apply the plugin. Now, the KSP plugins is versioned using its own version number and", "tokens": [3079, 264, 23407, 13, 823, 11, 264, 591, 27921, 33759, 307, 3037, 292, 1228, 1080, 1065, 3037, 1230, 293], "temperature": 0.0, "avg_logprob": -0.12462021442169839, "compression_ratio": 1.4126984126984128, "no_speech_prob": 0.000639952311757952}, {"id": 92, "seek": 77172, "start": 783.64, "end": 792.9200000000001, "text": " the Kotlin version number. For example, here, it's version 109 of the Kotlin symbol processor", "tokens": [264, 30123, 5045, 3037, 1230, 13, 1171, 1365, 11, 510, 11, 309, 311, 3037, 1266, 24, 295, 264, 30123, 5045, 5986, 15321], "temperature": 0.0, "avg_logprob": -0.12462021442169839, "compression_ratio": 1.4126984126984128, "no_speech_prob": 0.000639952311757952}, {"id": 93, "seek": 79292, "start": 792.92, "end": 804.16, "text": " of KSP and it's version 1810 of the Kotlin language. And at the moment, because the Kotlin", "tokens": [295, 591, 27921, 293, 309, 311, 3037, 2443, 3279, 295, 264, 30123, 5045, 2856, 13, 400, 412, 264, 1623, 11, 570, 264, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.09271907806396484, "compression_ratio": 1.6011560693641618, "no_speech_prob": 5.861330282641575e-05}, {"id": 94, "seek": 79292, "start": 804.16, "end": 812.36, "text": " compiler plugin API keeps changing and is not stable and is not documented, KSP depends", "tokens": [31958, 23407, 9362, 5965, 4473, 293, 307, 406, 8351, 293, 307, 406, 23007, 11, 591, 27921, 5946], "temperature": 0.0, "avg_logprob": -0.09271907806396484, "compression_ratio": 1.6011560693641618, "no_speech_prob": 5.861330282641575e-05}, {"id": 95, "seek": 79292, "start": 812.36, "end": 821.56, "text": " on a very specific version of the Kotlin language. So you need to upgrade KSP with the same Kotlin", "tokens": [322, 257, 588, 2685, 3037, 295, 264, 30123, 5045, 2856, 13, 407, 291, 643, 281, 11484, 591, 27921, 365, 264, 912, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.09271907806396484, "compression_ratio": 1.6011560693641618, "no_speech_prob": 5.861330282641575e-05}, {"id": 96, "seek": 82156, "start": 821.56, "end": 830.3599999999999, "text": " version that you need to upgrade Kotlin. And that's kind of a bummer because you need to", "tokens": [3037, 300, 291, 643, 281, 11484, 30123, 5045, 13, 400, 300, 311, 733, 295, 257, 13309, 936, 570, 291, 643, 281], "temperature": 0.0, "avg_logprob": -0.1442495346069336, "compression_ratio": 1.6097560975609757, "no_speech_prob": 0.000123812016681768}, {"id": 97, "seek": 82156, "start": 830.3599999999999, "end": 839.2399999999999, "text": " wait when a new Kotlin language comes up, you need to wait for KSP to be compatible with", "tokens": [1699, 562, 257, 777, 30123, 5045, 2856, 1487, 493, 11, 291, 643, 281, 1699, 337, 591, 27921, 281, 312, 18218, 365], "temperature": 0.0, "avg_logprob": -0.1442495346069336, "compression_ratio": 1.6097560975609757, "no_speech_prob": 0.000123812016681768}, {"id": 98, "seek": 82156, "start": 839.2399999999999, "end": 845.4399999999999, "text": " this new version, even for minor version. If you use the wrong minor version, KSP will", "tokens": [341, 777, 3037, 11, 754, 337, 6696, 3037, 13, 759, 291, 764, 264, 2085, 6696, 3037, 11, 591, 27921, 486], "temperature": 0.0, "avg_logprob": -0.1442495346069336, "compression_ratio": 1.6097560975609757, "no_speech_prob": 0.000123812016681768}, {"id": 99, "seek": 84544, "start": 845.44, "end": 851.96, "text": " warn you that it is not compatible with this minor version. And once again, that's because", "tokens": [12286, 291, 300, 309, 307, 406, 18218, 365, 341, 6696, 3037, 13, 400, 1564, 797, 11, 300, 311, 570], "temperature": 0.0, "avg_logprob": -0.10338740715613733, "compression_ratio": 1.5197740112994351, "no_speech_prob": 2.8320568162598647e-05}, {"id": 100, "seek": 84544, "start": 851.96, "end": 859.32, "text": " the Kotlin compiler plugin API isn't stable and that KSP is using internal function and", "tokens": [264, 30123, 5045, 31958, 23407, 9362, 1943, 380, 8351, 293, 300, 591, 27921, 307, 1228, 6920, 2445, 293], "temperature": 0.0, "avg_logprob": -0.10338740715613733, "compression_ratio": 1.5197740112994351, "no_speech_prob": 2.8320568162598647e-05}, {"id": 101, "seek": 84544, "start": 859.32, "end": 868.36, "text": " features of the Kotlin compiler plugin. Then, of course, you probably need to add your own", "tokens": [4122, 295, 264, 30123, 5045, 31958, 23407, 13, 1396, 11, 295, 1164, 11, 291, 1391, 643, 281, 909, 428, 1065], "temperature": 0.0, "avg_logprob": -0.10338740715613733, "compression_ratio": 1.5197740112994351, "no_speech_prob": 2.8320568162598647e-05}, {"id": 102, "seek": 86836, "start": 868.36, "end": 875.64, "text": " runtime because when you generate code, you will probably need to provide with the generated", "tokens": [34474, 570, 562, 291, 8460, 3089, 11, 291, 486, 1391, 643, 281, 2893, 365, 264, 10833], "temperature": 0.0, "avg_logprob": -0.14608491750863883, "compression_ratio": 1.5930232558139534, "no_speech_prob": 5.683871859218925e-05}, {"id": 103, "seek": 86836, "start": 875.64, "end": 884.0, "text": " code a runtime of your own. And then you need to declare that your KSP code processor will", "tokens": [3089, 257, 34474, 295, 428, 1065, 13, 400, 550, 291, 643, 281, 19710, 300, 428, 591, 27921, 3089, 15321, 486], "temperature": 0.0, "avg_logprob": -0.14608491750863883, "compression_ratio": 1.5930232558139534, "no_speech_prob": 5.683871859218925e-05}, {"id": 104, "seek": 86836, "start": 884.0, "end": 893.36, "text": " run on this code. Now, as you can see, it is declared differently than with regular Kotlin", "tokens": [1190, 322, 341, 3089, 13, 823, 11, 382, 291, 393, 536, 11, 309, 307, 15489, 7614, 813, 365, 3890, 30123, 5045], "temperature": 0.0, "avg_logprob": -0.14608491750863883, "compression_ratio": 1.5930232558139534, "no_speech_prob": 5.683871859218925e-05}, {"id": 105, "seek": 89336, "start": 893.36, "end": 901.84, "text": " dependencies because at the moment, KSP doesn't interact with the Kotlin Gradle compiler with", "tokens": [36606, 570, 412, 264, 1623, 11, 591, 27921, 1177, 380, 4648, 365, 264, 30123, 5045, 16710, 306, 31958, 365], "temperature": 0.0, "avg_logprob": -0.17674213906993036, "compression_ratio": 1.5511363636363635, "no_speech_prob": 4.6770728658884764e-05}, {"id": 106, "seek": 89336, "start": 901.84, "end": 911.6, "text": " the Kotlin Gradle DSL. So you have to use this word, KSP common main metadata configuration", "tokens": [264, 30123, 5045, 16710, 306, 15816, 43, 13, 407, 291, 362, 281, 764, 341, 1349, 11, 591, 27921, 2689, 2135, 26603, 11694], "temperature": 0.0, "avg_logprob": -0.17674213906993036, "compression_ratio": 1.5511363636363635, "no_speech_prob": 4.6770728658884764e-05}, {"id": 107, "seek": 89336, "start": 911.6, "end": 922.0, "text": " in Gradle dependencies. So what can you do with this technology? Well, for the last two", "tokens": [294, 16710, 306, 36606, 13, 407, 437, 393, 291, 360, 365, 341, 2899, 30, 1042, 11, 337, 264, 1036, 732], "temperature": 0.0, "avg_logprob": -0.17674213906993036, "compression_ratio": 1.5511363636363635, "no_speech_prob": 4.6770728658884764e-05}, {"id": 108, "seek": 92200, "start": 922.0, "end": 929.68, "text": " years, I have been developing an example because it was needed for the company I worked at", "tokens": [924, 11, 286, 362, 668, 6416, 364, 1365, 570, 309, 390, 2978, 337, 264, 2237, 286, 2732, 412], "temperature": 0.0, "avg_logprob": -0.17267688352670243, "compression_ratio": 1.6352941176470588, "no_speech_prob": 8.604708273196593e-05}, {"id": 109, "seek": 92200, "start": 929.68, "end": 939.92, "text": " and that was mocking. So what we have here is a class that works with Kotlin multi-platform", "tokens": [293, 300, 390, 49792, 13, 407, 437, 321, 362, 510, 307, 257, 1508, 300, 1985, 365, 30123, 5045, 4825, 12, 39975, 837], "temperature": 0.0, "avg_logprob": -0.17267688352670243, "compression_ratio": 1.6352941176470588, "no_speech_prob": 8.604708273196593e-05}, {"id": 110, "seek": 92200, "start": 939.92, "end": 949.08, "text": " test and that works with all targets of Kotlin and that generates mocks at compile time because", "tokens": [1500, 293, 300, 1985, 365, 439, 12911, 295, 30123, 5045, 293, 300, 23815, 705, 2761, 412, 31413, 565, 570], "temperature": 0.0, "avg_logprob": -0.17267688352670243, "compression_ratio": 1.6352941176470588, "no_speech_prob": 8.604708273196593e-05}, {"id": 111, "seek": 94908, "start": 949.08, "end": 961.32, "text": " mocking in, for example, mock K or with mockito, mocking uses the proxy reflection feature of", "tokens": [49792, 294, 11, 337, 1365, 11, 17362, 591, 420, 365, 705, 547, 3528, 11, 49792, 4960, 264, 29690, 12914, 4111, 295], "temperature": 0.0, "avg_logprob": -0.22360461841930043, "compression_ratio": 1.391304347826087, "no_speech_prob": 0.0001210180125781335}, {"id": 112, "seek": 94908, "start": 961.32, "end": 970.72, "text": " the JVM which does not exist in Kotlin multi-platform. So, for example, here we say we want a view", "tokens": [264, 508, 53, 44, 597, 775, 406, 2514, 294, 30123, 5045, 4825, 12, 39975, 837, 13, 407, 11, 337, 1365, 11, 510, 321, 584, 321, 528, 257, 1910], "temperature": 0.0, "avg_logprob": -0.22360461841930043, "compression_ratio": 1.391304347826087, "no_speech_prob": 0.0001210180125781335}, {"id": 113, "seek": 97072, "start": 970.72, "end": 979.64, "text": " that will be mocked. So view is an interface and it will be generated by the mock AMP compiler", "tokens": [300, 486, 312, 17362, 292, 13, 407, 1910, 307, 364, 9226, 293, 309, 486, 312, 10833, 538, 264, 705, 547, 31616, 31958], "temperature": 0.0, "avg_logprob": -0.18340784973568386, "compression_ratio": 1.5852272727272727, "no_speech_prob": 7.046167593216524e-05}, {"id": 114, "seek": 97072, "start": 979.64, "end": 985.64, "text": " plugin. We want a fake and a fake is a data class and we want a data class that filled", "tokens": [23407, 13, 492, 528, 257, 7592, 293, 257, 7592, 307, 257, 1412, 1508, 293, 321, 528, 257, 1412, 1508, 300, 6412], "temperature": 0.0, "avg_logprob": -0.18340784973568386, "compression_ratio": 1.5852272727272727, "no_speech_prob": 7.046167593216524e-05}, {"id": 115, "seek": 97072, "start": 985.64, "end": 992.5600000000001, "text": " with fake values, empty string, zeroed integers and all those kind of stuff. We want a controller", "tokens": [365, 7592, 4190, 11, 6707, 6798, 11, 4018, 292, 41674, 293, 439, 729, 733, 295, 1507, 13, 492, 528, 257, 10561], "temperature": 0.0, "avg_logprob": -0.18340784973568386, "compression_ratio": 1.5852272727272727, "no_speech_prob": 7.046167593216524e-05}, {"id": 116, "seek": 99256, "start": 992.56, "end": 1005.4399999999999, "text": " that uses both a fake and a mock. We want to define the behavior of our mock. For example,", "tokens": [300, 4960, 1293, 257, 7592, 293, 257, 17362, 13, 492, 528, 281, 6964, 264, 5223, 295, 527, 17362, 13, 1171, 1365, 11], "temperature": 0.0, "avg_logprob": -0.1811849369722254, "compression_ratio": 1.4206349206349207, "no_speech_prob": 0.00020206079352647066}, {"id": 117, "seek": 99256, "start": 1005.4399999999999, "end": 1014.0799999999999, "text": " here I say that in the interface view in my mock, in my view mock, if I call view.render", "tokens": [510, 286, 584, 300, 294, 264, 9226, 1910, 294, 452, 17362, 11, 294, 452, 1910, 17362, 11, 498, 286, 818, 1910, 13, 13292], "temperature": 0.0, "avg_logprob": -0.1811849369722254, "compression_ratio": 1.4206349206349207, "no_speech_prob": 0.00020206079352647066}, {"id": 118, "seek": 101408, "start": 1014.08, "end": 1023.0, "text": " with any argument it will return true and I want to be able to verify that a mocked", "tokens": [365, 604, 6770, 309, 486, 2736, 2074, 293, 286, 528, 281, 312, 1075, 281, 16888, 300, 257, 17362, 292], "temperature": 0.0, "avg_logprob": -0.1311561122085109, "compression_ratio": 1.4772727272727273, "no_speech_prob": 7.36109068384394e-05}, {"id": 119, "seek": 101408, "start": 1023.0, "end": 1032.6000000000001, "text": " has been called with a specific data in this instance model. So all that and all that DSL", "tokens": [575, 668, 1219, 365, 257, 2685, 1412, 294, 341, 5197, 2316, 13, 407, 439, 300, 293, 439, 300, 15816, 43], "temperature": 0.0, "avg_logprob": -0.1311561122085109, "compression_ratio": 1.4772727272727273, "no_speech_prob": 7.36109068384394e-05}, {"id": 120, "seek": 101408, "start": 1032.6000000000001, "end": 1040.4, "text": " is possible thanks to KSP and Kotlin Poets and the ability to generate code at compile", "tokens": [307, 1944, 3231, 281, 591, 27921, 293, 30123, 5045, 6165, 1385, 293, 264, 3485, 281, 8460, 3089, 412, 31413], "temperature": 0.0, "avg_logprob": -0.1311561122085109, "compression_ratio": 1.4772727272727273, "no_speech_prob": 7.36109068384394e-05}, {"id": 121, "seek": 104040, "start": 1040.4, "end": 1047.48, "text": " time. So what was previously unavailable to Kotlin multi-platform because reflection wasn't", "tokens": [565, 13, 407, 437, 390, 8046, 36541, 32699, 281, 30123, 5045, 4825, 12, 39975, 837, 570, 12914, 2067, 380], "temperature": 0.0, "avg_logprob": -0.15710514694897096, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.0001170932300738059}, {"id": 122, "seek": 104040, "start": 1047.48, "end": 1056.48, "text": " available is now available thanks to code generation. And by the way, if you're interested", "tokens": [2435, 307, 586, 2435, 3231, 281, 3089, 5125, 13, 400, 538, 264, 636, 11, 498, 291, 434, 3102], "temperature": 0.0, "avg_logprob": -0.15710514694897096, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.0001170932300738059}, {"id": 123, "seek": 104040, "start": 1056.48, "end": 1065.24, "text": " in this in mocking for Kotlin multi-platform you can use mock AMP which is a library that", "tokens": [294, 341, 294, 49792, 337, 30123, 5045, 4825, 12, 39975, 837, 291, 393, 764, 705, 547, 31616, 597, 307, 257, 6405, 300], "temperature": 0.0, "avg_logprob": -0.15710514694897096, "compression_ratio": 1.5454545454545454, "no_speech_prob": 0.0001170932300738059}, {"id": 124, "seek": 106524, "start": 1065.24, "end": 1073.16, "text": " we built with Deezer and this library, this testing library is used in production meaning", "tokens": [321, 3094, 365, 1346, 4371, 260, 293, 341, 6405, 11, 341, 4997, 6405, 307, 1143, 294, 4265, 3620], "temperature": 0.0, "avg_logprob": -0.17981034687587194, "compression_ratio": 1.5406976744186047, "no_speech_prob": 4.902038926957175e-05}, {"id": 125, "seek": 106524, "start": 1073.16, "end": 1082.96, "text": " in test production at Deezer, almost all the multi-platform tests at Deezer uses this mock", "tokens": [294, 1500, 4265, 412, 1346, 4371, 260, 11, 1920, 439, 264, 4825, 12, 39975, 837, 6921, 412, 1346, 4371, 260, 4960, 341, 705, 547], "temperature": 0.0, "avg_logprob": -0.17981034687587194, "compression_ratio": 1.5406976744186047, "no_speech_prob": 4.902038926957175e-05}, {"id": 126, "seek": 106524, "start": 1082.96, "end": 1093.2, "text": " AMP library that we developed together. So there's a problem with KSP. If we go back", "tokens": [31616, 6405, 300, 321, 4743, 1214, 13, 407, 456, 311, 257, 1154, 365, 591, 27921, 13, 759, 321, 352, 646], "temperature": 0.0, "avg_logprob": -0.17981034687587194, "compression_ratio": 1.5406976744186047, "no_speech_prob": 4.902038926957175e-05}, {"id": 127, "seek": 109320, "start": 1093.2, "end": 1103.6000000000001, "text": " to the example I just gave you, this method uses this inject mocks function, this class", "tokens": [281, 264, 1365, 286, 445, 2729, 291, 11, 341, 3170, 4960, 341, 10711, 705, 2761, 2445, 11, 341, 1508], "temperature": 0.0, "avg_logprob": -0.1720512777134992, "compression_ratio": 1.8104575163398693, "no_speech_prob": 0.00015036322292871773}, {"id": 128, "seek": 109320, "start": 1103.6000000000001, "end": 1111.0, "text": " uses inject mocks. And the fact is that inject mocks is precisely the function that is generated", "tokens": [4960, 10711, 705, 2761, 13, 400, 264, 1186, 307, 300, 10711, 705, 2761, 307, 13402, 264, 2445, 300, 307, 10833], "temperature": 0.0, "avg_logprob": -0.1720512777134992, "compression_ratio": 1.8104575163398693, "no_speech_prob": 0.00015036322292871773}, {"id": 129, "seek": 109320, "start": 1111.0, "end": 1117.8400000000001, "text": " for this class. Because this class, we can see here, because this class has atmock annotated", "tokens": [337, 341, 1508, 13, 1436, 341, 1508, 11, 321, 393, 536, 510, 11, 570, 341, 1508, 575, 412, 76, 1560, 25339, 770], "temperature": 0.0, "avg_logprob": -0.1720512777134992, "compression_ratio": 1.8104575163398693, "no_speech_prob": 0.00015036322292871773}, {"id": 130, "seek": 111784, "start": 1117.84, "end": 1125.1599999999999, "text": " properties and at fake annotated properties, then an inject mocks function will be generated", "tokens": [7221, 293, 412, 7592, 25339, 770, 7221, 11, 550, 364, 10711, 705, 2761, 2445, 486, 312, 10833], "temperature": 0.0, "avg_logprob": -0.1558277534716057, "compression_ratio": 1.5433526011560694, "no_speech_prob": 8.697276643943042e-05}, {"id": 131, "seek": 111784, "start": 1125.1599999999999, "end": 1135.8, "text": " by the mock AMP compiler plug-in slash symbol processor. And when you load the project,", "tokens": [538, 264, 705, 547, 31616, 31958, 5452, 12, 259, 17330, 5986, 15321, 13, 400, 562, 291, 3677, 264, 1716, 11], "temperature": 0.0, "avg_logprob": -0.1558277534716057, "compression_ratio": 1.5433526011560694, "no_speech_prob": 8.697276643943042e-05}, {"id": 132, "seek": 111784, "start": 1135.8, "end": 1142.52, "text": " the Deezer project or any project that uses this system, well, inject mock is an error", "tokens": [264, 1346, 4371, 260, 1716, 420, 604, 1716, 300, 4960, 341, 1185, 11, 731, 11, 10711, 705, 547, 307, 364, 6713], "temperature": 0.0, "avg_logprob": -0.1558277534716057, "compression_ratio": 1.5433526011560694, "no_speech_prob": 8.697276643943042e-05}, {"id": 133, "seek": 114252, "start": 1142.52, "end": 1147.9, "text": " because it hasn't been generated yet. So idea will show you an error saying, okay, this", "tokens": [570, 309, 6132, 380, 668, 10833, 1939, 13, 407, 1558, 486, 855, 291, 364, 6713, 1566, 11, 1392, 11, 341], "temperature": 0.0, "avg_logprob": -0.14642520745595297, "compression_ratio": 1.6045454545454545, "no_speech_prob": 0.0003673814353533089}, {"id": 134, "seek": 114252, "start": 1147.9, "end": 1153.72, "text": " function just doesn't exist. I don't know what you are talking about. So you need to", "tokens": [2445, 445, 1177, 380, 2514, 13, 286, 500, 380, 458, 437, 291, 366, 1417, 466, 13, 407, 291, 643, 281], "temperature": 0.0, "avg_logprob": -0.14642520745595297, "compression_ratio": 1.6045454545454545, "no_speech_prob": 0.0003673814353533089}, {"id": 135, "seek": 114252, "start": 1153.72, "end": 1163.48, "text": " either build the project or you need to say to, you need to say to Gradle to generate and", "tokens": [2139, 1322, 264, 1716, 420, 291, 643, 281, 584, 281, 11, 291, 643, 281, 584, 281, 16710, 306, 281, 8460, 293], "temperature": 0.0, "avg_logprob": -0.14642520745595297, "compression_ratio": 1.6045454545454545, "no_speech_prob": 0.0003673814353533089}, {"id": 136, "seek": 114252, "start": 1163.48, "end": 1171.08, "text": " run KSP. And at the moment, there is no way around that. And that's because KSP has a very", "tokens": [1190, 591, 27921, 13, 400, 412, 264, 1623, 11, 456, 307, 572, 636, 926, 300, 13, 400, 300, 311, 570, 591, 27921, 575, 257, 588], "temperature": 0.0, "avg_logprob": -0.14642520745595297, "compression_ratio": 1.6045454545454545, "no_speech_prob": 0.0003673814353533089}, {"id": 137, "seek": 117108, "start": 1171.08, "end": 1177.8, "text": " important limitation. It treats the source code it is instrumenting as read only. There", "tokens": [1021, 27432, 13, 467, 19566, 264, 4009, 3089, 309, 307, 7198, 278, 382, 1401, 787, 13, 821], "temperature": 0.0, "avg_logprob": -0.13069612839642694, "compression_ratio": 1.5662650602409638, "no_speech_prob": 9.40810059546493e-05}, {"id": 138, "seek": 117108, "start": 1177.8, "end": 1186.0, "text": " is no way with KSP to add properties or to modify a symbol that you are instrumenting.", "tokens": [307, 572, 636, 365, 591, 27921, 281, 909, 7221, 420, 281, 16927, 257, 5986, 300, 291, 366, 7198, 278, 13], "temperature": 0.0, "avg_logprob": -0.13069612839642694, "compression_ratio": 1.5662650602409638, "no_speech_prob": 9.40810059546493e-05}, {"id": 139, "seek": 117108, "start": 1186.0, "end": 1194.9199999999998, "text": " So this my test class, there's no way with KSP that I can add a property or I can add", "tokens": [407, 341, 452, 1500, 1508, 11, 456, 311, 572, 636, 365, 591, 27921, 300, 286, 393, 909, 257, 4707, 420, 286, 393, 909], "temperature": 0.0, "avg_logprob": -0.13069612839642694, "compression_ratio": 1.5662650602409638, "no_speech_prob": 9.40810059546493e-05}, {"id": 140, "seek": 119492, "start": 1194.92, "end": 1201.68, "text": " an annotation and all that. And since there is no reflection in Kotlin multiplatform, there", "tokens": [364, 48654, 293, 439, 300, 13, 400, 1670, 456, 307, 572, 12914, 294, 30123, 5045, 12788, 267, 837, 11, 456], "temperature": 0.0, "avg_logprob": -0.1514101995938066, "compression_ratio": 1.6303030303030304, "no_speech_prob": 7.288279448403046e-05}, {"id": 141, "seek": 119492, "start": 1201.68, "end": 1211.76, "text": " is no way to find a class that exists, but there's no class dot with name. So that means", "tokens": [307, 572, 636, 281, 915, 257, 1508, 300, 8198, 11, 457, 456, 311, 572, 1508, 5893, 365, 1315, 13, 407, 300, 1355], "temperature": 0.0, "avg_logprob": -0.1514101995938066, "compression_ratio": 1.6303030303030304, "no_speech_prob": 7.288279448403046e-05}, {"id": 142, "seek": 119492, "start": 1211.76, "end": 1219.68, "text": " that you need in your code to use the code that is generated and that code doesn't exist", "tokens": [300, 291, 643, 294, 428, 3089, 281, 764, 264, 3089, 300, 307, 10833, 293, 300, 3089, 1177, 380, 2514], "temperature": 0.0, "avg_logprob": -0.1514101995938066, "compression_ratio": 1.6303030303030304, "no_speech_prob": 7.288279448403046e-05}, {"id": 143, "seek": 121968, "start": 1219.68, "end": 1229.8400000000001, "text": " unless you generate it. And that's a small price to pay to use KSP. So why would you", "tokens": [5969, 291, 8460, 309, 13, 400, 300, 311, 257, 1359, 3218, 281, 1689, 281, 764, 591, 27921, 13, 407, 983, 576, 291], "temperature": 0.0, "avg_logprob": -0.09927769096530213, "compression_ratio": 1.2554744525547445, "no_speech_prob": 3.292210749350488e-05}, {"id": 144, "seek": 121968, "start": 1229.8400000000001, "end": 1237.68, "text": " use KSP as opposed to writing a full-fledged Kotlin compiler plugin? First and foremost", "tokens": [764, 591, 27921, 382, 8851, 281, 3579, 257, 1577, 12, 69, 1493, 3004, 30123, 5045, 31958, 23407, 30, 2386, 293, 18864], "temperature": 0.0, "avg_logprob": -0.09927769096530213, "compression_ratio": 1.2554744525547445, "no_speech_prob": 3.292210749350488e-05}, {"id": 145, "seek": 123768, "start": 1237.68, "end": 1252.4, "text": " because KSP provides a kind of stable API. The API changes, but it follows a depreciation", "tokens": [570, 591, 27921, 6417, 257, 733, 295, 8351, 9362, 13, 440, 9362, 2962, 11, 457, 309, 10002, 257, 40609, 399], "temperature": 0.0, "avg_logprob": -0.1927903095881144, "compression_ratio": 1.4696132596685083, "no_speech_prob": 5.765011883340776e-05}, {"id": 146, "seek": 123768, "start": 1252.4, "end": 1260.8, "text": " cycle. And the API of KSP is supposed to be public, so they treat it with respect of a", "tokens": [6586, 13, 400, 264, 9362, 295, 591, 27921, 307, 3442, 281, 312, 1908, 11, 370, 436, 2387, 309, 365, 3104, 295, 257], "temperature": 0.0, "avg_logprob": -0.1927903095881144, "compression_ratio": 1.4696132596685083, "no_speech_prob": 5.765011883340776e-05}, {"id": 147, "seek": 123768, "start": 1260.8, "end": 1267.6000000000001, "text": " public API. And also because when you use KSP, you don't have to write a compiler plugin.", "tokens": [1908, 9362, 13, 400, 611, 570, 562, 291, 764, 591, 27921, 11, 291, 500, 380, 362, 281, 2464, 257, 31958, 23407, 13], "temperature": 0.0, "avg_logprob": -0.1927903095881144, "compression_ratio": 1.4696132596685083, "no_speech_prob": 5.765011883340776e-05}, {"id": 148, "seek": 126760, "start": 1267.6, "end": 1276.32, "text": " Writing a compiler plugin with Kotlin just not only means that you will have to understand", "tokens": [32774, 257, 31958, 23407, 365, 30123, 5045, 445, 406, 787, 1355, 300, 291, 486, 362, 281, 1223], "temperature": 0.0, "avg_logprob": -0.15578004121780395, "compression_ratio": 1.854922279792746, "no_speech_prob": 0.0001231403584824875}, {"id": 149, "seek": 126760, "start": 1276.32, "end": 1283.24, "text": " the inner components of the Kotlin compiler, which are absolutely not documented. KSP is", "tokens": [264, 7284, 6677, 295, 264, 30123, 5045, 31958, 11, 597, 366, 3122, 406, 23007, 13, 591, 27921, 307], "temperature": 0.0, "avg_logprob": -0.15578004121780395, "compression_ratio": 1.854922279792746, "no_speech_prob": 0.0001231403584824875}, {"id": 150, "seek": 126760, "start": 1283.24, "end": 1288.28, "text": " a little bit documented. The Kotlin compiler internals are just not documented, but it", "tokens": [257, 707, 857, 23007, 13, 440, 30123, 5045, 31958, 2154, 1124, 366, 445, 406, 23007, 11, 457, 309], "temperature": 0.0, "avg_logprob": -0.15578004121780395, "compression_ratio": 1.854922279792746, "no_speech_prob": 0.0001231403584824875}, {"id": 151, "seek": 126760, "start": 1288.28, "end": 1293.1599999999999, "text": " also means that you will have to handle compiler integration and gradle integration. So you", "tokens": [611, 1355, 300, 291, 486, 362, 281, 4813, 31958, 10980, 293, 2771, 306, 10980, 13, 407, 291], "temperature": 0.0, "avg_logprob": -0.15578004121780395, "compression_ratio": 1.854922279792746, "no_speech_prob": 0.0001231403584824875}, {"id": 152, "seek": 129316, "start": 1293.16, "end": 1297.88, "text": " will have to add your own gradle plugin, you will have to add your own compiler plugin,", "tokens": [486, 362, 281, 909, 428, 1065, 2771, 306, 23407, 11, 291, 486, 362, 281, 909, 428, 1065, 31958, 23407, 11], "temperature": 0.0, "avg_logprob": -0.1350748652503604, "compression_ratio": 1.6442307692307692, "no_speech_prob": 8.383730164496228e-05}, {"id": 153, "seek": 129316, "start": 1297.88, "end": 1305.68, "text": " and it becomes a very complicated endeavor. And finally, because for code-generating", "tokens": [293, 309, 3643, 257, 588, 6179, 34975, 13, 400, 2721, 11, 570, 337, 3089, 12, 21848, 990], "temperature": 0.0, "avg_logprob": -0.1350748652503604, "compression_ratio": 1.6442307692307692, "no_speech_prob": 8.383730164496228e-05}, {"id": 154, "seek": 129316, "start": 1305.68, "end": 1315.5400000000002, "text": " use cases, KSP remains a lot simpler than writing a compiler plugin, which once again", "tokens": [764, 3331, 11, 591, 27921, 7023, 257, 688, 18587, 813, 3579, 257, 31958, 23407, 11, 597, 1564, 797], "temperature": 0.0, "avg_logprob": -0.1350748652503604, "compression_ratio": 1.6442307692307692, "no_speech_prob": 8.383730164496228e-05}, {"id": 155, "seek": 129316, "start": 1315.5400000000002, "end": 1320.6000000000001, "text": " is done completely in the dark. You won't have any support if you try to write your", "tokens": [307, 1096, 2584, 294, 264, 2877, 13, 509, 1582, 380, 362, 604, 1406, 498, 291, 853, 281, 2464, 428], "temperature": 0.0, "avg_logprob": -0.1350748652503604, "compression_ratio": 1.6442307692307692, "no_speech_prob": 8.383730164496228e-05}, {"id": 156, "seek": 132060, "start": 1320.6, "end": 1330.7199999999998, "text": " own compiler plugin. So using KSP, KSP is still a very, very important tool in the grand open", "tokens": [1065, 31958, 23407, 13, 407, 1228, 591, 27921, 11, 591, 27921, 307, 920, 257, 588, 11, 588, 1021, 2290, 294, 264, 2697, 1269], "temperature": 0.0, "avg_logprob": -0.17614261418172758, "compression_ratio": 1.5511363636363635, "no_speech_prob": 6.071695315768011e-05}, {"id": 157, "seek": 132060, "start": 1330.7199999999998, "end": 1338.6399999999999, "text": " source library of Kotlin multiplatform project. A lot of Kotlin multiplatform libraries use", "tokens": [4009, 6405, 295, 30123, 5045, 12788, 267, 837, 1716, 13, 316, 688, 295, 30123, 5045, 12788, 267, 837, 15148, 764], "temperature": 0.0, "avg_logprob": -0.17614261418172758, "compression_ratio": 1.5511363636363635, "no_speech_prob": 6.071695315768011e-05}, {"id": 158, "seek": 132060, "start": 1338.6399999999999, "end": 1350.52, "text": " KSP now, and I encourage you to contribute to that grand library. And that's it for me.", "tokens": [591, 27921, 586, 11, 293, 286, 5373, 291, 281, 10586, 281, 300, 2697, 6405, 13, 400, 300, 311, 309, 337, 385, 13], "temperature": 0.0, "avg_logprob": -0.17614261418172758, "compression_ratio": 1.5511363636363635, "no_speech_prob": 6.071695315768011e-05}, {"id": 159, "seek": 135052, "start": 1350.52, "end": 1357.32, "text": " Just want to say that I represent here coding coders. We are certified for our Kotlin training,", "tokens": [1449, 528, 281, 584, 300, 286, 2906, 510, 17720, 17656, 433, 13, 492, 366, 18580, 337, 527, 30123, 5045, 3097, 11], "temperature": 0.0, "avg_logprob": -0.14383541640414987, "compression_ratio": 1.6866359447004609, "no_speech_prob": 0.00011253548291279003}, {"id": 160, "seek": 135052, "start": 1357.32, "end": 1364.96, "text": " so if you want Kotlin multiplatform training, be sure to contact us. We have lots of libraries", "tokens": [370, 498, 291, 528, 30123, 5045, 12788, 267, 837, 3097, 11, 312, 988, 281, 3385, 505, 13, 492, 362, 3195, 295, 15148], "temperature": 0.0, "avg_logprob": -0.14383541640414987, "compression_ratio": 1.6866359447004609, "no_speech_prob": 0.00011253548291279003}, {"id": 161, "seek": 135052, "start": 1364.96, "end": 1371.8799999999999, "text": " that are open source. Romain with the next talk is going to present you another one of", "tokens": [300, 366, 1269, 4009, 13, 10141, 491, 365, 264, 958, 751, 307, 516, 281, 1974, 291, 1071, 472, 295], "temperature": 0.0, "avg_logprob": -0.14383541640414987, "compression_ratio": 1.6866359447004609, "no_speech_prob": 0.00011253548291279003}, {"id": 162, "seek": 135052, "start": 1371.8799999999999, "end": 1378.76, "text": " them, and we like to do our open source work with Kotlin multiplatform for every target.", "tokens": [552, 11, 293, 321, 411, 281, 360, 527, 1269, 4009, 589, 365, 30123, 5045, 12788, 267, 837, 337, 633, 3779, 13], "temperature": 0.0, "avg_logprob": -0.14383541640414987, "compression_ratio": 1.6866359447004609, "no_speech_prob": 0.00011253548291279003}, {"id": 163, "seek": 137876, "start": 1378.76, "end": 1387.48, "text": " It can compile too. So whether you want to contribute to Kotlin multiplatform libraries", "tokens": [467, 393, 31413, 886, 13, 407, 1968, 291, 528, 281, 10586, 281, 30123, 5045, 12788, 267, 837, 15148], "temperature": 0.0, "avg_logprob": -0.1906616515007572, "compression_ratio": 1.5773809523809523, "no_speech_prob": 0.0005525665474124253}, {"id": 164, "seek": 137876, "start": 1387.48, "end": 1399.32, "text": " or learn how to use Kotlin multiplatform, be sure to contact us. Thank you very much.", "tokens": [420, 1466, 577, 281, 764, 30123, 5045, 12788, 267, 837, 11, 312, 988, 281, 3385, 505, 13, 1044, 291, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.1906616515007572, "compression_ratio": 1.5773809523809523, "no_speech_prob": 0.0005525665474124253}, {"id": 165, "seek": 137876, "start": 1399.32, "end": 1407.68, "text": " Thank you again. We have time for one question. If someone has a question, raise your hand.", "tokens": [1044, 291, 797, 13, 492, 362, 565, 337, 472, 1168, 13, 759, 1580, 575, 257, 1168, 11, 5300, 428, 1011, 13], "temperature": 0.0, "avg_logprob": -0.1906616515007572, "compression_ratio": 1.5773809523809523, "no_speech_prob": 0.0005525665474124253}, {"id": 166, "seek": 140768, "start": 1407.68, "end": 1414.68, "text": " Shout it, and you have to repeat the question. Yes, so you've decided to write your own library.", "tokens": [32749, 309, 11, 293, 291, 362, 281, 7149, 264, 1168, 13, 1079, 11, 370, 291, 600, 3047, 281, 2464, 428, 1065, 6405, 13], "temperature": 0.0, "avg_logprob": -0.32593255091195156, "compression_ratio": 1.6605504587155964, "no_speech_prob": 0.003970978781580925}, {"id": 167, "seek": 140768, "start": 1414.68, "end": 1422.96, "text": " There was any way of making Mokey to work with yours, but if you were, is that possible?", "tokens": [821, 390, 604, 636, 295, 1455, 376, 2949, 88, 281, 589, 365, 6342, 11, 457, 498, 291, 645, 11, 307, 300, 1944, 30], "temperature": 0.0, "avg_logprob": -0.32593255091195156, "compression_ratio": 1.6605504587155964, "no_speech_prob": 0.003970978781580925}, {"id": 168, "seek": 140768, "start": 1422.96, "end": 1430.28, "text": " So the question is, rather than using, rather than creating a whole new library for marking", "tokens": [407, 264, 1168, 307, 11, 2831, 813, 1228, 11, 2831, 813, 4084, 257, 1379, 777, 6405, 337, 25482], "temperature": 0.0, "avg_logprob": -0.32593255091195156, "compression_ratio": 1.6605504587155964, "no_speech_prob": 0.003970978781580925}, {"id": 169, "seek": 140768, "start": 1430.28, "end": 1436.28, "text": " a Kotlin multiplatform, is there a way to put Mokey to Kotlin multiplatform? And the", "tokens": [257, 30123, 5045, 12788, 267, 837, 11, 307, 456, 257, 636, 281, 829, 376, 2949, 88, 281, 30123, 5045, 12788, 267, 837, 30, 400, 264], "temperature": 0.0, "avg_logprob": -0.32593255091195156, "compression_ratio": 1.6605504587155964, "no_speech_prob": 0.003970978781580925}, {"id": 170, "seek": 143628, "start": 1436.28, "end": 1443.36, "text": " answer is definitely no. Mokey to uses a lot of reflection, just not just for proxy, but", "tokens": [1867, 307, 2138, 572, 13, 376, 2949, 88, 281, 4960, 257, 688, 295, 12914, 11, 445, 406, 445, 337, 29690, 11, 457], "temperature": 0.0, "avg_logprob": -0.19644526640574136, "compression_ratio": 1.6990291262135921, "no_speech_prob": 0.0006287380820140243}, {"id": 171, "seek": 143628, "start": 1443.36, "end": 1452.84, "text": " for object generation and for verification, and it instruments the runtime heavily. And", "tokens": [337, 2657, 5125, 293, 337, 30206, 11, 293, 309, 12190, 264, 34474, 10950, 13, 400], "temperature": 0.0, "avg_logprob": -0.19644526640574136, "compression_ratio": 1.6990291262135921, "no_speech_prob": 0.0006287380820140243}, {"id": 172, "seek": 143628, "start": 1452.84, "end": 1457.96, "text": " since there is no runtime, there is no JVM runtime in Kotlin multiplatform, there is no", "tokens": [1670, 456, 307, 572, 34474, 11, 456, 307, 572, 508, 53, 44, 34474, 294, 30123, 5045, 12788, 267, 837, 11, 456, 307, 572], "temperature": 0.0, "avg_logprob": -0.19644526640574136, "compression_ratio": 1.6990291262135921, "no_speech_prob": 0.0006287380820140243}, {"id": 173, "seek": 143628, "start": 1457.96, "end": 1464.8, "text": " way to port Mokey to Kotlin multiplatform. Now, what we've tried to do with Mokey and", "tokens": [636, 281, 2436, 376, 2949, 88, 281, 30123, 5045, 12788, 267, 837, 13, 823, 11, 437, 321, 600, 3031, 281, 360, 365, 376, 2949, 88, 293], "temperature": 0.0, "avg_logprob": -0.19644526640574136, "compression_ratio": 1.6990291262135921, "no_speech_prob": 0.0006287380820140243}, {"id": 174, "seek": 146480, "start": 1464.8, "end": 1473.6, "text": " P is to emulate the same API that Mokey provides so that when you use Mokey and P, you're at", "tokens": [430, 307, 281, 45497, 264, 912, 9362, 300, 376, 2949, 88, 6417, 370, 300, 562, 291, 764, 376, 2949, 88, 293, 430, 11, 291, 434, 412], "temperature": 0.0, "avg_logprob": -0.1943326247365851, "compression_ratio": 1.4045801526717556, "no_speech_prob": 0.0009840014390647411}, {"id": 175, "seek": 146480, "start": 1473.6, "end": 1481.3999999999999, "text": " home, you're using an API that is really close, but there's no way to port Mokey to itself.", "tokens": [1280, 11, 291, 434, 1228, 364, 9362, 300, 307, 534, 1998, 11, 457, 456, 311, 572, 636, 281, 2436, 376, 2949, 88, 281, 2564, 13], "temperature": 0.0, "avg_logprob": -0.1943326247365851, "compression_ratio": 1.4045801526717556, "no_speech_prob": 0.0009840014390647411}, {"id": 176, "seek": 148140, "start": 1481.4, "end": 1495.68, "text": " Thank you very much, and have a nice first time.", "tokens": [50364, 1044, 291, 588, 709, 11, 293, 362, 257, 1481, 700, 565, 13, 51078], "temperature": 0.0, "avg_logprob": -0.6112005233764648, "compression_ratio": 0.8571428571428571, "no_speech_prob": 0.0012194669106975198}], "language": "en"}