{"text": " Hey everyone, thanks for coming and yeah, today I would like to talk a little bit about the Bluetooth Mesh and what we did in the Rust ecosystem to basically support it both on the embedded and on the Linux side and it's a good continuation on the topic that we had in the previous session because it's a little bit comparable and there's a lot of material so basically what I will, and a little time, 20 minutes, so what I will basically give you today is a lot of teasers and a lot of pointers and I hope you'll get interested and could follow the links to further investigate things. So let's get started with what the Bluetooth Mesh is. Bluetooth Mesh is based on the BLE, so Bluetooth Low Energy Technology, but it's designed to create a mesh network or devices on top of it, meaning that you should be able to connect nodes or devices directly in dynamic hierarchies basically. What's different between the Bluetooth Mesh and the thread, for example, is that Bluetooth Mesh doesn't use any routing, it's based on the managed flooding principle, meaning that the device will try to publish messages to all the devices in the range and those devices will then figure out what to do next with those messages that have been received and it supports published subscribe model as we will see in a minute. So this is how it basically looks like and it's a similar what Stefan showed us with the threads, so we have a regular node that can send and receive messages, we have relay nodes which are only there to extend the range of the network, so they're just relaying things that they're receiving and in a similar fashion as thread, we can have a low power nodes that are mostly sleeping and are not active and which are accompanied by the friend nodes which will buffer messages addressed over these low power nodes. The stack looks something like this, so as I said like we have a Bluetooth load energy as a basic layer, there's a networking layer that's responsible for creating networks and exchanging keys and all that kind of things and then we have an application layer which is completely defined in the Bluetooth mesh, meaning that all our models are predefined and we can use it as we will see now. So as I said the models are defined, so for example all the things that are talking like a sensors or on-off switches are defined as a model on the application level on the mesh and we can have a client and a server model meaning that the client and the server will exchange the messages and communicate like that. So how does it work then is that each device, each node can have multiple elements and those elements can have multiple client or server models between them and each element has its own unicast address that can be used to address an element within the device. We can also create more complex hierarchies by defining a group of addresses and defining the virtual addresses which provides us with a way to create more complex topologies and to have like a full power of public subscriber architectures on the mesh level. And every device is part of the particular network and the particular application within that network meaning that all the messages that are exchanged between the devices are double encrypted with the network and the application key. To onboard the device onto the network we need to go through something like a provisioning process meaning that we need to have like a special node that will behave like a provisioner of the network and that node will be responsible for creating and managing the keys, setting the addresses and things like that. So what are the use cases on top of the Bluetooth low energy we can have extended range and more flexible topologies but we can also have existing hardware so this is just another application on existing Bluetooth low energy hardware that can be applied but with more flexible technologies and providing an option to connect larger number of devices. So I don't want to go too deep into this because it's probably a session of its own. We heard a lot about the thread here but this is just a small comparison between all the operating technologies in the space and their respective solutions in all the different layers. So when we started playing with this we had one goal in mind and that is to create like a full stack meaning that we can create application based on the Bluetooth mesh that will cover the full stack going from the embedded microcontrollers to the Linux and having support for these applications in the cloud and try to do all that in Rust. We will talk about that a bit more in a moment and the idea was to create a platform that could be easy to build these applications both on devices and on the cloud side but also provide a way to ease the management of the Bluetooth mesh networks. But before we dive into what we did in Rust is let's go a little bit through the current state and on the embedded side the ZFR is the only thing that I found in the open source that had a support for the Bluetooth mesh. Of course all the vendors had their own support as the case that can be used out of the box On the Linux side everything related to the Bluetooth is basically under the BlueZ project and the BlueZ defines the Dibas APIs for communicating with the Bluetooth demon on the different kind of things and of course they have the mesh API as well for the Dibas and it's used to send messages between the Bluetooth demon and the applications that want to talk a Bluetooth mesh on the Linux side. But the demon is different so if you want to use the mesh on the Linux box you need to install the different package and basically disable and stop the regular Bluetooth demon and enable the specific Bluetooth mesh demon. There's also a provisioner tool included which is called the Mesh CFG client and it's an interactive tool that allows us to do all the provisioning things. So create new networks, scan for the provision devices, add those devices to the network and create addresses for their models. One of the downsides of this tool is that it's too interactive so it's not that easily scriptable and it's making it hard to create like reproducible networks and environments that you want to do. And the final state is then how do we create these applications on the Linux side that will do this and there's even less examples of that on the network. All that I could find when I started looking into it was some of the Python examples done in the Bluetooth white papers and basically those are just simple Python applications that use the divas interface to basically communicate with the mesh demon over it. So coming from this kind of state you could see the end goal that we try to do is to try to see how far can we go with this tech and try to implement most of these things in Rust. And now the question is why Rust of course and we found a very good solution for system programming so it basically allows us to create, it's statically compiled and strongly typed which means that it has a strong preform. Save programs without introducing runtimes and VMs, again a very suitable for system programming for this kind of applications. And finally it's a fairly modern language with a lot of good tooling so you know people coming from other areas for example I don't consider myself an embedded programmer but I feel much more comfortable playing with Rust for these use cases than I would be if I would try to do the same thing in a C so yeah. So first thing we did is to create a bit mesh create and that's a basic create that we try to do is to implement all the traits that are needed for implementing the Bluetooth mesh specification. So as you remember all the layers of the Bluetooth mesh so everything needed for representing the application models or the networking layer traits should be defined in this one create and as you can see you will see we will be able to reuse that in all different layers of the stack. But in order to be able to reuse it in the embedded space that this create needs to be and no STD meaning that it shouldn't rely on a standard library. And this is a kind of go to example to show how the sensor data representation could look like in defined by the BT mesh create. So Rust embedded I think it's going so how many people here are using Rust today for embedded programming. Let's go. So what's the goal here? There's a Rust embedded working group that are dedicated to this task and its goal is to enable people to run firmware using Rust, firmware targeted to the microcontrollers with the small RAM and ROM capabilities without operating system and without memory allocator. As I said like we have only 20 minutes and there's a lot of things so I just giving you the pointers. So there's a lot more to be said about embedded Rust but we don't have that much time. And the next thing, next cool thing as I said doing embedded with Rust is that it enables you to do quite a model programming things even for the firmware. So there's a project called embassy which allows us to use basically as in programming for the firmers. It provides a scheduler and the hardware abstractions that we can use to build quite capable asynchronous applications in Rust and it has a hardware support for all the major hardware platforms today. On top of that the project that we are involved in is building on top of the embassy and trying to add more IoT things on top of the basic embedded development. So communication with the cloud in terms of MQTT or HTTP, trying to support use cases like Bluetooth mesh and try to create more advanced applications like OTA firmware updates. And you can see here one of the examples from the workshop that we did that I'll mention later on is for example how we can use the Bitimesh create on the firmware to basically every time we read the sensor data we can package that sensor data in the proper sensor Bluetooth mesh message and send it over the Bluetooth. Then on the Linux side there's a project called Bluer which is part of the BlueZ Linux official group which tries to implement all the Linux Bluetooth protocol stack in Rust and at the moment it provides support for all the major features of the Bluetooth like get or Bluetooth cloud energy. What we try to do here is to provide support for the Bluetooth mesh in a similar way as the rest of the Bluer works. So again, nice thing about Rust is that you can use a lot of crates and existing technologies that are there for different use cases. So for example, a Bluer uses a Tokyo runtime, very frequently used runtime for building all kind of server applications in Rust and communicates with the mesh daemon over using the DBScrate. The good thing is and that was the part of the plan is to use the Bitimesh create here as well to use for the mesh traits that we would need it. So this is the quick architecture of how things work on the Linux so I hope you can see it well. So we have a mesh daemon which communicates directly with the devices. It has its own state in the mesh config and the mesh storage volumes and it communicates with using the system DBScrate to random applications, being the gateway application or some device simulator on the Linux as well. But the good thing is that you can see here is that and this is one of the things that I personally like a lot about using Rust for these use cases is that this code running on the Linux looks pretty much similar like the code running on the firmware. So here we are receiving the Bluetooth message, we are parsing it, we are creating a JSON out of it and sending it over the MQTT to the cloud. But you know, it's very easy for a single person to jump back and forth over the different stack layers and using the similar crates and a similar style code then it would be if we go from writing a C for the firmware and then a Python code for the gateway and then doing something in Java in the cloud for example. So the mesh support is not officially landed in Bloor and this is all my fault due to my laziness and other priorities. But hopefully this PR will be merged in the coming weeks, let's say. Final part of the project that we have been building is to build a kind of IoT friendly cloud platform, again done in Rust. Here we try to provide all the services that your typical IoT application is needing. So being able to do a lot of connectivity, having a capable device registry and being able to integrate further into the cloud applications and using digital twinning and all these kind of things on the other side. But again, I'm coming back to the same thing. So there's a thing called payload converter in the cloud that can actually intercept our messages coming from the gateways. And if you can remember in the previous example, we already parsed the Bluetooth messages and send them as a JSON. But if your gateway is sending just the row bytes, you can do that thing on the cloud, again with the same crates and with a very similar code. So we will parse the bytes, get the message, do some JSON processing, and forward that message deeper into the cloud. So we were playing with this for a while, and then there was a chance to actually try to put this all into the work. With the EclipseCon, we had a hackathon and a workshop where we tried to cover the whole area with the Bluetooth mesh network, provide the microbeads for people to play around with, and provide some basic applications in the cloud that will talk to each other. But the basic big architecture looks like this. So we have a public sandbox for our drug cloud consisting of Kafka and all this kind of stuff. And we brought the gateway based on the Bloor. We provided some examples of how to use microbeads with the Rust embedded drug device and embassy, and provided a couple of applications that will talk to the cloud using the web socket in the background. So just to recap how this architecture looks on the firmware. So you have a couple of layers, the embassy and the Bluetooth radio on the bottom. Then we have a drug device and the BTMesh support next on, and on top of that, we can write our own application that will do things with these messages. On the gateway side, we implemented the gateway using the Bloor. And we also tried to use some of the, so to say, latest edge technologies to deploy and manage those gateways. So trying to use MicroShift, which is the RedHeads version of the single node Kubernetes cluster, paired with the open cluster management to deploy these gateways to appropriate nodes. And I must say, to my surprise, it all worked pretty well. So we had like a four or five gateways based on the Intel Nux and some Raspberry Pis. Because Raspberry Pis didn't run the Kubernetes, we used the basic podman and the Docker images to run the gateways. And that provides a very good coverage of a very large space. What we needed to do is to provide a couple of relay nodes. You can see on this other picture, is to just to basically extend the range over some longer corridors that were there. But everything worked pretty good from this perspective. So that's all what I have to cover today. So as I said, there's a lot of teasers. We didn't get into anything too much deeply. But these are the communities. So hit us on the Drug IoT metrics channel. That's where we all hang and are happy to talk about these things. If you're interested in EBC, I would suggest to take a look at that and the Bloor thing, hopefully with the official BTMesh support very soon. Thanks. Thank you very much.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 11.84, "text": " Hey everyone, thanks for coming and yeah, today I would like to talk a little bit about", "tokens": [1911, 1518, 11, 3231, 337, 1348, 293, 1338, 11, 965, 286, 576, 411, 281, 751, 257, 707, 857, 466], "temperature": 0.0, "avg_logprob": -0.26210603406352384, "compression_ratio": 1.4576271186440677, "no_speech_prob": 0.31055060029029846}, {"id": 1, "seek": 0, "start": 11.84, "end": 18.64, "text": " the Bluetooth Mesh and what we did in the Rust ecosystem to basically support it both", "tokens": [264, 20286, 376, 14935, 293, 437, 321, 630, 294, 264, 34952, 11311, 281, 1936, 1406, 309, 1293], "temperature": 0.0, "avg_logprob": -0.26210603406352384, "compression_ratio": 1.4576271186440677, "no_speech_prob": 0.31055060029029846}, {"id": 2, "seek": 0, "start": 18.64, "end": 25.52, "text": " on the embedded and on the Linux side and it's a good continuation on the topic that", "tokens": [322, 264, 16741, 293, 322, 264, 18734, 1252, 293, 309, 311, 257, 665, 29357, 322, 264, 4829, 300], "temperature": 0.0, "avg_logprob": -0.26210603406352384, "compression_ratio": 1.4576271186440677, "no_speech_prob": 0.31055060029029846}, {"id": 3, "seek": 2552, "start": 25.52, "end": 30.96, "text": " we had in the previous session because it's a little bit comparable and there's a lot", "tokens": [321, 632, 294, 264, 3894, 5481, 570, 309, 311, 257, 707, 857, 25323, 293, 456, 311, 257, 688], "temperature": 0.0, "avg_logprob": -0.15504705905914307, "compression_ratio": 1.676923076923077, "no_speech_prob": 0.0006871151272207499}, {"id": 4, "seek": 2552, "start": 30.96, "end": 37.0, "text": " of material so basically what I will, and a little time, 20 minutes, so what I will", "tokens": [295, 2527, 370, 1936, 437, 286, 486, 11, 293, 257, 707, 565, 11, 945, 2077, 11, 370, 437, 286, 486], "temperature": 0.0, "avg_logprob": -0.15504705905914307, "compression_ratio": 1.676923076923077, "no_speech_prob": 0.0006871151272207499}, {"id": 5, "seek": 2552, "start": 37.0, "end": 43.28, "text": " basically give you today is a lot of teasers and a lot of pointers and I hope you'll get", "tokens": [1936, 976, 291, 965, 307, 257, 688, 295, 11488, 433, 293, 257, 688, 295, 44548, 293, 286, 1454, 291, 603, 483], "temperature": 0.0, "avg_logprob": -0.15504705905914307, "compression_ratio": 1.676923076923077, "no_speech_prob": 0.0006871151272207499}, {"id": 6, "seek": 2552, "start": 43.28, "end": 51.120000000000005, "text": " interested and could follow the links to further investigate things.", "tokens": [3102, 293, 727, 1524, 264, 6123, 281, 3052, 15013, 721, 13], "temperature": 0.0, "avg_logprob": -0.15504705905914307, "compression_ratio": 1.676923076923077, "no_speech_prob": 0.0006871151272207499}, {"id": 7, "seek": 5112, "start": 51.12, "end": 58.16, "text": " So let's get started with what the Bluetooth Mesh is.", "tokens": [407, 718, 311, 483, 1409, 365, 437, 264, 20286, 376, 14935, 307, 13], "temperature": 0.0, "avg_logprob": -0.19707954907026448, "compression_ratio": 1.475, "no_speech_prob": 0.0002466387231834233}, {"id": 8, "seek": 5112, "start": 58.16, "end": 67.4, "text": " Bluetooth Mesh is based on the BLE, so Bluetooth Low Energy Technology, but it's designed to", "tokens": [20286, 376, 14935, 307, 2361, 322, 264, 363, 2634, 11, 370, 20286, 17078, 14939, 15037, 11, 457, 309, 311, 4761, 281], "temperature": 0.0, "avg_logprob": -0.19707954907026448, "compression_ratio": 1.475, "no_speech_prob": 0.0002466387231834233}, {"id": 9, "seek": 5112, "start": 67.4, "end": 76.44, "text": " create a mesh network or devices on top of it, meaning that you should be able to connect", "tokens": [1884, 257, 17407, 3209, 420, 5759, 322, 1192, 295, 309, 11, 3620, 300, 291, 820, 312, 1075, 281, 1745], "temperature": 0.0, "avg_logprob": -0.19707954907026448, "compression_ratio": 1.475, "no_speech_prob": 0.0002466387231834233}, {"id": 10, "seek": 7644, "start": 76.44, "end": 86.8, "text": " nodes or devices directly in dynamic hierarchies basically.", "tokens": [13891, 420, 5759, 3838, 294, 8546, 35250, 530, 1936, 13], "temperature": 0.0, "avg_logprob": -0.17218544058603782, "compression_ratio": 1.5891089108910892, "no_speech_prob": 0.00034978013718500733}, {"id": 11, "seek": 7644, "start": 86.8, "end": 93.52, "text": " What's different between the Bluetooth Mesh and the thread, for example, is that Bluetooth", "tokens": [708, 311, 819, 1296, 264, 20286, 376, 14935, 293, 264, 7207, 11, 337, 1365, 11, 307, 300, 20286], "temperature": 0.0, "avg_logprob": -0.17218544058603782, "compression_ratio": 1.5891089108910892, "no_speech_prob": 0.00034978013718500733}, {"id": 12, "seek": 7644, "start": 93.52, "end": 99.8, "text": " Mesh doesn't use any routing, it's based on the managed flooding principle, meaning", "tokens": [376, 14935, 1177, 380, 764, 604, 32722, 11, 309, 311, 2361, 322, 264, 6453, 24132, 8665, 11, 3620], "temperature": 0.0, "avg_logprob": -0.17218544058603782, "compression_ratio": 1.5891089108910892, "no_speech_prob": 0.00034978013718500733}, {"id": 13, "seek": 7644, "start": 99.8, "end": 106.28, "text": " that the device will try to publish messages to all the devices in the range and those", "tokens": [300, 264, 4302, 486, 853, 281, 11374, 7897, 281, 439, 264, 5759, 294, 264, 3613, 293, 729], "temperature": 0.0, "avg_logprob": -0.17218544058603782, "compression_ratio": 1.5891089108910892, "no_speech_prob": 0.00034978013718500733}, {"id": 14, "seek": 10628, "start": 106.28, "end": 114.44, "text": " devices will then figure out what to do next with those messages that have been received", "tokens": [5759, 486, 550, 2573, 484, 437, 281, 360, 958, 365, 729, 7897, 300, 362, 668, 4613], "temperature": 0.0, "avg_logprob": -0.15830075895631468, "compression_ratio": 1.6354679802955665, "no_speech_prob": 0.002711791777983308}, {"id": 15, "seek": 10628, "start": 114.44, "end": 121.2, "text": " and it supports published subscribe model as we will see in a minute.", "tokens": [293, 309, 9346, 6572, 3022, 2316, 382, 321, 486, 536, 294, 257, 3456, 13], "temperature": 0.0, "avg_logprob": -0.15830075895631468, "compression_ratio": 1.6354679802955665, "no_speech_prob": 0.002711791777983308}, {"id": 16, "seek": 10628, "start": 121.2, "end": 128.6, "text": " So this is how it basically looks like and it's a similar what Stefan showed us with", "tokens": [407, 341, 307, 577, 309, 1936, 1542, 411, 293, 309, 311, 257, 2531, 437, 32158, 4712, 505, 365], "temperature": 0.0, "avg_logprob": -0.15830075895631468, "compression_ratio": 1.6354679802955665, "no_speech_prob": 0.002711791777983308}, {"id": 17, "seek": 10628, "start": 128.6, "end": 135.56, "text": " the threads, so we have a regular node that can send and receive messages, we have relay", "tokens": [264, 19314, 11, 370, 321, 362, 257, 3890, 9984, 300, 393, 2845, 293, 4774, 7897, 11, 321, 362, 24214], "temperature": 0.0, "avg_logprob": -0.15830075895631468, "compression_ratio": 1.6354679802955665, "no_speech_prob": 0.002711791777983308}, {"id": 18, "seek": 13556, "start": 135.56, "end": 142.44, "text": " nodes which are only there to extend the range of the network, so they're just relaying", "tokens": [13891, 597, 366, 787, 456, 281, 10101, 264, 3613, 295, 264, 3209, 11, 370, 436, 434, 445, 24214, 278], "temperature": 0.0, "avg_logprob": -0.19784385927261844, "compression_ratio": 1.608433734939759, "no_speech_prob": 0.0009885195177048445}, {"id": 19, "seek": 13556, "start": 142.44, "end": 151.12, "text": " things that they're receiving and in a similar fashion as thread, we can have a low power", "tokens": [721, 300, 436, 434, 10040, 293, 294, 257, 2531, 6700, 382, 7207, 11, 321, 393, 362, 257, 2295, 1347], "temperature": 0.0, "avg_logprob": -0.19784385927261844, "compression_ratio": 1.608433734939759, "no_speech_prob": 0.0009885195177048445}, {"id": 20, "seek": 13556, "start": 151.12, "end": 157.6, "text": " nodes that are mostly sleeping and are not active and which are accompanied by the friend", "tokens": [13891, 300, 366, 5240, 8296, 293, 366, 406, 4967, 293, 597, 366, 24202, 538, 264, 1277], "temperature": 0.0, "avg_logprob": -0.19784385927261844, "compression_ratio": 1.608433734939759, "no_speech_prob": 0.0009885195177048445}, {"id": 21, "seek": 15760, "start": 157.6, "end": 170.4, "text": " nodes which will buffer messages addressed over these low power nodes.", "tokens": [13891, 597, 486, 21762, 7897, 13847, 670, 613, 2295, 1347, 13891, 13], "temperature": 0.0, "avg_logprob": -0.17125434875488282, "compression_ratio": 1.4615384615384615, "no_speech_prob": 0.0012392447097226977}, {"id": 22, "seek": 15760, "start": 170.4, "end": 177.0, "text": " The stack looks something like this, so as I said like we have a Bluetooth load energy", "tokens": [440, 8630, 1542, 746, 411, 341, 11, 370, 382, 286, 848, 411, 321, 362, 257, 20286, 3677, 2281], "temperature": 0.0, "avg_logprob": -0.17125434875488282, "compression_ratio": 1.4615384615384615, "no_speech_prob": 0.0012392447097226977}, {"id": 23, "seek": 15760, "start": 177.0, "end": 184.12, "text": " as a basic layer, there's a networking layer that's responsible for creating networks and", "tokens": [382, 257, 3875, 4583, 11, 456, 311, 257, 17985, 4583, 300, 311, 6250, 337, 4084, 9590, 293], "temperature": 0.0, "avg_logprob": -0.17125434875488282, "compression_ratio": 1.4615384615384615, "no_speech_prob": 0.0012392447097226977}, {"id": 24, "seek": 18412, "start": 184.12, "end": 189.68, "text": " exchanging keys and all that kind of things and then we have an application layer which", "tokens": [6210, 9741, 9317, 293, 439, 300, 733, 295, 721, 293, 550, 321, 362, 364, 3861, 4583, 597], "temperature": 0.0, "avg_logprob": -0.13276276523119782, "compression_ratio": 1.6063829787234043, "no_speech_prob": 0.001381832524202764}, {"id": 25, "seek": 18412, "start": 189.68, "end": 198.48000000000002, "text": " is completely defined in the Bluetooth mesh, meaning that all our models are predefined", "tokens": [307, 2584, 7642, 294, 264, 20286, 17407, 11, 3620, 300, 439, 527, 5245, 366, 659, 37716], "temperature": 0.0, "avg_logprob": -0.13276276523119782, "compression_ratio": 1.6063829787234043, "no_speech_prob": 0.001381832524202764}, {"id": 26, "seek": 18412, "start": 198.48000000000002, "end": 202.72, "text": " and we can use it as we will see now.", "tokens": [293, 321, 393, 764, 309, 382, 321, 486, 536, 586, 13], "temperature": 0.0, "avg_logprob": -0.13276276523119782, "compression_ratio": 1.6063829787234043, "no_speech_prob": 0.001381832524202764}, {"id": 27, "seek": 18412, "start": 202.72, "end": 212.08, "text": " So as I said the models are defined, so for example all the things that are talking like", "tokens": [407, 382, 286, 848, 264, 5245, 366, 7642, 11, 370, 337, 1365, 439, 264, 721, 300, 366, 1417, 411], "temperature": 0.0, "avg_logprob": -0.13276276523119782, "compression_ratio": 1.6063829787234043, "no_speech_prob": 0.001381832524202764}, {"id": 28, "seek": 21208, "start": 212.08, "end": 224.72000000000003, "text": " a sensors or on-off switches are defined as a model on the application level on the mesh", "tokens": [257, 14840, 420, 322, 12, 4506, 19458, 366, 7642, 382, 257, 2316, 322, 264, 3861, 1496, 322, 264, 17407], "temperature": 0.0, "avg_logprob": -0.24121658757047834, "compression_ratio": 1.618705035971223, "no_speech_prob": 0.0006303531699813902}, {"id": 29, "seek": 21208, "start": 224.72000000000003, "end": 230.32000000000002, "text": " and we can have a client and a server model meaning that the client and the server will", "tokens": [293, 321, 393, 362, 257, 6423, 293, 257, 7154, 2316, 3620, 300, 264, 6423, 293, 264, 7154, 486], "temperature": 0.0, "avg_logprob": -0.24121658757047834, "compression_ratio": 1.618705035971223, "no_speech_prob": 0.0006303531699813902}, {"id": 30, "seek": 21208, "start": 230.32000000000002, "end": 238.72000000000003, "text": " exchange the messages and communicate like that.", "tokens": [7742, 264, 7897, 293, 7890, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.24121658757047834, "compression_ratio": 1.618705035971223, "no_speech_prob": 0.0006303531699813902}, {"id": 31, "seek": 23872, "start": 238.72, "end": 249.0, "text": " So how does it work then is that each device, each node can have multiple elements and those", "tokens": [407, 577, 775, 309, 589, 550, 307, 300, 1184, 4302, 11, 1184, 9984, 393, 362, 3866, 4959, 293, 729], "temperature": 0.0, "avg_logprob": -0.09969984474828687, "compression_ratio": 1.7152317880794703, "no_speech_prob": 0.0011608544737100601}, {"id": 32, "seek": 23872, "start": 249.0, "end": 256.44, "text": " elements can have multiple client or server models between them and each element has its", "tokens": [4959, 393, 362, 3866, 6423, 420, 7154, 5245, 1296, 552, 293, 1184, 4478, 575, 1080], "temperature": 0.0, "avg_logprob": -0.09969984474828687, "compression_ratio": 1.7152317880794703, "no_speech_prob": 0.0011608544737100601}, {"id": 33, "seek": 23872, "start": 256.44, "end": 266.6, "text": " own unicast address that can be used to address an element within the device.", "tokens": [1065, 517, 299, 525, 2985, 300, 393, 312, 1143, 281, 2985, 364, 4478, 1951, 264, 4302, 13], "temperature": 0.0, "avg_logprob": -0.09969984474828687, "compression_ratio": 1.7152317880794703, "no_speech_prob": 0.0011608544737100601}, {"id": 34, "seek": 26660, "start": 266.6, "end": 274.24, "text": " We can also create more complex hierarchies by defining a group of addresses and defining", "tokens": [492, 393, 611, 1884, 544, 3997, 35250, 530, 538, 17827, 257, 1594, 295, 16862, 293, 17827], "temperature": 0.0, "avg_logprob": -0.2207613331930978, "compression_ratio": 1.6024844720496894, "no_speech_prob": 0.0006403705338016152}, {"id": 35, "seek": 26660, "start": 274.24, "end": 283.32000000000005, "text": " the virtual addresses which provides us with a way to create more complex topologies and", "tokens": [264, 6374, 16862, 597, 6417, 505, 365, 257, 636, 281, 1884, 544, 3997, 1192, 6204, 293], "temperature": 0.0, "avg_logprob": -0.2207613331930978, "compression_ratio": 1.6024844720496894, "no_speech_prob": 0.0006403705338016152}, {"id": 36, "seek": 26660, "start": 283.32000000000005, "end": 290.92, "text": " to have like a full power of public subscriber architectures on the mesh level.", "tokens": [281, 362, 411, 257, 1577, 1347, 295, 1908, 26122, 6331, 1303, 322, 264, 17407, 1496, 13], "temperature": 0.0, "avg_logprob": -0.2207613331930978, "compression_ratio": 1.6024844720496894, "no_speech_prob": 0.0006403705338016152}, {"id": 37, "seek": 29092, "start": 290.92, "end": 299.40000000000003, "text": " And every device is part of the particular network and the particular application within", "tokens": [400, 633, 4302, 307, 644, 295, 264, 1729, 3209, 293, 264, 1729, 3861, 1951], "temperature": 0.0, "avg_logprob": -0.1558174280019907, "compression_ratio": 1.8202247191011236, "no_speech_prob": 9.908337233355269e-05}, {"id": 38, "seek": 29092, "start": 299.40000000000003, "end": 304.16, "text": " that network meaning that all the messages that are exchanged between the devices are", "tokens": [300, 3209, 3620, 300, 439, 264, 7897, 300, 366, 38378, 1296, 264, 5759, 366], "temperature": 0.0, "avg_logprob": -0.1558174280019907, "compression_ratio": 1.8202247191011236, "no_speech_prob": 9.908337233355269e-05}, {"id": 39, "seek": 29092, "start": 304.16, "end": 311.36, "text": " double encrypted with the network and the application key.", "tokens": [3834, 36663, 365, 264, 3209, 293, 264, 3861, 2141, 13], "temperature": 0.0, "avg_logprob": -0.1558174280019907, "compression_ratio": 1.8202247191011236, "no_speech_prob": 9.908337233355269e-05}, {"id": 40, "seek": 29092, "start": 311.36, "end": 317.44, "text": " To onboard the device onto the network we need to go through something like a provisioning", "tokens": [1407, 24033, 264, 4302, 3911, 264, 3209, 321, 643, 281, 352, 807, 746, 411, 257, 17225, 278], "temperature": 0.0, "avg_logprob": -0.1558174280019907, "compression_ratio": 1.8202247191011236, "no_speech_prob": 9.908337233355269e-05}, {"id": 41, "seek": 31744, "start": 317.44, "end": 324.71999999999997, "text": " process meaning that we need to have like a special node that will behave like a provisioner", "tokens": [1399, 3620, 300, 321, 643, 281, 362, 411, 257, 2121, 9984, 300, 486, 15158, 411, 257, 17225, 260], "temperature": 0.0, "avg_logprob": -0.13361982345581055, "compression_ratio": 1.637037037037037, "no_speech_prob": 0.0003954702115152031}, {"id": 42, "seek": 31744, "start": 324.71999999999997, "end": 333.64, "text": " of the network and that node will be responsible for creating and managing the keys, setting", "tokens": [295, 264, 3209, 293, 300, 9984, 486, 312, 6250, 337, 4084, 293, 11642, 264, 9317, 11, 3287], "temperature": 0.0, "avg_logprob": -0.13361982345581055, "compression_ratio": 1.637037037037037, "no_speech_prob": 0.0003954702115152031}, {"id": 43, "seek": 31744, "start": 333.64, "end": 340.24, "text": " the addresses and things like that.", "tokens": [264, 16862, 293, 721, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.13361982345581055, "compression_ratio": 1.637037037037037, "no_speech_prob": 0.0003954702115152031}, {"id": 44, "seek": 34024, "start": 340.24, "end": 352.12, "text": " So what are the use cases on top of the Bluetooth low energy we can have extended range and more", "tokens": [407, 437, 366, 264, 764, 3331, 322, 1192, 295, 264, 20286, 2295, 2281, 321, 393, 362, 10913, 3613, 293, 544], "temperature": 0.0, "avg_logprob": -0.18696092737132106, "compression_ratio": 1.725, "no_speech_prob": 0.0006241454975679517}, {"id": 45, "seek": 34024, "start": 352.12, "end": 361.88, "text": " flexible topologies but we can also have existing hardware so this is just another application", "tokens": [11358, 1192, 6204, 457, 321, 393, 611, 362, 6741, 8837, 370, 341, 307, 445, 1071, 3861], "temperature": 0.0, "avg_logprob": -0.18696092737132106, "compression_ratio": 1.725, "no_speech_prob": 0.0006241454975679517}, {"id": 46, "seek": 34024, "start": 361.88, "end": 369.88, "text": " on existing Bluetooth low energy hardware that can be applied but with more flexible", "tokens": [322, 6741, 20286, 2295, 2281, 8837, 300, 393, 312, 6456, 457, 365, 544, 11358], "temperature": 0.0, "avg_logprob": -0.18696092737132106, "compression_ratio": 1.725, "no_speech_prob": 0.0006241454975679517}, {"id": 47, "seek": 36988, "start": 369.88, "end": 378.64, "text": " technologies and providing an option to connect larger number of devices.", "tokens": [7943, 293, 6530, 364, 3614, 281, 1745, 4833, 1230, 295, 5759, 13], "temperature": 0.0, "avg_logprob": -0.18571050288313526, "compression_ratio": 1.4529411764705882, "no_speech_prob": 4.77678986499086e-05}, {"id": 48, "seek": 36988, "start": 378.64, "end": 384.76, "text": " So I don't want to go too deep into this because it's probably a session of its own.", "tokens": [407, 286, 500, 380, 528, 281, 352, 886, 2452, 666, 341, 570, 309, 311, 1391, 257, 5481, 295, 1080, 1065, 13], "temperature": 0.0, "avg_logprob": -0.18571050288313526, "compression_ratio": 1.4529411764705882, "no_speech_prob": 4.77678986499086e-05}, {"id": 49, "seek": 36988, "start": 384.76, "end": 394.88, "text": " We heard a lot about the thread here but this is just a small comparison between all the", "tokens": [492, 2198, 257, 688, 466, 264, 7207, 510, 457, 341, 307, 445, 257, 1359, 9660, 1296, 439, 264], "temperature": 0.0, "avg_logprob": -0.18571050288313526, "compression_ratio": 1.4529411764705882, "no_speech_prob": 4.77678986499086e-05}, {"id": 50, "seek": 39488, "start": 394.88, "end": 406.28, "text": " operating technologies in the space and their respective solutions in all the different layers.", "tokens": [7447, 7943, 294, 264, 1901, 293, 641, 23649, 6547, 294, 439, 264, 819, 7914, 13], "temperature": 0.0, "avg_logprob": -0.1818970664072845, "compression_ratio": 1.558659217877095, "no_speech_prob": 0.0021022867877036333}, {"id": 51, "seek": 39488, "start": 406.28, "end": 414.88, "text": " So when we started playing with this we had one goal in mind and that is to create like", "tokens": [407, 562, 321, 1409, 2433, 365, 341, 321, 632, 472, 3387, 294, 1575, 293, 300, 307, 281, 1884, 411], "temperature": 0.0, "avg_logprob": -0.1818970664072845, "compression_ratio": 1.558659217877095, "no_speech_prob": 0.0021022867877036333}, {"id": 52, "seek": 39488, "start": 414.88, "end": 424.2, "text": " a full stack meaning that we can create application based on the Bluetooth mesh that will cover", "tokens": [257, 1577, 8630, 3620, 300, 321, 393, 1884, 3861, 2361, 322, 264, 20286, 17407, 300, 486, 2060], "temperature": 0.0, "avg_logprob": -0.1818970664072845, "compression_ratio": 1.558659217877095, "no_speech_prob": 0.0021022867877036333}, {"id": 53, "seek": 42420, "start": 424.2, "end": 432.12, "text": " the full stack going from the embedded microcontrollers to the Linux and having support for these", "tokens": [264, 1577, 8630, 516, 490, 264, 16741, 4532, 9000, 3970, 433, 281, 264, 18734, 293, 1419, 1406, 337, 613], "temperature": 0.0, "avg_logprob": -0.13401598930358888, "compression_ratio": 1.5123456790123457, "no_speech_prob": 0.0004592505283653736}, {"id": 54, "seek": 42420, "start": 432.12, "end": 437.92, "text": " applications in the cloud and try to do all that in Rust.", "tokens": [5821, 294, 264, 4588, 293, 853, 281, 360, 439, 300, 294, 34952, 13], "temperature": 0.0, "avg_logprob": -0.13401598930358888, "compression_ratio": 1.5123456790123457, "no_speech_prob": 0.0004592505283653736}, {"id": 55, "seek": 42420, "start": 437.92, "end": 447.15999999999997, "text": " We will talk about that a bit more in a moment and the idea was to create a platform that", "tokens": [492, 486, 751, 466, 300, 257, 857, 544, 294, 257, 1623, 293, 264, 1558, 390, 281, 1884, 257, 3663, 300], "temperature": 0.0, "avg_logprob": -0.13401598930358888, "compression_ratio": 1.5123456790123457, "no_speech_prob": 0.0004592505283653736}, {"id": 56, "seek": 44716, "start": 447.16, "end": 454.40000000000003, "text": " could be easy to build these applications both on devices and on the cloud side but", "tokens": [727, 312, 1858, 281, 1322, 613, 5821, 1293, 322, 5759, 293, 322, 264, 4588, 1252, 457], "temperature": 0.0, "avg_logprob": -0.16432287957933214, "compression_ratio": 1.3652173913043477, "no_speech_prob": 0.00016115391917992383}, {"id": 57, "seek": 44716, "start": 454.40000000000003, "end": 466.12, "text": " also provide a way to ease the management of the Bluetooth mesh networks.", "tokens": [611, 2893, 257, 636, 281, 12708, 264, 4592, 295, 264, 20286, 17407, 9590, 13], "temperature": 0.0, "avg_logprob": -0.16432287957933214, "compression_ratio": 1.3652173913043477, "no_speech_prob": 0.00016115391917992383}, {"id": 58, "seek": 46612, "start": 466.12, "end": 477.16, "text": " But before we dive into what we did in Rust is let's go a little bit through the current", "tokens": [583, 949, 321, 9192, 666, 437, 321, 630, 294, 34952, 307, 718, 311, 352, 257, 707, 857, 807, 264, 2190], "temperature": 0.0, "avg_logprob": -0.20648099199126038, "compression_ratio": 1.5522388059701493, "no_speech_prob": 0.0022524124942719936}, {"id": 59, "seek": 46612, "start": 477.16, "end": 483.92, "text": " state and on the embedded side the ZFR is the only thing that I found in the open source", "tokens": [1785, 293, 322, 264, 16741, 1252, 264, 1176, 34658, 307, 264, 787, 551, 300, 286, 1352, 294, 264, 1269, 4009], "temperature": 0.0, "avg_logprob": -0.20648099199126038, "compression_ratio": 1.5522388059701493, "no_speech_prob": 0.0022524124942719936}, {"id": 60, "seek": 46612, "start": 483.92, "end": 488.16, "text": " that had a support for the Bluetooth mesh.", "tokens": [300, 632, 257, 1406, 337, 264, 20286, 17407, 13], "temperature": 0.0, "avg_logprob": -0.20648099199126038, "compression_ratio": 1.5522388059701493, "no_speech_prob": 0.0022524124942719936}, {"id": 61, "seek": 46612, "start": 488.16, "end": 496.08, "text": " Of course all the vendors had their own support as the case that can be used out of the box", "tokens": [2720, 1164, 439, 264, 22056, 632, 641, 1065, 1406, 382, 264, 1389, 300, 393, 312, 1143, 484, 295, 264, 2424], "temperature": 0.0, "avg_logprob": -0.20648099199126038, "compression_ratio": 1.5522388059701493, "no_speech_prob": 0.0022524124942719936}, {"id": 62, "seek": 49608, "start": 496.08, "end": 503.8, "text": " On the Linux side everything related to the Bluetooth is basically under the BlueZ project", "tokens": [1282, 264, 18734, 1252, 1203, 4077, 281, 264, 20286, 307, 1936, 833, 264, 8510, 57, 1716], "temperature": 0.0, "avg_logprob": -0.24845936114971454, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0001915280008688569}, {"id": 63, "seek": 49608, "start": 503.8, "end": 513.0799999999999, "text": " and the BlueZ defines the Dibas APIs for communicating with the Bluetooth demon on the different", "tokens": [293, 264, 8510, 57, 23122, 264, 413, 897, 296, 21445, 337, 17559, 365, 264, 20286, 14283, 322, 264, 819], "temperature": 0.0, "avg_logprob": -0.24845936114971454, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0001915280008688569}, {"id": 64, "seek": 49608, "start": 513.0799999999999, "end": 520.48, "text": " kind of things and of course they have the mesh API as well for the Dibas and it's used", "tokens": [733, 295, 721, 293, 295, 1164, 436, 362, 264, 17407, 9362, 382, 731, 337, 264, 413, 897, 296, 293, 309, 311, 1143], "temperature": 0.0, "avg_logprob": -0.24845936114971454, "compression_ratio": 1.5714285714285714, "no_speech_prob": 0.0001915280008688569}, {"id": 65, "seek": 52048, "start": 520.48, "end": 527.5600000000001, "text": " to send messages between the Bluetooth demon and the applications that want to talk a Bluetooth", "tokens": [281, 2845, 7897, 1296, 264, 20286, 14283, 293, 264, 5821, 300, 528, 281, 751, 257, 20286], "temperature": 0.0, "avg_logprob": -0.16030028416560246, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.0006430401699617505}, {"id": 66, "seek": 52048, "start": 527.5600000000001, "end": 530.8000000000001, "text": " mesh on the Linux side.", "tokens": [17407, 322, 264, 18734, 1252, 13], "temperature": 0.0, "avg_logprob": -0.16030028416560246, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.0006430401699617505}, {"id": 67, "seek": 52048, "start": 530.8000000000001, "end": 538.08, "text": " But the demon is different so if you want to use the mesh on the Linux box you need", "tokens": [583, 264, 14283, 307, 819, 370, 498, 291, 528, 281, 764, 264, 17407, 322, 264, 18734, 2424, 291, 643], "temperature": 0.0, "avg_logprob": -0.16030028416560246, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.0006430401699617505}, {"id": 68, "seek": 52048, "start": 538.08, "end": 545.2, "text": " to install the different package and basically disable and stop the regular Bluetooth demon", "tokens": [281, 3625, 264, 819, 7372, 293, 1936, 28362, 293, 1590, 264, 3890, 20286, 14283], "temperature": 0.0, "avg_logprob": -0.16030028416560246, "compression_ratio": 1.7771084337349397, "no_speech_prob": 0.0006430401699617505}, {"id": 69, "seek": 54520, "start": 545.2, "end": 557.6, "text": " and enable the specific Bluetooth mesh demon.", "tokens": [293, 9528, 264, 2685, 20286, 17407, 14283, 13], "temperature": 0.0, "avg_logprob": -0.20574308395385743, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.0012437541736289859}, {"id": 70, "seek": 54520, "start": 557.6, "end": 565.76, "text": " There's also a provisioner tool included which is called the Mesh CFG client and it's an", "tokens": [821, 311, 611, 257, 17225, 260, 2290, 5556, 597, 307, 1219, 264, 376, 14935, 21792, 38, 6423, 293, 309, 311, 364], "temperature": 0.0, "avg_logprob": -0.20574308395385743, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.0012437541736289859}, {"id": 71, "seek": 54520, "start": 565.76, "end": 570.08, "text": " interactive tool that allows us to do all the provisioning things.", "tokens": [15141, 2290, 300, 4045, 505, 281, 360, 439, 264, 17225, 278, 721, 13], "temperature": 0.0, "avg_logprob": -0.20574308395385743, "compression_ratio": 1.3862068965517242, "no_speech_prob": 0.0012437541736289859}, {"id": 72, "seek": 57008, "start": 570.08, "end": 576.0400000000001, "text": " So create new networks, scan for the provision devices, add those devices to the network", "tokens": [407, 1884, 777, 9590, 11, 11049, 337, 264, 17225, 5759, 11, 909, 729, 5759, 281, 264, 3209], "temperature": 0.0, "avg_logprob": -0.1503110340663365, "compression_ratio": 1.664835164835165, "no_speech_prob": 0.0021145036444067955}, {"id": 73, "seek": 57008, "start": 576.0400000000001, "end": 581.36, "text": " and create addresses for their models.", "tokens": [293, 1884, 16862, 337, 641, 5245, 13], "temperature": 0.0, "avg_logprob": -0.1503110340663365, "compression_ratio": 1.664835164835165, "no_speech_prob": 0.0021145036444067955}, {"id": 74, "seek": 57008, "start": 581.36, "end": 587.12, "text": " One of the downsides of this tool is that it's too interactive so it's not that easily", "tokens": [1485, 295, 264, 21554, 1875, 295, 341, 2290, 307, 300, 309, 311, 886, 15141, 370, 309, 311, 406, 300, 3612], "temperature": 0.0, "avg_logprob": -0.1503110340663365, "compression_ratio": 1.664835164835165, "no_speech_prob": 0.0021145036444067955}, {"id": 75, "seek": 57008, "start": 587.12, "end": 598.72, "text": " scriptable and it's making it hard to create like reproducible networks and environments", "tokens": [5755, 712, 293, 309, 311, 1455, 309, 1152, 281, 1884, 411, 11408, 32128, 9590, 293, 12388], "temperature": 0.0, "avg_logprob": -0.1503110340663365, "compression_ratio": 1.664835164835165, "no_speech_prob": 0.0021145036444067955}, {"id": 76, "seek": 59872, "start": 598.72, "end": 602.24, "text": " that you want to do.", "tokens": [300, 291, 528, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.22814044085415927, "compression_ratio": 1.5317919075144508, "no_speech_prob": 0.003452285658568144}, {"id": 77, "seek": 59872, "start": 602.24, "end": 608.0, "text": " And the final state is then how do we create these applications on the Linux side that", "tokens": [400, 264, 2572, 1785, 307, 550, 577, 360, 321, 1884, 613, 5821, 322, 264, 18734, 1252, 300], "temperature": 0.0, "avg_logprob": -0.22814044085415927, "compression_ratio": 1.5317919075144508, "no_speech_prob": 0.003452285658568144}, {"id": 78, "seek": 59872, "start": 608.0, "end": 619.5600000000001, "text": " will do this and there's even less examples of that on the network.", "tokens": [486, 360, 341, 293, 456, 311, 754, 1570, 5110, 295, 300, 322, 264, 3209, 13], "temperature": 0.0, "avg_logprob": -0.22814044085415927, "compression_ratio": 1.5317919075144508, "no_speech_prob": 0.003452285658568144}, {"id": 79, "seek": 59872, "start": 619.5600000000001, "end": 625.0400000000001, "text": " All that I could find when I started looking into it was some of the Python examples done", "tokens": [1057, 300, 286, 727, 915, 562, 286, 1409, 1237, 666, 309, 390, 512, 295, 264, 15329, 5110, 1096], "temperature": 0.0, "avg_logprob": -0.22814044085415927, "compression_ratio": 1.5317919075144508, "no_speech_prob": 0.003452285658568144}, {"id": 80, "seek": 62504, "start": 625.04, "end": 632.9599999999999, "text": " in the Bluetooth white papers and basically those are just simple Python applications", "tokens": [294, 264, 20286, 2418, 10577, 293, 1936, 729, 366, 445, 2199, 15329, 5821], "temperature": 0.0, "avg_logprob": -0.1813744512097589, "compression_ratio": 1.511764705882353, "no_speech_prob": 0.0008313158177770674}, {"id": 81, "seek": 62504, "start": 632.9599999999999, "end": 642.24, "text": " that use the divas interface to basically communicate with the mesh demon over it.", "tokens": [300, 764, 264, 3414, 296, 9226, 281, 1936, 7890, 365, 264, 17407, 14283, 670, 309, 13], "temperature": 0.0, "avg_logprob": -0.1813744512097589, "compression_ratio": 1.511764705882353, "no_speech_prob": 0.0008313158177770674}, {"id": 82, "seek": 62504, "start": 642.24, "end": 653.56, "text": " So coming from this kind of state you could see the end goal that we try to do is to try", "tokens": [407, 1348, 490, 341, 733, 295, 1785, 291, 727, 536, 264, 917, 3387, 300, 321, 853, 281, 360, 307, 281, 853], "temperature": 0.0, "avg_logprob": -0.1813744512097589, "compression_ratio": 1.511764705882353, "no_speech_prob": 0.0008313158177770674}, {"id": 83, "seek": 65356, "start": 653.56, "end": 663.8399999999999, "text": " to see how far can we go with this tech and try to implement most of these things in Rust.", "tokens": [281, 536, 577, 1400, 393, 321, 352, 365, 341, 7553, 293, 853, 281, 4445, 881, 295, 613, 721, 294, 34952, 13], "temperature": 0.0, "avg_logprob": -0.1895197033882141, "compression_ratio": 1.4972375690607735, "no_speech_prob": 0.0007676774985156953}, {"id": 84, "seek": 65356, "start": 663.8399999999999, "end": 673.16, "text": " And now the question is why Rust of course and we found a very good solution for system", "tokens": [400, 586, 264, 1168, 307, 983, 34952, 295, 1164, 293, 321, 1352, 257, 588, 665, 3827, 337, 1185], "temperature": 0.0, "avg_logprob": -0.1895197033882141, "compression_ratio": 1.4972375690607735, "no_speech_prob": 0.0007676774985156953}, {"id": 85, "seek": 65356, "start": 673.16, "end": 681.4399999999999, "text": " programming so it basically allows us to create, it's statically compiled and strongly typed", "tokens": [9410, 370, 309, 1936, 4045, 505, 281, 1884, 11, 309, 311, 2219, 984, 36548, 293, 10613, 33941], "temperature": 0.0, "avg_logprob": -0.1895197033882141, "compression_ratio": 1.4972375690607735, "no_speech_prob": 0.0007676774985156953}, {"id": 86, "seek": 68144, "start": 681.44, "end": 698.8800000000001, "text": " which means that it has a strong preform.", "tokens": [597, 1355, 300, 309, 575, 257, 2068, 659, 837, 13], "temperature": 0.0, "avg_logprob": -0.32986506020150536, "compression_ratio": 1.3203125, "no_speech_prob": 0.0007100903312675655}, {"id": 87, "seek": 68144, "start": 698.8800000000001, "end": 705.48, "text": " Save programs without introducing runtimes and VMs, again a very suitable for system", "tokens": [15541, 4268, 1553, 15424, 49435, 1532, 293, 18038, 82, 11, 797, 257, 588, 12873, 337, 1185], "temperature": 0.0, "avg_logprob": -0.32986506020150536, "compression_ratio": 1.3203125, "no_speech_prob": 0.0007100903312675655}, {"id": 88, "seek": 68144, "start": 705.48, "end": 708.44, "text": " programming for this kind of applications.", "tokens": [9410, 337, 341, 733, 295, 5821, 13], "temperature": 0.0, "avg_logprob": -0.32986506020150536, "compression_ratio": 1.3203125, "no_speech_prob": 0.0007100903312675655}, {"id": 89, "seek": 70844, "start": 708.44, "end": 715.5600000000001, "text": " And finally it's a fairly modern language with a lot of good tooling so you know people", "tokens": [400, 2721, 309, 311, 257, 6457, 4363, 2856, 365, 257, 688, 295, 665, 46593, 370, 291, 458, 561], "temperature": 0.0, "avg_logprob": -0.19789016568982923, "compression_ratio": 1.5147058823529411, "no_speech_prob": 0.0010994069743901491}, {"id": 90, "seek": 70844, "start": 715.5600000000001, "end": 723.48, "text": " coming from other areas for example I don't consider myself an embedded programmer but", "tokens": [1348, 490, 661, 3179, 337, 1365, 286, 500, 380, 1949, 2059, 364, 16741, 32116, 457], "temperature": 0.0, "avg_logprob": -0.19789016568982923, "compression_ratio": 1.5147058823529411, "no_speech_prob": 0.0010994069743901491}, {"id": 91, "seek": 70844, "start": 723.48, "end": 732.2, "text": " I feel much more comfortable playing with Rust for these use cases than I would be if", "tokens": [286, 841, 709, 544, 4619, 2433, 365, 34952, 337, 613, 764, 3331, 813, 286, 576, 312, 498], "temperature": 0.0, "avg_logprob": -0.19789016568982923, "compression_ratio": 1.5147058823529411, "no_speech_prob": 0.0010994069743901491}, {"id": 92, "seek": 70844, "start": 732.2, "end": 737.44, "text": " I would try to do the same thing in a C so yeah.", "tokens": [286, 576, 853, 281, 360, 264, 912, 551, 294, 257, 383, 370, 1338, 13], "temperature": 0.0, "avg_logprob": -0.19789016568982923, "compression_ratio": 1.5147058823529411, "no_speech_prob": 0.0010994069743901491}, {"id": 93, "seek": 73744, "start": 737.44, "end": 746.9200000000001, "text": " So first thing we did is to create a bit mesh create and that's a basic create that we try", "tokens": [407, 700, 551, 321, 630, 307, 281, 1884, 257, 857, 17407, 1884, 293, 300, 311, 257, 3875, 1884, 300, 321, 853], "temperature": 0.0, "avg_logprob": -0.20871590834397535, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0005130154895596206}, {"id": 94, "seek": 73744, "start": 746.9200000000001, "end": 753.9200000000001, "text": " to do is to implement all the traits that are needed for implementing the Bluetooth", "tokens": [281, 360, 307, 281, 4445, 439, 264, 19526, 300, 366, 2978, 337, 18114, 264, 20286], "temperature": 0.0, "avg_logprob": -0.20871590834397535, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0005130154895596206}, {"id": 95, "seek": 73744, "start": 753.9200000000001, "end": 755.24, "text": " mesh specification.", "tokens": [17407, 31256, 13], "temperature": 0.0, "avg_logprob": -0.20871590834397535, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0005130154895596206}, {"id": 96, "seek": 73744, "start": 755.24, "end": 764.12, "text": " So as you remember all the layers of the Bluetooth mesh so everything needed for representing", "tokens": [407, 382, 291, 1604, 439, 264, 7914, 295, 264, 20286, 17407, 370, 1203, 2978, 337, 13460], "temperature": 0.0, "avg_logprob": -0.20871590834397535, "compression_ratio": 1.7777777777777777, "no_speech_prob": 0.0005130154895596206}, {"id": 97, "seek": 76412, "start": 764.12, "end": 771.32, "text": " the application models or the networking layer traits should be defined in this one", "tokens": [264, 3861, 5245, 420, 264, 17985, 4583, 19526, 820, 312, 7642, 294, 341, 472], "temperature": 0.0, "avg_logprob": -0.20696272778866895, "compression_ratio": 1.6890243902439024, "no_speech_prob": 0.0001777926809154451}, {"id": 98, "seek": 76412, "start": 771.32, "end": 782.0, "text": " create and as you can see you will see we will be able to reuse that in all different", "tokens": [1884, 293, 382, 291, 393, 536, 291, 486, 536, 321, 486, 312, 1075, 281, 26225, 300, 294, 439, 819], "temperature": 0.0, "avg_logprob": -0.20696272778866895, "compression_ratio": 1.6890243902439024, "no_speech_prob": 0.0001777926809154451}, {"id": 99, "seek": 76412, "start": 782.0, "end": 783.36, "text": " layers of the stack.", "tokens": [7914, 295, 264, 8630, 13], "temperature": 0.0, "avg_logprob": -0.20696272778866895, "compression_ratio": 1.6890243902439024, "no_speech_prob": 0.0001777926809154451}, {"id": 100, "seek": 76412, "start": 783.36, "end": 791.48, "text": " But in order to be able to reuse it in the embedded space that this create needs to be", "tokens": [583, 294, 1668, 281, 312, 1075, 281, 26225, 309, 294, 264, 16741, 1901, 300, 341, 1884, 2203, 281, 312], "temperature": 0.0, "avg_logprob": -0.20696272778866895, "compression_ratio": 1.6890243902439024, "no_speech_prob": 0.0001777926809154451}, {"id": 101, "seek": 79148, "start": 791.48, "end": 799.88, "text": " and no STD meaning that it shouldn't rely on a standard library.", "tokens": [293, 572, 4904, 35, 3620, 300, 309, 4659, 380, 10687, 322, 257, 3832, 6405, 13], "temperature": 0.0, "avg_logprob": -0.2072768020629883, "compression_ratio": 1.3496503496503496, "no_speech_prob": 0.00016829361265990883}, {"id": 102, "seek": 79148, "start": 799.88, "end": 812.52, "text": " And this is a kind of go to example to show how the sensor data representation could look", "tokens": [400, 341, 307, 257, 733, 295, 352, 281, 1365, 281, 855, 577, 264, 10200, 1412, 10290, 727, 574], "temperature": 0.0, "avg_logprob": -0.2072768020629883, "compression_ratio": 1.3496503496503496, "no_speech_prob": 0.00016829361265990883}, {"id": 103, "seek": 79148, "start": 812.52, "end": 821.12, "text": " like in defined by the BT mesh create.", "tokens": [411, 294, 7642, 538, 264, 31144, 17407, 1884, 13], "temperature": 0.0, "avg_logprob": -0.2072768020629883, "compression_ratio": 1.3496503496503496, "no_speech_prob": 0.00016829361265990883}, {"id": 104, "seek": 82112, "start": 821.12, "end": 827.28, "text": " So Rust embedded I think it's going so how many people here are using Rust today for", "tokens": [407, 34952, 16741, 286, 519, 309, 311, 516, 370, 577, 867, 561, 510, 366, 1228, 34952, 965, 337], "temperature": 0.0, "avg_logprob": -0.28569521669481623, "compression_ratio": 1.4836601307189543, "no_speech_prob": 0.0012685330584645271}, {"id": 105, "seek": 82112, "start": 827.28, "end": 830.32, "text": " embedded programming.", "tokens": [16741, 9410, 13], "temperature": 0.0, "avg_logprob": -0.28569521669481623, "compression_ratio": 1.4836601307189543, "no_speech_prob": 0.0012685330584645271}, {"id": 106, "seek": 82112, "start": 830.32, "end": 831.32, "text": " Let's go.", "tokens": [961, 311, 352, 13], "temperature": 0.0, "avg_logprob": -0.28569521669481623, "compression_ratio": 1.4836601307189543, "no_speech_prob": 0.0012685330584645271}, {"id": 107, "seek": 82112, "start": 831.32, "end": 835.5600000000001, "text": " So what's the goal here?", "tokens": [407, 437, 311, 264, 3387, 510, 30], "temperature": 0.0, "avg_logprob": -0.28569521669481623, "compression_ratio": 1.4836601307189543, "no_speech_prob": 0.0012685330584645271}, {"id": 108, "seek": 82112, "start": 835.5600000000001, "end": 842.6, "text": " There's a Rust embedded working group that are dedicated to this task and its goal is", "tokens": [821, 311, 257, 34952, 16741, 1364, 1594, 300, 366, 8374, 281, 341, 5633, 293, 1080, 3387, 307], "temperature": 0.0, "avg_logprob": -0.28569521669481623, "compression_ratio": 1.4836601307189543, "no_speech_prob": 0.0012685330584645271}, {"id": 109, "seek": 84260, "start": 842.6, "end": 851.72, "text": " to enable people to run firmware using Rust, firmware targeted to the microcontrollers", "tokens": [281, 9528, 561, 281, 1190, 30289, 1228, 34952, 11, 30289, 15045, 281, 264, 4532, 9000, 3970, 433], "temperature": 0.0, "avg_logprob": -0.23595596427348123, "compression_ratio": 1.4512820512820512, "no_speech_prob": 0.0011177131673321128}, {"id": 110, "seek": 84260, "start": 851.72, "end": 864.48, "text": " with the small RAM and ROM capabilities without operating system and without memory allocator.", "tokens": [365, 264, 1359, 14561, 293, 41678, 10862, 1553, 7447, 1185, 293, 1553, 4675, 12660, 1639, 13], "temperature": 0.0, "avg_logprob": -0.23595596427348123, "compression_ratio": 1.4512820512820512, "no_speech_prob": 0.0011177131673321128}, {"id": 111, "seek": 84260, "start": 864.48, "end": 869.6, "text": " As I said like we have only 20 minutes and there's a lot of things so I just giving you", "tokens": [1018, 286, 848, 411, 321, 362, 787, 945, 2077, 293, 456, 311, 257, 688, 295, 721, 370, 286, 445, 2902, 291], "temperature": 0.0, "avg_logprob": -0.23595596427348123, "compression_ratio": 1.4512820512820512, "no_speech_prob": 0.0011177131673321128}, {"id": 112, "seek": 84260, "start": 869.6, "end": 870.6, "text": " the pointers.", "tokens": [264, 44548, 13], "temperature": 0.0, "avg_logprob": -0.23595596427348123, "compression_ratio": 1.4512820512820512, "no_speech_prob": 0.0011177131673321128}, {"id": 113, "seek": 87060, "start": 870.6, "end": 878.2, "text": " So there's a lot more to be said about embedded Rust but we don't have that much time.", "tokens": [407, 456, 311, 257, 688, 544, 281, 312, 848, 466, 16741, 34952, 457, 321, 500, 380, 362, 300, 709, 565, 13], "temperature": 0.0, "avg_logprob": -0.20216529313908066, "compression_ratio": 1.6634615384615385, "no_speech_prob": 0.0011408294085413218}, {"id": 114, "seek": 87060, "start": 878.2, "end": 884.9200000000001, "text": " And the next thing, next cool thing as I said doing embedded with Rust is that it enables", "tokens": [400, 264, 958, 551, 11, 958, 1627, 551, 382, 286, 848, 884, 16741, 365, 34952, 307, 300, 309, 17077], "temperature": 0.0, "avg_logprob": -0.20216529313908066, "compression_ratio": 1.6634615384615385, "no_speech_prob": 0.0011408294085413218}, {"id": 115, "seek": 87060, "start": 884.9200000000001, "end": 890.0400000000001, "text": " you to do quite a model programming things even for the firmware.", "tokens": [291, 281, 360, 1596, 257, 2316, 9410, 721, 754, 337, 264, 30289, 13], "temperature": 0.0, "avg_logprob": -0.20216529313908066, "compression_ratio": 1.6634615384615385, "no_speech_prob": 0.0011408294085413218}, {"id": 116, "seek": 87060, "start": 890.0400000000001, "end": 895.72, "text": " So there's a project called embassy which allows us to use basically as in programming", "tokens": [407, 456, 311, 257, 1716, 1219, 38012, 597, 4045, 505, 281, 764, 1936, 382, 294, 9410], "temperature": 0.0, "avg_logprob": -0.20216529313908066, "compression_ratio": 1.6634615384615385, "no_speech_prob": 0.0011408294085413218}, {"id": 117, "seek": 87060, "start": 895.72, "end": 896.72, "text": " for the firmers.", "tokens": [337, 264, 6174, 433, 13], "temperature": 0.0, "avg_logprob": -0.20216529313908066, "compression_ratio": 1.6634615384615385, "no_speech_prob": 0.0011408294085413218}, {"id": 118, "seek": 89672, "start": 896.72, "end": 906.28, "text": " It provides a scheduler and the hardware abstractions that we can use to build quite capable asynchronous", "tokens": [467, 6417, 257, 12000, 260, 293, 264, 8837, 12649, 626, 300, 321, 393, 764, 281, 1322, 1596, 8189, 49174], "temperature": 0.0, "avg_logprob": -0.18967722401474463, "compression_ratio": 1.6, "no_speech_prob": 0.0011240099556744099}, {"id": 119, "seek": 89672, "start": 906.28, "end": 913.5600000000001, "text": " applications in Rust and it has a hardware support for all the major hardware platforms", "tokens": [5821, 294, 34952, 293, 309, 575, 257, 8837, 1406, 337, 439, 264, 2563, 8837, 9473], "temperature": 0.0, "avg_logprob": -0.18967722401474463, "compression_ratio": 1.6, "no_speech_prob": 0.0011240099556744099}, {"id": 120, "seek": 89672, "start": 913.5600000000001, "end": 914.5600000000001, "text": " today.", "tokens": [965, 13], "temperature": 0.0, "avg_logprob": -0.18967722401474463, "compression_ratio": 1.6, "no_speech_prob": 0.0011240099556744099}, {"id": 121, "seek": 89672, "start": 914.5600000000001, "end": 922.4, "text": " On top of that the project that we are involved in is building on top of the embassy and trying", "tokens": [1282, 1192, 295, 300, 264, 1716, 300, 321, 366, 3288, 294, 307, 2390, 322, 1192, 295, 264, 38012, 293, 1382], "temperature": 0.0, "avg_logprob": -0.18967722401474463, "compression_ratio": 1.6, "no_speech_prob": 0.0011240099556744099}, {"id": 122, "seek": 92240, "start": 922.4, "end": 928.4399999999999, "text": " to add more IoT things on top of the basic embedded development.", "tokens": [281, 909, 544, 30112, 721, 322, 1192, 295, 264, 3875, 16741, 3250, 13], "temperature": 0.0, "avg_logprob": -0.1580930267061506, "compression_ratio": 1.3908045977011494, "no_speech_prob": 0.00022825995984021574}, {"id": 123, "seek": 92240, "start": 928.4399999999999, "end": 935.72, "text": " So communication with the cloud in terms of MQTT or HTTP, trying to support use cases", "tokens": [407, 6101, 365, 264, 4588, 294, 2115, 295, 376, 48, 28178, 420, 33283, 11, 1382, 281, 1406, 764, 3331], "temperature": 0.0, "avg_logprob": -0.1580930267061506, "compression_ratio": 1.3908045977011494, "no_speech_prob": 0.00022825995984021574}, {"id": 124, "seek": 92240, "start": 935.72, "end": 947.8, "text": " like Bluetooth mesh and try to create more advanced applications like OTA firmware updates.", "tokens": [411, 20286, 17407, 293, 853, 281, 1884, 544, 7339, 5821, 411, 422, 8241, 30289, 9205, 13], "temperature": 0.0, "avg_logprob": -0.1580930267061506, "compression_ratio": 1.3908045977011494, "no_speech_prob": 0.00022825995984021574}, {"id": 125, "seek": 94780, "start": 947.8, "end": 956.4, "text": " And you can see here one of the examples from the workshop that we did that I'll mention", "tokens": [400, 291, 393, 536, 510, 472, 295, 264, 5110, 490, 264, 13541, 300, 321, 630, 300, 286, 603, 2152], "temperature": 0.0, "avg_logprob": -0.19062667846679687, "compression_ratio": 1.6614583333333333, "no_speech_prob": 0.0016263958532363176}, {"id": 126, "seek": 94780, "start": 956.4, "end": 963.28, "text": " later on is for example how we can use the Bitimesh create on the firmware to basically", "tokens": [1780, 322, 307, 337, 1365, 577, 321, 393, 764, 264, 9101, 332, 14935, 1884, 322, 264, 30289, 281, 1936], "temperature": 0.0, "avg_logprob": -0.19062667846679687, "compression_ratio": 1.6614583333333333, "no_speech_prob": 0.0016263958532363176}, {"id": 127, "seek": 94780, "start": 963.28, "end": 969.56, "text": " every time we read the sensor data we can package that sensor data in the proper sensor", "tokens": [633, 565, 321, 1401, 264, 10200, 1412, 321, 393, 7372, 300, 10200, 1412, 294, 264, 2296, 10200], "temperature": 0.0, "avg_logprob": -0.19062667846679687, "compression_ratio": 1.6614583333333333, "no_speech_prob": 0.0016263958532363176}, {"id": 128, "seek": 94780, "start": 969.56, "end": 975.28, "text": " Bluetooth mesh message and send it over the Bluetooth.", "tokens": [20286, 17407, 3636, 293, 2845, 309, 670, 264, 20286, 13], "temperature": 0.0, "avg_logprob": -0.19062667846679687, "compression_ratio": 1.6614583333333333, "no_speech_prob": 0.0016263958532363176}, {"id": 129, "seek": 97528, "start": 975.28, "end": 986.48, "text": " Then on the Linux side there's a project called Bluer which is part of the BlueZ Linux official", "tokens": [1396, 322, 264, 18734, 1252, 456, 311, 257, 1716, 1219, 2177, 5486, 597, 307, 644, 295, 264, 8510, 57, 18734, 4783], "temperature": 0.0, "avg_logprob": -0.2428143141699619, "compression_ratio": 1.6294117647058823, "no_speech_prob": 0.0003960556350648403}, {"id": 130, "seek": 97528, "start": 986.48, "end": 994.92, "text": " group which tries to implement all the Linux Bluetooth protocol stack in Rust and at the", "tokens": [1594, 597, 9898, 281, 4445, 439, 264, 18734, 20286, 10336, 8630, 294, 34952, 293, 412, 264], "temperature": 0.0, "avg_logprob": -0.2428143141699619, "compression_ratio": 1.6294117647058823, "no_speech_prob": 0.0003960556350648403}, {"id": 131, "seek": 97528, "start": 994.92, "end": 1003.16, "text": " moment it provides support for all the major features of the Bluetooth like get or Bluetooth", "tokens": [1623, 309, 6417, 1406, 337, 439, 264, 2563, 4122, 295, 264, 20286, 411, 483, 420, 20286], "temperature": 0.0, "avg_logprob": -0.2428143141699619, "compression_ratio": 1.6294117647058823, "no_speech_prob": 0.0003960556350648403}, {"id": 132, "seek": 100316, "start": 1003.16, "end": 1005.3199999999999, "text": " cloud energy.", "tokens": [4588, 2281, 13], "temperature": 0.0, "avg_logprob": -0.21453208923339845, "compression_ratio": 1.4831460674157304, "no_speech_prob": 0.0009008803754113615}, {"id": 133, "seek": 100316, "start": 1005.3199999999999, "end": 1012.6, "text": " What we try to do here is to provide support for the Bluetooth mesh in a similar way as", "tokens": [708, 321, 853, 281, 360, 510, 307, 281, 2893, 1406, 337, 264, 20286, 17407, 294, 257, 2531, 636, 382], "temperature": 0.0, "avg_logprob": -0.21453208923339845, "compression_ratio": 1.4831460674157304, "no_speech_prob": 0.0009008803754113615}, {"id": 134, "seek": 100316, "start": 1012.6, "end": 1016.56, "text": " the rest of the Bluer works.", "tokens": [264, 1472, 295, 264, 2177, 5486, 1985, 13], "temperature": 0.0, "avg_logprob": -0.21453208923339845, "compression_ratio": 1.4831460674157304, "no_speech_prob": 0.0009008803754113615}, {"id": 135, "seek": 100316, "start": 1016.56, "end": 1024.6399999999999, "text": " So again, nice thing about Rust is that you can use a lot of crates and existing technologies", "tokens": [407, 797, 11, 1481, 551, 466, 34952, 307, 300, 291, 393, 764, 257, 688, 295, 941, 1024, 293, 6741, 7943], "temperature": 0.0, "avg_logprob": -0.21453208923339845, "compression_ratio": 1.4831460674157304, "no_speech_prob": 0.0009008803754113615}, {"id": 136, "seek": 100316, "start": 1024.6399999999999, "end": 1027.56, "text": " that are there for different use cases.", "tokens": [300, 366, 456, 337, 819, 764, 3331, 13], "temperature": 0.0, "avg_logprob": -0.21453208923339845, "compression_ratio": 1.4831460674157304, "no_speech_prob": 0.0009008803754113615}, {"id": 137, "seek": 102756, "start": 1027.56, "end": 1036.24, "text": " So for example, a Bluer uses a Tokyo runtime, very frequently used runtime for building", "tokens": [407, 337, 1365, 11, 257, 2177, 5486, 4960, 257, 15147, 34474, 11, 588, 10374, 1143, 34474, 337, 2390], "temperature": 0.0, "avg_logprob": -0.26353613535563153, "compression_ratio": 1.4972972972972973, "no_speech_prob": 0.0006710187299177051}, {"id": 138, "seek": 102756, "start": 1036.24, "end": 1045.0, "text": " all kind of server applications in Rust and communicates with the mesh daemon over using", "tokens": [439, 733, 295, 7154, 5821, 294, 34952, 293, 3363, 1024, 365, 264, 17407, 1120, 36228, 670, 1228], "temperature": 0.0, "avg_logprob": -0.26353613535563153, "compression_ratio": 1.4972972972972973, "no_speech_prob": 0.0006710187299177051}, {"id": 139, "seek": 102756, "start": 1045.0, "end": 1047.8, "text": " the DBScrate.", "tokens": [264, 413, 8176, 66, 4404, 13], "temperature": 0.0, "avg_logprob": -0.26353613535563153, "compression_ratio": 1.4972972972972973, "no_speech_prob": 0.0006710187299177051}, {"id": 140, "seek": 102756, "start": 1047.8, "end": 1052.24, "text": " The good thing is and that was the part of the plan is to use the Bitimesh create here", "tokens": [440, 665, 551, 307, 293, 300, 390, 264, 644, 295, 264, 1393, 307, 281, 764, 264, 9101, 332, 14935, 1884, 510], "temperature": 0.0, "avg_logprob": -0.26353613535563153, "compression_ratio": 1.4972972972972973, "no_speech_prob": 0.0006710187299177051}, {"id": 141, "seek": 105224, "start": 1052.24, "end": 1058.88, "text": " as well to use for the mesh traits that we would need it.", "tokens": [382, 731, 281, 764, 337, 264, 17407, 19526, 300, 321, 576, 643, 309, 13], "temperature": 0.0, "avg_logprob": -0.168458608933437, "compression_ratio": 1.6185567010309279, "no_speech_prob": 0.0003911288222298026}, {"id": 142, "seek": 105224, "start": 1058.88, "end": 1065.6, "text": " So this is the quick architecture of how things work on the Linux so I hope you can", "tokens": [407, 341, 307, 264, 1702, 9482, 295, 577, 721, 589, 322, 264, 18734, 370, 286, 1454, 291, 393], "temperature": 0.0, "avg_logprob": -0.168458608933437, "compression_ratio": 1.6185567010309279, "no_speech_prob": 0.0003911288222298026}, {"id": 143, "seek": 105224, "start": 1065.6, "end": 1066.88, "text": " see it well.", "tokens": [536, 309, 731, 13], "temperature": 0.0, "avg_logprob": -0.168458608933437, "compression_ratio": 1.6185567010309279, "no_speech_prob": 0.0003911288222298026}, {"id": 144, "seek": 105224, "start": 1066.88, "end": 1073.0, "text": " So we have a mesh daemon which communicates directly with the devices.", "tokens": [407, 321, 362, 257, 17407, 1120, 36228, 597, 3363, 1024, 3838, 365, 264, 5759, 13], "temperature": 0.0, "avg_logprob": -0.168458608933437, "compression_ratio": 1.6185567010309279, "no_speech_prob": 0.0003911288222298026}, {"id": 145, "seek": 105224, "start": 1073.0, "end": 1081.68, "text": " It has its own state in the mesh config and the mesh storage volumes and it communicates", "tokens": [467, 575, 1080, 1065, 1785, 294, 264, 17407, 6662, 293, 264, 17407, 6725, 22219, 293, 309, 3363, 1024], "temperature": 0.0, "avg_logprob": -0.168458608933437, "compression_ratio": 1.6185567010309279, "no_speech_prob": 0.0003911288222298026}, {"id": 146, "seek": 108168, "start": 1081.68, "end": 1089.68, "text": " with using the system DBScrate to random applications, being the gateway application", "tokens": [365, 1228, 264, 1185, 413, 8176, 66, 4404, 281, 4974, 5821, 11, 885, 264, 28532, 3861], "temperature": 0.0, "avg_logprob": -0.16932298059332862, "compression_ratio": 1.5968586387434556, "no_speech_prob": 0.0006490983068943024}, {"id": 147, "seek": 108168, "start": 1089.68, "end": 1095.8400000000001, "text": " or some device simulator on the Linux as well.", "tokens": [420, 512, 4302, 32974, 322, 264, 18734, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.16932298059332862, "compression_ratio": 1.5968586387434556, "no_speech_prob": 0.0006490983068943024}, {"id": 148, "seek": 108168, "start": 1095.8400000000001, "end": 1102.88, "text": " But the good thing is that you can see here is that and this is one of the things that", "tokens": [583, 264, 665, 551, 307, 300, 291, 393, 536, 510, 307, 300, 293, 341, 307, 472, 295, 264, 721, 300], "temperature": 0.0, "avg_logprob": -0.16932298059332862, "compression_ratio": 1.5968586387434556, "no_speech_prob": 0.0006490983068943024}, {"id": 149, "seek": 108168, "start": 1102.88, "end": 1108.04, "text": " I personally like a lot about using Rust for these use cases is that this code running", "tokens": [286, 5665, 411, 257, 688, 466, 1228, 34952, 337, 613, 764, 3331, 307, 300, 341, 3089, 2614], "temperature": 0.0, "avg_logprob": -0.16932298059332862, "compression_ratio": 1.5968586387434556, "no_speech_prob": 0.0006490983068943024}, {"id": 150, "seek": 110804, "start": 1108.04, "end": 1113.8, "text": " on the Linux looks pretty much similar like the code running on the firmware.", "tokens": [322, 264, 18734, 1542, 1238, 709, 2531, 411, 264, 3089, 2614, 322, 264, 30289, 13], "temperature": 0.0, "avg_logprob": -0.15469998121261597, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.00047394412104040384}, {"id": 151, "seek": 110804, "start": 1113.8, "end": 1120.08, "text": " So here we are receiving the Bluetooth message, we are parsing it, we are creating a JSON", "tokens": [407, 510, 321, 366, 10040, 264, 20286, 3636, 11, 321, 366, 21156, 278, 309, 11, 321, 366, 4084, 257, 31828], "temperature": 0.0, "avg_logprob": -0.15469998121261597, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.00047394412104040384}, {"id": 152, "seek": 110804, "start": 1120.08, "end": 1124.48, "text": " out of it and sending it over the MQTT to the cloud.", "tokens": [484, 295, 309, 293, 7750, 309, 670, 264, 376, 48, 28178, 281, 264, 4588, 13], "temperature": 0.0, "avg_logprob": -0.15469998121261597, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.00047394412104040384}, {"id": 153, "seek": 110804, "start": 1124.48, "end": 1133.3999999999999, "text": " But you know, it's very easy for a single person to jump back and forth over the different", "tokens": [583, 291, 458, 11, 309, 311, 588, 1858, 337, 257, 2167, 954, 281, 3012, 646, 293, 5220, 670, 264, 819], "temperature": 0.0, "avg_logprob": -0.15469998121261597, "compression_ratio": 1.5245098039215685, "no_speech_prob": 0.00047394412104040384}, {"id": 154, "seek": 113340, "start": 1133.4, "end": 1141.0800000000002, "text": " stack layers and using the similar crates and a similar style code then it would be", "tokens": [8630, 7914, 293, 1228, 264, 2531, 941, 1024, 293, 257, 2531, 3758, 3089, 550, 309, 576, 312], "temperature": 0.0, "avg_logprob": -0.15723046695484835, "compression_ratio": 1.6226415094339623, "no_speech_prob": 0.0007002180791459978}, {"id": 155, "seek": 113340, "start": 1141.0800000000002, "end": 1149.52, "text": " if we go from writing a C for the firmware and then a Python code for the gateway and", "tokens": [498, 321, 352, 490, 3579, 257, 383, 337, 264, 30289, 293, 550, 257, 15329, 3089, 337, 264, 28532, 293], "temperature": 0.0, "avg_logprob": -0.15723046695484835, "compression_ratio": 1.6226415094339623, "no_speech_prob": 0.0007002180791459978}, {"id": 156, "seek": 113340, "start": 1149.52, "end": 1153.0800000000002, "text": " then doing something in Java in the cloud for example.", "tokens": [550, 884, 746, 294, 10745, 294, 264, 4588, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.15723046695484835, "compression_ratio": 1.6226415094339623, "no_speech_prob": 0.0007002180791459978}, {"id": 157, "seek": 113340, "start": 1153.0800000000002, "end": 1159.3200000000002, "text": " So the mesh support is not officially landed in Bloor and this is all my fault due to my", "tokens": [407, 264, 17407, 1406, 307, 406, 12053, 15336, 294, 9865, 284, 293, 341, 307, 439, 452, 7441, 3462, 281, 452], "temperature": 0.0, "avg_logprob": -0.15723046695484835, "compression_ratio": 1.6226415094339623, "no_speech_prob": 0.0007002180791459978}, {"id": 158, "seek": 113340, "start": 1159.3200000000002, "end": 1162.72, "text": " laziness and other priorities.", "tokens": [19320, 1324, 293, 661, 15503, 13], "temperature": 0.0, "avg_logprob": -0.15723046695484835, "compression_ratio": 1.6226415094339623, "no_speech_prob": 0.0007002180791459978}, {"id": 159, "seek": 116272, "start": 1162.72, "end": 1170.2, "text": " But hopefully this PR will be merged in the coming weeks, let's say.", "tokens": [583, 4696, 341, 11568, 486, 312, 36427, 294, 264, 1348, 3259, 11, 718, 311, 584, 13], "temperature": 0.0, "avg_logprob": -0.18948986951042623, "compression_ratio": 1.4183673469387754, "no_speech_prob": 0.0006937459111213684}, {"id": 160, "seek": 116272, "start": 1170.2, "end": 1176.72, "text": " Final part of the project that we have been building is to build a kind of IoT friendly", "tokens": [13443, 644, 295, 264, 1716, 300, 321, 362, 668, 2390, 307, 281, 1322, 257, 733, 295, 30112, 9208], "temperature": 0.0, "avg_logprob": -0.18948986951042623, "compression_ratio": 1.4183673469387754, "no_speech_prob": 0.0006937459111213684}, {"id": 161, "seek": 116272, "start": 1176.72, "end": 1181.72, "text": " cloud platform, again done in Rust.", "tokens": [4588, 3663, 11, 797, 1096, 294, 34952, 13], "temperature": 0.0, "avg_logprob": -0.18948986951042623, "compression_ratio": 1.4183673469387754, "no_speech_prob": 0.0006937459111213684}, {"id": 162, "seek": 116272, "start": 1181.72, "end": 1186.84, "text": " Here we try to provide all the services that your typical IoT application is needing.", "tokens": [1692, 321, 853, 281, 2893, 439, 264, 3328, 300, 428, 7476, 30112, 3861, 307, 18006, 13], "temperature": 0.0, "avg_logprob": -0.18948986951042623, "compression_ratio": 1.4183673469387754, "no_speech_prob": 0.0006937459111213684}, {"id": 163, "seek": 118684, "start": 1186.84, "end": 1193.4399999999998, "text": " So being able to do a lot of connectivity, having a capable device registry and being", "tokens": [407, 885, 1075, 281, 360, 257, 688, 295, 21095, 11, 1419, 257, 8189, 4302, 36468, 293, 885], "temperature": 0.0, "avg_logprob": -0.15084355974954272, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.00047171718324534595}, {"id": 164, "seek": 118684, "start": 1193.4399999999998, "end": 1201.08, "text": " able to integrate further into the cloud applications and using digital twinning and all these", "tokens": [1075, 281, 13365, 3052, 666, 264, 4588, 5821, 293, 1228, 4562, 18397, 773, 293, 439, 613], "temperature": 0.0, "avg_logprob": -0.15084355974954272, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.00047171718324534595}, {"id": 165, "seek": 118684, "start": 1201.08, "end": 1204.84, "text": " kind of things on the other side.", "tokens": [733, 295, 721, 322, 264, 661, 1252, 13], "temperature": 0.0, "avg_logprob": -0.15084355974954272, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.00047171718324534595}, {"id": 166, "seek": 118684, "start": 1204.84, "end": 1210.24, "text": " But again, I'm coming back to the same thing.", "tokens": [583, 797, 11, 286, 478, 1348, 646, 281, 264, 912, 551, 13], "temperature": 0.0, "avg_logprob": -0.15084355974954272, "compression_ratio": 1.5294117647058822, "no_speech_prob": 0.00047171718324534595}, {"id": 167, "seek": 121024, "start": 1210.24, "end": 1216.84, "text": " So there's a thing called payload converter in the cloud that can actually intercept our", "tokens": [407, 456, 311, 257, 551, 1219, 30918, 33905, 294, 264, 4588, 300, 393, 767, 24700, 527], "temperature": 0.0, "avg_logprob": -0.18154767219056475, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0004943471285514534}, {"id": 168, "seek": 121024, "start": 1216.84, "end": 1219.32, "text": " messages coming from the gateways.", "tokens": [7897, 1348, 490, 264, 8539, 942, 13], "temperature": 0.0, "avg_logprob": -0.18154767219056475, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0004943471285514534}, {"id": 169, "seek": 121024, "start": 1219.32, "end": 1227.44, "text": " And if you can remember in the previous example, we already parsed the Bluetooth messages and", "tokens": [400, 498, 291, 393, 1604, 294, 264, 3894, 1365, 11, 321, 1217, 21156, 292, 264, 20286, 7897, 293], "temperature": 0.0, "avg_logprob": -0.18154767219056475, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0004943471285514534}, {"id": 170, "seek": 121024, "start": 1227.44, "end": 1228.76, "text": " send them as a JSON.", "tokens": [2845, 552, 382, 257, 31828, 13], "temperature": 0.0, "avg_logprob": -0.18154767219056475, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0004943471285514534}, {"id": 171, "seek": 121024, "start": 1228.76, "end": 1234.72, "text": " But if your gateway is sending just the row bytes, you can do that thing on the cloud,", "tokens": [583, 498, 428, 28532, 307, 7750, 445, 264, 5386, 36088, 11, 291, 393, 360, 300, 551, 322, 264, 4588, 11], "temperature": 0.0, "avg_logprob": -0.18154767219056475, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0004943471285514534}, {"id": 172, "seek": 121024, "start": 1234.72, "end": 1238.92, "text": " again with the same crates and with a very similar code.", "tokens": [797, 365, 264, 912, 941, 1024, 293, 365, 257, 588, 2531, 3089, 13], "temperature": 0.0, "avg_logprob": -0.18154767219056475, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0004943471285514534}, {"id": 173, "seek": 123892, "start": 1238.92, "end": 1247.1200000000001, "text": " So we will parse the bytes, get the message, do some JSON processing, and forward that", "tokens": [407, 321, 486, 48377, 264, 36088, 11, 483, 264, 3636, 11, 360, 512, 31828, 9007, 11, 293, 2128, 300], "temperature": 0.0, "avg_logprob": -0.1406522104817052, "compression_ratio": 1.471698113207547, "no_speech_prob": 0.000545144488569349}, {"id": 174, "seek": 123892, "start": 1247.1200000000001, "end": 1253.0, "text": " message deeper into the cloud.", "tokens": [3636, 7731, 666, 264, 4588, 13], "temperature": 0.0, "avg_logprob": -0.1406522104817052, "compression_ratio": 1.471698113207547, "no_speech_prob": 0.000545144488569349}, {"id": 175, "seek": 123892, "start": 1253.0, "end": 1258.64, "text": " So we were playing with this for a while, and then there was a chance to actually try", "tokens": [407, 321, 645, 2433, 365, 341, 337, 257, 1339, 11, 293, 550, 456, 390, 257, 2931, 281, 767, 853], "temperature": 0.0, "avg_logprob": -0.1406522104817052, "compression_ratio": 1.471698113207547, "no_speech_prob": 0.000545144488569349}, {"id": 176, "seek": 123892, "start": 1258.64, "end": 1262.6000000000001, "text": " to put this all into the work.", "tokens": [281, 829, 341, 439, 666, 264, 589, 13], "temperature": 0.0, "avg_logprob": -0.1406522104817052, "compression_ratio": 1.471698113207547, "no_speech_prob": 0.000545144488569349}, {"id": 177, "seek": 126260, "start": 1262.6, "end": 1271.1999999999998, "text": " With the EclipseCon, we had a hackathon and a workshop where we tried to cover the whole", "tokens": [2022, 264, 462, 27197, 9838, 11, 321, 632, 257, 10339, 18660, 293, 257, 13541, 689, 321, 3031, 281, 2060, 264, 1379], "temperature": 0.0, "avg_logprob": -0.1848678846617003, "compression_ratio": 1.54, "no_speech_prob": 0.0007607156876474619}, {"id": 178, "seek": 126260, "start": 1271.1999999999998, "end": 1277.8799999999999, "text": " area with the Bluetooth mesh network, provide the microbeads for people to play around with,", "tokens": [1859, 365, 264, 20286, 17407, 3209, 11, 2893, 264, 4532, 650, 5834, 337, 561, 281, 862, 926, 365, 11], "temperature": 0.0, "avg_logprob": -0.1848678846617003, "compression_ratio": 1.54, "no_speech_prob": 0.0007607156876474619}, {"id": 179, "seek": 126260, "start": 1277.8799999999999, "end": 1285.04, "text": " and provide some basic applications in the cloud that will talk to each other.", "tokens": [293, 2893, 512, 3875, 5821, 294, 264, 4588, 300, 486, 751, 281, 1184, 661, 13], "temperature": 0.0, "avg_logprob": -0.1848678846617003, "compression_ratio": 1.54, "no_speech_prob": 0.0007607156876474619}, {"id": 180, "seek": 126260, "start": 1285.04, "end": 1290.52, "text": " But the basic big architecture looks like this.", "tokens": [583, 264, 3875, 955, 9482, 1542, 411, 341, 13], "temperature": 0.0, "avg_logprob": -0.1848678846617003, "compression_ratio": 1.54, "no_speech_prob": 0.0007607156876474619}, {"id": 181, "seek": 129052, "start": 1290.52, "end": 1297.68, "text": " So we have a public sandbox for our drug cloud consisting of Kafka and all this kind of stuff.", "tokens": [407, 321, 362, 257, 1908, 42115, 337, 527, 4110, 4588, 33921, 295, 47064, 293, 439, 341, 733, 295, 1507, 13], "temperature": 0.0, "avg_logprob": -0.19390391154461598, "compression_ratio": 1.5377777777777777, "no_speech_prob": 0.0005524840671569109}, {"id": 182, "seek": 129052, "start": 1297.68, "end": 1300.28, "text": " And we brought the gateway based on the Bloor.", "tokens": [400, 321, 3038, 264, 28532, 2361, 322, 264, 9865, 284, 13], "temperature": 0.0, "avg_logprob": -0.19390391154461598, "compression_ratio": 1.5377777777777777, "no_speech_prob": 0.0005524840671569109}, {"id": 183, "seek": 129052, "start": 1300.28, "end": 1311.92, "text": " We provided some examples of how to use microbeads with the Rust embedded drug device and embassy,", "tokens": [492, 5649, 512, 5110, 295, 577, 281, 764, 4532, 650, 5834, 365, 264, 34952, 16741, 4110, 4302, 293, 38012, 11], "temperature": 0.0, "avg_logprob": -0.19390391154461598, "compression_ratio": 1.5377777777777777, "no_speech_prob": 0.0005524840671569109}, {"id": 184, "seek": 129052, "start": 1311.92, "end": 1317.84, "text": " and provided a couple of applications that will talk to the cloud using the web socket", "tokens": [293, 5649, 257, 1916, 295, 5821, 300, 486, 751, 281, 264, 4588, 1228, 264, 3670, 19741], "temperature": 0.0, "avg_logprob": -0.19390391154461598, "compression_ratio": 1.5377777777777777, "no_speech_prob": 0.0005524840671569109}, {"id": 185, "seek": 129052, "start": 1317.84, "end": 1319.8799999999999, "text": " in the background.", "tokens": [294, 264, 3678, 13], "temperature": 0.0, "avg_logprob": -0.19390391154461598, "compression_ratio": 1.5377777777777777, "no_speech_prob": 0.0005524840671569109}, {"id": 186, "seek": 131988, "start": 1319.88, "end": 1326.96, "text": " So just to recap how this architecture looks on the firmware.", "tokens": [407, 445, 281, 20928, 577, 341, 9482, 1542, 322, 264, 30289, 13], "temperature": 0.0, "avg_logprob": -0.1902057303756964, "compression_ratio": 1.4556962025316456, "no_speech_prob": 0.0008365410612896085}, {"id": 187, "seek": 131988, "start": 1326.96, "end": 1335.24, "text": " So you have a couple of layers, the embassy and the Bluetooth radio on the bottom.", "tokens": [407, 291, 362, 257, 1916, 295, 7914, 11, 264, 38012, 293, 264, 20286, 6477, 322, 264, 2767, 13], "temperature": 0.0, "avg_logprob": -0.1902057303756964, "compression_ratio": 1.4556962025316456, "no_speech_prob": 0.0008365410612896085}, {"id": 188, "seek": 131988, "start": 1335.24, "end": 1341.2, "text": " Then we have a drug device and the BTMesh support next on, and on top of that, we can", "tokens": [1396, 321, 362, 257, 4110, 4302, 293, 264, 31144, 44, 14935, 1406, 958, 322, 11, 293, 322, 1192, 295, 300, 11, 321, 393], "temperature": 0.0, "avg_logprob": -0.1902057303756964, "compression_ratio": 1.4556962025316456, "no_speech_prob": 0.0008365410612896085}, {"id": 189, "seek": 134120, "start": 1341.2, "end": 1350.76, "text": " write our own application that will do things with these messages.", "tokens": [2464, 527, 1065, 3861, 300, 486, 360, 721, 365, 613, 7897, 13], "temperature": 0.0, "avg_logprob": -0.14341889053094584, "compression_ratio": 1.5125, "no_speech_prob": 0.00034881566534750164}, {"id": 190, "seek": 134120, "start": 1350.76, "end": 1355.56, "text": " On the gateway side, we implemented the gateway using the Bloor.", "tokens": [1282, 264, 28532, 1252, 11, 321, 12270, 264, 28532, 1228, 264, 9865, 284, 13], "temperature": 0.0, "avg_logprob": -0.14341889053094584, "compression_ratio": 1.5125, "no_speech_prob": 0.00034881566534750164}, {"id": 191, "seek": 134120, "start": 1355.56, "end": 1362.8, "text": " And we also tried to use some of the, so to say, latest edge technologies to deploy and", "tokens": [400, 321, 611, 3031, 281, 764, 512, 295, 264, 11, 370, 281, 584, 11, 6792, 4691, 7943, 281, 7274, 293], "temperature": 0.0, "avg_logprob": -0.14341889053094584, "compression_ratio": 1.5125, "no_speech_prob": 0.00034881566534750164}, {"id": 192, "seek": 134120, "start": 1362.8, "end": 1364.44, "text": " manage those gateways.", "tokens": [3067, 729, 8539, 942, 13], "temperature": 0.0, "avg_logprob": -0.14341889053094584, "compression_ratio": 1.5125, "no_speech_prob": 0.00034881566534750164}, {"id": 193, "seek": 136444, "start": 1364.44, "end": 1371.3600000000001, "text": " So trying to use MicroShift, which is the RedHeads version of the single node Kubernetes cluster,", "tokens": [407, 1382, 281, 764, 25642, 7774, 2008, 11, 597, 307, 264, 4477, 39, 2056, 82, 3037, 295, 264, 2167, 9984, 23145, 13630, 11], "temperature": 0.0, "avg_logprob": -0.2768761089869908, "compression_ratio": 1.4753363228699552, "no_speech_prob": 0.0008017070358619094}, {"id": 194, "seek": 136444, "start": 1371.3600000000001, "end": 1379.8400000000001, "text": " paired with the open cluster management to deploy these gateways to appropriate nodes.", "tokens": [25699, 365, 264, 1269, 13630, 4592, 281, 7274, 613, 8539, 942, 281, 6854, 13891, 13], "temperature": 0.0, "avg_logprob": -0.2768761089869908, "compression_ratio": 1.4753363228699552, "no_speech_prob": 0.0008017070358619094}, {"id": 195, "seek": 136444, "start": 1379.8400000000001, "end": 1385.4, "text": " And I must say, to my surprise, it all worked pretty well.", "tokens": [400, 286, 1633, 584, 11, 281, 452, 6365, 11, 309, 439, 2732, 1238, 731, 13], "temperature": 0.0, "avg_logprob": -0.2768761089869908, "compression_ratio": 1.4753363228699552, "no_speech_prob": 0.0008017070358619094}, {"id": 196, "seek": 136444, "start": 1385.4, "end": 1391.04, "text": " So we had like a four or five gateways based on the Intel Nux and some Raspberry Pis.", "tokens": [407, 321, 632, 411, 257, 1451, 420, 1732, 8539, 942, 2361, 322, 264, 19762, 426, 2449, 293, 512, 41154, 43263, 13], "temperature": 0.0, "avg_logprob": -0.2768761089869908, "compression_ratio": 1.4753363228699552, "no_speech_prob": 0.0008017070358619094}, {"id": 197, "seek": 139104, "start": 1391.04, "end": 1397.28, "text": " Because Raspberry Pis didn't run the Kubernetes, we used the basic podman and the Docker images", "tokens": [1436, 41154, 43263, 994, 380, 1190, 264, 23145, 11, 321, 1143, 264, 3875, 2497, 1601, 293, 264, 33772, 5267], "temperature": 0.0, "avg_logprob": -0.17178014119466145, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0016558239003643394}, {"id": 198, "seek": 139104, "start": 1397.28, "end": 1399.48, "text": " to run the gateways.", "tokens": [281, 1190, 264, 8539, 942, 13], "temperature": 0.0, "avg_logprob": -0.17178014119466145, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0016558239003643394}, {"id": 199, "seek": 139104, "start": 1399.48, "end": 1404.28, "text": " And that provides a very good coverage of a very large space.", "tokens": [400, 300, 6417, 257, 588, 665, 9645, 295, 257, 588, 2416, 1901, 13], "temperature": 0.0, "avg_logprob": -0.17178014119466145, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0016558239003643394}, {"id": 200, "seek": 139104, "start": 1404.28, "end": 1408.44, "text": " What we needed to do is to provide a couple of relay nodes.", "tokens": [708, 321, 2978, 281, 360, 307, 281, 2893, 257, 1916, 295, 24214, 13891, 13], "temperature": 0.0, "avg_logprob": -0.17178014119466145, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0016558239003643394}, {"id": 201, "seek": 139104, "start": 1408.44, "end": 1416.6399999999999, "text": " You can see on this other picture, is to just to basically extend the range over some longer", "tokens": [509, 393, 536, 322, 341, 661, 3036, 11, 307, 281, 445, 281, 1936, 10101, 264, 3613, 670, 512, 2854], "temperature": 0.0, "avg_logprob": -0.17178014119466145, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0016558239003643394}, {"id": 202, "seek": 139104, "start": 1416.6399999999999, "end": 1419.68, "text": " corridors that were there.", "tokens": [46920, 300, 645, 456, 13], "temperature": 0.0, "avg_logprob": -0.17178014119466145, "compression_ratio": 1.5982142857142858, "no_speech_prob": 0.0016558239003643394}, {"id": 203, "seek": 141968, "start": 1419.68, "end": 1428.3600000000001, "text": " But everything worked pretty good from this perspective.", "tokens": [583, 1203, 2732, 1238, 665, 490, 341, 4585, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 204, "seek": 141968, "start": 1428.3600000000001, "end": 1433.44, "text": " So that's all what I have to cover today.", "tokens": [407, 300, 311, 439, 437, 286, 362, 281, 2060, 965, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 205, "seek": 141968, "start": 1433.44, "end": 1435.92, "text": " So as I said, there's a lot of teasers.", "tokens": [407, 382, 286, 848, 11, 456, 311, 257, 688, 295, 11488, 433, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 206, "seek": 141968, "start": 1435.92, "end": 1439.02, "text": " We didn't get into anything too much deeply.", "tokens": [492, 994, 380, 483, 666, 1340, 886, 709, 8760, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 207, "seek": 141968, "start": 1439.02, "end": 1440.52, "text": " But these are the communities.", "tokens": [583, 613, 366, 264, 4456, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 208, "seek": 141968, "start": 1440.52, "end": 1443.88, "text": " So hit us on the Drug IoT metrics channel.", "tokens": [407, 2045, 505, 322, 264, 35806, 30112, 16367, 2269, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 209, "seek": 141968, "start": 1443.88, "end": 1449.16, "text": " That's where we all hang and are happy to talk about these things.", "tokens": [663, 311, 689, 321, 439, 3967, 293, 366, 2055, 281, 751, 466, 613, 721, 13], "temperature": 0.0, "avg_logprob": -0.1767361323038737, "compression_ratio": 1.5211267605633803, "no_speech_prob": 0.0030755705665796995}, {"id": 210, "seek": 144916, "start": 1449.16, "end": 1453.88, "text": " If you're interested in EBC, I would suggest to take a look at that and the Bloor thing,", "tokens": [759, 291, 434, 3102, 294, 462, 7869, 11, 286, 576, 3402, 281, 747, 257, 574, 412, 300, 293, 264, 9865, 284, 551, 11], "temperature": 0.0, "avg_logprob": -0.4722305211153897, "compression_ratio": 1.2, "no_speech_prob": 0.005001756362617016}, {"id": 211, "seek": 144916, "start": 1453.88, "end": 1457.6000000000001, "text": " hopefully with the official BTMesh support very soon.", "tokens": [4696, 365, 264, 4783, 31144, 44, 14935, 1406, 588, 2321, 13], "temperature": 0.0, "avg_logprob": -0.4722305211153897, "compression_ratio": 1.2, "no_speech_prob": 0.005001756362617016}, {"id": 212, "seek": 144916, "start": 1457.6000000000001, "end": 1458.6000000000001, "text": " Thanks.", "tokens": [2561, 13], "temperature": 0.0, "avg_logprob": -0.4722305211153897, "compression_ratio": 1.2, "no_speech_prob": 0.005001756362617016}, {"id": 213, "seek": 145860, "start": 1458.6, "end": 1477.04, "text": " Thank you very much.", "tokens": [1044, 291, 588, 709, 13], "temperature": 1.0, "avg_logprob": -1.9180890719095867, "compression_ratio": 0.8235294117647058, "no_speech_prob": 0.0009423258597962558}], "language": "en"}