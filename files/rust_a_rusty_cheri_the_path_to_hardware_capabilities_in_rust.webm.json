{"text": " Yeah, so my talk is about modifying the Rust compiler to support Cherry's hardware capabilities. I'm going to start off with a brief introduction. My name is Lewis Reville, and I work for a company called Embercosm. I work on many things, but I'd say I specialize in developing LLVM backends for constrained or unusual architectures. Embercosm itself is a software services company. We operate in the boundary between hardware and software, particularly in the embedded space where you can find many unusual, difficult and interesting problems like writing compilers. So what is Cherry? It's an acronym capability hardware enhanced risk instructions. It's best described as an instruction set extension, which can be adapted and applied to different architectures. The main feature of Cherry is that you can encode access constraints on memory addresses using things called capabilities. Capabilities essentially have metadata alongside memory addresses that allow you to specify these access constraints. These can only be operated on using capability operations, which replace the normal pointer operations, and these operations utilize the metadata to enforce those access constraints. It's worth pointing out there are two modes of operation for Cherry. There's pure cap mode where all pointers are capabilities, and in hybrid mode you have pointers by default on normal pointers, but capabilities are annotated as such in the source code. So capabilities together with capability operations allow you to enforce spatial, referential and temporal safety in the hardware at runtime. Spatial safety is to do with disallowing accesses out of bounds of an original allocation. Temporal safety is disallowing accesses without valid provenance, and temporal safety means that if the lifetime of an object is over, you can no longer access it through a capability. So what about integrating Cherry and Rust? Well, we're working on this as part of a project which is led by our customer Cyberhive. They're funded in turn by Digital Security by Design, which is a UK government initiative. Cyberhive want to use Cherry hardware to enhance secure network protocols that are written in Rust. So the goal for us then is to produce a Rust compiler that's capable of targeting Cherry-based architectures, with the long-term goal of a stable compiler that can produce production ready code for security purposes. We know that we're initially going to be targeting ARM's Morello platform. So other than being able to compile existing Rust code for Cherry, what's the motivation between integrating Cherry and Rust? Essentially it boils down to another layer of protection. We know that Rust is good at identifying and enforcing access constraints at compile time, but with Cherry you can identify constraints at compile time and enforce them in hardware at runtime. So a good example is that Rust code annotated with unsafe is often a necessity in many real world projects, which means that it could behave badly, but we don't know until runtime. With Cherry you can prevent this bad behavior in hardware when it occurs at runtime. There's some other small side benefits such as replacing slow software bounce checks with hardware bounce checking and replacing pointer plus length types with Cherry capabilities. So to make things more clear, I have a motivating example. So say we want to add a dynamic offset to a pointer and then load from that pointer. Well this needs to be done in an unsafe block because we don't know until runtime if it's going to do something bad. Without Cherry you could end up accessing out of range of your original allocated array, but with Cherry that access will not occur at runtime and the hardware will either panic or give you something, a default value. So now that we know that we want these benefits, how do we go about modifying Rust to get them? The main problem is that we need to account for capability sizes correctly, that is we need to stop assuming that pointer type size is equal to the addressable range of the pointer because capabilities have metadata, this isn't the case. Also in LLVM, in the Cherry LLVM fork capabilities are pointers in address space 200, whereas in Rust it seems like we assume that all pointers to data are in address space zero. Also if we want to support hybrid mode we need to be able to specify different pointer type sizes for different address spaces, so address space zero will have different sizes from address space 200. One thing I hope doesn't require many changes is that we need provenance and bounds to be propagated through the compiler because they need to be attached to capabilities. And of course if we want the optional bonus stuff we need to implement that as well. Progress so far, so the data layout changes are completed, which means that we can correctly specify capability sizes, both the type size and the addressable range for both pure cap and hybrid mode. I have modified APIs which produce pointer types to get rid of the assumption that pointers are in address space zero and now these APIs require an explicit address space parameter. And the biggest change is that for APIs where we have a, where we report a size for a type, this is replaced with a total type size and a size of the value that you can represent. And yeah, this means that, like I said before, we can support cherry capabilities. There's also in the strict provenance API there is an explicit unsafe method of producing pointers with no provenance from a U size. And for cherry we need to use cherry operations to set the address of a null capability to achieve the same result. What I'm currently working through is trawling through assertion failures that come up when building the core libraries with this modified compiler. What still needs to be done, well, there's almost definitely going to be modifications to the libraries to remove any assumptions that break for cherry. There's also the question of how do we specify capability types in hybrid mode and because I don't think that Rust annotations are the right tool to specify a specific pointer as being a capability, I think this requires a library solution. For APIs where I have replaced a size with a type size and added a size of the value that you can represent, we need to go through all of those uses of the type size and see if they should really be using the size of the value that you can represent because this is the main cause of the errors that I'm seeing in building the libraries. And of course, a lot of testing and polishing is going to be required. Before I finish this talk, I do need to mention that there's ongoing and past work that is in this same area. There was a master's thesis from the University of Cambridge and there's another government funded project from the University of Kent. And well, thank you for listening. Please feel free to check out the code on GitHub or ask me any questions outside.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 16.64, "text": " Yeah, so my talk is about modifying the Rust compiler to support Cherry's hardware capabilities.", "tokens": [865, 11, 370, 452, 751, 307, 466, 42626, 264, 34952, 31958, 281, 1406, 34831, 311, 8837, 10862, 13], "temperature": 0.0, "avg_logprob": -0.21766946315765381, "compression_ratio": 1.3891402714932126, "no_speech_prob": 0.2668398916721344}, {"id": 1, "seek": 0, "start": 16.64, "end": 18.88, "text": " I'm going to start off with a brief introduction.", "tokens": [286, 478, 516, 281, 722, 766, 365, 257, 5353, 9339, 13], "temperature": 0.0, "avg_logprob": -0.21766946315765381, "compression_ratio": 1.3891402714932126, "no_speech_prob": 0.2668398916721344}, {"id": 2, "seek": 0, "start": 18.88, "end": 23.240000000000002, "text": " My name is Lewis Reville, and I work for a company called Embercosm.", "tokens": [1222, 1315, 307, 17412, 1300, 8386, 11, 293, 286, 589, 337, 257, 2237, 1219, 3968, 607, 6877, 76, 13], "temperature": 0.0, "avg_logprob": -0.21766946315765381, "compression_ratio": 1.3891402714932126, "no_speech_prob": 0.2668398916721344}, {"id": 3, "seek": 0, "start": 23.240000000000002, "end": 28.400000000000002, "text": " I work on many things, but I'd say I specialize in developing LLVM backends for constrained", "tokens": [286, 589, 322, 867, 721, 11, 457, 286, 1116, 584, 286, 37938, 294, 6416, 441, 43, 53, 44, 646, 2581, 337, 38901], "temperature": 0.0, "avg_logprob": -0.21766946315765381, "compression_ratio": 1.3891402714932126, "no_speech_prob": 0.2668398916721344}, {"id": 4, "seek": 2840, "start": 28.4, "end": 32.16, "text": " or unusual architectures.", "tokens": [420, 10901, 6331, 1303, 13], "temperature": 0.0, "avg_logprob": -0.16567086554192878, "compression_ratio": 1.5336322869955157, "no_speech_prob": 0.00010863460920518264}, {"id": 5, "seek": 2840, "start": 32.16, "end": 35.36, "text": " Embercosm itself is a software services company.", "tokens": [3968, 607, 6877, 76, 2564, 307, 257, 4722, 3328, 2237, 13], "temperature": 0.0, "avg_logprob": -0.16567086554192878, "compression_ratio": 1.5336322869955157, "no_speech_prob": 0.00010863460920518264}, {"id": 6, "seek": 2840, "start": 35.36, "end": 40.04, "text": " We operate in the boundary between hardware and software, particularly in the embedded", "tokens": [492, 9651, 294, 264, 12866, 1296, 8837, 293, 4722, 11, 4098, 294, 264, 16741], "temperature": 0.0, "avg_logprob": -0.16567086554192878, "compression_ratio": 1.5336322869955157, "no_speech_prob": 0.00010863460920518264}, {"id": 7, "seek": 2840, "start": 40.04, "end": 48.879999999999995, "text": " space where you can find many unusual, difficult and interesting problems like writing compilers.", "tokens": [1901, 689, 291, 393, 915, 867, 10901, 11, 2252, 293, 1880, 2740, 411, 3579, 715, 388, 433, 13], "temperature": 0.0, "avg_logprob": -0.16567086554192878, "compression_ratio": 1.5336322869955157, "no_speech_prob": 0.00010863460920518264}, {"id": 8, "seek": 2840, "start": 48.879999999999995, "end": 50.32, "text": " So what is Cherry?", "tokens": [407, 437, 307, 34831, 30], "temperature": 0.0, "avg_logprob": -0.16567086554192878, "compression_ratio": 1.5336322869955157, "no_speech_prob": 0.00010863460920518264}, {"id": 9, "seek": 2840, "start": 50.32, "end": 54.0, "text": " It's an acronym capability hardware enhanced risk instructions.", "tokens": [467, 311, 364, 39195, 13759, 8837, 21191, 3148, 9415, 13], "temperature": 0.0, "avg_logprob": -0.16567086554192878, "compression_ratio": 1.5336322869955157, "no_speech_prob": 0.00010863460920518264}, {"id": 10, "seek": 5400, "start": 54.0, "end": 58.52, "text": " It's best described as an instruction set extension, which can be adapted and applied", "tokens": [467, 311, 1151, 7619, 382, 364, 10951, 992, 10320, 11, 597, 393, 312, 20871, 293, 6456], "temperature": 0.0, "avg_logprob": -0.14468537944636933, "compression_ratio": 1.6542056074766356, "no_speech_prob": 5.995960600557737e-05}, {"id": 11, "seek": 5400, "start": 58.52, "end": 60.72, "text": " to different architectures.", "tokens": [281, 819, 6331, 1303, 13], "temperature": 0.0, "avg_logprob": -0.14468537944636933, "compression_ratio": 1.6542056074766356, "no_speech_prob": 5.995960600557737e-05}, {"id": 12, "seek": 5400, "start": 60.72, "end": 66.12, "text": " The main feature of Cherry is that you can encode access constraints on memory addresses", "tokens": [440, 2135, 4111, 295, 34831, 307, 300, 291, 393, 2058, 1429, 2105, 18491, 322, 4675, 16862], "temperature": 0.0, "avg_logprob": -0.14468537944636933, "compression_ratio": 1.6542056074766356, "no_speech_prob": 5.995960600557737e-05}, {"id": 13, "seek": 5400, "start": 66.12, "end": 69.52, "text": " using things called capabilities.", "tokens": [1228, 721, 1219, 10862, 13], "temperature": 0.0, "avg_logprob": -0.14468537944636933, "compression_ratio": 1.6542056074766356, "no_speech_prob": 5.995960600557737e-05}, {"id": 14, "seek": 5400, "start": 69.52, "end": 75.68, "text": " Capabilities essentially have metadata alongside memory addresses that allow you to specify", "tokens": [8363, 6167, 4476, 362, 26603, 12385, 4675, 16862, 300, 2089, 291, 281, 16500], "temperature": 0.0, "avg_logprob": -0.14468537944636933, "compression_ratio": 1.6542056074766356, "no_speech_prob": 5.995960600557737e-05}, {"id": 15, "seek": 5400, "start": 75.68, "end": 79.12, "text": " these access constraints.", "tokens": [613, 2105, 18491, 13], "temperature": 0.0, "avg_logprob": -0.14468537944636933, "compression_ratio": 1.6542056074766356, "no_speech_prob": 5.995960600557737e-05}, {"id": 16, "seek": 7912, "start": 79.12, "end": 85.36, "text": " These can only be operated on using capability operations, which replace the normal pointer", "tokens": [1981, 393, 787, 312, 20826, 322, 1228, 13759, 7705, 11, 597, 7406, 264, 2710, 23918], "temperature": 0.0, "avg_logprob": -0.1637213843209403, "compression_ratio": 1.681592039800995, "no_speech_prob": 0.00013268749171402305}, {"id": 17, "seek": 7912, "start": 85.36, "end": 92.92, "text": " operations, and these operations utilize the metadata to enforce those access constraints.", "tokens": [7705, 11, 293, 613, 7705, 16117, 264, 26603, 281, 24825, 729, 2105, 18491, 13], "temperature": 0.0, "avg_logprob": -0.1637213843209403, "compression_ratio": 1.681592039800995, "no_speech_prob": 0.00013268749171402305}, {"id": 18, "seek": 7912, "start": 92.92, "end": 96.80000000000001, "text": " It's worth pointing out there are two modes of operation for Cherry.", "tokens": [467, 311, 3163, 12166, 484, 456, 366, 732, 14068, 295, 6916, 337, 34831, 13], "temperature": 0.0, "avg_logprob": -0.1637213843209403, "compression_ratio": 1.681592039800995, "no_speech_prob": 0.00013268749171402305}, {"id": 19, "seek": 7912, "start": 96.80000000000001, "end": 103.92, "text": " There's pure cap mode where all pointers are capabilities, and in hybrid mode you have", "tokens": [821, 311, 6075, 1410, 4391, 689, 439, 44548, 366, 10862, 11, 293, 294, 13051, 4391, 291, 362], "temperature": 0.0, "avg_logprob": -0.1637213843209403, "compression_ratio": 1.681592039800995, "no_speech_prob": 0.00013268749171402305}, {"id": 20, "seek": 10392, "start": 103.92, "end": 109.12, "text": " pointers by default on normal pointers, but capabilities are annotated as such in the source", "tokens": [44548, 538, 7576, 322, 2710, 44548, 11, 457, 10862, 366, 25339, 770, 382, 1270, 294, 264, 4009], "temperature": 0.0, "avg_logprob": -0.12668192545572918, "compression_ratio": 1.6802030456852792, "no_speech_prob": 7.306547922780737e-05}, {"id": 21, "seek": 10392, "start": 109.12, "end": 111.28, "text": " code.", "tokens": [3089, 13], "temperature": 0.0, "avg_logprob": -0.12668192545572918, "compression_ratio": 1.6802030456852792, "no_speech_prob": 7.306547922780737e-05}, {"id": 22, "seek": 10392, "start": 111.28, "end": 117.8, "text": " So capabilities together with capability operations allow you to enforce spatial, referential and", "tokens": [407, 10862, 1214, 365, 13759, 7705, 2089, 291, 281, 24825, 23598, 11, 2864, 2549, 293], "temperature": 0.0, "avg_logprob": -0.12668192545572918, "compression_ratio": 1.6802030456852792, "no_speech_prob": 7.306547922780737e-05}, {"id": 23, "seek": 10392, "start": 117.8, "end": 122.28, "text": " temporal safety in the hardware at runtime.", "tokens": [30881, 4514, 294, 264, 8837, 412, 34474, 13], "temperature": 0.0, "avg_logprob": -0.12668192545572918, "compression_ratio": 1.6802030456852792, "no_speech_prob": 7.306547922780737e-05}, {"id": 24, "seek": 10392, "start": 122.28, "end": 129.16, "text": " Spatial safety is to do with disallowing accesses out of bounds of an original allocation.", "tokens": [1738, 267, 831, 4514, 307, 281, 360, 365, 717, 336, 9637, 2105, 279, 484, 295, 29905, 295, 364, 3380, 27599, 13], "temperature": 0.0, "avg_logprob": -0.12668192545572918, "compression_ratio": 1.6802030456852792, "no_speech_prob": 7.306547922780737e-05}, {"id": 25, "seek": 12916, "start": 129.16, "end": 136.92, "text": " Temporal safety is disallowing accesses without valid provenance, and temporal safety means", "tokens": [8095, 2816, 304, 4514, 307, 717, 336, 9637, 2105, 279, 1553, 7363, 12785, 719, 11, 293, 30881, 4514, 1355], "temperature": 0.0, "avg_logprob": -0.1738991207546658, "compression_ratio": 1.5534351145038168, "no_speech_prob": 6.301964458543807e-05}, {"id": 26, "seek": 12916, "start": 136.92, "end": 145.07999999999998, "text": " that if the lifetime of an object is over, you can no longer access it through a capability.", "tokens": [300, 498, 264, 11364, 295, 364, 2657, 307, 670, 11, 291, 393, 572, 2854, 2105, 309, 807, 257, 13759, 13], "temperature": 0.0, "avg_logprob": -0.1738991207546658, "compression_ratio": 1.5534351145038168, "no_speech_prob": 6.301964458543807e-05}, {"id": 27, "seek": 12916, "start": 145.07999999999998, "end": 147.4, "text": " So what about integrating Cherry and Rust?", "tokens": [407, 437, 466, 26889, 34831, 293, 34952, 30], "temperature": 0.0, "avg_logprob": -0.1738991207546658, "compression_ratio": 1.5534351145038168, "no_speech_prob": 6.301964458543807e-05}, {"id": 28, "seek": 12916, "start": 147.4, "end": 152.6, "text": " Well, we're working on this as part of a project which is led by our customer Cyberhive.", "tokens": [1042, 11, 321, 434, 1364, 322, 341, 382, 644, 295, 257, 1716, 597, 307, 4684, 538, 527, 5474, 22935, 71, 488, 13], "temperature": 0.0, "avg_logprob": -0.1738991207546658, "compression_ratio": 1.5534351145038168, "no_speech_prob": 6.301964458543807e-05}, {"id": 29, "seek": 12916, "start": 152.6, "end": 157.88, "text": " They're funded in turn by Digital Security by Design, which is a UK government initiative.", "tokens": [814, 434, 14385, 294, 1261, 538, 15522, 11164, 538, 12748, 11, 597, 307, 257, 7051, 2463, 11552, 13], "temperature": 0.0, "avg_logprob": -0.1738991207546658, "compression_ratio": 1.5534351145038168, "no_speech_prob": 6.301964458543807e-05}, {"id": 30, "seek": 15788, "start": 157.88, "end": 164.51999999999998, "text": " Cyberhive want to use Cherry hardware to enhance secure network protocols that are written", "tokens": [22935, 71, 488, 528, 281, 764, 34831, 8837, 281, 11985, 7144, 3209, 20618, 300, 366, 3720], "temperature": 0.0, "avg_logprob": -0.1386830703071926, "compression_ratio": 1.615702479338843, "no_speech_prob": 6.679762009298429e-05}, {"id": 31, "seek": 15788, "start": 164.51999999999998, "end": 166.12, "text": " in Rust.", "tokens": [294, 34952, 13], "temperature": 0.0, "avg_logprob": -0.1386830703071926, "compression_ratio": 1.615702479338843, "no_speech_prob": 6.679762009298429e-05}, {"id": 32, "seek": 15788, "start": 166.12, "end": 171.07999999999998, "text": " So the goal for us then is to produce a Rust compiler that's capable of targeting Cherry-based", "tokens": [407, 264, 3387, 337, 505, 550, 307, 281, 5258, 257, 34952, 31958, 300, 311, 8189, 295, 17918, 34831, 12, 6032], "temperature": 0.0, "avg_logprob": -0.1386830703071926, "compression_ratio": 1.615702479338843, "no_speech_prob": 6.679762009298429e-05}, {"id": 33, "seek": 15788, "start": 171.07999999999998, "end": 176.88, "text": " architectures, with the long-term goal of a stable compiler that can produce production", "tokens": [6331, 1303, 11, 365, 264, 938, 12, 7039, 3387, 295, 257, 8351, 31958, 300, 393, 5258, 4265], "temperature": 0.0, "avg_logprob": -0.1386830703071926, "compression_ratio": 1.615702479338843, "no_speech_prob": 6.679762009298429e-05}, {"id": 34, "seek": 15788, "start": 176.88, "end": 179.32, "text": " ready code for security purposes.", "tokens": [1919, 3089, 337, 3825, 9932, 13], "temperature": 0.0, "avg_logprob": -0.1386830703071926, "compression_ratio": 1.615702479338843, "no_speech_prob": 6.679762009298429e-05}, {"id": 35, "seek": 15788, "start": 179.32, "end": 186.32, "text": " We know that we're initially going to be targeting ARM's Morello platform.", "tokens": [492, 458, 300, 321, 434, 9105, 516, 281, 312, 17918, 45209, 311, 5048, 1913, 3663, 13], "temperature": 0.0, "avg_logprob": -0.1386830703071926, "compression_ratio": 1.615702479338843, "no_speech_prob": 6.679762009298429e-05}, {"id": 36, "seek": 18632, "start": 186.32, "end": 191.35999999999999, "text": " So other than being able to compile existing Rust code for Cherry, what's the motivation", "tokens": [407, 661, 813, 885, 1075, 281, 31413, 6741, 34952, 3089, 337, 34831, 11, 437, 311, 264, 12335], "temperature": 0.0, "avg_logprob": -0.1117317036884587, "compression_ratio": 1.7013574660633484, "no_speech_prob": 2.6073950721183792e-05}, {"id": 37, "seek": 18632, "start": 191.35999999999999, "end": 195.16, "text": " between integrating Cherry and Rust?", "tokens": [1296, 26889, 34831, 293, 34952, 30], "temperature": 0.0, "avg_logprob": -0.1117317036884587, "compression_ratio": 1.7013574660633484, "no_speech_prob": 2.6073950721183792e-05}, {"id": 38, "seek": 18632, "start": 195.16, "end": 198.95999999999998, "text": " Essentially it boils down to another layer of protection.", "tokens": [23596, 309, 35049, 760, 281, 1071, 4583, 295, 6334, 13], "temperature": 0.0, "avg_logprob": -0.1117317036884587, "compression_ratio": 1.7013574660633484, "no_speech_prob": 2.6073950721183792e-05}, {"id": 39, "seek": 18632, "start": 198.95999999999998, "end": 204.51999999999998, "text": " We know that Rust is good at identifying and enforcing access constraints at compile", "tokens": [492, 458, 300, 34952, 307, 665, 412, 16696, 293, 25495, 2175, 2105, 18491, 412, 31413], "temperature": 0.0, "avg_logprob": -0.1117317036884587, "compression_ratio": 1.7013574660633484, "no_speech_prob": 2.6073950721183792e-05}, {"id": 40, "seek": 18632, "start": 204.51999999999998, "end": 210.48, "text": " time, but with Cherry you can identify constraints at compile time and enforce them in hardware", "tokens": [565, 11, 457, 365, 34831, 291, 393, 5876, 18491, 412, 31413, 565, 293, 24825, 552, 294, 8837], "temperature": 0.0, "avg_logprob": -0.1117317036884587, "compression_ratio": 1.7013574660633484, "no_speech_prob": 2.6073950721183792e-05}, {"id": 41, "seek": 18632, "start": 210.48, "end": 212.4, "text": " at runtime.", "tokens": [412, 34474, 13], "temperature": 0.0, "avg_logprob": -0.1117317036884587, "compression_ratio": 1.7013574660633484, "no_speech_prob": 2.6073950721183792e-05}, {"id": 42, "seek": 21240, "start": 212.4, "end": 218.8, "text": " So a good example is that Rust code annotated with unsafe is often a necessity in many real", "tokens": [407, 257, 665, 1365, 307, 300, 34952, 3089, 25339, 770, 365, 35948, 307, 2049, 257, 24217, 294, 867, 957], "temperature": 0.0, "avg_logprob": -0.10215293304829658, "compression_ratio": 1.517094017094017, "no_speech_prob": 2.1595949874608777e-05}, {"id": 43, "seek": 21240, "start": 218.8, "end": 226.48000000000002, "text": " world projects, which means that it could behave badly, but we don't know until runtime.", "tokens": [1002, 4455, 11, 597, 1355, 300, 309, 727, 15158, 13425, 11, 457, 321, 500, 380, 458, 1826, 34474, 13], "temperature": 0.0, "avg_logprob": -0.10215293304829658, "compression_ratio": 1.517094017094017, "no_speech_prob": 2.1595949874608777e-05}, {"id": 44, "seek": 21240, "start": 226.48000000000002, "end": 232.32, "text": " With Cherry you can prevent this bad behavior in hardware when it occurs at runtime.", "tokens": [2022, 34831, 291, 393, 4871, 341, 1578, 5223, 294, 8837, 562, 309, 11843, 412, 34474, 13], "temperature": 0.0, "avg_logprob": -0.10215293304829658, "compression_ratio": 1.517094017094017, "no_speech_prob": 2.1595949874608777e-05}, {"id": 45, "seek": 21240, "start": 232.32, "end": 236.8, "text": " There's some other small side benefits such as replacing slow software bounce checks with", "tokens": [821, 311, 512, 661, 1359, 1252, 5311, 1270, 382, 19139, 2964, 4722, 15894, 13834, 365], "temperature": 0.0, "avg_logprob": -0.10215293304829658, "compression_ratio": 1.517094017094017, "no_speech_prob": 2.1595949874608777e-05}, {"id": 46, "seek": 23680, "start": 236.8, "end": 245.96, "text": " hardware bounce checking and replacing pointer plus length types with Cherry capabilities.", "tokens": [8837, 15894, 8568, 293, 19139, 23918, 1804, 4641, 3467, 365, 34831, 10862, 13], "temperature": 0.0, "avg_logprob": -0.1346252510346562, "compression_ratio": 1.5394736842105263, "no_speech_prob": 7.823717169230804e-05}, {"id": 47, "seek": 23680, "start": 245.96, "end": 250.24, "text": " So to make things more clear, I have a motivating example.", "tokens": [407, 281, 652, 721, 544, 1850, 11, 286, 362, 257, 41066, 1365, 13], "temperature": 0.0, "avg_logprob": -0.1346252510346562, "compression_ratio": 1.5394736842105263, "no_speech_prob": 7.823717169230804e-05}, {"id": 48, "seek": 23680, "start": 250.24, "end": 256.32, "text": " So say we want to add a dynamic offset to a pointer and then load from that pointer.", "tokens": [407, 584, 321, 528, 281, 909, 257, 8546, 18687, 281, 257, 23918, 293, 550, 3677, 490, 300, 23918, 13], "temperature": 0.0, "avg_logprob": -0.1346252510346562, "compression_ratio": 1.5394736842105263, "no_speech_prob": 7.823717169230804e-05}, {"id": 49, "seek": 23680, "start": 256.32, "end": 260.92, "text": " Well this needs to be done in an unsafe block because we don't know until runtime if it's", "tokens": [1042, 341, 2203, 281, 312, 1096, 294, 364, 35948, 3461, 570, 321, 500, 380, 458, 1826, 34474, 498, 309, 311], "temperature": 0.0, "avg_logprob": -0.1346252510346562, "compression_ratio": 1.5394736842105263, "no_speech_prob": 7.823717169230804e-05}, {"id": 50, "seek": 23680, "start": 260.92, "end": 263.12, "text": " going to do something bad.", "tokens": [516, 281, 360, 746, 1578, 13], "temperature": 0.0, "avg_logprob": -0.1346252510346562, "compression_ratio": 1.5394736842105263, "no_speech_prob": 7.823717169230804e-05}, {"id": 51, "seek": 26312, "start": 263.12, "end": 269.16, "text": " Without Cherry you could end up accessing out of range of your original allocated array,", "tokens": [9129, 34831, 291, 727, 917, 493, 26440, 484, 295, 3613, 295, 428, 3380, 29772, 10225, 11], "temperature": 0.0, "avg_logprob": -0.11896162163721372, "compression_ratio": 1.541871921182266, "no_speech_prob": 4.376481956569478e-05}, {"id": 52, "seek": 26312, "start": 269.16, "end": 274.88, "text": " but with Cherry that access will not occur at runtime and the hardware will either panic", "tokens": [457, 365, 34831, 300, 2105, 486, 406, 5160, 412, 34474, 293, 264, 8837, 486, 2139, 14783], "temperature": 0.0, "avg_logprob": -0.11896162163721372, "compression_ratio": 1.541871921182266, "no_speech_prob": 4.376481956569478e-05}, {"id": 53, "seek": 26312, "start": 274.88, "end": 282.28000000000003, "text": " or give you something, a default value.", "tokens": [420, 976, 291, 746, 11, 257, 7576, 2158, 13], "temperature": 0.0, "avg_logprob": -0.11896162163721372, "compression_ratio": 1.541871921182266, "no_speech_prob": 4.376481956569478e-05}, {"id": 54, "seek": 26312, "start": 282.28000000000003, "end": 287.96, "text": " So now that we know that we want these benefits, how do we go about modifying Rust to get them?", "tokens": [407, 586, 300, 321, 458, 300, 321, 528, 613, 5311, 11, 577, 360, 321, 352, 466, 42626, 34952, 281, 483, 552, 30], "temperature": 0.0, "avg_logprob": -0.11896162163721372, "compression_ratio": 1.541871921182266, "no_speech_prob": 4.376481956569478e-05}, {"id": 55, "seek": 28796, "start": 287.96, "end": 293.4, "text": " The main problem is that we need to account for capability sizes correctly, that is we", "tokens": [440, 2135, 1154, 307, 300, 321, 643, 281, 2696, 337, 13759, 11602, 8944, 11, 300, 307, 321], "temperature": 0.0, "avg_logprob": -0.11946907043457031, "compression_ratio": 1.6146341463414635, "no_speech_prob": 4.0434926631860435e-05}, {"id": 56, "seek": 28796, "start": 293.4, "end": 299.79999999999995, "text": " need to stop assuming that pointer type size is equal to the addressable range of the pointer", "tokens": [643, 281, 1590, 11926, 300, 23918, 2010, 2744, 307, 2681, 281, 264, 2985, 712, 3613, 295, 264, 23918], "temperature": 0.0, "avg_logprob": -0.11946907043457031, "compression_ratio": 1.6146341463414635, "no_speech_prob": 4.0434926631860435e-05}, {"id": 57, "seek": 28796, "start": 299.79999999999995, "end": 304.52, "text": " because capabilities have metadata, this isn't the case.", "tokens": [570, 10862, 362, 26603, 11, 341, 1943, 380, 264, 1389, 13], "temperature": 0.0, "avg_logprob": -0.11946907043457031, "compression_ratio": 1.6146341463414635, "no_speech_prob": 4.0434926631860435e-05}, {"id": 58, "seek": 28796, "start": 304.52, "end": 312.84, "text": " Also in LLVM, in the Cherry LLVM fork capabilities are pointers in address space 200, whereas", "tokens": [2743, 294, 441, 43, 53, 44, 11, 294, 264, 34831, 441, 43, 53, 44, 17716, 10862, 366, 44548, 294, 2985, 1901, 2331, 11, 9735], "temperature": 0.0, "avg_logprob": -0.11946907043457031, "compression_ratio": 1.6146341463414635, "no_speech_prob": 4.0434926631860435e-05}, {"id": 59, "seek": 31284, "start": 312.84, "end": 319.15999999999997, "text": " in Rust it seems like we assume that all pointers to data are in address space zero.", "tokens": [294, 34952, 309, 2544, 411, 321, 6552, 300, 439, 44548, 281, 1412, 366, 294, 2985, 1901, 4018, 13], "temperature": 0.0, "avg_logprob": -0.10086469872053279, "compression_ratio": 1.7077625570776256, "no_speech_prob": 7.696133252466097e-05}, {"id": 60, "seek": 31284, "start": 319.15999999999997, "end": 323.47999999999996, "text": " Also if we want to support hybrid mode we need to be able to specify different pointer", "tokens": [2743, 498, 321, 528, 281, 1406, 13051, 4391, 321, 643, 281, 312, 1075, 281, 16500, 819, 23918], "temperature": 0.0, "avg_logprob": -0.10086469872053279, "compression_ratio": 1.7077625570776256, "no_speech_prob": 7.696133252466097e-05}, {"id": 61, "seek": 31284, "start": 323.47999999999996, "end": 329.28, "text": " type sizes for different address spaces, so address space zero will have different sizes", "tokens": [2010, 11602, 337, 819, 2985, 7673, 11, 370, 2985, 1901, 4018, 486, 362, 819, 11602], "temperature": 0.0, "avg_logprob": -0.10086469872053279, "compression_ratio": 1.7077625570776256, "no_speech_prob": 7.696133252466097e-05}, {"id": 62, "seek": 31284, "start": 329.28, "end": 333.59999999999997, "text": " from address space 200.", "tokens": [490, 2985, 1901, 2331, 13], "temperature": 0.0, "avg_logprob": -0.10086469872053279, "compression_ratio": 1.7077625570776256, "no_speech_prob": 7.696133252466097e-05}, {"id": 63, "seek": 31284, "start": 333.59999999999997, "end": 338.47999999999996, "text": " One thing I hope doesn't require many changes is that we need provenance and bounds to be", "tokens": [1485, 551, 286, 1454, 1177, 380, 3651, 867, 2962, 307, 300, 321, 643, 12785, 719, 293, 29905, 281, 312], "temperature": 0.0, "avg_logprob": -0.10086469872053279, "compression_ratio": 1.7077625570776256, "no_speech_prob": 7.696133252466097e-05}, {"id": 64, "seek": 33848, "start": 338.48, "end": 343.36, "text": " propagated through the compiler because they need to be attached to capabilities.", "tokens": [12425, 770, 807, 264, 31958, 570, 436, 643, 281, 312, 8570, 281, 10862, 13], "temperature": 0.0, "avg_logprob": -0.11410766050040004, "compression_ratio": 1.6441441441441442, "no_speech_prob": 8.722727216081694e-05}, {"id": 65, "seek": 33848, "start": 343.36, "end": 349.92, "text": " And of course if we want the optional bonus stuff we need to implement that as well.", "tokens": [400, 295, 1164, 498, 321, 528, 264, 17312, 10882, 1507, 321, 643, 281, 4445, 300, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.11410766050040004, "compression_ratio": 1.6441441441441442, "no_speech_prob": 8.722727216081694e-05}, {"id": 66, "seek": 33848, "start": 349.92, "end": 355.32, "text": " Progress so far, so the data layout changes are completed, which means that we can correctly", "tokens": [32587, 370, 1400, 11, 370, 264, 1412, 13333, 2962, 366, 7365, 11, 597, 1355, 300, 321, 393, 8944], "temperature": 0.0, "avg_logprob": -0.11410766050040004, "compression_ratio": 1.6441441441441442, "no_speech_prob": 8.722727216081694e-05}, {"id": 67, "seek": 33848, "start": 355.32, "end": 361.56, "text": " specify capability sizes, both the type size and the addressable range for both pure cap", "tokens": [16500, 13759, 11602, 11, 1293, 264, 2010, 2744, 293, 264, 2985, 712, 3613, 337, 1293, 6075, 1410], "temperature": 0.0, "avg_logprob": -0.11410766050040004, "compression_ratio": 1.6441441441441442, "no_speech_prob": 8.722727216081694e-05}, {"id": 68, "seek": 33848, "start": 361.56, "end": 365.12, "text": " and hybrid mode.", "tokens": [293, 13051, 4391, 13], "temperature": 0.0, "avg_logprob": -0.11410766050040004, "compression_ratio": 1.6441441441441442, "no_speech_prob": 8.722727216081694e-05}, {"id": 69, "seek": 36512, "start": 365.12, "end": 370.88, "text": " I have modified APIs which produce pointer types to get rid of the assumption that pointers", "tokens": [286, 362, 15873, 21445, 597, 5258, 23918, 3467, 281, 483, 3973, 295, 264, 15302, 300, 44548], "temperature": 0.0, "avg_logprob": -0.10110914850809488, "compression_ratio": 1.6712962962962963, "no_speech_prob": 0.00011192677629878744}, {"id": 70, "seek": 36512, "start": 370.88, "end": 378.28000000000003, "text": " are in address space zero and now these APIs require an explicit address space parameter.", "tokens": [366, 294, 2985, 1901, 4018, 293, 586, 613, 21445, 3651, 364, 13691, 2985, 1901, 13075, 13], "temperature": 0.0, "avg_logprob": -0.10110914850809488, "compression_ratio": 1.6712962962962963, "no_speech_prob": 0.00011192677629878744}, {"id": 71, "seek": 36512, "start": 378.28000000000003, "end": 385.28000000000003, "text": " And the biggest change is that for APIs where we have a, where we report a size for a type,", "tokens": [400, 264, 3880, 1319, 307, 300, 337, 21445, 689, 321, 362, 257, 11, 689, 321, 2275, 257, 2744, 337, 257, 2010, 11], "temperature": 0.0, "avg_logprob": -0.10110914850809488, "compression_ratio": 1.6712962962962963, "no_speech_prob": 0.00011192677629878744}, {"id": 72, "seek": 36512, "start": 385.28000000000003, "end": 392.96, "text": " this is replaced with a total type size and a size of the value that you can represent.", "tokens": [341, 307, 10772, 365, 257, 3217, 2010, 2744, 293, 257, 2744, 295, 264, 2158, 300, 291, 393, 2906, 13], "temperature": 0.0, "avg_logprob": -0.10110914850809488, "compression_ratio": 1.6712962962962963, "no_speech_prob": 0.00011192677629878744}, {"id": 73, "seek": 39296, "start": 392.96, "end": 400.59999999999997, "text": " And yeah, this means that, like I said before, we can support cherry capabilities.", "tokens": [400, 1338, 11, 341, 1355, 300, 11, 411, 286, 848, 949, 11, 321, 393, 1406, 20164, 10862, 13], "temperature": 0.0, "avg_logprob": -0.13711766004562378, "compression_ratio": 1.5395348837209302, "no_speech_prob": 0.00011550051567610353}, {"id": 74, "seek": 39296, "start": 400.59999999999997, "end": 406.91999999999996, "text": " There's also in the strict provenance API there is an explicit unsafe method of producing", "tokens": [821, 311, 611, 294, 264, 10910, 12785, 719, 9362, 456, 307, 364, 13691, 35948, 3170, 295, 10501], "temperature": 0.0, "avg_logprob": -0.13711766004562378, "compression_ratio": 1.5395348837209302, "no_speech_prob": 0.00011550051567610353}, {"id": 75, "seek": 39296, "start": 406.91999999999996, "end": 413.47999999999996, "text": " pointers with no provenance from a U size.", "tokens": [44548, 365, 572, 12785, 719, 490, 257, 624, 2744, 13], "temperature": 0.0, "avg_logprob": -0.13711766004562378, "compression_ratio": 1.5395348837209302, "no_speech_prob": 0.00011550051567610353}, {"id": 76, "seek": 39296, "start": 413.47999999999996, "end": 419.03999999999996, "text": " And for cherry we need to use cherry operations to set the address of a null capability to", "tokens": [400, 337, 20164, 321, 643, 281, 764, 20164, 7705, 281, 992, 264, 2985, 295, 257, 18184, 13759, 281], "temperature": 0.0, "avg_logprob": -0.13711766004562378, "compression_ratio": 1.5395348837209302, "no_speech_prob": 0.00011550051567610353}, {"id": 77, "seek": 39296, "start": 419.03999999999996, "end": 421.56, "text": " achieve the same result.", "tokens": [4584, 264, 912, 1874, 13], "temperature": 0.0, "avg_logprob": -0.13711766004562378, "compression_ratio": 1.5395348837209302, "no_speech_prob": 0.00011550051567610353}, {"id": 78, "seek": 42156, "start": 421.56, "end": 425.52, "text": " What I'm currently working through is trawling through assertion failures that come up when", "tokens": [708, 286, 478, 4362, 1364, 807, 307, 944, 86, 1688, 807, 19810, 313, 20774, 300, 808, 493, 562], "temperature": 0.0, "avg_logprob": -0.12681395586799174, "compression_ratio": 1.6401673640167365, "no_speech_prob": 0.00010660754196578637}, {"id": 79, "seek": 42156, "start": 425.52, "end": 431.6, "text": " building the core libraries with this modified compiler.", "tokens": [2390, 264, 4965, 15148, 365, 341, 15873, 31958, 13], "temperature": 0.0, "avg_logprob": -0.12681395586799174, "compression_ratio": 1.6401673640167365, "no_speech_prob": 0.00010660754196578637}, {"id": 80, "seek": 42156, "start": 431.6, "end": 434.96, "text": " What still needs to be done, well, there's almost definitely going to be modifications", "tokens": [708, 920, 2203, 281, 312, 1096, 11, 731, 11, 456, 311, 1920, 2138, 516, 281, 312, 26881], "temperature": 0.0, "avg_logprob": -0.12681395586799174, "compression_ratio": 1.6401673640167365, "no_speech_prob": 0.00010660754196578637}, {"id": 81, "seek": 42156, "start": 434.96, "end": 441.72, "text": " to the libraries to remove any assumptions that break for cherry.", "tokens": [281, 264, 15148, 281, 4159, 604, 17695, 300, 1821, 337, 20164, 13], "temperature": 0.0, "avg_logprob": -0.12681395586799174, "compression_ratio": 1.6401673640167365, "no_speech_prob": 0.00010660754196578637}, {"id": 82, "seek": 42156, "start": 441.72, "end": 447.32, "text": " There's also the question of how do we specify capability types in hybrid mode and because", "tokens": [821, 311, 611, 264, 1168, 295, 577, 360, 321, 16500, 13759, 3467, 294, 13051, 4391, 293, 570], "temperature": 0.0, "avg_logprob": -0.12681395586799174, "compression_ratio": 1.6401673640167365, "no_speech_prob": 0.00010660754196578637}, {"id": 83, "seek": 44732, "start": 447.32, "end": 453.88, "text": " I don't think that Rust annotations are the right tool to specify a specific pointer as", "tokens": [286, 500, 380, 519, 300, 34952, 25339, 763, 366, 264, 558, 2290, 281, 16500, 257, 2685, 23918, 382], "temperature": 0.0, "avg_logprob": -0.09401125810584243, "compression_ratio": 1.7606837606837606, "no_speech_prob": 6.966535875108093e-05}, {"id": 84, "seek": 44732, "start": 453.88, "end": 459.15999999999997, "text": " being a capability, I think this requires a library solution.", "tokens": [885, 257, 13759, 11, 286, 519, 341, 7029, 257, 6405, 3827, 13], "temperature": 0.0, "avg_logprob": -0.09401125810584243, "compression_ratio": 1.7606837606837606, "no_speech_prob": 6.966535875108093e-05}, {"id": 85, "seek": 44732, "start": 459.15999999999997, "end": 465.8, "text": " For APIs where I have replaced a size with a type size and added a size of the value", "tokens": [1171, 21445, 689, 286, 362, 10772, 257, 2744, 365, 257, 2010, 2744, 293, 3869, 257, 2744, 295, 264, 2158], "temperature": 0.0, "avg_logprob": -0.09401125810584243, "compression_ratio": 1.7606837606837606, "no_speech_prob": 6.966535875108093e-05}, {"id": 86, "seek": 44732, "start": 465.8, "end": 471.8, "text": " that you can represent, we need to go through all of those uses of the type size and see", "tokens": [300, 291, 393, 2906, 11, 321, 643, 281, 352, 807, 439, 295, 729, 4960, 295, 264, 2010, 2744, 293, 536], "temperature": 0.0, "avg_logprob": -0.09401125810584243, "compression_ratio": 1.7606837606837606, "no_speech_prob": 6.966535875108093e-05}, {"id": 87, "seek": 44732, "start": 471.8, "end": 475.15999999999997, "text": " if they should really be using the size of the value that you can represent because this", "tokens": [498, 436, 820, 534, 312, 1228, 264, 2744, 295, 264, 2158, 300, 291, 393, 2906, 570, 341], "temperature": 0.0, "avg_logprob": -0.09401125810584243, "compression_ratio": 1.7606837606837606, "no_speech_prob": 6.966535875108093e-05}, {"id": 88, "seek": 47516, "start": 475.16, "end": 481.32000000000005, "text": " is the main cause of the errors that I'm seeing in building the libraries.", "tokens": [307, 264, 2135, 3082, 295, 264, 13603, 300, 286, 478, 2577, 294, 2390, 264, 15148, 13], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 89, "seek": 47516, "start": 481.32000000000005, "end": 487.76000000000005, "text": " And of course, a lot of testing and polishing is going to be required.", "tokens": [400, 295, 1164, 11, 257, 688, 295, 4997, 293, 47258, 307, 516, 281, 312, 4739, 13], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 90, "seek": 47516, "start": 487.76000000000005, "end": 492.24, "text": " Before I finish this talk, I do need to mention that there's ongoing and past work that is", "tokens": [4546, 286, 2413, 341, 751, 11, 286, 360, 643, 281, 2152, 300, 456, 311, 10452, 293, 1791, 589, 300, 307], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 91, "seek": 47516, "start": 492.24, "end": 493.24, "text": " in this same area.", "tokens": [294, 341, 912, 1859, 13], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 92, "seek": 47516, "start": 493.24, "end": 498.20000000000005, "text": " There was a master's thesis from the University of Cambridge and there's another government", "tokens": [821, 390, 257, 4505, 311, 22288, 490, 264, 3535, 295, 24876, 293, 456, 311, 1071, 2463], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 93, "seek": 47516, "start": 498.20000000000005, "end": 502.88, "text": " funded project from the University of Kent.", "tokens": [14385, 1716, 490, 264, 3535, 295, 15843, 13], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 94, "seek": 47516, "start": 502.88, "end": 505.08000000000004, "text": " And well, thank you for listening.", "tokens": [400, 731, 11, 1309, 291, 337, 4764, 13], "temperature": 0.0, "avg_logprob": -0.15635096232096354, "compression_ratio": 1.6904761904761905, "no_speech_prob": 7.627505692653358e-05}, {"id": 95, "seek": 50508, "start": 505.08, "end": 508.76, "text": " Please feel free to check out the code on GitHub or ask me any questions outside.", "tokens": [50364, 2555, 841, 1737, 281, 1520, 484, 264, 3089, 322, 23331, 420, 1029, 385, 604, 1651, 2380, 13, 50548], "temperature": 0.0, "avg_logprob": -0.19262800216674805, "compression_ratio": 1.051948051948052, "no_speech_prob": 0.0005371465813368559}], "language": "en"}