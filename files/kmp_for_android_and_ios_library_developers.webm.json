{"text": " So, hi, everyone. Welcome back to the next talk. Today we have on stage Anna La Bellarte and Paolo Rattolo from Nextome talking about cutting multiplatform for Android and iOS library developers, I guess it was. Now, yeah, gonna talk about it. Awesome. Thank you. Yes, I'm Paolo and it's a very pleasure to be here with you. We come from Italy. We come from a small company in the southern Italy and we decided to introduce cutting multiplatform in our code about a year ago. We did this because for us it was easier to develop and also we wanted to share as much code as possible. We make libraries so we didn't have the part of UI to transpose in the multiplatform and this is our journey in the multiplatform world. Now, we've seen during this conference that we cut in multiplatform mobile. We can develop a library that targets both Android and iOS by just writing a single code base in Kotlin. Now, if you look at what happens when we distribute the jar inside an Android library, we can say that the process is pretty straightforward. Now, for an Android developer, the language is the same. The IDE that uses is the same and most of the library that we can use are the same. So, we can't tell the difference between a library that was made with Kotlin multiplatform mobile and one made with the native tooling. Now, things are not quite the same when we talk about the iOS part. So, if we distribute the framework, the process is not so straightforward. And the main of the problem arises because the code is converted for an objective C and then most of the time we'll be using side projects that has Rift as the main language. Now, for a Rift developer point of view, sometimes what can happen is that they can find the API that we expose is just strange and this is just the base case scenario. Other times, the app may just crash and this is due to some differences that there are between the two platforms that aren't automatically translated for us by the compiler. So, we will see during this talk what we can do to what happens when we distribute the framework and what we can do to make libraries enjoyable also for the iOS part. Now, let's start with a simple example. So, in this case, we talk about coroutines. So, inside our common code, we can use coroutine. So, we can have a function like this, which is a suspend function because it performs some operation with the network and some interaction with a persistent layer. Now, on Android, we don't have many issues because if we have a coroutine scope, we can launch the coroutine. But what happens on iOS when we don't have the coroutine library? Now, this function gets converted by two alternatives. The first one which uses a completion handler, which is basically a callback that gets called either when we have a result or when, in this case, the to-do variable would be populated or when we have an error. So, in this case, I will have the error variable populated. Now, if we don't want to use the callback because it can become cumbersome when we have different functions, one inside the other, we can use the second alternative which uses sync and await, but we have to target at least iOS 13. Now, if we go back on Android, we launch the coroutine inside the scope, and this means that if I don't need the job anymore, what I can do is just cancel the scope and then also the job gets cancelled. By default, I don't have this power on iOS. So, what we can do is try to use a library which is called Coru. Yes. We fixed that problem with Coru that is actually a library inspired by a blog post of TouchLab. So, thanks to TouchLab for this. Does it work? Basically, you have to include, of course, in the common dependency of your code. And using this library, it basically introduces you to a new annotation that is too native class. So, with that annotation, you can specify a name for a class that will be generated just in the iOS implementation of your code. So, if you have a look at the generated class, we can see that it is basically a wrapper of our original repository. So, you have two parameters that are passed. We have a wrapper that is the original repository, and we have a scope provider. We'll see what a scope provider is later. And all the methods of that generated class are the same methods that you have in the original repository, but the result type, list of to-do, is wrapped in another object. So, if we try to use this on iOS, the code that's get generated is something like that. We have two callbacks actually now, but I can see, for example, other two problems with that code. First of all, we are exposing a coroutine scope for iOS developers, and maybe iOS developers are not familiar with that concept of scope, like coroutine developers are. And also, we have that object that now is an SRA, and it is not a list of to-do anymore. That is because we are wrapped in a list of to-do in another object that accepts generics. And the Objective C translation of the Kotlin code cannot do that for now, so it gets simplified to an SRA. To solve this, we go back in the common code, and we use another function of that library, that is, launch on scope. So, we can define a scope in common code and tell the library to run all our coroutines in that scope. So, the scope will not be provided by iOS developers anymore. Also, for the second problem, it's just a workaround. We can define a data class, we can define a typology, or something to hide the fact that we are using a list of something. So, if we try to generate a new code for this, this is the final code that is much more readable and usable. And, of course, now we can dismiss the job if we are not interested in the result anymore. What about flows? We'll talk about coroutines. What about flows? This is an example of a simple flow that emits integers. Of course, again, on Android, it is simple, you have a scope, you can start collecting values. As with the code that gets generated, it is something like that. We still have a collect function to collect the values of the flow, but we have to pass this, that is a flow collector, so we have to implement the function emit, do something with that value that gets emitted, and then when we are done, call the completion handler so we can receive the next value. Also, notice that we don't have the type that we are collecting from the flow, we just have any. I can prove this. First of all, we tried to make that collector generic, so we can use it in more parts of our code, and so we exposed another callback. Yes, make it generic. So we exposed another callback, and we actually casted the value as the one that we wanted, but we found that this is not good enough. Also, because the highest developer has to do this in his code, we are not doing it in common, so every time he has to use our library, he has to define this. So we decided to fix it in common code, and again, we used this, that is a common flow. There is a class found actually in the Kotlin Conf app, and this class wraps up flow and basically emits all the values of the flow and returns a crossable object, so you can dismiss the flow when you don't want to listen to it anymore. So again, we return now a common flow using the extension function, and on iOS again, now we have a much more readable code that we can also cancel if we want. Now, we mentioned before that sometimes the app may crash because of the differences between the two platforms, and one great example of this is our exception handling are handled in the languages, because Kotlin only works with unchecked exception, while Swift only works with the unchecked one, and now we will see what this means and what happens. So if I have, we are bringing back the function from the coroutine that we saw before, so in this case, because in Kotlin, I don't have to mark explicitly each throwing function, I can wrap it inside a tri-catch, so if something happens, I will receive the error inside the callback. Now, if we bring back also the first alternative that we saw before with coroutine, what I expect is to have the error in the function, but if I launch the application, it actually crashes, and this is because in Swift, I have to mark explicitly each throwing function, so the fix is actually quite easy, because there is an annotation that we can use, which is called throws exception. So by doing this, just in the common code, and we don't have to make any changes inside the Swift implementation, so in this case, I will receive the error in the callback, and this works also with non-suspending functions, so if I have this function and mark it throws and exception, once I compile the code, the generated function in Swift will be marked as throwing, so this time will be the compiler to force us to handle the exception. Now, another API that is not quite Swift-friendly is the one of sealed classes. Now, on Kotlin, we can restrict the concept of inheritance by using sealed classes and sealed interfaces, so when we use them inside our Android code, we can just make something like this, because, okay, something like this, because we know for sure that those three, so data, error, and loading in this case are the only cases that we have to handle, but on iOS, actually it gets converted by just using the concept of inheritance, and so when I have to handle the, in this case, the status, I have to define also the case, a default case, which I know for sure that will never be called, and on Swift, we actually have a concept which is similar to the concept of sealed classes, which is the concept of enum, so what we want is to map the sealed classes with enum, and to do so, we can use a library, which is called, it's quite dark, but Merkur keys, Swift, and in this case, using this library, it automatically detects any sealed classes and sealed interfaces, and generates, in this case, will be UI state KS, and it just takes the status as input, and it is actually an enum that I can use, so for a Swift developer, this is much easier to use, because I don't have to define a default case anymore. So, if you're writing code that is platform-specific from 400, for example, you probably will need a context to access some system functionalities. What happens in the library ecosystem? So, you may expose an API like this that gets the context from the user of the library, but of course you don't have to do this on iOS, because you don't need a context on iOS. How you can improve that, how you can unify those APIs, we try to use Jetpack app startup for this, because if you include the app startup in your library, basically you will be able to get a context that is injected by the operating system, and maybe save it.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 27.44, "text": " So, hi, everyone. Welcome back to the next talk. Today we have on stage Anna La Bellarte", "tokens": [407, 11, 4879, 11, 1518, 13, 4027, 646, 281, 264, 958, 751, 13, 2692, 321, 362, 322, 3233, 12899, 2369, 11485, 11026], "temperature": 0.0, "avg_logprob": -0.5339773251460149, "compression_ratio": 1.0476190476190477, "no_speech_prob": 0.41418910026550293}, {"id": 1, "seek": 2744, "start": 27.44, "end": 33.68, "text": " and Paolo Rattolo from Nextome talking about cutting multiplatform for Android and iOS library", "tokens": [293, 3426, 7902, 497, 1591, 7902, 490, 3087, 423, 1417, 466, 6492, 12788, 267, 837, 337, 8853, 293, 17430, 6405], "temperature": 0.0, "avg_logprob": -0.20633599252411813, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.0032524890266358852}, {"id": 2, "seek": 2744, "start": 33.68, "end": 43.28, "text": " developers, I guess it was. Now, yeah, gonna talk about it. Awesome. Thank you. Yes, I'm Paolo", "tokens": [8849, 11, 286, 2041, 309, 390, 13, 823, 11, 1338, 11, 799, 751, 466, 309, 13, 10391, 13, 1044, 291, 13, 1079, 11, 286, 478, 3426, 7902], "temperature": 0.0, "avg_logprob": -0.20633599252411813, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.0032524890266358852}, {"id": 3, "seek": 2744, "start": 44.400000000000006, "end": 51.2, "text": " and it's a very pleasure to be here with you. We come from Italy. We come from a small company", "tokens": [293, 309, 311, 257, 588, 6834, 281, 312, 510, 365, 291, 13, 492, 808, 490, 10705, 13, 492, 808, 490, 257, 1359, 2237], "temperature": 0.0, "avg_logprob": -0.20633599252411813, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.0032524890266358852}, {"id": 4, "seek": 2744, "start": 51.2, "end": 57.28, "text": " in the southern Italy and we decided to introduce cutting multiplatform in our code about a year", "tokens": [294, 264, 13456, 10705, 293, 321, 3047, 281, 5366, 6492, 12788, 267, 837, 294, 527, 3089, 466, 257, 1064], "temperature": 0.0, "avg_logprob": -0.20633599252411813, "compression_ratio": 1.6144067796610169, "no_speech_prob": 0.0032524890266358852}, {"id": 5, "seek": 5728, "start": 57.28, "end": 64.4, "text": " ago. We did this because for us it was easier to develop and also we wanted to share as much code", "tokens": [2057, 13, 492, 630, 341, 570, 337, 505, 309, 390, 3571, 281, 1499, 293, 611, 321, 1415, 281, 2073, 382, 709, 3089], "temperature": 0.0, "avg_logprob": -0.12955848206865025, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0005400144727900624}, {"id": 6, "seek": 5728, "start": 64.4, "end": 73.2, "text": " as possible. We make libraries so we didn't have the part of UI to transpose in the multiplatform", "tokens": [382, 1944, 13, 492, 652, 15148, 370, 321, 994, 380, 362, 264, 644, 295, 15682, 281, 25167, 294, 264, 12788, 267, 837], "temperature": 0.0, "avg_logprob": -0.12955848206865025, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0005400144727900624}, {"id": 7, "seek": 5728, "start": 73.2, "end": 81.28, "text": " and this is our journey in the multiplatform world. Now, we've seen during this conference that we", "tokens": [293, 341, 307, 527, 4671, 294, 264, 12788, 267, 837, 1002, 13, 823, 11, 321, 600, 1612, 1830, 341, 7586, 300, 321], "temperature": 0.0, "avg_logprob": -0.12955848206865025, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0005400144727900624}, {"id": 8, "seek": 5728, "start": 81.28, "end": 86.48, "text": " cut in multiplatform mobile. We can develop a library that targets both Android and iOS", "tokens": [1723, 294, 12788, 267, 837, 6013, 13, 492, 393, 1499, 257, 6405, 300, 12911, 1293, 8853, 293, 17430], "temperature": 0.0, "avg_logprob": -0.12955848206865025, "compression_ratio": 1.646551724137931, "no_speech_prob": 0.0005400144727900624}, {"id": 9, "seek": 8648, "start": 86.48, "end": 91.92, "text": " by just writing a single code base in Kotlin. Now, if you look at what happens when we distribute", "tokens": [538, 445, 3579, 257, 2167, 3089, 3096, 294, 30123, 5045, 13, 823, 11, 498, 291, 574, 412, 437, 2314, 562, 321, 20594], "temperature": 0.0, "avg_logprob": -0.1355625401372495, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0003023285826202482}, {"id": 10, "seek": 8648, "start": 91.92, "end": 96.80000000000001, "text": " the jar inside an Android library, we can say that the process is pretty straightforward.", "tokens": [264, 15181, 1854, 364, 8853, 6405, 11, 321, 393, 584, 300, 264, 1399, 307, 1238, 15325, 13], "temperature": 0.0, "avg_logprob": -0.1355625401372495, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0003023285826202482}, {"id": 11, "seek": 8648, "start": 96.80000000000001, "end": 102.96000000000001, "text": " Now, for an Android developer, the language is the same. The IDE that uses is the same and most", "tokens": [823, 11, 337, 364, 8853, 10754, 11, 264, 2856, 307, 264, 912, 13, 440, 40930, 300, 4960, 307, 264, 912, 293, 881], "temperature": 0.0, "avg_logprob": -0.1355625401372495, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0003023285826202482}, {"id": 12, "seek": 8648, "start": 102.96000000000001, "end": 107.92, "text": " of the library that we can use are the same. So, we can't tell the difference between a library", "tokens": [295, 264, 6405, 300, 321, 393, 764, 366, 264, 912, 13, 407, 11, 321, 393, 380, 980, 264, 2649, 1296, 257, 6405], "temperature": 0.0, "avg_logprob": -0.1355625401372495, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0003023285826202482}, {"id": 13, "seek": 8648, "start": 107.92, "end": 114.0, "text": " that was made with Kotlin multiplatform mobile and one made with the native tooling. Now,", "tokens": [300, 390, 1027, 365, 30123, 5045, 12788, 267, 837, 6013, 293, 472, 1027, 365, 264, 8470, 46593, 13, 823, 11], "temperature": 0.0, "avg_logprob": -0.1355625401372495, "compression_ratio": 1.737037037037037, "no_speech_prob": 0.0003023285826202482}, {"id": 14, "seek": 11400, "start": 114.0, "end": 120.08, "text": " things are not quite the same when we talk about the iOS part. So, if we distribute the framework,", "tokens": [721, 366, 406, 1596, 264, 912, 562, 321, 751, 466, 264, 17430, 644, 13, 407, 11, 498, 321, 20594, 264, 8388, 11], "temperature": 0.0, "avg_logprob": -0.15844029965608017, "compression_ratio": 1.6996466431095407, "no_speech_prob": 0.00026300677563995123}, {"id": 15, "seek": 11400, "start": 120.64, "end": 126.48, "text": " the process is not so straightforward. And the main of the problem arises because the code is", "tokens": [264, 1399, 307, 406, 370, 15325, 13, 400, 264, 2135, 295, 264, 1154, 27388, 570, 264, 3089, 307], "temperature": 0.0, "avg_logprob": -0.15844029965608017, "compression_ratio": 1.6996466431095407, "no_speech_prob": 0.00026300677563995123}, {"id": 16, "seek": 11400, "start": 126.48, "end": 131.12, "text": " converted for an objective C and then most of the time we'll be using side projects that", "tokens": [16424, 337, 364, 10024, 383, 293, 550, 881, 295, 264, 565, 321, 603, 312, 1228, 1252, 4455, 300], "temperature": 0.0, "avg_logprob": -0.15844029965608017, "compression_ratio": 1.6996466431095407, "no_speech_prob": 0.00026300677563995123}, {"id": 17, "seek": 11400, "start": 131.12, "end": 137.28, "text": " has Rift as the main language. Now, for a Rift developer point of view, sometimes what can happen", "tokens": [575, 497, 2008, 382, 264, 2135, 2856, 13, 823, 11, 337, 257, 497, 2008, 10754, 935, 295, 1910, 11, 2171, 437, 393, 1051], "temperature": 0.0, "avg_logprob": -0.15844029965608017, "compression_ratio": 1.6996466431095407, "no_speech_prob": 0.00026300677563995123}, {"id": 18, "seek": 11400, "start": 137.28, "end": 143.84, "text": " is that they can find the API that we expose is just strange and this is just the base case scenario.", "tokens": [307, 300, 436, 393, 915, 264, 9362, 300, 321, 19219, 307, 445, 5861, 293, 341, 307, 445, 264, 3096, 1389, 9005, 13], "temperature": 0.0, "avg_logprob": -0.15844029965608017, "compression_ratio": 1.6996466431095407, "no_speech_prob": 0.00026300677563995123}, {"id": 19, "seek": 14384, "start": 143.84, "end": 149.6, "text": " Other times, the app may just crash and this is due to some differences that there are between", "tokens": [5358, 1413, 11, 264, 724, 815, 445, 8252, 293, 341, 307, 3462, 281, 512, 7300, 300, 456, 366, 1296], "temperature": 0.0, "avg_logprob": -0.09811990836571002, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.00018573332636151463}, {"id": 20, "seek": 14384, "start": 149.6, "end": 155.12, "text": " the two platforms that aren't automatically translated for us by the compiler. So, we will see", "tokens": [264, 732, 9473, 300, 3212, 380, 6772, 16805, 337, 505, 538, 264, 31958, 13, 407, 11, 321, 486, 536], "temperature": 0.0, "avg_logprob": -0.09811990836571002, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.00018573332636151463}, {"id": 21, "seek": 14384, "start": 155.12, "end": 160.0, "text": " during this talk what we can do to what happens when we distribute the framework and what we can", "tokens": [1830, 341, 751, 437, 321, 393, 360, 281, 437, 2314, 562, 321, 20594, 264, 8388, 293, 437, 321, 393], "temperature": 0.0, "avg_logprob": -0.09811990836571002, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.00018573332636151463}, {"id": 22, "seek": 14384, "start": 160.0, "end": 166.8, "text": " do to make libraries enjoyable also for the iOS part. Now, let's start with a simple example.", "tokens": [360, 281, 652, 15148, 20305, 611, 337, 264, 17430, 644, 13, 823, 11, 718, 311, 722, 365, 257, 2199, 1365, 13], "temperature": 0.0, "avg_logprob": -0.09811990836571002, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.00018573332636151463}, {"id": 23, "seek": 14384, "start": 166.8, "end": 172.56, "text": " So, in this case, we talk about coroutines. So, inside our common code, we can use coroutine.", "tokens": [407, 11, 294, 341, 1389, 11, 321, 751, 466, 1181, 346, 1652, 13, 407, 11, 1854, 527, 2689, 3089, 11, 321, 393, 764, 1181, 45075, 13], "temperature": 0.0, "avg_logprob": -0.09811990836571002, "compression_ratio": 1.7050359712230216, "no_speech_prob": 0.00018573332636151463}, {"id": 24, "seek": 17256, "start": 172.56, "end": 176.96, "text": " So, we can have a function like this, which is a suspend function because it performs some", "tokens": [407, 11, 321, 393, 362, 257, 2445, 411, 341, 11, 597, 307, 257, 42546, 2445, 570, 309, 26213, 512], "temperature": 0.0, "avg_logprob": -0.0902183619412509, "compression_ratio": 1.7840909090909092, "no_speech_prob": 0.00023980428522918373}, {"id": 25, "seek": 17256, "start": 176.96, "end": 183.84, "text": " operation with the network and some interaction with a persistent layer. Now, on Android, we", "tokens": [6916, 365, 264, 3209, 293, 512, 9285, 365, 257, 24315, 4583, 13, 823, 11, 322, 8853, 11, 321], "temperature": 0.0, "avg_logprob": -0.0902183619412509, "compression_ratio": 1.7840909090909092, "no_speech_prob": 0.00023980428522918373}, {"id": 26, "seek": 17256, "start": 183.84, "end": 188.56, "text": " don't have many issues because if we have a coroutine scope, we can launch the coroutine.", "tokens": [500, 380, 362, 867, 2663, 570, 498, 321, 362, 257, 1181, 45075, 11923, 11, 321, 393, 4025, 264, 1181, 45075, 13], "temperature": 0.0, "avg_logprob": -0.0902183619412509, "compression_ratio": 1.7840909090909092, "no_speech_prob": 0.00023980428522918373}, {"id": 27, "seek": 17256, "start": 188.56, "end": 195.36, "text": " But what happens on iOS when we don't have the coroutine library? Now, this function gets converted", "tokens": [583, 437, 2314, 322, 17430, 562, 321, 500, 380, 362, 264, 1181, 45075, 6405, 30, 823, 11, 341, 2445, 2170, 16424], "temperature": 0.0, "avg_logprob": -0.0902183619412509, "compression_ratio": 1.7840909090909092, "no_speech_prob": 0.00023980428522918373}, {"id": 28, "seek": 17256, "start": 195.36, "end": 200.96, "text": " by two alternatives. The first one which uses a completion handler, which is basically a callback", "tokens": [538, 732, 20478, 13, 440, 700, 472, 597, 4960, 257, 19372, 41967, 11, 597, 307, 1936, 257, 818, 3207], "temperature": 0.0, "avg_logprob": -0.0902183619412509, "compression_ratio": 1.7840909090909092, "no_speech_prob": 0.00023980428522918373}, {"id": 29, "seek": 20096, "start": 200.96, "end": 206.48000000000002, "text": " that gets called either when we have a result or when, in this case, the to-do variable would be", "tokens": [300, 2170, 1219, 2139, 562, 321, 362, 257, 1874, 420, 562, 11, 294, 341, 1389, 11, 264, 281, 12, 2595, 7006, 576, 312], "temperature": 0.0, "avg_logprob": -0.12093522548675537, "compression_ratio": 1.7846153846153847, "no_speech_prob": 9.815934026846662e-05}, {"id": 30, "seek": 20096, "start": 206.48000000000002, "end": 212.24, "text": " populated or when we have an error. So, in this case, I will have the error variable populated.", "tokens": [32998, 420, 562, 321, 362, 364, 6713, 13, 407, 11, 294, 341, 1389, 11, 286, 486, 362, 264, 6713, 7006, 32998, 13], "temperature": 0.0, "avg_logprob": -0.12093522548675537, "compression_ratio": 1.7846153846153847, "no_speech_prob": 9.815934026846662e-05}, {"id": 31, "seek": 20096, "start": 213.52, "end": 218.0, "text": " Now, if we don't want to use the callback because it can become cumbersome when we have", "tokens": [823, 11, 498, 321, 500, 380, 528, 281, 764, 264, 818, 3207, 570, 309, 393, 1813, 12713, 1616, 423, 562, 321, 362], "temperature": 0.0, "avg_logprob": -0.12093522548675537, "compression_ratio": 1.7846153846153847, "no_speech_prob": 9.815934026846662e-05}, {"id": 32, "seek": 20096, "start": 218.0, "end": 222.96, "text": " different functions, one inside the other, we can use the second alternative which uses", "tokens": [819, 6828, 11, 472, 1854, 264, 661, 11, 321, 393, 764, 264, 1150, 8535, 597, 4960], "temperature": 0.0, "avg_logprob": -0.12093522548675537, "compression_ratio": 1.7846153846153847, "no_speech_prob": 9.815934026846662e-05}, {"id": 33, "seek": 20096, "start": 222.96, "end": 229.92000000000002, "text": " sync and await, but we have to target at least iOS 13. Now, if we go back on Android, we launch", "tokens": [20271, 293, 19670, 11, 457, 321, 362, 281, 3779, 412, 1935, 17430, 3705, 13, 823, 11, 498, 321, 352, 646, 322, 8853, 11, 321, 4025], "temperature": 0.0, "avg_logprob": -0.12093522548675537, "compression_ratio": 1.7846153846153847, "no_speech_prob": 9.815934026846662e-05}, {"id": 34, "seek": 22992, "start": 229.92, "end": 234.79999999999998, "text": " the coroutine inside the scope, and this means that if I don't need the job anymore, what I can do", "tokens": [264, 1181, 45075, 1854, 264, 11923, 11, 293, 341, 1355, 300, 498, 286, 500, 380, 643, 264, 1691, 3602, 11, 437, 286, 393, 360], "temperature": 0.0, "avg_logprob": -0.13298165429498732, "compression_ratio": 1.6334841628959276, "no_speech_prob": 0.000568318588193506}, {"id": 35, "seek": 22992, "start": 234.79999999999998, "end": 241.76, "text": " is just cancel the scope and then also the job gets cancelled. By default, I don't have this", "tokens": [307, 445, 10373, 264, 11923, 293, 550, 611, 264, 1691, 2170, 25103, 13, 3146, 7576, 11, 286, 500, 380, 362, 341], "temperature": 0.0, "avg_logprob": -0.13298165429498732, "compression_ratio": 1.6334841628959276, "no_speech_prob": 0.000568318588193506}, {"id": 36, "seek": 22992, "start": 241.76, "end": 245.83999999999997, "text": " power on iOS. So, what we can do is try to use a library which is called Coru.", "tokens": [1347, 322, 17430, 13, 407, 11, 437, 321, 393, 360, 307, 853, 281, 764, 257, 6405, 597, 307, 1219, 3925, 84, 13], "temperature": 0.0, "avg_logprob": -0.13298165429498732, "compression_ratio": 1.6334841628959276, "no_speech_prob": 0.000568318588193506}, {"id": 37, "seek": 22992, "start": 247.2, "end": 253.51999999999998, "text": " Yes. We fixed that problem with Coru that is actually a library inspired by a blog post of", "tokens": [1079, 13, 492, 6806, 300, 1154, 365, 3925, 84, 300, 307, 767, 257, 6405, 7547, 538, 257, 6968, 2183, 295], "temperature": 0.0, "avg_logprob": -0.13298165429498732, "compression_ratio": 1.6334841628959276, "no_speech_prob": 0.000568318588193506}, {"id": 38, "seek": 25352, "start": 253.52, "end": 260.48, "text": " TouchLab. So, thanks to TouchLab for this. Does it work? Basically, you have to include, of course,", "tokens": [20029, 37880, 13, 407, 11, 3231, 281, 20029, 37880, 337, 341, 13, 4402, 309, 589, 30, 8537, 11, 291, 362, 281, 4090, 11, 295, 1164, 11], "temperature": 0.0, "avg_logprob": -0.12849441170692444, "compression_ratio": 1.6508620689655173, "no_speech_prob": 6.705908890580758e-05}, {"id": 39, "seek": 25352, "start": 260.48, "end": 267.2, "text": " in the common dependency of your code. And using this library, it basically introduces you to a", "tokens": [294, 264, 2689, 33621, 295, 428, 3089, 13, 400, 1228, 341, 6405, 11, 309, 1936, 31472, 291, 281, 257], "temperature": 0.0, "avg_logprob": -0.12849441170692444, "compression_ratio": 1.6508620689655173, "no_speech_prob": 6.705908890580758e-05}, {"id": 40, "seek": 25352, "start": 267.2, "end": 274.56, "text": " new annotation that is too native class. So, with that annotation, you can specify a name for a", "tokens": [777, 48654, 300, 307, 886, 8470, 1508, 13, 407, 11, 365, 300, 48654, 11, 291, 393, 16500, 257, 1315, 337, 257], "temperature": 0.0, "avg_logprob": -0.12849441170692444, "compression_ratio": 1.6508620689655173, "no_speech_prob": 6.705908890580758e-05}, {"id": 41, "seek": 25352, "start": 274.56, "end": 280.64, "text": " class that will be generated just in the iOS implementation of your code. So, if you have a", "tokens": [1508, 300, 486, 312, 10833, 445, 294, 264, 17430, 11420, 295, 428, 3089, 13, 407, 11, 498, 291, 362, 257], "temperature": 0.0, "avg_logprob": -0.12849441170692444, "compression_ratio": 1.6508620689655173, "no_speech_prob": 6.705908890580758e-05}, {"id": 42, "seek": 28064, "start": 280.64, "end": 287.76, "text": " look at the generated class, we can see that it is basically a wrapper of our original repository.", "tokens": [574, 412, 264, 10833, 1508, 11, 321, 393, 536, 300, 309, 307, 1936, 257, 46906, 295, 527, 3380, 25841, 13], "temperature": 0.0, "avg_logprob": -0.1309872097439236, "compression_ratio": 1.9019607843137254, "no_speech_prob": 0.00023326050722971559}, {"id": 43, "seek": 28064, "start": 287.76, "end": 293.76, "text": " So, you have two parameters that are passed. We have a wrapper that is the original repository,", "tokens": [407, 11, 291, 362, 732, 9834, 300, 366, 4678, 13, 492, 362, 257, 46906, 300, 307, 264, 3380, 25841, 11], "temperature": 0.0, "avg_logprob": -0.1309872097439236, "compression_ratio": 1.9019607843137254, "no_speech_prob": 0.00023326050722971559}, {"id": 44, "seek": 28064, "start": 293.76, "end": 299.2, "text": " and we have a scope provider. We'll see what a scope provider is later. And all the methods of", "tokens": [293, 321, 362, 257, 11923, 12398, 13, 492, 603, 536, 437, 257, 11923, 12398, 307, 1780, 13, 400, 439, 264, 7150, 295], "temperature": 0.0, "avg_logprob": -0.1309872097439236, "compression_ratio": 1.9019607843137254, "no_speech_prob": 0.00023326050722971559}, {"id": 45, "seek": 28064, "start": 299.2, "end": 304.56, "text": " that generated class are the same methods that you have in the original repository, but the result", "tokens": [300, 10833, 1508, 366, 264, 912, 7150, 300, 291, 362, 294, 264, 3380, 25841, 11, 457, 264, 1874], "temperature": 0.0, "avg_logprob": -0.1309872097439236, "compression_ratio": 1.9019607843137254, "no_speech_prob": 0.00023326050722971559}, {"id": 46, "seek": 30456, "start": 304.56, "end": 314.88, "text": " type, list of to-do, is wrapped in another object. So, if we try to use this on iOS, the code that's", "tokens": [2010, 11, 1329, 295, 281, 12, 2595, 11, 307, 14226, 294, 1071, 2657, 13, 407, 11, 498, 321, 853, 281, 764, 341, 322, 17430, 11, 264, 3089, 300, 311], "temperature": 0.0, "avg_logprob": -0.16569107393675211, "compression_ratio": 1.4744897959183674, "no_speech_prob": 0.0001444867521058768}, {"id": 47, "seek": 30456, "start": 314.88, "end": 325.28, "text": " get generated is something like that. We have two callbacks actually now, but I can see, for", "tokens": [483, 10833, 307, 746, 411, 300, 13, 492, 362, 732, 818, 17758, 767, 586, 11, 457, 286, 393, 536, 11, 337], "temperature": 0.0, "avg_logprob": -0.16569107393675211, "compression_ratio": 1.4744897959183674, "no_speech_prob": 0.0001444867521058768}, {"id": 48, "seek": 30456, "start": 325.28, "end": 331.6, "text": " example, other two problems with that code. First of all, we are exposing a coroutine scope for", "tokens": [1365, 11, 661, 732, 2740, 365, 300, 3089, 13, 2386, 295, 439, 11, 321, 366, 33178, 257, 1181, 45075, 11923, 337], "temperature": 0.0, "avg_logprob": -0.16569107393675211, "compression_ratio": 1.4744897959183674, "no_speech_prob": 0.0001444867521058768}, {"id": 49, "seek": 33160, "start": 331.6, "end": 337.92, "text": " iOS developers, and maybe iOS developers are not familiar with that concept of scope, like", "tokens": [17430, 8849, 11, 293, 1310, 17430, 8849, 366, 406, 4963, 365, 300, 3410, 295, 11923, 11, 411], "temperature": 0.0, "avg_logprob": -0.18944114145606455, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.00011711283877957612}, {"id": 50, "seek": 33160, "start": 337.92, "end": 345.68, "text": " coroutine developers are. And also, we have that object that now is an SRA, and it is not a list", "tokens": [1181, 45075, 8849, 366, 13, 400, 611, 11, 321, 362, 300, 2657, 300, 586, 307, 364, 318, 3750, 11, 293, 309, 307, 406, 257, 1329], "temperature": 0.0, "avg_logprob": -0.18944114145606455, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.00011711283877957612}, {"id": 51, "seek": 33160, "start": 345.68, "end": 352.32000000000005, "text": " of to-do anymore. That is because we are wrapped in a list of to-do in another object that accepts", "tokens": [295, 281, 12, 2595, 3602, 13, 663, 307, 570, 321, 366, 14226, 294, 257, 1329, 295, 281, 12, 2595, 294, 1071, 2657, 300, 33538], "temperature": 0.0, "avg_logprob": -0.18944114145606455, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.00011711283877957612}, {"id": 52, "seek": 33160, "start": 352.32000000000005, "end": 360.48, "text": " generics. And the Objective C translation of the Kotlin code cannot do that for now, so it gets", "tokens": [1337, 1167, 13, 400, 264, 24753, 488, 383, 12853, 295, 264, 30123, 5045, 3089, 2644, 360, 300, 337, 586, 11, 370, 309, 2170], "temperature": 0.0, "avg_logprob": -0.18944114145606455, "compression_ratio": 1.7130044843049328, "no_speech_prob": 0.00011711283877957612}, {"id": 53, "seek": 36048, "start": 360.48, "end": 369.12, "text": " simplified to an SRA. To solve this, we go back in the common code, and we use another function", "tokens": [26335, 281, 364, 318, 3750, 13, 1407, 5039, 341, 11, 321, 352, 646, 294, 264, 2689, 3089, 11, 293, 321, 764, 1071, 2445], "temperature": 0.0, "avg_logprob": -0.12730098724365235, "compression_ratio": 1.6431718061674008, "no_speech_prob": 3.458277205936611e-05}, {"id": 54, "seek": 36048, "start": 369.12, "end": 376.96000000000004, "text": " of that library, that is, launch on scope. So, we can define a scope in common code and tell", "tokens": [295, 300, 6405, 11, 300, 307, 11, 4025, 322, 11923, 13, 407, 11, 321, 393, 6964, 257, 11923, 294, 2689, 3089, 293, 980], "temperature": 0.0, "avg_logprob": -0.12730098724365235, "compression_ratio": 1.6431718061674008, "no_speech_prob": 3.458277205936611e-05}, {"id": 55, "seek": 36048, "start": 376.96000000000004, "end": 383.76, "text": " the library to run all our coroutines in that scope. So, the scope will not be provided by", "tokens": [264, 6405, 281, 1190, 439, 527, 1181, 346, 1652, 294, 300, 11923, 13, 407, 11, 264, 11923, 486, 406, 312, 5649, 538], "temperature": 0.0, "avg_logprob": -0.12730098724365235, "compression_ratio": 1.6431718061674008, "no_speech_prob": 3.458277205936611e-05}, {"id": 56, "seek": 36048, "start": 383.76, "end": 389.44, "text": " iOS developers anymore. Also, for the second problem, it's just a workaround. We can define a", "tokens": [17430, 8849, 3602, 13, 2743, 11, 337, 264, 1150, 1154, 11, 309, 311, 445, 257, 589, 25762, 13, 492, 393, 6964, 257], "temperature": 0.0, "avg_logprob": -0.12730098724365235, "compression_ratio": 1.6431718061674008, "no_speech_prob": 3.458277205936611e-05}, {"id": 57, "seek": 38944, "start": 389.44, "end": 397.2, "text": " data class, we can define a typology, or something to hide the fact that we are using a list of", "tokens": [1412, 1508, 11, 321, 393, 6964, 257, 2125, 1793, 11, 420, 746, 281, 6479, 264, 1186, 300, 321, 366, 1228, 257, 1329, 295], "temperature": 0.0, "avg_logprob": -0.10474619112516705, "compression_ratio": 1.580110497237569, "no_speech_prob": 2.3472683096770197e-05}, {"id": 58, "seek": 38944, "start": 397.2, "end": 405.04, "text": " something. So, if we try to generate a new code for this, this is the final code that is much", "tokens": [746, 13, 407, 11, 498, 321, 853, 281, 8460, 257, 777, 3089, 337, 341, 11, 341, 307, 264, 2572, 3089, 300, 307, 709], "temperature": 0.0, "avg_logprob": -0.10474619112516705, "compression_ratio": 1.580110497237569, "no_speech_prob": 2.3472683096770197e-05}, {"id": 59, "seek": 38944, "start": 405.04, "end": 414.0, "text": " more readable and usable. And, of course, now we can dismiss the job if we are not interested in", "tokens": [544, 49857, 293, 29975, 13, 400, 11, 295, 1164, 11, 586, 321, 393, 16974, 264, 1691, 498, 321, 366, 406, 3102, 294], "temperature": 0.0, "avg_logprob": -0.10474619112516705, "compression_ratio": 1.580110497237569, "no_speech_prob": 2.3472683096770197e-05}, {"id": 60, "seek": 41400, "start": 414.0, "end": 421.12, "text": " the result anymore. What about flows? We'll talk about coroutines. What about flows? This is an", "tokens": [264, 1874, 3602, 13, 708, 466, 12867, 30, 492, 603, 751, 466, 1181, 346, 1652, 13, 708, 466, 12867, 30, 639, 307, 364], "temperature": 0.0, "avg_logprob": -0.14807084266175616, "compression_ratio": 1.6772727272727272, "no_speech_prob": 2.4229306291090325e-05}, {"id": 61, "seek": 41400, "start": 421.12, "end": 429.28, "text": " example of a simple flow that emits integers. Of course, again, on Android, it is simple, you", "tokens": [1365, 295, 257, 2199, 3095, 300, 846, 1208, 41674, 13, 2720, 1164, 11, 797, 11, 322, 8853, 11, 309, 307, 2199, 11, 291], "temperature": 0.0, "avg_logprob": -0.14807084266175616, "compression_ratio": 1.6772727272727272, "no_speech_prob": 2.4229306291090325e-05}, {"id": 62, "seek": 41400, "start": 429.28, "end": 435.76, "text": " have a scope, you can start collecting values. As with the code that gets generated, it is", "tokens": [362, 257, 11923, 11, 291, 393, 722, 12510, 4190, 13, 1018, 365, 264, 3089, 300, 2170, 10833, 11, 309, 307], "temperature": 0.0, "avg_logprob": -0.14807084266175616, "compression_ratio": 1.6772727272727272, "no_speech_prob": 2.4229306291090325e-05}, {"id": 63, "seek": 41400, "start": 435.76, "end": 441.36, "text": " something like that. We still have a collect function to collect the values of the flow,", "tokens": [746, 411, 300, 13, 492, 920, 362, 257, 2500, 2445, 281, 2500, 264, 4190, 295, 264, 3095, 11], "temperature": 0.0, "avg_logprob": -0.14807084266175616, "compression_ratio": 1.6772727272727272, "no_speech_prob": 2.4229306291090325e-05}, {"id": 64, "seek": 44136, "start": 441.36, "end": 446.64, "text": " but we have to pass this, that is a flow collector, so we have to implement the function emit,", "tokens": [457, 321, 362, 281, 1320, 341, 11, 300, 307, 257, 3095, 23960, 11, 370, 321, 362, 281, 4445, 264, 2445, 32084, 11], "temperature": 0.0, "avg_logprob": -0.14772533333819846, "compression_ratio": 1.7061611374407584, "no_speech_prob": 8.101577259367332e-05}, {"id": 65, "seek": 44136, "start": 447.76, "end": 453.28000000000003, "text": " do something with that value that gets emitted, and then when we are done, call the", "tokens": [360, 746, 365, 300, 2158, 300, 2170, 44897, 11, 293, 550, 562, 321, 366, 1096, 11, 818, 264], "temperature": 0.0, "avg_logprob": -0.14772533333819846, "compression_ratio": 1.7061611374407584, "no_speech_prob": 8.101577259367332e-05}, {"id": 66, "seek": 44136, "start": 453.28000000000003, "end": 460.24, "text": " completion handler so we can receive the next value. Also, notice that we don't have the type", "tokens": [19372, 41967, 370, 321, 393, 4774, 264, 958, 2158, 13, 2743, 11, 3449, 300, 321, 500, 380, 362, 264, 2010], "temperature": 0.0, "avg_logprob": -0.14772533333819846, "compression_ratio": 1.7061611374407584, "no_speech_prob": 8.101577259367332e-05}, {"id": 67, "seek": 44136, "start": 461.04, "end": 467.68, "text": " that we are collecting from the flow, we just have any. I can prove this. First of all,", "tokens": [300, 321, 366, 12510, 490, 264, 3095, 11, 321, 445, 362, 604, 13, 286, 393, 7081, 341, 13, 2386, 295, 439, 11], "temperature": 0.0, "avg_logprob": -0.14772533333819846, "compression_ratio": 1.7061611374407584, "no_speech_prob": 8.101577259367332e-05}, {"id": 68, "seek": 46768, "start": 467.68, "end": 475.84000000000003, "text": " we tried to make that collector generic, so we can use it in more parts of our code,", "tokens": [321, 3031, 281, 652, 300, 23960, 19577, 11, 370, 321, 393, 764, 309, 294, 544, 3166, 295, 527, 3089, 11], "temperature": 0.0, "avg_logprob": -0.19095065253121513, "compression_ratio": 1.6923076923076923, "no_speech_prob": 0.0001373826089547947}, {"id": 69, "seek": 46768, "start": 475.84000000000003, "end": 484.8, "text": " and so we exposed another callback. Yes, make it generic. So we exposed another callback,", "tokens": [293, 370, 321, 9495, 1071, 818, 3207, 13, 1079, 11, 652, 309, 19577, 13, 407, 321, 9495, 1071, 818, 3207, 11], "temperature": 0.0, "avg_logprob": -0.19095065253121513, "compression_ratio": 1.6923076923076923, "no_speech_prob": 0.0001373826089547947}, {"id": 70, "seek": 46768, "start": 484.8, "end": 493.12, "text": " and we actually casted the value as the one that we wanted, but we found that this is not", "tokens": [293, 321, 767, 4193, 292, 264, 2158, 382, 264, 472, 300, 321, 1415, 11, 457, 321, 1352, 300, 341, 307, 406], "temperature": 0.0, "avg_logprob": -0.19095065253121513, "compression_ratio": 1.6923076923076923, "no_speech_prob": 0.0001373826089547947}, {"id": 71, "seek": 49312, "start": 493.12, "end": 501.36, "text": " good enough. Also, because the highest developer has to do this in his code, we are not doing it", "tokens": [665, 1547, 13, 2743, 11, 570, 264, 6343, 10754, 575, 281, 360, 341, 294, 702, 3089, 11, 321, 366, 406, 884, 309], "temperature": 0.0, "avg_logprob": -0.16369759281979332, "compression_ratio": 1.6065573770491803, "no_speech_prob": 0.0001884307712316513}, {"id": 72, "seek": 49312, "start": 501.36, "end": 507.76, "text": " in common, so every time he has to use our library, he has to define this. So we decided to fix it", "tokens": [294, 2689, 11, 370, 633, 565, 415, 575, 281, 764, 527, 6405, 11, 415, 575, 281, 6964, 341, 13, 407, 321, 3047, 281, 3191, 309], "temperature": 0.0, "avg_logprob": -0.16369759281979332, "compression_ratio": 1.6065573770491803, "no_speech_prob": 0.0001884307712316513}, {"id": 73, "seek": 49312, "start": 507.76, "end": 515.6, "text": " in common code, and again, we used this, that is a common flow. There is a class found actually in", "tokens": [294, 2689, 3089, 11, 293, 797, 11, 321, 1143, 341, 11, 300, 307, 257, 2689, 3095, 13, 821, 307, 257, 1508, 1352, 767, 294], "temperature": 0.0, "avg_logprob": -0.16369759281979332, "compression_ratio": 1.6065573770491803, "no_speech_prob": 0.0001884307712316513}, {"id": 74, "seek": 51560, "start": 515.6, "end": 525.12, "text": " the Kotlin Conf app, and this class wraps up flow and basically emits all the values of the flow", "tokens": [264, 30123, 5045, 11701, 724, 11, 293, 341, 1508, 25831, 493, 3095, 293, 1936, 846, 1208, 439, 264, 4190, 295, 264, 3095], "temperature": 0.0, "avg_logprob": -0.17456762758019853, "compression_ratio": 1.559782608695652, "no_speech_prob": 8.309524127980694e-05}, {"id": 75, "seek": 51560, "start": 525.12, "end": 531.12, "text": " and returns a crossable object, so you can dismiss the flow when you don't want to listen to it", "tokens": [293, 11247, 257, 3278, 712, 2657, 11, 370, 291, 393, 16974, 264, 3095, 562, 291, 500, 380, 528, 281, 2140, 281, 309], "temperature": 0.0, "avg_logprob": -0.17456762758019853, "compression_ratio": 1.559782608695652, "no_speech_prob": 8.309524127980694e-05}, {"id": 76, "seek": 51560, "start": 531.12, "end": 539.6, "text": " anymore. So again, we return now a common flow using the extension function, and on iOS again,", "tokens": [3602, 13, 407, 797, 11, 321, 2736, 586, 257, 2689, 3095, 1228, 264, 10320, 2445, 11, 293, 322, 17430, 797, 11], "temperature": 0.0, "avg_logprob": -0.17456762758019853, "compression_ratio": 1.559782608695652, "no_speech_prob": 8.309524127980694e-05}, {"id": 77, "seek": 53960, "start": 539.6, "end": 546.48, "text": " now we have a much more readable code that we can also cancel if we want.", "tokens": [586, 321, 362, 257, 709, 544, 49857, 3089, 300, 321, 393, 611, 10373, 498, 321, 528, 13], "temperature": 0.0, "avg_logprob": -0.1447943916803674, "compression_ratio": 1.628440366972477, "no_speech_prob": 0.0003419755375944078}, {"id": 78, "seek": 53960, "start": 549.0400000000001, "end": 553.52, "text": " Now, we mentioned before that sometimes the app may crash because of the differences between the", "tokens": [823, 11, 321, 2835, 949, 300, 2171, 264, 724, 815, 8252, 570, 295, 264, 7300, 1296, 264], "temperature": 0.0, "avg_logprob": -0.1447943916803674, "compression_ratio": 1.628440366972477, "no_speech_prob": 0.0003419755375944078}, {"id": 79, "seek": 53960, "start": 553.52, "end": 559.76, "text": " two platforms, and one great example of this is our exception handling are handled in the languages,", "tokens": [732, 9473, 11, 293, 472, 869, 1365, 295, 341, 307, 527, 11183, 13175, 366, 18033, 294, 264, 8650, 11], "temperature": 0.0, "avg_logprob": -0.1447943916803674, "compression_ratio": 1.628440366972477, "no_speech_prob": 0.0003419755375944078}, {"id": 80, "seek": 53960, "start": 559.76, "end": 564.24, "text": " because Kotlin only works with unchecked exception, while Swift only works with the", "tokens": [570, 30123, 5045, 787, 1985, 365, 46672, 292, 11183, 11, 1339, 25539, 787, 1985, 365, 264], "temperature": 0.0, "avg_logprob": -0.1447943916803674, "compression_ratio": 1.628440366972477, "no_speech_prob": 0.0003419755375944078}, {"id": 81, "seek": 56424, "start": 564.24, "end": 570.48, "text": " unchecked one, and now we will see what this means and what happens. So if I have, we are", "tokens": [46672, 292, 472, 11, 293, 586, 321, 486, 536, 437, 341, 1355, 293, 437, 2314, 13, 407, 498, 286, 362, 11, 321, 366], "temperature": 0.0, "avg_logprob": -0.1431613498263889, "compression_ratio": 1.735632183908046, "no_speech_prob": 0.00010274237138219178}, {"id": 82, "seek": 56424, "start": 570.48, "end": 575.84, "text": " bringing back the function from the coroutine that we saw before, so in this case, because in", "tokens": [5062, 646, 264, 2445, 490, 264, 1181, 45075, 300, 321, 1866, 949, 11, 370, 294, 341, 1389, 11, 570, 294], "temperature": 0.0, "avg_logprob": -0.1431613498263889, "compression_ratio": 1.735632183908046, "no_speech_prob": 0.00010274237138219178}, {"id": 83, "seek": 56424, "start": 575.84, "end": 580.48, "text": " Kotlin, I don't have to mark explicitly each throwing function, I can wrap it inside a", "tokens": [30123, 5045, 11, 286, 500, 380, 362, 281, 1491, 20803, 1184, 10238, 2445, 11, 286, 393, 7019, 309, 1854, 257], "temperature": 0.0, "avg_logprob": -0.1431613498263889, "compression_ratio": 1.735632183908046, "no_speech_prob": 0.00010274237138219178}, {"id": 84, "seek": 56424, "start": 580.48, "end": 585.28, "text": " tri-catch, so if something happens, I will receive the error inside the callback. Now,", "tokens": [1376, 12, 66, 852, 11, 370, 498, 746, 2314, 11, 286, 486, 4774, 264, 6713, 1854, 264, 818, 3207, 13, 823, 11], "temperature": 0.0, "avg_logprob": -0.1431613498263889, "compression_ratio": 1.735632183908046, "no_speech_prob": 0.00010274237138219178}, {"id": 85, "seek": 56424, "start": 585.28, "end": 592.08, "text": " if we bring back also the first alternative that we saw before with coroutine, what I expect is", "tokens": [498, 321, 1565, 646, 611, 264, 700, 8535, 300, 321, 1866, 949, 365, 1181, 45075, 11, 437, 286, 2066, 307], "temperature": 0.0, "avg_logprob": -0.1431613498263889, "compression_ratio": 1.735632183908046, "no_speech_prob": 0.00010274237138219178}, {"id": 86, "seek": 59208, "start": 592.08, "end": 596.4000000000001, "text": " to have the error in the function, but if I launch the application, it actually crashes,", "tokens": [281, 362, 264, 6713, 294, 264, 2445, 11, 457, 498, 286, 4025, 264, 3861, 11, 309, 767, 28642, 11], "temperature": 0.0, "avg_logprob": -0.09381796003461958, "compression_ratio": 1.7890625, "no_speech_prob": 0.00047506566625088453}, {"id": 87, "seek": 59208, "start": 597.0400000000001, "end": 602.08, "text": " and this is because in Swift, I have to mark explicitly each throwing function, so the fix is", "tokens": [293, 341, 307, 570, 294, 25539, 11, 286, 362, 281, 1491, 20803, 1184, 10238, 2445, 11, 370, 264, 3191, 307], "temperature": 0.0, "avg_logprob": -0.09381796003461958, "compression_ratio": 1.7890625, "no_speech_prob": 0.00047506566625088453}, {"id": 88, "seek": 59208, "start": 602.08, "end": 605.84, "text": " actually quite easy, because there is an annotation that we can use, which is called", "tokens": [767, 1596, 1858, 11, 570, 456, 307, 364, 48654, 300, 321, 393, 764, 11, 597, 307, 1219], "temperature": 0.0, "avg_logprob": -0.09381796003461958, "compression_ratio": 1.7890625, "no_speech_prob": 0.00047506566625088453}, {"id": 89, "seek": 59208, "start": 605.84, "end": 612.4000000000001, "text": " throws exception. So by doing this, just in the common code, and we don't have to make any changes", "tokens": [19251, 11183, 13, 407, 538, 884, 341, 11, 445, 294, 264, 2689, 3089, 11, 293, 321, 500, 380, 362, 281, 652, 604, 2962], "temperature": 0.0, "avg_logprob": -0.09381796003461958, "compression_ratio": 1.7890625, "no_speech_prob": 0.00047506566625088453}, {"id": 90, "seek": 59208, "start": 612.4000000000001, "end": 618.8000000000001, "text": " inside the Swift implementation, so in this case, I will receive the error in the callback,", "tokens": [1854, 264, 25539, 11420, 11, 370, 294, 341, 1389, 11, 286, 486, 4774, 264, 6713, 294, 264, 818, 3207, 11], "temperature": 0.0, "avg_logprob": -0.09381796003461958, "compression_ratio": 1.7890625, "no_speech_prob": 0.00047506566625088453}, {"id": 91, "seek": 61880, "start": 618.8, "end": 626.24, "text": " and this works also with non-suspending functions, so if I have this function and mark it", "tokens": [293, 341, 1985, 611, 365, 2107, 12, 82, 301, 79, 2029, 6828, 11, 370, 498, 286, 362, 341, 2445, 293, 1491, 309], "temperature": 0.0, "avg_logprob": -0.13306126543270644, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.00038219071575440466}, {"id": 92, "seek": 61880, "start": 626.24, "end": 632.9599999999999, "text": " throws and exception, once I compile the code, the generated function in Swift will be marked as", "tokens": [19251, 293, 11183, 11, 1564, 286, 31413, 264, 3089, 11, 264, 10833, 2445, 294, 25539, 486, 312, 12658, 382], "temperature": 0.0, "avg_logprob": -0.13306126543270644, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.00038219071575440466}, {"id": 93, "seek": 61880, "start": 632.9599999999999, "end": 640.0, "text": " throwing, so this time will be the compiler to force us to handle the exception. Now,", "tokens": [10238, 11, 370, 341, 565, 486, 312, 264, 31958, 281, 3464, 505, 281, 4813, 264, 11183, 13, 823, 11], "temperature": 0.0, "avg_logprob": -0.13306126543270644, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.00038219071575440466}, {"id": 94, "seek": 61880, "start": 640.0, "end": 645.92, "text": " another API that is not quite Swift-friendly is the one of sealed classes. Now, on Kotlin, we", "tokens": [1071, 9362, 300, 307, 406, 1596, 25539, 12, 22864, 307, 264, 472, 295, 21514, 5359, 13, 823, 11, 322, 30123, 5045, 11, 321], "temperature": 0.0, "avg_logprob": -0.13306126543270644, "compression_ratio": 1.6486486486486487, "no_speech_prob": 0.00038219071575440466}, {"id": 95, "seek": 64592, "start": 645.92, "end": 650.0799999999999, "text": " can restrict the concept of inheritance by using sealed classes and sealed interfaces,", "tokens": [393, 7694, 264, 3410, 295, 32122, 538, 1228, 21514, 5359, 293, 21514, 28416, 11], "temperature": 0.0, "avg_logprob": -0.12793282256729302, "compression_ratio": 1.6863636363636363, "no_speech_prob": 0.0007630906184203923}, {"id": 96, "seek": 64592, "start": 650.8, "end": 655.76, "text": " so when we use them inside our Android code, we can just make something like this, because,", "tokens": [370, 562, 321, 764, 552, 1854, 527, 8853, 3089, 11, 321, 393, 445, 652, 746, 411, 341, 11, 570, 11], "temperature": 0.0, "avg_logprob": -0.12793282256729302, "compression_ratio": 1.6863636363636363, "no_speech_prob": 0.0007630906184203923}, {"id": 97, "seek": 64592, "start": 661.8399999999999, "end": 666.8, "text": " okay, something like this, because we know for sure that those three, so data, error, and loading", "tokens": [1392, 11, 746, 411, 341, 11, 570, 321, 458, 337, 988, 300, 729, 1045, 11, 370, 1412, 11, 6713, 11, 293, 15114], "temperature": 0.0, "avg_logprob": -0.12793282256729302, "compression_ratio": 1.6863636363636363, "no_speech_prob": 0.0007630906184203923}, {"id": 98, "seek": 64592, "start": 666.8, "end": 673.12, "text": " in this case are the only cases that we have to handle, but on iOS, actually it gets converted", "tokens": [294, 341, 1389, 366, 264, 787, 3331, 300, 321, 362, 281, 4813, 11, 457, 322, 17430, 11, 767, 309, 2170, 16424], "temperature": 0.0, "avg_logprob": -0.12793282256729302, "compression_ratio": 1.6863636363636363, "no_speech_prob": 0.0007630906184203923}, {"id": 99, "seek": 67312, "start": 673.12, "end": 678.48, "text": " by just using the concept of inheritance, and so when I have to handle the, in this case, the", "tokens": [538, 445, 1228, 264, 3410, 295, 32122, 11, 293, 370, 562, 286, 362, 281, 4813, 264, 11, 294, 341, 1389, 11, 264], "temperature": 0.0, "avg_logprob": -0.13072779684355765, "compression_ratio": 1.90625, "no_speech_prob": 0.00034992137807421386}, {"id": 100, "seek": 67312, "start": 678.48, "end": 684.48, "text": " status, I have to define also the case, a default case, which I know for sure that will never be", "tokens": [6558, 11, 286, 362, 281, 6964, 611, 264, 1389, 11, 257, 7576, 1389, 11, 597, 286, 458, 337, 988, 300, 486, 1128, 312], "temperature": 0.0, "avg_logprob": -0.13072779684355765, "compression_ratio": 1.90625, "no_speech_prob": 0.00034992137807421386}, {"id": 101, "seek": 67312, "start": 684.48, "end": 690.0, "text": " called, and on Swift, we actually have a concept which is similar to the concept of sealed classes,", "tokens": [1219, 11, 293, 322, 25539, 11, 321, 767, 362, 257, 3410, 597, 307, 2531, 281, 264, 3410, 295, 21514, 5359, 11], "temperature": 0.0, "avg_logprob": -0.13072779684355765, "compression_ratio": 1.90625, "no_speech_prob": 0.00034992137807421386}, {"id": 102, "seek": 67312, "start": 690.0, "end": 695.84, "text": " which is the concept of enum, so what we want is to map the sealed classes with enum, and to do so,", "tokens": [597, 307, 264, 3410, 295, 465, 449, 11, 370, 437, 321, 528, 307, 281, 4471, 264, 21514, 5359, 365, 465, 449, 11, 293, 281, 360, 370, 11], "temperature": 0.0, "avg_logprob": -0.13072779684355765, "compression_ratio": 1.90625, "no_speech_prob": 0.00034992137807421386}, {"id": 103, "seek": 67312, "start": 695.84, "end": 702.64, "text": " we can use a library, which is called, it's quite dark, but Merkur keys, Swift, and in this case,", "tokens": [321, 393, 764, 257, 6405, 11, 597, 307, 1219, 11, 309, 311, 1596, 2877, 11, 457, 6124, 33503, 9317, 11, 25539, 11, 293, 294, 341, 1389, 11], "temperature": 0.0, "avg_logprob": -0.13072779684355765, "compression_ratio": 1.90625, "no_speech_prob": 0.00034992137807421386}, {"id": 104, "seek": 70264, "start": 702.64, "end": 707.1999999999999, "text": " using this library, it automatically detects any sealed classes and sealed interfaces,", "tokens": [1228, 341, 6405, 11, 309, 6772, 5531, 82, 604, 21514, 5359, 293, 21514, 28416, 11], "temperature": 0.0, "avg_logprob": -0.14518277785357306, "compression_ratio": 1.5645933014354068, "no_speech_prob": 0.00038319904706440866}, {"id": 105, "seek": 70264, "start": 707.1999999999999, "end": 716.08, "text": " and generates, in this case, will be UI state KS, and it just takes the status as input, and it", "tokens": [293, 23815, 11, 294, 341, 1389, 11, 486, 312, 15682, 1785, 591, 50, 11, 293, 309, 445, 2516, 264, 6558, 382, 4846, 11, 293, 309], "temperature": 0.0, "avg_logprob": -0.14518277785357306, "compression_ratio": 1.5645933014354068, "no_speech_prob": 0.00038319904706440866}, {"id": 106, "seek": 70264, "start": 716.08, "end": 720.88, "text": " is actually an enum that I can use, so for a Swift developer, this is much easier to use,", "tokens": [307, 767, 364, 465, 449, 300, 286, 393, 764, 11, 370, 337, 257, 25539, 10754, 11, 341, 307, 709, 3571, 281, 764, 11], "temperature": 0.0, "avg_logprob": -0.14518277785357306, "compression_ratio": 1.5645933014354068, "no_speech_prob": 0.00038319904706440866}, {"id": 107, "seek": 70264, "start": 720.88, "end": 723.28, "text": " because I don't have to define a default case anymore.", "tokens": [570, 286, 500, 380, 362, 281, 6964, 257, 7576, 1389, 3602, 13], "temperature": 0.0, "avg_logprob": -0.14518277785357306, "compression_ratio": 1.5645933014354068, "no_speech_prob": 0.00038319904706440866}, {"id": 108, "seek": 72328, "start": 723.28, "end": 734.0799999999999, "text": " So, if you're writing code that is platform-specific from 400, for example, you probably will need", "tokens": [407, 11, 498, 291, 434, 3579, 3089, 300, 307, 3663, 12, 29258, 490, 8423, 11, 337, 1365, 11, 291, 1391, 486, 643], "temperature": 0.0, "avg_logprob": -0.18823535625751203, "compression_ratio": 1.6061946902654867, "no_speech_prob": 0.0001497799821663648}, {"id": 109, "seek": 72328, "start": 734.0799999999999, "end": 741.68, "text": " a context to access some system functionalities. What happens in the library ecosystem? So,", "tokens": [257, 4319, 281, 2105, 512, 1185, 11745, 1088, 13, 708, 2314, 294, 264, 6405, 11311, 30, 407, 11], "temperature": 0.0, "avg_logprob": -0.18823535625751203, "compression_ratio": 1.6061946902654867, "no_speech_prob": 0.0001497799821663648}, {"id": 110, "seek": 72328, "start": 741.68, "end": 747.68, "text": " you may expose an API like this that gets the context from the user of the library,", "tokens": [291, 815, 19219, 364, 9362, 411, 341, 300, 2170, 264, 4319, 490, 264, 4195, 295, 264, 6405, 11], "temperature": 0.0, "avg_logprob": -0.18823535625751203, "compression_ratio": 1.6061946902654867, "no_speech_prob": 0.0001497799821663648}, {"id": 111, "seek": 72328, "start": 747.68, "end": 752.8, "text": " but of course you don't have to do this on iOS, because you don't need a context on iOS.", "tokens": [457, 295, 1164, 291, 500, 380, 362, 281, 360, 341, 322, 17430, 11, 570, 291, 500, 380, 643, 257, 4319, 322, 17430, 13], "temperature": 0.0, "avg_logprob": -0.18823535625751203, "compression_ratio": 1.6061946902654867, "no_speech_prob": 0.0001497799821663648}, {"id": 112, "seek": 75280, "start": 752.8, "end": 763.04, "text": " How you can improve that, how you can unify those APIs, we try to use Jetpack app startup for this,", "tokens": [1012, 291, 393, 3470, 300, 11, 577, 291, 393, 517, 2505, 729, 21445, 11, 321, 853, 281, 764, 28730, 9539, 724, 18578, 337, 341, 11], "temperature": 0.0, "avg_logprob": -0.17622715054136334, "compression_ratio": 1.5116279069767442, "no_speech_prob": 0.0003517947916407138}, {"id": 113, "seek": 75280, "start": 763.04, "end": 771.12, "text": " because if you include the app startup in your library, basically you will be able to", "tokens": [570, 498, 291, 4090, 264, 724, 18578, 294, 428, 6405, 11, 1936, 291, 486, 312, 1075, 281], "temperature": 0.0, "avg_logprob": -0.17622715054136334, "compression_ratio": 1.5116279069767442, "no_speech_prob": 0.0003517947916407138}, {"id": 114, "seek": 77112, "start": 771.12, "end": 784.24, "text": " get a context that is injected by the operating system, and maybe save it.", "tokens": [50364, 483, 257, 4319, 300, 307, 36967, 538, 264, 7447, 1185, 11, 293, 1310, 3155, 309, 13, 51020], "temperature": 0.0, "avg_logprob": -0.2901227599696109, "compression_ratio": 1.0571428571428572, "no_speech_prob": 0.0004161102988291532}], "language": "en"}