{"text": " Yeah, thanks. Thanks for introducing me. Hello, a warm welcome also from my side to first them to the embedded froom. And we're going to hear something today about Delta like streaming of encrypted over the air updates for Rao. So luckily I managed to put the entire abstract of the presentation already in the title. So what we hear about is the changes and developments during the roughly two or three years that happened in Rao, the Rao updating framework. And so it's basically the development that happened since we've last met here, I guess. So short notes about me. My name is Sandvik. I'm an embedded software developer. I work at Pangotronics. I'm the team lead of the integration team at Pangotronics, and I'm the co-maintenor of the update framework Rao that we will hear more about soon. Pangotronics for those who don't know, it is a company based in Germany and we provide professional embedded Linux consulting and support and work closely together with the community. And with since the beginning, I think more than 7,000 patches in the Linux kernel. So a short overview of what we hear today. So the first thing is a short introduction into what Rao is for those who are not that familiar with, but very, very short. Then we talk about the bundle format because this is crucial development for or the base for all the further features that are listed here. So the first thing I will talk about then is bundle streaming. Then we will hear about adaptive or delta-like updates, how to encrypt our bundle, give a short outlook on recent development about app updates, and at the end, we have a short look into what's coming next on features and what's in the ecosystem. So, yeah, a typical over-the-air field update scenario could look like this. We have here our server. The server builds the image that we want to deploy to the target. We create an update artifact from it, sign it, upload it to our deployment infrastructure, and then we have the individual targets, update targets here that download the update and install it. And there's also still this conventional not-so-over-the-air use case for, for example, using a USB stick. So what Rao handles is basically two parts. The first one is the creation of the update artifacts, the signing, verification and so on, and the actual installation, the failsafe installation of the updates on the target. So, yeah, basically Raoq is an embedded Linux update framework, so it handles the failsafe and atomic update of AB systems, so redundant system where you have one partition, where you're running from an inactive partition, and when you update, you write your update into the inactive partition. Once you're done, you switch in the bootloader to the inactive partition reboot, and everything is fine. Raoq is basically two parts on the target. It's the service that handles the update that runs and installed there, and it gets its view on the system from the system configuration file. And, yeah, the artifact for updating we call in Raoq a bundle. A bundle consists of the images that should be installed. It consists of additional hooks or something like this, and a manifest that holds the description, yeah, what these images are for, basically. So, it's written in C with some utility libraries to not reinvent the wheel for everything. It's licensed on the LGPL and hosted on GitHub. It was started in 2015, and I think the first release was in 2017. So, yeah, as I already mentioned, the bundle format is quite essential for the next things that we talk about here. So, let's first of all have a short look at the initial bundle format, because this was a motivation for changing the bundle format then. The initial bundle format was quite straightforward. It was just all the artifacts and the manifest packed together in a squash file system. We signed this squash file system and append the signature to the end of the bundle. So, the verification is also quite easy. We just have to read the entire bundle and have to read the signature to be able to verify the bundle. So, yeah, this is also the downside. Even if we don't also just want to access the manifest, we have to always authenticate or read the entire bundle. So, this is quite slow, and if it comes to over-the-air updating, it requires us to always download the full bundle before we can access any data in this. So, yeah, this is bad if we want to use it for streaming. So, this is why we have introduced in 2020 a new bundle format. And this bundle format is basically, it's called the variety format, and it uses the DM variety. So, short intro, a device mapper system in Linux is a generic abstraction of, yeah, manipulating block devices. So, a device mapper has the same API as the block device has. So, for the upper layer, it looks like it's just talking to a block device. But below, it can manipulate the block device, authenticate data, it can merge data together like we know from DM linear, and there are several device mappers in the kernel. So, the one that we talk about here is DM variety. It is basically an integrity protection method for read-only block devices. So, the rough concept is that you split the block image into several chunks and generate a hash for each. And of these, you recursively do this again and again until you have a single root hash, and then you can verify each single block until the root hash recursively. So, yeah, you have the data protection or integrity protection for read-only files. The variety table is just appended to the image. So, let's see how we use this in the RAUK bundle. So, we take our images here and first create the variety hash and the root hash. The variety hash is simply appended to the bundle, and the root hash is now placed in the manifest. And then, we just sign the manifest with an enveloping signature, which means that the manifest is a payload of the signature. And what this gives us is now the verification of the manifest is quite easy. We just have to verify the manifest or the signature and get the manifest content. And inside the manifest, there's also the root hash. This is then automatically trusted if we have verified the authentication of the manifest. And then, we can set up the invariity and use the hash tree appended to the manifest and the authenticated root hash. And then, for each access to each chunk or block on the block device, this is authenticated to the invariity in the kernel. And this allows you to have fully authenticated random access to your bundle. And you also, you only need to verify by the time of using the data. So, the next logical consequence is to implement streaming. So, up to now, RAUK was not so over the air. So, downloading means that we assume there is an external service like Hockbird or an application or an SCP that downloads the RAUK bundle to the target device. And then, with RAUK, we start installing it from the local storage. Well, the disadvantage of this is obvious. We have to have some extra space on the target where we can store the bundle. And the artifacts can, yeah, in a modern system become quite huge. And so, the approach is that we implement streaming or downloading in RAUK itself. And if RAUK is able to do this and directly download it to the target device that we update, then no intermediate storage would be required. So, let's have a look how this is realized in RAUK. So, first of all, what we do in RAUK is that we spawn an, or fork an unprivileged helper process because RAUK, yeah, runs as root as it has to update the system. And you really don't want to use a root service to download data from the internet. So, it spawns an unprivileged helper. And this helper acts as a translation. It plays a block device on one side and talks to the update server via HTTPS range request on the other side. And, yeah, HTTPS range request should be supported by all common web service, also light TTP services, and it's also supported by many delivery networks. And if we combine this now with what we've seen with the access to a variety bundle, then we have fully authenticated random access to the remote bundle. And, yeah, we can randomly access so no intermediate storage is required. So, the next need when we are able to download things is normally that we want to save download bandwidth because bandwidth is limited, expansive, or something. And the normal approach for this is to do conventional data updates. It means you have two versions of your image on your host system, calculate a delta, and then you perform the update with this delta image on the target. So, if you have the exact version that you have to calculate the delta for on your target, this works very well. You can go here from version two to the target to version three. But, if you now have a system that is on a different version, yeah, this fails because it simply doesn't apply. So, it's an optimal diff. It allows very small updates. But, yeah, you require to have access to the different image versions on the host, and you only can update step-by-step. So, from version one to version two to version three. So, in route we've chosen a different approach, a more generic approach for optimizing download. This is called adaptive updates. The concept behind this is that the bundle or the manifest itself provides a number of optimization options. So, with each option, there's normally an additional data connected that is stored in the device for optimizing the download. But, since we are able to stream the bundle, we don't have to download these additional data that is stored in the manifest. And then, it's a responsibility of the route service on the target to see, okay, which of these capabilities do I support and which can I use and which is the best one. And, there's always a fallback to use a full bundle download. So, you're always able to download the image you want to install. One method, adaptive method, generic one is the hash index. The idea behind this is that you split your image into several chunks and hash each chunk and generate a hash list from this. And, for installation, you just basically do the same on the target. You take your target device, block device, for example, you hash it with the same algorithm, create the same hash index. And then, for the optimization, yeah, you just download, first of all, the hash index that is stored in the bundle. And then, you compare it line by line with the hashes that you've calculated on the target. And then, you can download or just need to download the hashes that differ between what's on your target and what's in the bundle. And this works both for the intended target version, but also, if you come from a fully different image, then you just have to download a bit more, because the hashes that differ are a bit more. For block devices, this is already implemented in the current drug version. And there are also plans to support this for file-based updates using R-Sync and offline generated checksum files. The next topic is bundle encryption. So, the motivation is, I think, quite clear. You will have some sensitive data in your bundle, and you want to protect it, because you have it on an unsafe cloud storage or an unsafe communication channel. So, in Raoq, we have implemented this in two-stage approach. So, the first one is a symmetric encryption of only the payload. This is this part. This is what normally already the build server does. And this does not yet require access to the key material. And the second part is the individual encryption. Then you can take the symmetrically encrypted image and encrypted per recipient. You can just take one key and encrypt it for all your devices by using a shared key, or if you really want to do security, then you can also use per device or per recipient keys and encrypt the bundle for many individual recipients, many thousands. So, this again uses a device mapper, a different device mapper. Now we use DMCrypt. It's also quite simple. For the generation of the DMCrypt image or the image we use for DMCrypt, we just split up the original image into equal sized chunks, generate random symmetric key, and encrypt each block individual. And the DMCrypt device mapper then just provides a transparent description of the images. So, if we access a chunk there, then, yeah, DMCrypt just decrypts this chunk we just selected with the key, with the symmetric key, which is the same used for encrypting. And if we combine this now in the bundle, so we have here the image encrypted and combined it with DMVarity, then we have a blockwise authenticated description. And since we have random access to the device mapper and the variety format, we also have the possibility to stream an encrypted update. So, short on time, a few notes about app updates. So far in route we assumed, okay, the application is normally the application. So, we assumed a bit a monotolic system where the application is the one thing that the device should do. And so we said, okay, the application is normally either part of the root file system or you can have it in a separate slot. But it actually, anyway, linked against the libraries that are contained in the root file system. So, it's fine to install it always together with the updated root file system. The reality showed it's a bit different and there are more and more demands of having the capability of doing container updates, doing app store-like updates and where you also have one vendor which provides a base system, which is rarely updated and other vendors provide the applications, which are much more frequently updated and additional data should be added there. And up to now we had no solution for this in route and said, okay, then use route for the base system and use another updater or update approach for this application or file updates. What we are working on, and this is in a quite premature state, actually, is route artifact updates. The basic concept behind this is that you have a slot for artifacts and inside the slots we don't do image-based updates, what we do directly are file-based updates. And then we provide the same as we do for image-based updates. We ensure that the update is atomically and we also support both the case where we don't have any dependency of the app of the container to the base system, so this is what you basically see here. But we also support the use case of having a dependency on the root file system but the need to more frequently and independently from the root file system update your application. And together with our checks and files, the idea is that this again also supports streaming and delta-like updates. So just a very quick rest through the other features and community things. We've switched to Mason build system recently. This is already merged. It wasn't when I started the slides. So a new feature we also have is adding custom metadata in the manifest that you can then access via route info or the deepest API for custom application. And an ongoing development is also about providing more fine-grained process because currently we just have a per slot progress and if you have a large tar then you wait very long until the progress gets to the next step. And a contribution that came or was started by the community is the Rooke Hockpit update. This is basically an interface between the Hockpit deployment server and Rooke on the other side. It talks via the deepest API with Rooke and this is a good example where the community started things and they moved then to the Rooke organization and are now maintained by the Rooke community. And with the latest version of Rooke Hockpit update we are also compatible with using streaming updates for Hockpit. And shout out to Leon who is sitting somewhere here in the room. The Meteorite community is a layer or layer collection started by Leon which provides some example integration of Rooke into, for example, QEMO or for Raspberry Pi and it's a very good starting point if you want to check out how to use Rooke, how to use all the features in Rooke. And yeah, I really recommend you to use this as a starting point. A final slide. For an open source project it's always hard to know which are the users of your project and where it's actually used. So it's always interesting for us to know this. One example where we came aware of that Rooke has used is a very famous one. It's a well-steamed deck that uses Rooke together with the async. Another example is the home-assisted operating system that uses Rooke for updating the PANY system and the Ornero Eclipse project. And one thing that I also find very interesting is that the infotainment or information panels on the German ICE trains have a custom distribution they call Linux for ICEs and they also use Rooke for updating the systems. So this was very quick. Thank you for attending. I think we still have two or three more questions. Yeah, I think we have a time for one or two questions. Yeah. Hi there. Thank you for that. That's absolutely intriguing, really interesting. So one of the questions was how do I plug this into BitBake and you've answered that. That's great. I know what to do when I get home. The other was what's the granularity of this? I saw a sort of a 4K block size in there somewhere. In terms of your hashes and then downloading blocks through the streaming process, is that 4K increments? How does that change? And what's the overhead in verifying those hashes as you download? What's the impact on performance and have you looked at any figures for that? Getting quite low. So the question was if the 4K is fine-brained enough for normal downloads, so it's currently fixed, but it could also be changed if that's not sufficient. But in the current approach, the 4K is a fixed size there. Okay, so it's getting late, so unfortunately we don't have time for any more questions, but don't hesitate to ask them in matrix chat or try to catch our speaker in the corridor. I'll be in front of the room. You can ask questions and we can discuss there. Thank you for a great talk. Thank you very much. Thank you very much.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 13.0, "text": " Yeah, thanks. Thanks for introducing me. Hello, a warm welcome also from my side to", "tokens": [865, 11, 3231, 13, 2561, 337, 15424, 385, 13, 2425, 11, 257, 4561, 2928, 611, 490, 452, 1252, 281], "temperature": 0.0, "avg_logprob": -0.3475677783672626, "compression_ratio": 1.4224598930481283, "no_speech_prob": 0.12306445837020874}, {"id": 1, "seek": 0, "start": 13.0, "end": 19.0, "text": " first them to the embedded froom. And we're going to hear something today about Delta", "tokens": [700, 552, 281, 264, 16741, 283, 2861, 13, 400, 321, 434, 516, 281, 1568, 746, 965, 466, 18183], "temperature": 0.0, "avg_logprob": -0.3475677783672626, "compression_ratio": 1.4224598930481283, "no_speech_prob": 0.12306445837020874}, {"id": 2, "seek": 0, "start": 19.0, "end": 25.8, "text": " like streaming of encrypted over the air updates for Rao. So luckily I managed to put the entire", "tokens": [411, 11791, 295, 36663, 670, 264, 1988, 9205, 337, 7591, 78, 13, 407, 22880, 286, 6453, 281, 829, 264, 2302], "temperature": 0.0, "avg_logprob": -0.3475677783672626, "compression_ratio": 1.4224598930481283, "no_speech_prob": 0.12306445837020874}, {"id": 3, "seek": 2580, "start": 25.8, "end": 32.3, "text": " abstract of the presentation already in the title. So what we hear about is the changes and", "tokens": [12649, 295, 264, 5860, 1217, 294, 264, 4876, 13, 407, 437, 321, 1568, 466, 307, 264, 2962, 293], "temperature": 0.0, "avg_logprob": -0.2385342415798916, "compression_ratio": 1.5991379310344827, "no_speech_prob": 9.756188956089318e-05}, {"id": 4, "seek": 2580, "start": 32.3, "end": 39.120000000000005, "text": " developments during the roughly two or three years that happened in Rao, the Rao updating", "tokens": [20862, 1830, 264, 9810, 732, 420, 1045, 924, 300, 2011, 294, 7591, 78, 11, 264, 7591, 78, 25113], "temperature": 0.0, "avg_logprob": -0.2385342415798916, "compression_ratio": 1.5991379310344827, "no_speech_prob": 9.756188956089318e-05}, {"id": 5, "seek": 2580, "start": 39.120000000000005, "end": 45.120000000000005, "text": " framework. And so it's basically the development that happened since we've last met here, I guess.", "tokens": [8388, 13, 400, 370, 309, 311, 1936, 264, 3250, 300, 2011, 1670, 321, 600, 1036, 1131, 510, 11, 286, 2041, 13], "temperature": 0.0, "avg_logprob": -0.2385342415798916, "compression_ratio": 1.5991379310344827, "no_speech_prob": 9.756188956089318e-05}, {"id": 6, "seek": 2580, "start": 45.120000000000005, "end": 51.36, "text": " So short notes about me. My name is Sandvik. I'm an embedded software developer. I work at", "tokens": [407, 2099, 5570, 466, 385, 13, 1222, 1315, 307, 7985, 42252, 13, 286, 478, 364, 16741, 4722, 10754, 13, 286, 589, 412], "temperature": 0.0, "avg_logprob": -0.2385342415798916, "compression_ratio": 1.5991379310344827, "no_speech_prob": 9.756188956089318e-05}, {"id": 7, "seek": 5136, "start": 51.36, "end": 57.84, "text": " Pangotronics. I'm the team lead of the integration team at Pangotronics, and I'm the co-maintenor", "tokens": [49499, 310, 37042, 13, 286, 478, 264, 1469, 1477, 295, 264, 10980, 1469, 412, 49499, 310, 37042, 11, 293, 286, 478, 264, 598, 12, 49417, 1147, 284], "temperature": 0.0, "avg_logprob": -0.22090922119796916, "compression_ratio": 1.6050420168067228, "no_speech_prob": 6.52425442240201e-05}, {"id": 8, "seek": 5136, "start": 57.84, "end": 65.6, "text": " of the update framework Rao that we will hear more about soon. Pangotronics for those who don't", "tokens": [295, 264, 5623, 8388, 7591, 78, 300, 321, 486, 1568, 544, 466, 2321, 13, 49499, 310, 37042, 337, 729, 567, 500, 380], "temperature": 0.0, "avg_logprob": -0.22090922119796916, "compression_ratio": 1.6050420168067228, "no_speech_prob": 6.52425442240201e-05}, {"id": 9, "seek": 5136, "start": 65.6, "end": 72.03999999999999, "text": " know, it is a company based in Germany and we provide professional embedded Linux consulting", "tokens": [458, 11, 309, 307, 257, 2237, 2361, 294, 7244, 293, 321, 2893, 4843, 16741, 18734, 23682], "temperature": 0.0, "avg_logprob": -0.22090922119796916, "compression_ratio": 1.6050420168067228, "no_speech_prob": 6.52425442240201e-05}, {"id": 10, "seek": 5136, "start": 72.03999999999999, "end": 78.72, "text": " and support and work closely together with the community. And with since the beginning, I think", "tokens": [293, 1406, 293, 589, 8185, 1214, 365, 264, 1768, 13, 400, 365, 1670, 264, 2863, 11, 286, 519], "temperature": 0.0, "avg_logprob": -0.22090922119796916, "compression_ratio": 1.6050420168067228, "no_speech_prob": 6.52425442240201e-05}, {"id": 11, "seek": 7872, "start": 78.72, "end": 87.56, "text": " more than 7,000 patches in the Linux kernel. So a short overview of what we hear today. So the", "tokens": [544, 813, 1614, 11, 1360, 26531, 294, 264, 18734, 28256, 13, 407, 257, 2099, 12492, 295, 437, 321, 1568, 965, 13, 407, 264], "temperature": 0.0, "avg_logprob": -0.1257273528886878, "compression_ratio": 1.61864406779661, "no_speech_prob": 5.952959327260032e-05}, {"id": 12, "seek": 7872, "start": 87.56, "end": 92.24, "text": " first thing is a short introduction into what Rao is for those who are not that familiar with,", "tokens": [700, 551, 307, 257, 2099, 9339, 666, 437, 7591, 78, 307, 337, 729, 567, 366, 406, 300, 4963, 365, 11], "temperature": 0.0, "avg_logprob": -0.1257273528886878, "compression_ratio": 1.61864406779661, "no_speech_prob": 5.952959327260032e-05}, {"id": 13, "seek": 7872, "start": 92.24, "end": 98.56, "text": " but very, very short. Then we talk about the bundle format because this is crucial development for", "tokens": [457, 588, 11, 588, 2099, 13, 1396, 321, 751, 466, 264, 24438, 7877, 570, 341, 307, 11462, 3250, 337], "temperature": 0.0, "avg_logprob": -0.1257273528886878, "compression_ratio": 1.61864406779661, "no_speech_prob": 5.952959327260032e-05}, {"id": 14, "seek": 7872, "start": 98.56, "end": 105.28, "text": " or the base for all the further features that are listed here. So the first thing I will talk", "tokens": [420, 264, 3096, 337, 439, 264, 3052, 4122, 300, 366, 10052, 510, 13, 407, 264, 700, 551, 286, 486, 751], "temperature": 0.0, "avg_logprob": -0.1257273528886878, "compression_ratio": 1.61864406779661, "no_speech_prob": 5.952959327260032e-05}, {"id": 15, "seek": 10528, "start": 105.28, "end": 112.52, "text": " about then is bundle streaming. Then we will hear about adaptive or delta-like updates, how to", "tokens": [466, 550, 307, 24438, 11791, 13, 1396, 321, 486, 1568, 466, 27912, 420, 8289, 12, 4092, 9205, 11, 577, 281], "temperature": 0.0, "avg_logprob": -0.16629473368326822, "compression_ratio": 1.591160220994475, "no_speech_prob": 3.72808390238788e-05}, {"id": 16, "seek": 10528, "start": 112.52, "end": 121.28, "text": " encrypt our bundle, give a short outlook on recent development about app updates, and at the end,", "tokens": [17972, 662, 527, 24438, 11, 976, 257, 2099, 26650, 322, 5162, 3250, 466, 724, 9205, 11, 293, 412, 264, 917, 11], "temperature": 0.0, "avg_logprob": -0.16629473368326822, "compression_ratio": 1.591160220994475, "no_speech_prob": 3.72808390238788e-05}, {"id": 17, "seek": 10528, "start": 121.28, "end": 129.76, "text": " we have a short look into what's coming next on features and what's in the ecosystem. So, yeah,", "tokens": [321, 362, 257, 2099, 574, 666, 437, 311, 1348, 958, 322, 4122, 293, 437, 311, 294, 264, 11311, 13, 407, 11, 1338, 11], "temperature": 0.0, "avg_logprob": -0.16629473368326822, "compression_ratio": 1.591160220994475, "no_speech_prob": 3.72808390238788e-05}, {"id": 18, "seek": 12976, "start": 129.76, "end": 136.28, "text": " a typical over-the-air field update scenario could look like this. We have here our server. The", "tokens": [257, 7476, 670, 12, 3322, 12, 1246, 2519, 5623, 9005, 727, 574, 411, 341, 13, 492, 362, 510, 527, 7154, 13, 440], "temperature": 0.0, "avg_logprob": -0.17058686004287896, "compression_ratio": 1.6651785714285714, "no_speech_prob": 4.243287548888475e-05}, {"id": 19, "seek": 12976, "start": 136.28, "end": 142.0, "text": " server builds the image that we want to deploy to the target. We create an update artifact from", "tokens": [7154, 15182, 264, 3256, 300, 321, 528, 281, 7274, 281, 264, 3779, 13, 492, 1884, 364, 5623, 34806, 490], "temperature": 0.0, "avg_logprob": -0.17058686004287896, "compression_ratio": 1.6651785714285714, "no_speech_prob": 4.243287548888475e-05}, {"id": 20, "seek": 12976, "start": 142.0, "end": 147.76, "text": " it, sign it, upload it to our deployment infrastructure, and then we have the individual", "tokens": [309, 11, 1465, 309, 11, 6580, 309, 281, 527, 19317, 6896, 11, 293, 550, 321, 362, 264, 2609], "temperature": 0.0, "avg_logprob": -0.17058686004287896, "compression_ratio": 1.6651785714285714, "no_speech_prob": 4.243287548888475e-05}, {"id": 21, "seek": 12976, "start": 147.76, "end": 155.64, "text": " targets, update targets here that download the update and install it. And there's also still", "tokens": [12911, 11, 5623, 12911, 510, 300, 5484, 264, 5623, 293, 3625, 309, 13, 400, 456, 311, 611, 920], "temperature": 0.0, "avg_logprob": -0.17058686004287896, "compression_ratio": 1.6651785714285714, "no_speech_prob": 4.243287548888475e-05}, {"id": 22, "seek": 15564, "start": 155.64, "end": 164.07999999999998, "text": " this conventional not-so-over-the-air use case for, for example, using a USB stick. So what Rao", "tokens": [341, 16011, 406, 12, 539, 12, 3570, 12, 3322, 12, 1246, 764, 1389, 337, 11, 337, 1365, 11, 1228, 257, 10109, 2897, 13, 407, 437, 7591, 78], "temperature": 0.0, "avg_logprob": -0.1679501215616862, "compression_ratio": 1.5828877005347595, "no_speech_prob": 1.565421734994743e-05}, {"id": 23, "seek": 15564, "start": 164.07999999999998, "end": 171.79999999999998, "text": " handles is basically two parts. The first one is the creation of the update artifacts, the signing,", "tokens": [18722, 307, 1936, 732, 3166, 13, 440, 700, 472, 307, 264, 8016, 295, 264, 5623, 24617, 11, 264, 13393, 11], "temperature": 0.0, "avg_logprob": -0.1679501215616862, "compression_ratio": 1.5828877005347595, "no_speech_prob": 1.565421734994743e-05}, {"id": 24, "seek": 15564, "start": 171.79999999999998, "end": 178.48, "text": " verification and so on, and the actual installation, the failsafe installation of the updates on the", "tokens": [30206, 293, 370, 322, 11, 293, 264, 3539, 13260, 11, 264, 3061, 5790, 2106, 13260, 295, 264, 9205, 322, 264], "temperature": 0.0, "avg_logprob": -0.1679501215616862, "compression_ratio": 1.5828877005347595, "no_speech_prob": 1.565421734994743e-05}, {"id": 25, "seek": 17848, "start": 178.48, "end": 187.23999999999998, "text": " target. So, yeah, basically Raoq is an embedded Linux update framework, so it handles the failsafe", "tokens": [3779, 13, 407, 11, 1338, 11, 1936, 7591, 78, 80, 307, 364, 16741, 18734, 5623, 8388, 11, 370, 309, 18722, 264, 3061, 5790, 2106], "temperature": 0.0, "avg_logprob": -0.15841335945941032, "compression_ratio": 1.7649769585253456, "no_speech_prob": 1.3193894119467586e-05}, {"id": 26, "seek": 17848, "start": 187.23999999999998, "end": 195.16, "text": " and atomic update of AB systems, so redundant system where you have one partition, where you're", "tokens": [293, 22275, 5623, 295, 13838, 3652, 11, 370, 40997, 1185, 689, 291, 362, 472, 24808, 11, 689, 291, 434], "temperature": 0.0, "avg_logprob": -0.15841335945941032, "compression_ratio": 1.7649769585253456, "no_speech_prob": 1.3193894119467586e-05}, {"id": 27, "seek": 17848, "start": 195.16, "end": 200.79999999999998, "text": " running from an inactive partition, and when you update, you write your update into the inactive", "tokens": [2614, 490, 364, 294, 12596, 24808, 11, 293, 562, 291, 5623, 11, 291, 2464, 428, 5623, 666, 264, 294, 12596], "temperature": 0.0, "avg_logprob": -0.15841335945941032, "compression_ratio": 1.7649769585253456, "no_speech_prob": 1.3193894119467586e-05}, {"id": 28, "seek": 17848, "start": 200.79999999999998, "end": 206.12, "text": " partition. Once you're done, you switch in the bootloader to the inactive partition reboot,", "tokens": [24808, 13, 3443, 291, 434, 1096, 11, 291, 3679, 294, 264, 11450, 2907, 260, 281, 264, 294, 12596, 24808, 33818, 11], "temperature": 0.0, "avg_logprob": -0.15841335945941032, "compression_ratio": 1.7649769585253456, "no_speech_prob": 1.3193894119467586e-05}, {"id": 29, "seek": 20612, "start": 206.12, "end": 215.04, "text": " and everything is fine. Raoq is basically two parts on the target. It's the service that handles", "tokens": [293, 1203, 307, 2489, 13, 7591, 78, 80, 307, 1936, 732, 3166, 322, 264, 3779, 13, 467, 311, 264, 2643, 300, 18722], "temperature": 0.0, "avg_logprob": -0.10852237277560764, "compression_ratio": 1.6964285714285714, "no_speech_prob": 1.6175972632481717e-05}, {"id": 30, "seek": 20612, "start": 215.04, "end": 222.4, "text": " the update that runs and installed there, and it gets its view on the system from the system", "tokens": [264, 5623, 300, 6676, 293, 8899, 456, 11, 293, 309, 2170, 1080, 1910, 322, 264, 1185, 490, 264, 1185], "temperature": 0.0, "avg_logprob": -0.10852237277560764, "compression_ratio": 1.6964285714285714, "no_speech_prob": 1.6175972632481717e-05}, {"id": 31, "seek": 20612, "start": 222.4, "end": 230.28, "text": " configuration file. And, yeah, the artifact for updating we call in Raoq a bundle. A bundle", "tokens": [11694, 3991, 13, 400, 11, 1338, 11, 264, 34806, 337, 25113, 321, 818, 294, 7591, 78, 80, 257, 24438, 13, 316, 24438], "temperature": 0.0, "avg_logprob": -0.10852237277560764, "compression_ratio": 1.6964285714285714, "no_speech_prob": 1.6175972632481717e-05}, {"id": 32, "seek": 20612, "start": 230.28, "end": 235.88, "text": " consists of the images that should be installed. It consists of additional hooks or something like", "tokens": [14689, 295, 264, 5267, 300, 820, 312, 8899, 13, 467, 14689, 295, 4497, 26485, 420, 746, 411], "temperature": 0.0, "avg_logprob": -0.10852237277560764, "compression_ratio": 1.6964285714285714, "no_speech_prob": 1.6175972632481717e-05}, {"id": 33, "seek": 23588, "start": 235.88, "end": 244.44, "text": " this, and a manifest that holds the description, yeah, what these images are for, basically. So,", "tokens": [341, 11, 293, 257, 10067, 300, 9190, 264, 3855, 11, 1338, 11, 437, 613, 5267, 366, 337, 11, 1936, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.17162254878452846, "compression_ratio": 1.4183673469387754, "no_speech_prob": 3.3110940421465784e-05}, {"id": 34, "seek": 23588, "start": 244.44, "end": 250.96, "text": " it's written in C with some utility libraries to not reinvent the wheel for everything. It's", "tokens": [309, 311, 3720, 294, 383, 365, 512, 14877, 15148, 281, 406, 33477, 264, 5589, 337, 1203, 13, 467, 311], "temperature": 0.0, "avg_logprob": -0.17162254878452846, "compression_ratio": 1.4183673469387754, "no_speech_prob": 3.3110940421465784e-05}, {"id": 35, "seek": 23588, "start": 250.96, "end": 258.52, "text": " licensed on the LGPL and hosted on GitHub. It was started in 2015, and I think the first", "tokens": [25225, 322, 264, 25449, 21593, 293, 19204, 322, 23331, 13, 467, 390, 1409, 294, 7546, 11, 293, 286, 519, 264, 700], "temperature": 0.0, "avg_logprob": -0.17162254878452846, "compression_ratio": 1.4183673469387754, "no_speech_prob": 3.3110940421465784e-05}, {"id": 36, "seek": 25852, "start": 258.52, "end": 267.68, "text": " release was in 2017. So, yeah, as I already mentioned, the bundle format is quite essential", "tokens": [4374, 390, 294, 6591, 13, 407, 11, 1338, 11, 382, 286, 1217, 2835, 11, 264, 24438, 7877, 307, 1596, 7115], "temperature": 0.0, "avg_logprob": -0.1251671670497149, "compression_ratio": 1.6933333333333334, "no_speech_prob": 9.496638085693121e-06}, {"id": 37, "seek": 25852, "start": 267.68, "end": 273.2, "text": " for the next things that we talk about here. So, let's first of all have a short look at the", "tokens": [337, 264, 958, 721, 300, 321, 751, 466, 510, 13, 407, 11, 718, 311, 700, 295, 439, 362, 257, 2099, 574, 412, 264], "temperature": 0.0, "avg_logprob": -0.1251671670497149, "compression_ratio": 1.6933333333333334, "no_speech_prob": 9.496638085693121e-06}, {"id": 38, "seek": 25852, "start": 273.2, "end": 279.88, "text": " initial bundle format, because this was a motivation for changing the bundle format then. The initial", "tokens": [5883, 24438, 7877, 11, 570, 341, 390, 257, 12335, 337, 4473, 264, 24438, 7877, 550, 13, 440, 5883], "temperature": 0.0, "avg_logprob": -0.1251671670497149, "compression_ratio": 1.6933333333333334, "no_speech_prob": 9.496638085693121e-06}, {"id": 39, "seek": 25852, "start": 279.88, "end": 286.91999999999996, "text": " bundle format was quite straightforward. It was just all the artifacts and the manifest packed", "tokens": [24438, 7877, 390, 1596, 15325, 13, 467, 390, 445, 439, 264, 24617, 293, 264, 10067, 13265], "temperature": 0.0, "avg_logprob": -0.1251671670497149, "compression_ratio": 1.6933333333333334, "no_speech_prob": 9.496638085693121e-06}, {"id": 40, "seek": 28692, "start": 286.92, "end": 292.48, "text": " together in a squash file system. We signed this squash file system and append the signature to the", "tokens": [1214, 294, 257, 30725, 3991, 1185, 13, 492, 8175, 341, 30725, 3991, 1185, 293, 34116, 264, 13397, 281, 264], "temperature": 0.0, "avg_logprob": -0.09712555039096886, "compression_ratio": 1.8766233766233766, "no_speech_prob": 2.4262431907118298e-05}, {"id": 41, "seek": 28692, "start": 292.48, "end": 300.0, "text": " end of the bundle. So, the verification is also quite easy. We just have to read the entire", "tokens": [917, 295, 264, 24438, 13, 407, 11, 264, 30206, 307, 611, 1596, 1858, 13, 492, 445, 362, 281, 1401, 264, 2302], "temperature": 0.0, "avg_logprob": -0.09712555039096886, "compression_ratio": 1.8766233766233766, "no_speech_prob": 2.4262431907118298e-05}, {"id": 42, "seek": 28692, "start": 300.0, "end": 308.12, "text": " bundle and have to read the signature to be able to verify the bundle. So, yeah, this is also the", "tokens": [24438, 293, 362, 281, 1401, 264, 13397, 281, 312, 1075, 281, 16888, 264, 24438, 13, 407, 11, 1338, 11, 341, 307, 611, 264], "temperature": 0.0, "avg_logprob": -0.09712555039096886, "compression_ratio": 1.8766233766233766, "no_speech_prob": 2.4262431907118298e-05}, {"id": 43, "seek": 30812, "start": 308.12, "end": 317.64, "text": " downside. Even if we don't also just want to access the manifest, we have to always authenticate", "tokens": [25060, 13, 2754, 498, 321, 500, 380, 611, 445, 528, 281, 2105, 264, 10067, 11, 321, 362, 281, 1009, 9214, 8700], "temperature": 0.0, "avg_logprob": -0.08628158820302863, "compression_ratio": 1.5319148936170213, "no_speech_prob": 1.8853759684134275e-05}, {"id": 44, "seek": 30812, "start": 317.64, "end": 324.08, "text": " or read the entire bundle. So, this is quite slow, and if it comes to over-the-air updating,", "tokens": [420, 1401, 264, 2302, 24438, 13, 407, 11, 341, 307, 1596, 2964, 11, 293, 498, 309, 1487, 281, 670, 12, 3322, 12, 1246, 25113, 11], "temperature": 0.0, "avg_logprob": -0.08628158820302863, "compression_ratio": 1.5319148936170213, "no_speech_prob": 1.8853759684134275e-05}, {"id": 45, "seek": 30812, "start": 324.08, "end": 331.2, "text": " it requires us to always download the full bundle before we can access any data in this. So, yeah,", "tokens": [309, 7029, 505, 281, 1009, 5484, 264, 1577, 24438, 949, 321, 393, 2105, 604, 1412, 294, 341, 13, 407, 11, 1338, 11], "temperature": 0.0, "avg_logprob": -0.08628158820302863, "compression_ratio": 1.5319148936170213, "no_speech_prob": 1.8853759684134275e-05}, {"id": 46, "seek": 33120, "start": 331.2, "end": 339.4, "text": " this is bad if we want to use it for streaming. So, this is why we have introduced in 2020 a new", "tokens": [341, 307, 1578, 498, 321, 528, 281, 764, 309, 337, 11791, 13, 407, 11, 341, 307, 983, 321, 362, 7268, 294, 4808, 257, 777], "temperature": 0.0, "avg_logprob": -0.18655455739874588, "compression_ratio": 1.5129533678756477, "no_speech_prob": 1.1797165825555567e-05}, {"id": 47, "seek": 33120, "start": 339.4, "end": 346.32, "text": " bundle format. And this bundle format is basically, it's called the variety format, and it uses the", "tokens": [24438, 7877, 13, 400, 341, 24438, 7877, 307, 1936, 11, 309, 311, 1219, 264, 5673, 7877, 11, 293, 309, 4960, 264], "temperature": 0.0, "avg_logprob": -0.18655455739874588, "compression_ratio": 1.5129533678756477, "no_speech_prob": 1.1797165825555567e-05}, {"id": 48, "seek": 33120, "start": 346.32, "end": 356.32, "text": " DM variety. So, short intro, a device mapper system in Linux is a generic abstraction of, yeah,", "tokens": [15322, 5673, 13, 407, 11, 2099, 12897, 11, 257, 4302, 463, 3717, 1185, 294, 18734, 307, 257, 19577, 37765, 295, 11, 1338, 11], "temperature": 0.0, "avg_logprob": -0.18655455739874588, "compression_ratio": 1.5129533678756477, "no_speech_prob": 1.1797165825555567e-05}, {"id": 49, "seek": 35632, "start": 356.32, "end": 363.15999999999997, "text": " manipulating block devices. So, a device mapper has the same API as the block device has. So,", "tokens": [40805, 3461, 5759, 13, 407, 11, 257, 4302, 463, 3717, 575, 264, 912, 9362, 382, 264, 3461, 4302, 575, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.1509272625571803, "compression_ratio": 1.744186046511628, "no_speech_prob": 1.9406685169087723e-05}, {"id": 50, "seek": 35632, "start": 363.15999999999997, "end": 367.96, "text": " for the upper layer, it looks like it's just talking to a block device. But below, it can", "tokens": [337, 264, 6597, 4583, 11, 309, 1542, 411, 309, 311, 445, 1417, 281, 257, 3461, 4302, 13, 583, 2507, 11, 309, 393], "temperature": 0.0, "avg_logprob": -0.1509272625571803, "compression_ratio": 1.744186046511628, "no_speech_prob": 1.9406685169087723e-05}, {"id": 51, "seek": 35632, "start": 367.96, "end": 375.84, "text": " manipulate the block device, authenticate data, it can merge data together like we know from", "tokens": [20459, 264, 3461, 4302, 11, 9214, 8700, 1412, 11, 309, 393, 22183, 1412, 1214, 411, 321, 458, 490], "temperature": 0.0, "avg_logprob": -0.1509272625571803, "compression_ratio": 1.744186046511628, "no_speech_prob": 1.9406685169087723e-05}, {"id": 52, "seek": 35632, "start": 375.84, "end": 384.12, "text": " DM linear, and there are several device mappers in the kernel. So, the one that we talk about here", "tokens": [15322, 8213, 11, 293, 456, 366, 2940, 4302, 463, 15226, 294, 264, 28256, 13, 407, 11, 264, 472, 300, 321, 751, 466, 510], "temperature": 0.0, "avg_logprob": -0.1509272625571803, "compression_ratio": 1.744186046511628, "no_speech_prob": 1.9406685169087723e-05}, {"id": 53, "seek": 38412, "start": 384.12, "end": 393.28000000000003, "text": " is DM variety. It is basically an integrity protection method for read-only block devices. So,", "tokens": [307, 15322, 5673, 13, 467, 307, 1936, 364, 16000, 6334, 3170, 337, 1401, 12, 25202, 3461, 5759, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.13029330709706183, "compression_ratio": 1.4974093264248705, "no_speech_prob": 4.6039262088015676e-05}, {"id": 54, "seek": 38412, "start": 393.28000000000003, "end": 401.8, "text": " the rough concept is that you split the block image into several chunks and generate a hash for", "tokens": [264, 5903, 3410, 307, 300, 291, 7472, 264, 3461, 3256, 666, 2940, 24004, 293, 8460, 257, 22019, 337], "temperature": 0.0, "avg_logprob": -0.13029330709706183, "compression_ratio": 1.4974093264248705, "no_speech_prob": 4.6039262088015676e-05}, {"id": 55, "seek": 38412, "start": 401.8, "end": 408.12, "text": " each. And of these, you recursively do this again and again until you have a single root hash, and", "tokens": [1184, 13, 400, 295, 613, 11, 291, 20560, 3413, 360, 341, 797, 293, 797, 1826, 291, 362, 257, 2167, 5593, 22019, 11, 293], "temperature": 0.0, "avg_logprob": -0.13029330709706183, "compression_ratio": 1.4974093264248705, "no_speech_prob": 4.6039262088015676e-05}, {"id": 56, "seek": 40812, "start": 408.12, "end": 419.16, "text": " then you can verify each single block until the root hash recursively. So, yeah, you have the data", "tokens": [550, 291, 393, 16888, 1184, 2167, 3461, 1826, 264, 5593, 22019, 20560, 3413, 13, 407, 11, 1338, 11, 291, 362, 264, 1412], "temperature": 0.0, "avg_logprob": -0.157243854121158, "compression_ratio": 1.5, "no_speech_prob": 1.2591048289323226e-05}, {"id": 57, "seek": 40812, "start": 419.16, "end": 427.6, "text": " protection or integrity protection for read-only files. The variety table is just appended to the", "tokens": [6334, 420, 16000, 6334, 337, 1401, 12, 25202, 7098, 13, 440, 5673, 3199, 307, 445, 724, 3502, 281, 264], "temperature": 0.0, "avg_logprob": -0.157243854121158, "compression_ratio": 1.5, "no_speech_prob": 1.2591048289323226e-05}, {"id": 58, "seek": 40812, "start": 427.6, "end": 435.88, "text": " image. So, let's see how we use this in the RAUK bundle. So, we take our images here and first", "tokens": [3256, 13, 407, 11, 718, 311, 536, 577, 321, 764, 341, 294, 264, 497, 2340, 42, 24438, 13, 407, 11, 321, 747, 527, 5267, 510, 293, 700], "temperature": 0.0, "avg_logprob": -0.157243854121158, "compression_ratio": 1.5, "no_speech_prob": 1.2591048289323226e-05}, {"id": 59, "seek": 43588, "start": 435.88, "end": 442.92, "text": " create the variety hash and the root hash. The variety hash is simply appended to the bundle,", "tokens": [1884, 264, 5673, 22019, 293, 264, 5593, 22019, 13, 440, 5673, 22019, 307, 2935, 724, 3502, 281, 264, 24438, 11], "temperature": 0.0, "avg_logprob": -0.11110010567833395, "compression_ratio": 1.814102564102564, "no_speech_prob": 2.4592149202362634e-05}, {"id": 60, "seek": 43588, "start": 442.92, "end": 452.32, "text": " and the root hash is now placed in the manifest. And then, we just sign the manifest with an", "tokens": [293, 264, 5593, 22019, 307, 586, 7074, 294, 264, 10067, 13, 400, 550, 11, 321, 445, 1465, 264, 10067, 365, 364], "temperature": 0.0, "avg_logprob": -0.11110010567833395, "compression_ratio": 1.814102564102564, "no_speech_prob": 2.4592149202362634e-05}, {"id": 61, "seek": 43588, "start": 452.32, "end": 459.28, "text": " enveloping signature, which means that the manifest is a payload of the signature. And what this", "tokens": [33860, 278, 13397, 11, 597, 1355, 300, 264, 10067, 307, 257, 30918, 295, 264, 13397, 13, 400, 437, 341], "temperature": 0.0, "avg_logprob": -0.11110010567833395, "compression_ratio": 1.814102564102564, "no_speech_prob": 2.4592149202362634e-05}, {"id": 62, "seek": 45928, "start": 459.28, "end": 468.91999999999996, "text": " gives us is now the verification of the manifest is quite easy. We just have to verify the manifest", "tokens": [2709, 505, 307, 586, 264, 30206, 295, 264, 10067, 307, 1596, 1858, 13, 492, 445, 362, 281, 16888, 264, 10067], "temperature": 0.0, "avg_logprob": -0.12950138747692108, "compression_ratio": 1.7791411042944785, "no_speech_prob": 2.240090907434933e-05}, {"id": 63, "seek": 45928, "start": 468.91999999999996, "end": 475.23999999999995, "text": " or the signature and get the manifest content. And inside the manifest, there's also the root", "tokens": [420, 264, 13397, 293, 483, 264, 10067, 2701, 13, 400, 1854, 264, 10067, 11, 456, 311, 611, 264, 5593], "temperature": 0.0, "avg_logprob": -0.12950138747692108, "compression_ratio": 1.7791411042944785, "no_speech_prob": 2.240090907434933e-05}, {"id": 64, "seek": 45928, "start": 475.23999999999995, "end": 482.96, "text": " hash. This is then automatically trusted if we have verified the authentication of the manifest.", "tokens": [22019, 13, 639, 307, 550, 6772, 16034, 498, 321, 362, 31197, 264, 26643, 295, 264, 10067, 13], "temperature": 0.0, "avg_logprob": -0.12950138747692108, "compression_ratio": 1.7791411042944785, "no_speech_prob": 2.240090907434933e-05}, {"id": 65, "seek": 48296, "start": 482.96, "end": 494.59999999999997, "text": " And then, we can set up the invariity and use the hash tree appended to the manifest and the", "tokens": [400, 550, 11, 321, 393, 992, 493, 264, 33270, 507, 293, 764, 264, 22019, 4230, 724, 3502, 281, 264, 10067, 293, 264], "temperature": 0.0, "avg_logprob": -0.1865026421017117, "compression_ratio": 1.7621951219512195, "no_speech_prob": 1.3833875527780037e-05}, {"id": 66, "seek": 48296, "start": 494.59999999999997, "end": 502.67999999999995, "text": " authenticated root hash. And then, for each access to each chunk or block on the block device,", "tokens": [9214, 3587, 5593, 22019, 13, 400, 550, 11, 337, 1184, 2105, 281, 1184, 16635, 420, 3461, 322, 264, 3461, 4302, 11], "temperature": 0.0, "avg_logprob": -0.1865026421017117, "compression_ratio": 1.7621951219512195, "no_speech_prob": 1.3833875527780037e-05}, {"id": 67, "seek": 48296, "start": 502.67999999999995, "end": 510.91999999999996, "text": " this is authenticated to the invariity in the kernel. And this allows you to have fully authenticated", "tokens": [341, 307, 9214, 3587, 281, 264, 33270, 507, 294, 264, 28256, 13, 400, 341, 4045, 291, 281, 362, 4498, 9214, 3587], "temperature": 0.0, "avg_logprob": -0.1865026421017117, "compression_ratio": 1.7621951219512195, "no_speech_prob": 1.3833875527780037e-05}, {"id": 68, "seek": 51092, "start": 510.92, "end": 518.6, "text": " random access to your bundle. And you also, you only need to verify by the time of using the", "tokens": [4974, 2105, 281, 428, 24438, 13, 400, 291, 611, 11, 291, 787, 643, 281, 16888, 538, 264, 565, 295, 1228, 264], "temperature": 0.0, "avg_logprob": -0.1360197470221721, "compression_ratio": 1.4891304347826086, "no_speech_prob": 5.327745748218149e-05}, {"id": 69, "seek": 51092, "start": 518.6, "end": 530.44, "text": " data. So, the next logical consequence is to implement streaming. So, up to now, RAUK was not", "tokens": [1412, 13, 407, 11, 264, 958, 14978, 18326, 307, 281, 4445, 11791, 13, 407, 11, 493, 281, 586, 11, 497, 2340, 42, 390, 406], "temperature": 0.0, "avg_logprob": -0.1360197470221721, "compression_ratio": 1.4891304347826086, "no_speech_prob": 5.327745748218149e-05}, {"id": 70, "seek": 51092, "start": 530.44, "end": 536.52, "text": " so over the air. So, downloading means that we assume there is an external service like", "tokens": [370, 670, 264, 1988, 13, 407, 11, 32529, 1355, 300, 321, 6552, 456, 307, 364, 8320, 2643, 411], "temperature": 0.0, "avg_logprob": -0.1360197470221721, "compression_ratio": 1.4891304347826086, "no_speech_prob": 5.327745748218149e-05}, {"id": 71, "seek": 53652, "start": 536.52, "end": 545.12, "text": " Hockbird or an application or an SCP that downloads the RAUK bundle to the target device. And then,", "tokens": [389, 1560, 18080, 420, 364, 3861, 420, 364, 18489, 300, 36553, 264, 497, 2340, 42, 24438, 281, 264, 3779, 4302, 13, 400, 550, 11], "temperature": 0.0, "avg_logprob": -0.17370568312607804, "compression_ratio": 1.5357142857142858, "no_speech_prob": 4.606529182638042e-05}, {"id": 72, "seek": 53652, "start": 545.12, "end": 551.88, "text": " with RAUK, we start installing it from the local storage. Well, the disadvantage of this is obvious.", "tokens": [365, 497, 2340, 42, 11, 321, 722, 20762, 309, 490, 264, 2654, 6725, 13, 1042, 11, 264, 24292, 295, 341, 307, 6322, 13], "temperature": 0.0, "avg_logprob": -0.17370568312607804, "compression_ratio": 1.5357142857142858, "no_speech_prob": 4.606529182638042e-05}, {"id": 73, "seek": 53652, "start": 551.88, "end": 559.48, "text": " We have to have some extra space on the target where we can store the bundle. And the artifacts can,", "tokens": [492, 362, 281, 362, 512, 2857, 1901, 322, 264, 3779, 689, 321, 393, 3531, 264, 24438, 13, 400, 264, 24617, 393, 11], "temperature": 0.0, "avg_logprob": -0.17370568312607804, "compression_ratio": 1.5357142857142858, "no_speech_prob": 4.606529182638042e-05}, {"id": 74, "seek": 55948, "start": 559.48, "end": 570.5600000000001, "text": " yeah, in a modern system become quite huge. And so, the approach is that we implement streaming", "tokens": [1338, 11, 294, 257, 4363, 1185, 1813, 1596, 2603, 13, 400, 370, 11, 264, 3109, 307, 300, 321, 4445, 11791], "temperature": 0.0, "avg_logprob": -0.09204666581872391, "compression_ratio": 1.5052083333333333, "no_speech_prob": 1.463567059545312e-05}, {"id": 75, "seek": 55948, "start": 570.5600000000001, "end": 580.6800000000001, "text": " or downloading in RAUK itself. And if RAUK is able to do this and directly download it to the", "tokens": [420, 32529, 294, 497, 2340, 42, 2564, 13, 400, 498, 497, 2340, 42, 307, 1075, 281, 360, 341, 293, 3838, 5484, 309, 281, 264], "temperature": 0.0, "avg_logprob": -0.09204666581872391, "compression_ratio": 1.5052083333333333, "no_speech_prob": 1.463567059545312e-05}, {"id": 76, "seek": 55948, "start": 580.6800000000001, "end": 588.16, "text": " target device that we update, then no intermediate storage would be required. So, let's have a look", "tokens": [3779, 4302, 300, 321, 5623, 11, 550, 572, 19376, 6725, 576, 312, 4739, 13, 407, 11, 718, 311, 362, 257, 574], "temperature": 0.0, "avg_logprob": -0.09204666581872391, "compression_ratio": 1.5052083333333333, "no_speech_prob": 1.463567059545312e-05}, {"id": 77, "seek": 58816, "start": 588.16, "end": 594.88, "text": " how this is realized in RAUK. So, first of all, what we do in RAUK is that we spawn an, or fork", "tokens": [577, 341, 307, 5334, 294, 497, 2340, 42, 13, 407, 11, 700, 295, 439, 11, 437, 321, 360, 294, 497, 2340, 42, 307, 300, 321, 17088, 364, 11, 420, 17716], "temperature": 0.0, "avg_logprob": -0.15001997514204546, "compression_ratio": 1.6437768240343347, "no_speech_prob": 7.689736230531707e-05}, {"id": 78, "seek": 58816, "start": 594.88, "end": 600.6, "text": " an unprivileged helper process because RAUK, yeah, runs as root as it has to update the system.", "tokens": [364, 20994, 29994, 794, 3004, 36133, 1399, 570, 497, 2340, 42, 11, 1338, 11, 6676, 382, 5593, 382, 309, 575, 281, 5623, 264, 1185, 13], "temperature": 0.0, "avg_logprob": -0.15001997514204546, "compression_ratio": 1.6437768240343347, "no_speech_prob": 7.689736230531707e-05}, {"id": 79, "seek": 58816, "start": 600.6, "end": 608.3199999999999, "text": " And you really don't want to use a root service to download data from the internet. So, it spawns", "tokens": [400, 291, 534, 500, 380, 528, 281, 764, 257, 5593, 2643, 281, 5484, 1412, 490, 264, 4705, 13, 407, 11, 309, 17088, 82], "temperature": 0.0, "avg_logprob": -0.15001997514204546, "compression_ratio": 1.6437768240343347, "no_speech_prob": 7.689736230531707e-05}, {"id": 80, "seek": 58816, "start": 608.3199999999999, "end": 615.36, "text": " an unprivileged helper. And this helper acts as a translation. It plays a block device on one", "tokens": [364, 20994, 29994, 794, 3004, 36133, 13, 400, 341, 36133, 10672, 382, 257, 12853, 13, 467, 5749, 257, 3461, 4302, 322, 472], "temperature": 0.0, "avg_logprob": -0.15001997514204546, "compression_ratio": 1.6437768240343347, "no_speech_prob": 7.689736230531707e-05}, {"id": 81, "seek": 61536, "start": 615.36, "end": 624.08, "text": " side and talks to the update server via HTTPS range request on the other side. And, yeah,", "tokens": [1252, 293, 6686, 281, 264, 5623, 7154, 5766, 11751, 51, 6273, 3613, 5308, 322, 264, 661, 1252, 13, 400, 11, 1338, 11], "temperature": 0.0, "avg_logprob": -0.23544510317520356, "compression_ratio": 1.530054644808743, "no_speech_prob": 3.5261349694337696e-05}, {"id": 82, "seek": 61536, "start": 624.08, "end": 632.64, "text": " HTTPS range request should be supported by all common web service, also light TTP services,", "tokens": [11751, 51, 6273, 3613, 5308, 820, 312, 8104, 538, 439, 2689, 3670, 2643, 11, 611, 1442, 314, 16804, 3328, 11], "temperature": 0.0, "avg_logprob": -0.23544510317520356, "compression_ratio": 1.530054644808743, "no_speech_prob": 3.5261349694337696e-05}, {"id": 83, "seek": 61536, "start": 632.64, "end": 640.36, "text": " and it's also supported by many delivery networks. And if we combine this now with what we've seen", "tokens": [293, 309, 311, 611, 8104, 538, 867, 8982, 9590, 13, 400, 498, 321, 10432, 341, 586, 365, 437, 321, 600, 1612], "temperature": 0.0, "avg_logprob": -0.23544510317520356, "compression_ratio": 1.530054644808743, "no_speech_prob": 3.5261349694337696e-05}, {"id": 84, "seek": 64036, "start": 640.36, "end": 648.24, "text": " with the access to a variety bundle, then we have fully authenticated random access to the", "tokens": [365, 264, 2105, 281, 257, 5673, 24438, 11, 550, 321, 362, 4498, 9214, 3587, 4974, 2105, 281, 264], "temperature": 0.0, "avg_logprob": -0.12618079781532288, "compression_ratio": 1.5895953757225434, "no_speech_prob": 4.7598397941328585e-05}, {"id": 85, "seek": 64036, "start": 648.24, "end": 657.08, "text": " remote bundle. And, yeah, we can randomly access so no intermediate storage is required. So,", "tokens": [8607, 24438, 13, 400, 11, 1338, 11, 321, 393, 16979, 2105, 370, 572, 19376, 6725, 307, 4739, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.12618079781532288, "compression_ratio": 1.5895953757225434, "no_speech_prob": 4.7598397941328585e-05}, {"id": 86, "seek": 64036, "start": 657.08, "end": 662.8000000000001, "text": " the next need when we are able to download things is normally that we want to save download", "tokens": [264, 958, 643, 562, 321, 366, 1075, 281, 5484, 721, 307, 5646, 300, 321, 528, 281, 3155, 5484], "temperature": 0.0, "avg_logprob": -0.12618079781532288, "compression_ratio": 1.5895953757225434, "no_speech_prob": 4.7598397941328585e-05}, {"id": 87, "seek": 66280, "start": 662.8, "end": 670.5999999999999, "text": " bandwidth because bandwidth is limited, expansive, or something. And the normal approach for this is", "tokens": [23647, 570, 23647, 307, 5567, 11, 46949, 11, 420, 746, 13, 400, 264, 2710, 3109, 337, 341, 307], "temperature": 0.0, "avg_logprob": -0.14243104845978494, "compression_ratio": 1.75, "no_speech_prob": 2.0108627722947858e-05}, {"id": 88, "seek": 66280, "start": 670.5999999999999, "end": 676.9599999999999, "text": " to do conventional data updates. It means you have two versions of your image on your host", "tokens": [281, 360, 16011, 1412, 9205, 13, 467, 1355, 291, 362, 732, 9606, 295, 428, 3256, 322, 428, 3975], "temperature": 0.0, "avg_logprob": -0.14243104845978494, "compression_ratio": 1.75, "no_speech_prob": 2.0108627722947858e-05}, {"id": 89, "seek": 66280, "start": 676.9599999999999, "end": 683.68, "text": " system, calculate a delta, and then you perform the update with this delta image on the target. So,", "tokens": [1185, 11, 8873, 257, 8289, 11, 293, 550, 291, 2042, 264, 5623, 365, 341, 8289, 3256, 322, 264, 3779, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.14243104845978494, "compression_ratio": 1.75, "no_speech_prob": 2.0108627722947858e-05}, {"id": 90, "seek": 66280, "start": 683.68, "end": 688.52, "text": " if you have the exact version that you have to calculate the delta for on your target,", "tokens": [498, 291, 362, 264, 1900, 3037, 300, 291, 362, 281, 8873, 264, 8289, 337, 322, 428, 3779, 11], "temperature": 0.0, "avg_logprob": -0.14243104845978494, "compression_ratio": 1.75, "no_speech_prob": 2.0108627722947858e-05}, {"id": 91, "seek": 68852, "start": 688.52, "end": 697.28, "text": " this works very well. You can go here from version two to the target to version three. But,", "tokens": [341, 1985, 588, 731, 13, 509, 393, 352, 510, 490, 3037, 732, 281, 264, 3779, 281, 3037, 1045, 13, 583, 11], "temperature": 0.0, "avg_logprob": -0.1537317198676032, "compression_ratio": 1.4973262032085561, "no_speech_prob": 1.5412966604344547e-05}, {"id": 92, "seek": 68852, "start": 697.28, "end": 703.04, "text": " if you now have a system that is on a different version, yeah, this fails because it simply", "tokens": [498, 291, 586, 362, 257, 1185, 300, 307, 322, 257, 819, 3037, 11, 1338, 11, 341, 18199, 570, 309, 2935], "temperature": 0.0, "avg_logprob": -0.1537317198676032, "compression_ratio": 1.4973262032085561, "no_speech_prob": 1.5412966604344547e-05}, {"id": 93, "seek": 68852, "start": 703.04, "end": 710.84, "text": " doesn't apply. So, it's an optimal diff. It allows very small updates. But, yeah, you require to", "tokens": [1177, 380, 3079, 13, 407, 11, 309, 311, 364, 16252, 7593, 13, 467, 4045, 588, 1359, 9205, 13, 583, 11, 1338, 11, 291, 3651, 281], "temperature": 0.0, "avg_logprob": -0.1537317198676032, "compression_ratio": 1.4973262032085561, "no_speech_prob": 1.5412966604344547e-05}, {"id": 94, "seek": 71084, "start": 710.84, "end": 720.88, "text": " have access to the different image versions on the host, and you only can update step-by-step. So,", "tokens": [362, 2105, 281, 264, 819, 3256, 9606, 322, 264, 3975, 11, 293, 291, 787, 393, 5623, 1823, 12, 2322, 12, 16792, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.1859915913015172, "compression_ratio": 1.5934065934065933, "no_speech_prob": 1.4694024685013574e-05}, {"id": 95, "seek": 71084, "start": 720.88, "end": 727.48, "text": " from version one to version two to version three. So, in route we've chosen a different approach,", "tokens": [490, 3037, 472, 281, 3037, 732, 281, 3037, 1045, 13, 407, 11, 294, 7955, 321, 600, 8614, 257, 819, 3109, 11], "temperature": 0.0, "avg_logprob": -0.1859915913015172, "compression_ratio": 1.5934065934065933, "no_speech_prob": 1.4694024685013574e-05}, {"id": 96, "seek": 71084, "start": 727.48, "end": 734.76, "text": " a more generic approach for optimizing download. This is called adaptive updates. The concept", "tokens": [257, 544, 19577, 3109, 337, 40425, 5484, 13, 639, 307, 1219, 27912, 9205, 13, 440, 3410], "temperature": 0.0, "avg_logprob": -0.1859915913015172, "compression_ratio": 1.5934065934065933, "no_speech_prob": 1.4694024685013574e-05}, {"id": 97, "seek": 73476, "start": 734.76, "end": 746.0, "text": " behind this is that the bundle or the manifest itself provides a number of optimization options.", "tokens": [2261, 341, 307, 300, 264, 24438, 420, 264, 10067, 2564, 6417, 257, 1230, 295, 19618, 3956, 13], "temperature": 0.0, "avg_logprob": -0.12899756798377404, "compression_ratio": 1.5434782608695652, "no_speech_prob": 9.50771845964482e-06}, {"id": 98, "seek": 73476, "start": 746.0, "end": 752.64, "text": " So, with each option, there's normally an additional data connected that is stored in the", "tokens": [407, 11, 365, 1184, 3614, 11, 456, 311, 5646, 364, 4497, 1412, 4582, 300, 307, 12187, 294, 264], "temperature": 0.0, "avg_logprob": -0.12899756798377404, "compression_ratio": 1.5434782608695652, "no_speech_prob": 9.50771845964482e-06}, {"id": 99, "seek": 73476, "start": 752.64, "end": 760.4, "text": " device for optimizing the download. But, since we are able to stream the bundle, we don't have to", "tokens": [4302, 337, 40425, 264, 5484, 13, 583, 11, 1670, 321, 366, 1075, 281, 4309, 264, 24438, 11, 321, 500, 380, 362, 281], "temperature": 0.0, "avg_logprob": -0.12899756798377404, "compression_ratio": 1.5434782608695652, "no_speech_prob": 9.50771845964482e-06}, {"id": 100, "seek": 76040, "start": 760.4, "end": 766.64, "text": " download these additional data that is stored in the manifest. And then, it's a responsibility of", "tokens": [5484, 613, 4497, 1412, 300, 307, 12187, 294, 264, 10067, 13, 400, 550, 11, 309, 311, 257, 6357, 295], "temperature": 0.0, "avg_logprob": -0.12808788701107626, "compression_ratio": 1.6652360515021458, "no_speech_prob": 1.6928483091760427e-05}, {"id": 101, "seek": 76040, "start": 766.64, "end": 773.4, "text": " the route service on the target to see, okay, which of these capabilities do I support and which", "tokens": [264, 7955, 2643, 322, 264, 3779, 281, 536, 11, 1392, 11, 597, 295, 613, 10862, 360, 286, 1406, 293, 597], "temperature": 0.0, "avg_logprob": -0.12808788701107626, "compression_ratio": 1.6652360515021458, "no_speech_prob": 1.6928483091760427e-05}, {"id": 102, "seek": 76040, "start": 773.4, "end": 779.0, "text": " can I use and which is the best one. And, there's always a fallback to use a full bundle download.", "tokens": [393, 286, 764, 293, 597, 307, 264, 1151, 472, 13, 400, 11, 456, 311, 1009, 257, 2100, 3207, 281, 764, 257, 1577, 24438, 5484, 13], "temperature": 0.0, "avg_logprob": -0.12808788701107626, "compression_ratio": 1.6652360515021458, "no_speech_prob": 1.6928483091760427e-05}, {"id": 103, "seek": 76040, "start": 779.0, "end": 788.48, "text": " So, you're always able to download the image you want to install. One method, adaptive method,", "tokens": [407, 11, 291, 434, 1009, 1075, 281, 5484, 264, 3256, 291, 528, 281, 3625, 13, 1485, 3170, 11, 27912, 3170, 11], "temperature": 0.0, "avg_logprob": -0.12808788701107626, "compression_ratio": 1.6652360515021458, "no_speech_prob": 1.6928483091760427e-05}, {"id": 104, "seek": 78848, "start": 788.48, "end": 796.08, "text": " generic one is the hash index. The idea behind this is that you split your image into several", "tokens": [19577, 472, 307, 264, 22019, 8186, 13, 440, 1558, 2261, 341, 307, 300, 291, 7472, 428, 3256, 666, 2940], "temperature": 0.0, "avg_logprob": -0.1508212725321452, "compression_ratio": 1.7419354838709677, "no_speech_prob": 3.3591171813895926e-05}, {"id": 105, "seek": 78848, "start": 796.08, "end": 802.5600000000001, "text": " chunks and hash each chunk and generate a hash list from this. And, for installation, you just", "tokens": [24004, 293, 22019, 1184, 16635, 293, 8460, 257, 22019, 1329, 490, 341, 13, 400, 11, 337, 13260, 11, 291, 445], "temperature": 0.0, "avg_logprob": -0.1508212725321452, "compression_ratio": 1.7419354838709677, "no_speech_prob": 3.3591171813895926e-05}, {"id": 106, "seek": 78848, "start": 802.5600000000001, "end": 809.32, "text": " basically do the same on the target. You take your target device, block device, for example,", "tokens": [1936, 360, 264, 912, 322, 264, 3779, 13, 509, 747, 428, 3779, 4302, 11, 3461, 4302, 11, 337, 1365, 11], "temperature": 0.0, "avg_logprob": -0.1508212725321452, "compression_ratio": 1.7419354838709677, "no_speech_prob": 3.3591171813895926e-05}, {"id": 107, "seek": 78848, "start": 809.32, "end": 814.8000000000001, "text": " you hash it with the same algorithm, create the same hash index. And then, for the optimization,", "tokens": [291, 22019, 309, 365, 264, 912, 9284, 11, 1884, 264, 912, 22019, 8186, 13, 400, 550, 11, 337, 264, 19618, 11], "temperature": 0.0, "avg_logprob": -0.1508212725321452, "compression_ratio": 1.7419354838709677, "no_speech_prob": 3.3591171813895926e-05}, {"id": 108, "seek": 81480, "start": 814.8, "end": 820.7199999999999, "text": " yeah, you just download, first of all, the hash index that is stored in the bundle. And then,", "tokens": [1338, 11, 291, 445, 5484, 11, 700, 295, 439, 11, 264, 22019, 8186, 300, 307, 12187, 294, 264, 24438, 13, 400, 550, 11], "temperature": 0.0, "avg_logprob": -0.11091933334082887, "compression_ratio": 1.9156118143459915, "no_speech_prob": 2.1059715436422266e-05}, {"id": 109, "seek": 81480, "start": 820.7199999999999, "end": 826.28, "text": " you compare it line by line with the hashes that you've calculated on the target. And then,", "tokens": [291, 6794, 309, 1622, 538, 1622, 365, 264, 575, 8076, 300, 291, 600, 15598, 322, 264, 3779, 13, 400, 550, 11], "temperature": 0.0, "avg_logprob": -0.11091933334082887, "compression_ratio": 1.9156118143459915, "no_speech_prob": 2.1059715436422266e-05}, {"id": 110, "seek": 81480, "start": 826.28, "end": 832.12, "text": " you can download or just need to download the hashes that differ between what's on your target", "tokens": [291, 393, 5484, 420, 445, 643, 281, 5484, 264, 575, 8076, 300, 743, 1296, 437, 311, 322, 428, 3779], "temperature": 0.0, "avg_logprob": -0.11091933334082887, "compression_ratio": 1.9156118143459915, "no_speech_prob": 2.1059715436422266e-05}, {"id": 111, "seek": 81480, "start": 832.12, "end": 838.88, "text": " and what's in the bundle. And this works both for the intended target version, but also,", "tokens": [293, 437, 311, 294, 264, 24438, 13, 400, 341, 1985, 1293, 337, 264, 10226, 3779, 3037, 11, 457, 611, 11], "temperature": 0.0, "avg_logprob": -0.11091933334082887, "compression_ratio": 1.9156118143459915, "no_speech_prob": 2.1059715436422266e-05}, {"id": 112, "seek": 81480, "start": 838.88, "end": 843.28, "text": " if you come from a fully different image, then you just have to download a bit more,", "tokens": [498, 291, 808, 490, 257, 4498, 819, 3256, 11, 550, 291, 445, 362, 281, 5484, 257, 857, 544, 11], "temperature": 0.0, "avg_logprob": -0.11091933334082887, "compression_ratio": 1.9156118143459915, "no_speech_prob": 2.1059715436422266e-05}, {"id": 113, "seek": 84328, "start": 843.28, "end": 851.1999999999999, "text": " because the hashes that differ are a bit more. For block devices, this is already implemented", "tokens": [570, 264, 575, 8076, 300, 743, 366, 257, 857, 544, 13, 1171, 3461, 5759, 11, 341, 307, 1217, 12270], "temperature": 0.0, "avg_logprob": -0.1715485862131869, "compression_ratio": 1.4939271255060729, "no_speech_prob": 8.920666914491449e-06}, {"id": 114, "seek": 84328, "start": 851.1999999999999, "end": 857.64, "text": " in the current drug version. And there are also plans to support this for file-based updates", "tokens": [294, 264, 2190, 4110, 3037, 13, 400, 456, 366, 611, 5482, 281, 1406, 341, 337, 3991, 12, 6032, 9205], "temperature": 0.0, "avg_logprob": -0.1715485862131869, "compression_ratio": 1.4939271255060729, "no_speech_prob": 8.920666914491449e-06}, {"id": 115, "seek": 84328, "start": 857.64, "end": 867.56, "text": " using R-Sync and offline generated checksum files. The next topic is bundle encryption. So,", "tokens": [1228, 497, 12, 50, 34015, 293, 21857, 10833, 13834, 449, 7098, 13, 440, 958, 4829, 307, 24438, 29575, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.1715485862131869, "compression_ratio": 1.4939271255060729, "no_speech_prob": 8.920666914491449e-06}, {"id": 116, "seek": 84328, "start": 867.56, "end": 872.12, "text": " the motivation is, I think, quite clear. You will have some sensitive data in your bundle,", "tokens": [264, 12335, 307, 11, 286, 519, 11, 1596, 1850, 13, 509, 486, 362, 512, 9477, 1412, 294, 428, 24438, 11], "temperature": 0.0, "avg_logprob": -0.1715485862131869, "compression_ratio": 1.4939271255060729, "no_speech_prob": 8.920666914491449e-06}, {"id": 117, "seek": 87212, "start": 872.12, "end": 877.5600000000001, "text": " and you want to protect it, because you have it on an unsafe cloud storage or an unsafe", "tokens": [293, 291, 528, 281, 2371, 309, 11, 570, 291, 362, 309, 322, 364, 35948, 4588, 6725, 420, 364, 35948], "temperature": 0.0, "avg_logprob": -0.18674432966444227, "compression_ratio": 1.6194690265486726, "no_speech_prob": 3.583791112760082e-05}, {"id": 118, "seek": 87212, "start": 877.5600000000001, "end": 883.24, "text": " communication channel. So, in Raoq, we have implemented this in two-stage approach. So,", "tokens": [6101, 2269, 13, 407, 11, 294, 7591, 78, 80, 11, 321, 362, 12270, 341, 294, 732, 12, 17882, 3109, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.18674432966444227, "compression_ratio": 1.6194690265486726, "no_speech_prob": 3.583791112760082e-05}, {"id": 119, "seek": 87212, "start": 883.24, "end": 888.6, "text": " the first one is a symmetric encryption of only the payload. This is this part. This is what", "tokens": [264, 700, 472, 307, 257, 32330, 29575, 295, 787, 264, 30918, 13, 639, 307, 341, 644, 13, 639, 307, 437], "temperature": 0.0, "avg_logprob": -0.18674432966444227, "compression_ratio": 1.6194690265486726, "no_speech_prob": 3.583791112760082e-05}, {"id": 120, "seek": 87212, "start": 888.6, "end": 895.4, "text": " normally already the build server does. And this does not yet require access to the key material.", "tokens": [5646, 1217, 264, 1322, 7154, 775, 13, 400, 341, 775, 406, 1939, 3651, 2105, 281, 264, 2141, 2527, 13], "temperature": 0.0, "avg_logprob": -0.18674432966444227, "compression_ratio": 1.6194690265486726, "no_speech_prob": 3.583791112760082e-05}, {"id": 121, "seek": 89540, "start": 895.4, "end": 903.0799999999999, "text": " And the second part is the individual encryption. Then you can take the symmetrically encrypted", "tokens": [400, 264, 1150, 644, 307, 264, 2609, 29575, 13, 1396, 291, 393, 747, 264, 14232, 27965, 984, 36663], "temperature": 0.0, "avg_logprob": -0.13949311480802648, "compression_ratio": 1.6436781609195403, "no_speech_prob": 3.472150274319574e-05}, {"id": 122, "seek": 89540, "start": 903.0799999999999, "end": 910.88, "text": " image and encrypted per recipient. You can just take one key and encrypt it for all your devices", "tokens": [3256, 293, 36663, 680, 26216, 13, 509, 393, 445, 747, 472, 2141, 293, 17972, 662, 309, 337, 439, 428, 5759], "temperature": 0.0, "avg_logprob": -0.13949311480802648, "compression_ratio": 1.6436781609195403, "no_speech_prob": 3.472150274319574e-05}, {"id": 123, "seek": 89540, "start": 910.88, "end": 917.36, "text": " by using a shared key, or if you really want to do security, then you can also use per device", "tokens": [538, 1228, 257, 5507, 2141, 11, 420, 498, 291, 534, 528, 281, 360, 3825, 11, 550, 291, 393, 611, 764, 680, 4302], "temperature": 0.0, "avg_logprob": -0.13949311480802648, "compression_ratio": 1.6436781609195403, "no_speech_prob": 3.472150274319574e-05}, {"id": 124, "seek": 91736, "start": 917.36, "end": 925.72, "text": " or per recipient keys and encrypt the bundle for many individual recipients, many thousands.", "tokens": [420, 680, 26216, 9317, 293, 17972, 662, 264, 24438, 337, 867, 2609, 32440, 11, 867, 5383, 13], "temperature": 0.0, "avg_logprob": -0.15754862467447917, "compression_ratio": 1.5698324022346368, "no_speech_prob": 1.1291239388810936e-05}, {"id": 125, "seek": 91736, "start": 925.72, "end": 935.84, "text": " So, this again uses a device mapper, a different device mapper. Now we use DMCrypt. It's also", "tokens": [407, 11, 341, 797, 4960, 257, 4302, 463, 3717, 11, 257, 819, 4302, 463, 3717, 13, 823, 321, 764, 15322, 38477, 662, 13, 467, 311, 611], "temperature": 0.0, "avg_logprob": -0.15754862467447917, "compression_ratio": 1.5698324022346368, "no_speech_prob": 1.1291239388810936e-05}, {"id": 126, "seek": 91736, "start": 935.84, "end": 942.52, "text": " quite simple. For the generation of the DMCrypt image or the image we use for DMCrypt, we just", "tokens": [1596, 2199, 13, 1171, 264, 5125, 295, 264, 15322, 38477, 662, 3256, 420, 264, 3256, 321, 764, 337, 15322, 38477, 662, 11, 321, 445], "temperature": 0.0, "avg_logprob": -0.15754862467447917, "compression_ratio": 1.5698324022346368, "no_speech_prob": 1.1291239388810936e-05}, {"id": 127, "seek": 94252, "start": 942.52, "end": 950.56, "text": " split up the original image into equal sized chunks, generate random symmetric key, and encrypt", "tokens": [7472, 493, 264, 3380, 3256, 666, 2681, 20004, 24004, 11, 8460, 4974, 32330, 2141, 11, 293, 17972, 662], "temperature": 0.0, "avg_logprob": -0.12212554386683873, "compression_ratio": 1.507936507936508, "no_speech_prob": 3.410788849578239e-05}, {"id": 128, "seek": 94252, "start": 950.56, "end": 961.36, "text": " each block individual. And the DMCrypt device mapper then just provides a transparent description", "tokens": [1184, 3461, 2609, 13, 400, 264, 15322, 38477, 662, 4302, 463, 3717, 550, 445, 6417, 257, 12737, 3855], "temperature": 0.0, "avg_logprob": -0.12212554386683873, "compression_ratio": 1.507936507936508, "no_speech_prob": 3.410788849578239e-05}, {"id": 129, "seek": 94252, "start": 961.36, "end": 971.16, "text": " of the images. So, if we access a chunk there, then, yeah, DMCrypt just decrypts this chunk", "tokens": [295, 264, 5267, 13, 407, 11, 498, 321, 2105, 257, 16635, 456, 11, 550, 11, 1338, 11, 15322, 38477, 662, 445, 979, 627, 39280, 341, 16635], "temperature": 0.0, "avg_logprob": -0.12212554386683873, "compression_ratio": 1.507936507936508, "no_speech_prob": 3.410788849578239e-05}, {"id": 130, "seek": 97116, "start": 971.16, "end": 978.36, "text": " we just selected with the key, with the symmetric key, which is the same used for encrypting.", "tokens": [321, 445, 8209, 365, 264, 2141, 11, 365, 264, 32330, 2141, 11, 597, 307, 264, 912, 1143, 337, 17972, 662, 278, 13], "temperature": 0.0, "avg_logprob": -0.1793560114773837, "compression_ratio": 1.651376146788991, "no_speech_prob": 1.1110728337371256e-05}, {"id": 131, "seek": 97116, "start": 978.36, "end": 984.48, "text": " And if we combine this now in the bundle, so we have here the image encrypted and combined", "tokens": [400, 498, 321, 10432, 341, 586, 294, 264, 24438, 11, 370, 321, 362, 510, 264, 3256, 36663, 293, 9354], "temperature": 0.0, "avg_logprob": -0.1793560114773837, "compression_ratio": 1.651376146788991, "no_speech_prob": 1.1110728337371256e-05}, {"id": 132, "seek": 97116, "start": 984.48, "end": 992.1999999999999, "text": " it with DMVarity, then we have a blockwise authenticated description. And since we have", "tokens": [309, 365, 15322, 53, 17409, 11, 550, 321, 362, 257, 3461, 3711, 9214, 3587, 3855, 13, 400, 1670, 321, 362], "temperature": 0.0, "avg_logprob": -0.1793560114773837, "compression_ratio": 1.651376146788991, "no_speech_prob": 1.1110728337371256e-05}, {"id": 133, "seek": 97116, "start": 992.1999999999999, "end": 999.48, "text": " random access to the device mapper and the variety format, we also have the possibility", "tokens": [4974, 2105, 281, 264, 4302, 463, 3717, 293, 264, 5673, 7877, 11, 321, 611, 362, 264, 7959], "temperature": 0.0, "avg_logprob": -0.1793560114773837, "compression_ratio": 1.651376146788991, "no_speech_prob": 1.1110728337371256e-05}, {"id": 134, "seek": 99948, "start": 999.48, "end": 1009.4, "text": " to stream an encrypted update. So, short on time, a few notes about app updates. So far", "tokens": [281, 4309, 364, 36663, 5623, 13, 407, 11, 2099, 322, 565, 11, 257, 1326, 5570, 466, 724, 9205, 13, 407, 1400], "temperature": 0.0, "avg_logprob": -0.19317355101135955, "compression_ratio": 1.8571428571428572, "no_speech_prob": 1.0751476111181546e-05}, {"id": 135, "seek": 99948, "start": 1009.4, "end": 1015.6, "text": " in route we assumed, okay, the application is normally the application. So, we assumed", "tokens": [294, 7955, 321, 15895, 11, 1392, 11, 264, 3861, 307, 5646, 264, 3861, 13, 407, 11, 321, 15895], "temperature": 0.0, "avg_logprob": -0.19317355101135955, "compression_ratio": 1.8571428571428572, "no_speech_prob": 1.0751476111181546e-05}, {"id": 136, "seek": 99948, "start": 1015.6, "end": 1023.08, "text": " a bit a monotolic system where the application is the one thing that the device should do.", "tokens": [257, 857, 257, 1108, 310, 7940, 1185, 689, 264, 3861, 307, 264, 472, 551, 300, 264, 4302, 820, 360, 13], "temperature": 0.0, "avg_logprob": -0.19317355101135955, "compression_ratio": 1.8571428571428572, "no_speech_prob": 1.0751476111181546e-05}, {"id": 137, "seek": 99948, "start": 1023.08, "end": 1027.96, "text": " And so we said, okay, the application is normally either part of the root file system", "tokens": [400, 370, 321, 848, 11, 1392, 11, 264, 3861, 307, 5646, 2139, 644, 295, 264, 5593, 3991, 1185], "temperature": 0.0, "avg_logprob": -0.19317355101135955, "compression_ratio": 1.8571428571428572, "no_speech_prob": 1.0751476111181546e-05}, {"id": 138, "seek": 102796, "start": 1027.96, "end": 1033.76, "text": " or you can have it in a separate slot. But it actually, anyway, linked against the libraries", "tokens": [420, 291, 393, 362, 309, 294, 257, 4994, 14747, 13, 583, 309, 767, 11, 4033, 11, 9408, 1970, 264, 15148], "temperature": 0.0, "avg_logprob": -0.15398987040800208, "compression_ratio": 1.6590909090909092, "no_speech_prob": 3.055760316783562e-05}, {"id": 139, "seek": 102796, "start": 1033.76, "end": 1039.64, "text": " that are contained in the root file system. So, it's fine to install it always together", "tokens": [300, 366, 16212, 294, 264, 5593, 3991, 1185, 13, 407, 11, 309, 311, 2489, 281, 3625, 309, 1009, 1214], "temperature": 0.0, "avg_logprob": -0.15398987040800208, "compression_ratio": 1.6590909090909092, "no_speech_prob": 3.055760316783562e-05}, {"id": 140, "seek": 102796, "start": 1039.64, "end": 1045.96, "text": " with the updated root file system. The reality showed it's a bit different and there are", "tokens": [365, 264, 10588, 5593, 3991, 1185, 13, 440, 4103, 4712, 309, 311, 257, 857, 819, 293, 456, 366], "temperature": 0.0, "avg_logprob": -0.15398987040800208, "compression_ratio": 1.6590909090909092, "no_speech_prob": 3.055760316783562e-05}, {"id": 141, "seek": 102796, "start": 1045.96, "end": 1052.88, "text": " more and more demands of having the capability of doing container updates, doing app store-like", "tokens": [544, 293, 544, 15107, 295, 1419, 264, 13759, 295, 884, 10129, 9205, 11, 884, 724, 3531, 12, 4092], "temperature": 0.0, "avg_logprob": -0.15398987040800208, "compression_ratio": 1.6590909090909092, "no_speech_prob": 3.055760316783562e-05}, {"id": 142, "seek": 105288, "start": 1052.88, "end": 1061.3200000000002, "text": " updates and where you also have one vendor which provides a base system, which is rarely", "tokens": [9205, 293, 689, 291, 611, 362, 472, 24321, 597, 6417, 257, 3096, 1185, 11, 597, 307, 13752], "temperature": 0.0, "avg_logprob": -0.17372311486138237, "compression_ratio": 1.7990196078431373, "no_speech_prob": 1.949666147993412e-05}, {"id": 143, "seek": 105288, "start": 1061.3200000000002, "end": 1067.0400000000002, "text": " updated and other vendors provide the applications, which are much more frequently updated and", "tokens": [10588, 293, 661, 22056, 2893, 264, 5821, 11, 597, 366, 709, 544, 10374, 10588, 293], "temperature": 0.0, "avg_logprob": -0.17372311486138237, "compression_ratio": 1.7990196078431373, "no_speech_prob": 1.949666147993412e-05}, {"id": 144, "seek": 105288, "start": 1067.0400000000002, "end": 1071.88, "text": " additional data should be added there. And up to now we had no solution for this in route", "tokens": [4497, 1412, 820, 312, 3869, 456, 13, 400, 493, 281, 586, 321, 632, 572, 3827, 337, 341, 294, 7955], "temperature": 0.0, "avg_logprob": -0.17372311486138237, "compression_ratio": 1.7990196078431373, "no_speech_prob": 1.949666147993412e-05}, {"id": 145, "seek": 105288, "start": 1071.88, "end": 1078.44, "text": " and said, okay, then use route for the base system and use another updater or update approach", "tokens": [293, 848, 11, 1392, 11, 550, 764, 7955, 337, 264, 3096, 1185, 293, 764, 1071, 3460, 771, 420, 5623, 3109], "temperature": 0.0, "avg_logprob": -0.17372311486138237, "compression_ratio": 1.7990196078431373, "no_speech_prob": 1.949666147993412e-05}, {"id": 146, "seek": 107844, "start": 1078.44, "end": 1086.56, "text": " for this application or file updates. What we are working on, and this is in a quite premature", "tokens": [337, 341, 3861, 420, 3991, 9205, 13, 708, 321, 366, 1364, 322, 11, 293, 341, 307, 294, 257, 1596, 34877], "temperature": 0.0, "avg_logprob": -0.21381666443564676, "compression_ratio": 1.7211538461538463, "no_speech_prob": 1.518546741863247e-05}, {"id": 147, "seek": 107844, "start": 1086.56, "end": 1093.8400000000001, "text": " state, actually, is route artifact updates. The basic concept behind this is that you", "tokens": [1785, 11, 767, 11, 307, 7955, 34806, 9205, 13, 440, 3875, 3410, 2261, 341, 307, 300, 291], "temperature": 0.0, "avg_logprob": -0.21381666443564676, "compression_ratio": 1.7211538461538463, "no_speech_prob": 1.518546741863247e-05}, {"id": 148, "seek": 107844, "start": 1093.8400000000001, "end": 1099.88, "text": " have a slot for artifacts and inside the slots we don't do image-based updates, what we do", "tokens": [362, 257, 14747, 337, 24617, 293, 1854, 264, 24266, 321, 500, 380, 360, 3256, 12, 6032, 9205, 11, 437, 321, 360], "temperature": 0.0, "avg_logprob": -0.21381666443564676, "compression_ratio": 1.7211538461538463, "no_speech_prob": 1.518546741863247e-05}, {"id": 149, "seek": 107844, "start": 1099.88, "end": 1106.68, "text": " directly are file-based updates. And then we provide the same as we do for image-based", "tokens": [3838, 366, 3991, 12, 6032, 9205, 13, 400, 550, 321, 2893, 264, 912, 382, 321, 360, 337, 3256, 12, 6032], "temperature": 0.0, "avg_logprob": -0.21381666443564676, "compression_ratio": 1.7211538461538463, "no_speech_prob": 1.518546741863247e-05}, {"id": 150, "seek": 110668, "start": 1106.68, "end": 1115.0, "text": " updates. We ensure that the update is atomically and we also support both the case where we", "tokens": [9205, 13, 492, 5586, 300, 264, 5623, 307, 12018, 984, 293, 321, 611, 1406, 1293, 264, 1389, 689, 321], "temperature": 0.0, "avg_logprob": -0.15543524041233292, "compression_ratio": 1.805, "no_speech_prob": 1.8905449906014837e-05}, {"id": 151, "seek": 110668, "start": 1115.0, "end": 1120.0, "text": " don't have any dependency of the app of the container to the base system, so this is what", "tokens": [500, 380, 362, 604, 33621, 295, 264, 724, 295, 264, 10129, 281, 264, 3096, 1185, 11, 370, 341, 307, 437], "temperature": 0.0, "avg_logprob": -0.15543524041233292, "compression_ratio": 1.805, "no_speech_prob": 1.8905449906014837e-05}, {"id": 152, "seek": 110668, "start": 1120.0, "end": 1127.68, "text": " you basically see here. But we also support the use case of having a dependency on the", "tokens": [291, 1936, 536, 510, 13, 583, 321, 611, 1406, 264, 764, 1389, 295, 1419, 257, 33621, 322, 264], "temperature": 0.0, "avg_logprob": -0.15543524041233292, "compression_ratio": 1.805, "no_speech_prob": 1.8905449906014837e-05}, {"id": 153, "seek": 110668, "start": 1127.68, "end": 1132.64, "text": " root file system but the need to more frequently and independently from the root file system", "tokens": [5593, 3991, 1185, 457, 264, 643, 281, 544, 10374, 293, 21761, 490, 264, 5593, 3991, 1185], "temperature": 0.0, "avg_logprob": -0.15543524041233292, "compression_ratio": 1.805, "no_speech_prob": 1.8905449906014837e-05}, {"id": 154, "seek": 113264, "start": 1132.64, "end": 1140.5200000000002, "text": " update your application. And together with our checks and files, the idea is that this", "tokens": [5623, 428, 3861, 13, 400, 1214, 365, 527, 13834, 293, 7098, 11, 264, 1558, 307, 300, 341], "temperature": 0.0, "avg_logprob": -0.26654006339408254, "compression_ratio": 1.4748858447488584, "no_speech_prob": 1.829597204050515e-05}, {"id": 155, "seek": 113264, "start": 1140.5200000000002, "end": 1147.76, "text": " again also supports streaming and delta-like updates.", "tokens": [797, 611, 9346, 11791, 293, 8289, 12, 4092, 9205, 13], "temperature": 0.0, "avg_logprob": -0.26654006339408254, "compression_ratio": 1.4748858447488584, "no_speech_prob": 1.829597204050515e-05}, {"id": 156, "seek": 113264, "start": 1147.76, "end": 1154.48, "text": " So just a very quick rest through the other features and community things. We've switched", "tokens": [407, 445, 257, 588, 1702, 1472, 807, 264, 661, 4122, 293, 1768, 721, 13, 492, 600, 16858], "temperature": 0.0, "avg_logprob": -0.26654006339408254, "compression_ratio": 1.4748858447488584, "no_speech_prob": 1.829597204050515e-05}, {"id": 157, "seek": 113264, "start": 1154.48, "end": 1160.6000000000001, "text": " to Mason build system recently. This is already merged. It wasn't when I started the slides.", "tokens": [281, 25730, 1322, 1185, 3938, 13, 639, 307, 1217, 36427, 13, 467, 2067, 380, 562, 286, 1409, 264, 9788, 13], "temperature": 0.0, "avg_logprob": -0.26654006339408254, "compression_ratio": 1.4748858447488584, "no_speech_prob": 1.829597204050515e-05}, {"id": 158, "seek": 116060, "start": 1160.6, "end": 1167.52, "text": " So a new feature we also have is adding custom metadata in the manifest that you can then", "tokens": [407, 257, 777, 4111, 321, 611, 362, 307, 5127, 2375, 26603, 294, 264, 10067, 300, 291, 393, 550], "temperature": 0.0, "avg_logprob": -0.21229879161979578, "compression_ratio": 1.6199095022624435, "no_speech_prob": 1.562822944833897e-05}, {"id": 159, "seek": 116060, "start": 1167.52, "end": 1174.7199999999998, "text": " access via route info or the deepest API for custom application. And an ongoing development", "tokens": [2105, 5766, 7955, 13614, 420, 264, 28288, 9362, 337, 2375, 3861, 13, 400, 364, 10452, 3250], "temperature": 0.0, "avg_logprob": -0.21229879161979578, "compression_ratio": 1.6199095022624435, "no_speech_prob": 1.562822944833897e-05}, {"id": 160, "seek": 116060, "start": 1174.7199999999998, "end": 1180.28, "text": " is also about providing more fine-grained process because currently we just have a per", "tokens": [307, 611, 466, 6530, 544, 2489, 12, 20735, 2001, 1399, 570, 4362, 321, 445, 362, 257, 680], "temperature": 0.0, "avg_logprob": -0.21229879161979578, "compression_ratio": 1.6199095022624435, "no_speech_prob": 1.562822944833897e-05}, {"id": 161, "seek": 116060, "start": 1180.28, "end": 1185.9199999999998, "text": " slot progress and if you have a large tar then you wait very long until the progress gets", "tokens": [14747, 4205, 293, 498, 291, 362, 257, 2416, 3112, 550, 291, 1699, 588, 938, 1826, 264, 4205, 2170], "temperature": 0.0, "avg_logprob": -0.21229879161979578, "compression_ratio": 1.6199095022624435, "no_speech_prob": 1.562822944833897e-05}, {"id": 162, "seek": 118592, "start": 1185.92, "end": 1193.96, "text": " to the next step. And a contribution that came or was started by the community is the", "tokens": [281, 264, 958, 1823, 13, 400, 257, 13150, 300, 1361, 420, 390, 1409, 538, 264, 1768, 307, 264], "temperature": 0.0, "avg_logprob": -0.2848339947787198, "compression_ratio": 1.6418604651162791, "no_speech_prob": 2.0704110283986665e-05}, {"id": 163, "seek": 118592, "start": 1193.96, "end": 1200.24, "text": " Rooke Hockpit update. This is basically an interface between the Hockpit deployment server", "tokens": [497, 1986, 330, 389, 1560, 20144, 5623, 13, 639, 307, 1936, 364, 9226, 1296, 264, 389, 1560, 20144, 19317, 7154], "temperature": 0.0, "avg_logprob": -0.2848339947787198, "compression_ratio": 1.6418604651162791, "no_speech_prob": 2.0704110283986665e-05}, {"id": 164, "seek": 118592, "start": 1200.24, "end": 1207.8400000000001, "text": " and Rooke on the other side. It talks via the deepest API with Rooke and this is a good", "tokens": [293, 497, 1986, 330, 322, 264, 661, 1252, 13, 467, 6686, 5766, 264, 28288, 9362, 365, 497, 1986, 330, 293, 341, 307, 257, 665], "temperature": 0.0, "avg_logprob": -0.2848339947787198, "compression_ratio": 1.6418604651162791, "no_speech_prob": 2.0704110283986665e-05}, {"id": 165, "seek": 118592, "start": 1207.8400000000001, "end": 1212.68, "text": " example where the community started things and they moved then to the Rooke organization", "tokens": [1365, 689, 264, 1768, 1409, 721, 293, 436, 4259, 550, 281, 264, 497, 1986, 330, 4475], "temperature": 0.0, "avg_logprob": -0.2848339947787198, "compression_ratio": 1.6418604651162791, "no_speech_prob": 2.0704110283986665e-05}, {"id": 166, "seek": 121268, "start": 1212.68, "end": 1220.3200000000002, "text": " and are now maintained by the Rooke community. And with the latest version of Rooke Hockpit", "tokens": [293, 366, 586, 17578, 538, 264, 497, 1986, 330, 1768, 13, 400, 365, 264, 6792, 3037, 295, 497, 1986, 330, 389, 1560, 20144], "temperature": 0.0, "avg_logprob": -0.22403624478508444, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0740397303598e-05}, {"id": 167, "seek": 121268, "start": 1220.3200000000002, "end": 1228.52, "text": " update we are also compatible with using streaming updates for Hockpit. And shout out", "tokens": [5623, 321, 366, 611, 18218, 365, 1228, 11791, 9205, 337, 389, 1560, 20144, 13, 400, 8043, 484], "temperature": 0.0, "avg_logprob": -0.22403624478508444, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0740397303598e-05}, {"id": 168, "seek": 121268, "start": 1228.52, "end": 1236.3200000000002, "text": " to Leon who is sitting somewhere here in the room. The Meteorite community is a layer or", "tokens": [281, 13244, 567, 307, 3798, 4079, 510, 294, 264, 1808, 13, 440, 43328, 284, 642, 1768, 307, 257, 4583, 420], "temperature": 0.0, "avg_logprob": -0.22403624478508444, "compression_ratio": 1.5555555555555556, "no_speech_prob": 2.0740397303598e-05}, {"id": 169, "seek": 123632, "start": 1236.32, "end": 1243.6799999999998, "text": " layer collection started by Leon which provides some example integration of Rooke into, for", "tokens": [4583, 5765, 1409, 538, 13244, 597, 6417, 512, 1365, 10980, 295, 497, 1986, 330, 666, 11, 337], "temperature": 0.0, "avg_logprob": -0.19429170581656444, "compression_ratio": 1.441988950276243, "no_speech_prob": 1.8552762412582524e-05}, {"id": 170, "seek": 123632, "start": 1243.6799999999998, "end": 1248.9199999999998, "text": " example, QEMO or for Raspberry Pi and it's a very good starting point if you want to", "tokens": [1365, 11, 1249, 6683, 46, 420, 337, 41154, 17741, 293, 309, 311, 257, 588, 665, 2891, 935, 498, 291, 528, 281], "temperature": 0.0, "avg_logprob": -0.19429170581656444, "compression_ratio": 1.441988950276243, "no_speech_prob": 1.8552762412582524e-05}, {"id": 171, "seek": 123632, "start": 1248.9199999999998, "end": 1256.8, "text": " check out how to use Rooke, how to use all the features in Rooke. And yeah, I really", "tokens": [1520, 484, 577, 281, 764, 497, 1986, 330, 11, 577, 281, 764, 439, 264, 4122, 294, 497, 1986, 330, 13, 400, 1338, 11, 286, 534], "temperature": 0.0, "avg_logprob": -0.19429170581656444, "compression_ratio": 1.441988950276243, "no_speech_prob": 1.8552762412582524e-05}, {"id": 172, "seek": 125680, "start": 1256.8, "end": 1268.28, "text": " recommend you to use this as a starting point. A final slide. For an open source project", "tokens": [2748, 291, 281, 764, 341, 382, 257, 2891, 935, 13, 316, 2572, 4137, 13, 1171, 364, 1269, 4009, 1716], "temperature": 0.0, "avg_logprob": -0.2077129117904171, "compression_ratio": 1.6018099547511313, "no_speech_prob": 3.053772888961248e-05}, {"id": 173, "seek": 125680, "start": 1268.28, "end": 1272.8, "text": " it's always hard to know which are the users of your project and where it's actually used.", "tokens": [309, 311, 1009, 1152, 281, 458, 597, 366, 264, 5022, 295, 428, 1716, 293, 689, 309, 311, 767, 1143, 13], "temperature": 0.0, "avg_logprob": -0.2077129117904171, "compression_ratio": 1.6018099547511313, "no_speech_prob": 3.053772888961248e-05}, {"id": 174, "seek": 125680, "start": 1272.8, "end": 1279.52, "text": " So it's always interesting for us to know this. One example where we came aware of that", "tokens": [407, 309, 311, 1009, 1880, 337, 505, 281, 458, 341, 13, 1485, 1365, 689, 321, 1361, 3650, 295, 300], "temperature": 0.0, "avg_logprob": -0.2077129117904171, "compression_ratio": 1.6018099547511313, "no_speech_prob": 3.053772888961248e-05}, {"id": 175, "seek": 125680, "start": 1279.52, "end": 1284.76, "text": " Rooke has used is a very famous one. It's a well-steamed deck that uses Rooke together", "tokens": [497, 1986, 330, 575, 1143, 307, 257, 588, 4618, 472, 13, 467, 311, 257, 731, 12, 2941, 3475, 9341, 300, 4960, 497, 1986, 330, 1214], "temperature": 0.0, "avg_logprob": -0.2077129117904171, "compression_ratio": 1.6018099547511313, "no_speech_prob": 3.053772888961248e-05}, {"id": 176, "seek": 128476, "start": 1284.76, "end": 1289.72, "text": " with the async. Another example is the home-assisted operating system that uses Rooke for updating", "tokens": [365, 264, 382, 34015, 13, 3996, 1365, 307, 264, 1280, 12, 640, 33250, 7447, 1185, 300, 4960, 497, 1986, 330, 337, 25113], "temperature": 0.0, "avg_logprob": -0.28237057736045434, "compression_ratio": 1.6379310344827587, "no_speech_prob": 0.00011577604891499504}, {"id": 177, "seek": 128476, "start": 1289.72, "end": 1296.76, "text": " the PANY system and the Ornero Eclipse project. And one thing that I also find very interesting", "tokens": [264, 430, 1770, 56, 1185, 293, 264, 1610, 1193, 78, 462, 27197, 1716, 13, 400, 472, 551, 300, 286, 611, 915, 588, 1880], "temperature": 0.0, "avg_logprob": -0.28237057736045434, "compression_ratio": 1.6379310344827587, "no_speech_prob": 0.00011577604891499504}, {"id": 178, "seek": 128476, "start": 1296.76, "end": 1305.04, "text": " is that the infotainment or information panels on the German ICE trains have a custom distribution", "tokens": [307, 300, 264, 1536, 310, 491, 518, 420, 1589, 13419, 322, 264, 6521, 43337, 16329, 362, 257, 2375, 7316], "temperature": 0.0, "avg_logprob": -0.28237057736045434, "compression_ratio": 1.6379310344827587, "no_speech_prob": 0.00011577604891499504}, {"id": 179, "seek": 128476, "start": 1305.04, "end": 1311.28, "text": " they call Linux for ICEs and they also use Rooke for updating the systems. So this was", "tokens": [436, 818, 18734, 337, 43337, 82, 293, 436, 611, 764, 497, 1986, 330, 337, 25113, 264, 3652, 13, 407, 341, 390], "temperature": 0.0, "avg_logprob": -0.28237057736045434, "compression_ratio": 1.6379310344827587, "no_speech_prob": 0.00011577604891499504}, {"id": 180, "seek": 131128, "start": 1311.28, "end": 1318.28, "text": " very quick. Thank you for attending. I think we still have two or three more questions.", "tokens": [588, 1702, 13, 1044, 291, 337, 15862, 13, 286, 519, 321, 920, 362, 732, 420, 1045, 544, 1651, 13], "temperature": 0.0, "avg_logprob": -0.22676716019621992, "compression_ratio": 1.7584745762711864, "no_speech_prob": 0.000680780503898859}, {"id": 181, "seek": 131128, "start": 1318.28, "end": 1320.92, "text": " Yeah, I think we have a time for one or two questions.", "tokens": [865, 11, 286, 519, 321, 362, 257, 565, 337, 472, 420, 732, 1651, 13], "temperature": 0.0, "avg_logprob": -0.22676716019621992, "compression_ratio": 1.7584745762711864, "no_speech_prob": 0.000680780503898859}, {"id": 182, "seek": 131128, "start": 1320.92, "end": 1321.92, "text": " Yeah.", "tokens": [865, 13], "temperature": 0.0, "avg_logprob": -0.22676716019621992, "compression_ratio": 1.7584745762711864, "no_speech_prob": 0.000680780503898859}, {"id": 183, "seek": 131128, "start": 1321.92, "end": 1328.72, "text": " Hi there. Thank you for that. That's absolutely intriguing, really interesting. So one of", "tokens": [2421, 456, 13, 1044, 291, 337, 300, 13, 663, 311, 3122, 32503, 11, 534, 1880, 13, 407, 472, 295], "temperature": 0.0, "avg_logprob": -0.22676716019621992, "compression_ratio": 1.7584745762711864, "no_speech_prob": 0.000680780503898859}, {"id": 184, "seek": 131128, "start": 1328.72, "end": 1332.56, "text": " the questions was how do I plug this into BitBake and you've answered that. That's great. I", "tokens": [264, 1651, 390, 577, 360, 286, 5452, 341, 666, 9101, 33, 619, 293, 291, 600, 10103, 300, 13, 663, 311, 869, 13, 286], "temperature": 0.0, "avg_logprob": -0.22676716019621992, "compression_ratio": 1.7584745762711864, "no_speech_prob": 0.000680780503898859}, {"id": 185, "seek": 131128, "start": 1332.56, "end": 1337.0, "text": " know what to do when I get home. The other was what's the granularity of this? I saw", "tokens": [458, 437, 281, 360, 562, 286, 483, 1280, 13, 440, 661, 390, 437, 311, 264, 39962, 507, 295, 341, 30, 286, 1866], "temperature": 0.0, "avg_logprob": -0.22676716019621992, "compression_ratio": 1.7584745762711864, "no_speech_prob": 0.000680780503898859}, {"id": 186, "seek": 133700, "start": 1337.0, "end": 1343.52, "text": " a sort of a 4K block size in there somewhere. In terms of your hashes and then downloading", "tokens": [257, 1333, 295, 257, 1017, 42, 3461, 2744, 294, 456, 4079, 13, 682, 2115, 295, 428, 575, 8076, 293, 550, 32529], "temperature": 0.0, "avg_logprob": -0.13891339302062988, "compression_ratio": 1.6284584980237153, "no_speech_prob": 0.0007837928715161979}, {"id": 187, "seek": 133700, "start": 1343.52, "end": 1348.6, "text": " blocks through the streaming process, is that 4K increments? How does that change? And what's", "tokens": [8474, 807, 264, 11791, 1399, 11, 307, 300, 1017, 42, 1946, 1117, 30, 1012, 775, 300, 1319, 30, 400, 437, 311], "temperature": 0.0, "avg_logprob": -0.13891339302062988, "compression_ratio": 1.6284584980237153, "no_speech_prob": 0.0007837928715161979}, {"id": 188, "seek": 133700, "start": 1348.6, "end": 1353.72, "text": " the overhead in verifying those hashes as you download? What's the impact on performance", "tokens": [264, 19922, 294, 1306, 5489, 729, 575, 8076, 382, 291, 5484, 30, 708, 311, 264, 2712, 322, 3389], "temperature": 0.0, "avg_logprob": -0.13891339302062988, "compression_ratio": 1.6284584980237153, "no_speech_prob": 0.0007837928715161979}, {"id": 189, "seek": 133700, "start": 1353.72, "end": 1356.76, "text": " and have you looked at any figures for that?", "tokens": [293, 362, 291, 2956, 412, 604, 9624, 337, 300, 30], "temperature": 0.0, "avg_logprob": -0.13891339302062988, "compression_ratio": 1.6284584980237153, "no_speech_prob": 0.0007837928715161979}, {"id": 190, "seek": 133700, "start": 1356.76, "end": 1366.64, "text": " Getting quite low. So the question was if the 4K is fine-brained enough for normal downloads,", "tokens": [13674, 1596, 2295, 13, 407, 264, 1168, 390, 498, 264, 1017, 42, 307, 2489, 12, 6198, 2001, 1547, 337, 2710, 36553, 11], "temperature": 0.0, "avg_logprob": -0.13891339302062988, "compression_ratio": 1.6284584980237153, "no_speech_prob": 0.0007837928715161979}, {"id": 191, "seek": 136664, "start": 1366.64, "end": 1372.3600000000001, "text": " so it's currently fixed, but it could also be changed if that's not sufficient. But in", "tokens": [370, 309, 311, 4362, 6806, 11, 457, 309, 727, 611, 312, 3105, 498, 300, 311, 406, 11563, 13, 583, 294], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 192, "seek": 136664, "start": 1372.3600000000001, "end": 1376.8400000000001, "text": " the current approach, the 4K is a fixed size there.", "tokens": [264, 2190, 3109, 11, 264, 1017, 42, 307, 257, 6806, 2744, 456, 13], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 193, "seek": 136664, "start": 1376.8400000000001, "end": 1381.76, "text": " Okay, so it's getting late, so unfortunately we don't have time for any more questions,", "tokens": [1033, 11, 370, 309, 311, 1242, 3469, 11, 370, 7015, 321, 500, 380, 362, 565, 337, 604, 544, 1651, 11], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 194, "seek": 136664, "start": 1381.76, "end": 1386.72, "text": " but don't hesitate to ask them in matrix chat or try to catch our speaker in the corridor.", "tokens": [457, 500, 380, 20842, 281, 1029, 552, 294, 8141, 5081, 420, 853, 281, 3745, 527, 8145, 294, 264, 25602, 13], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 195, "seek": 136664, "start": 1386.72, "end": 1391.0400000000002, "text": " I'll be in front of the room. You can ask questions and we can discuss there.", "tokens": [286, 603, 312, 294, 1868, 295, 264, 1808, 13, 509, 393, 1029, 1651, 293, 321, 393, 2248, 456, 13], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 196, "seek": 136664, "start": 1391.0400000000002, "end": 1392.0400000000002, "text": " Thank you for a great talk.", "tokens": [1044, 291, 337, 257, 869, 751, 13], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 197, "seek": 136664, "start": 1392.0400000000002, "end": 1393.0400000000002, "text": " Thank you very much.", "tokens": [1044, 291, 588, 709, 13], "temperature": 0.0, "avg_logprob": -0.2224673589070638, "compression_ratio": 1.6444444444444444, "no_speech_prob": 0.00020253413822501898}, {"id": 198, "seek": 139304, "start": 1393.04, "end": 1400.04, "text": " Thank you very much.", "tokens": [50364, 1044, 291, 588, 709, 13, 50714], "temperature": 0.0, "avg_logprob": -0.614739179611206, "compression_ratio": 0.7142857142857143, "no_speech_prob": 0.00440026493743062}], "language": "en"}