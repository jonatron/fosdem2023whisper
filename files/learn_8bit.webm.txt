[00:00.000 --> 00:12.360]  Hi, everyone, and welcome to my FOSDOM talk about Learn 8-Bit Machine Language with the
[00:12.360 --> 00:15.280]  Toy CPU emulator.
[00:15.280 --> 00:21.120]  It's an emulator in the style of the Alchair 8800 or the MSI 8080.
[00:21.120 --> 00:27.920]  Now, let me go ahead and share my screen so we can all see my slides together.
[00:27.920 --> 00:29.040]  And so here we are.
[00:29.040 --> 00:31.000]  So let me go ahead and first introduce myself.
[00:31.000 --> 00:37.320]  My name is Jim Hall, and I am from the Freedos project as well as a number of other open
[00:37.320 --> 00:39.240]  source software projects.
[00:39.240 --> 00:42.480]  If you'd like to reach out to me after the conference, there's my email address on screen
[00:42.480 --> 00:45.160]  at jhaulatfreedos.org.
[00:45.160 --> 00:50.840]  I'm going to be talking about the Toy CPU, and you can reach that at my GitHub, and that's
[00:50.840 --> 00:57.560]  at github.com slash freedosproject slash toy CPU.
[00:57.560 --> 01:03.160]  Now this project is something that I used in a class that I teach to kind of back up
[01:03.160 --> 01:04.160]  a little bit.
[01:04.160 --> 01:09.760]  Among other things, I also do instruction of university courses part time.
[01:09.760 --> 01:15.600]  And one of the courses that I like to teach is this class, MIS 100, Fundamentals of Information
[01:15.600 --> 01:21.000]  Technology in Organizations, and that's at Metropolitan State University.
[01:21.000 --> 01:24.040]  It's located near to me in St. Paul, Minnesota.
[01:24.040 --> 01:26.360]  That's where I live.
[01:26.360 --> 01:30.760]  And this course is not meant for computer science students.
[01:30.760 --> 01:35.240]  This is really an introduction, I would describe it as sort of an introduction to technology
[01:35.240 --> 01:40.120]  for people who are going into our College of Management or basically any kind of management
[01:40.120 --> 01:42.160]  major.
[01:42.160 --> 01:47.160]  These are not meant to be people who are going to be computer programmers or engineers of
[01:47.160 --> 01:48.160]  any kind.
[01:48.160 --> 01:53.960]  They're going to be project managers and directors and things like that later on in their career.
[01:53.960 --> 01:56.200]  The goal of the course is really two-fold.
[01:56.200 --> 02:01.080]  One is to kind of teach some tools like, for example, WordXL PowerPoint, things like that.
[02:01.080 --> 02:07.840]  But also it's to build a basic understanding of how technology works because really everything
[02:07.840 --> 02:13.800]  that we do in business today and in our personal lives requires technology.
[02:13.800 --> 02:17.880]  So it's important if you're going to be decision makers in an organization, you really should
[02:17.880 --> 02:22.400]  understand how that technology works, even at some sort of a basic level.
[02:22.640 --> 02:27.920]  Again, I'm not teaching them about computer programming per se, and I'm not teaching them
[02:27.920 --> 02:32.640]  how to build a computer, but they do need to understand at a high level how all that
[02:32.640 --> 02:33.640]  stuff works.
[02:33.640 --> 02:39.640]  My goal in this class is to basically remove the mystery around how technology works.
[02:39.640 --> 02:45.080]  So it's not just you press a button and magic happens on the back end, but they should have
[02:45.080 --> 02:51.800]  some understanding of what's happening in the back end to make different things happen.
[02:51.800 --> 02:56.640]  Now part of this class in terms of the outcomes is, well, and certainly a number of things
[02:56.640 --> 02:58.680]  are going to be understanding some operating systems.
[02:58.680 --> 03:04.360]  You can see up here about computer security, but also a little bit of programming.
[03:04.360 --> 03:08.800]  Now, as I said, we're not teaching them how to be computer programmers.
[03:08.800 --> 03:13.040]  We're not going to expect them to come out of this and know how to program and see or
[03:13.040 --> 03:14.800]  Java or something.
[03:14.800 --> 03:19.400]  But again, they do need to understand how that stuff works on the back end.
[03:19.400 --> 03:25.160]  I don't want them to think as they graduate this course and as they graduate the university,
[03:25.160 --> 03:31.040]  I don't want them to think about computer programming as some sort of magical thing that they don't
[03:31.040 --> 03:32.040]  completely understand.
[03:32.040 --> 03:36.320]  They need to have some general idea about what's happening.
[03:36.320 --> 03:42.680]  Now this course is kind of similar to another course that Brian Kernighen teaches.
[03:42.680 --> 03:48.440]  And I kind of wanted to do something that he does in his course, which is basically teaching
[03:48.440 --> 03:54.920]  the students about how computer programming works on a very simple CPU, something that
[03:54.920 --> 04:01.000]  would be very common for a CPU in the 1960s, maybe the 1970s, where basically you have
[04:01.000 --> 04:06.960]  a series of very simple instructions and the computer has an accumulator and you can manipulate
[04:06.960 --> 04:10.720]  values in the accumulator to make the program do different things.
[04:10.720 --> 04:15.120]  And in his course, and I've interviewed Brian a couple of times, which is why I know about
[04:15.120 --> 04:16.120]  it.
[04:16.120 --> 04:21.240]  And so in his course, he wrote this toy machine simulator.
[04:21.240 --> 04:26.600]  And as you can see, it's sort of similar to assembly.
[04:26.600 --> 04:31.360]  And so the program I've got up on screen would add two numbers together.
[04:31.360 --> 04:37.040]  It loads the value of one into the accumulator and then it adds the value of two to what's
[04:37.040 --> 04:38.040]  in the accumulator.
[04:38.040 --> 04:40.400]  And that, of course, results in the value of three.
[04:40.400 --> 04:46.160]  And then we'll store the value that's in the accumulator into a variable called sum.
[04:46.160 --> 04:50.680]  You can see that that is stored after the rest of the program instructions are done.
[04:50.680 --> 04:54.800]  And then it prints the value to this output device that he has defined.
[04:54.800 --> 04:59.280]  And so that's why you can see three on the first line on the output side on the right
[04:59.280 --> 05:02.160]  hand side of the simulator.
[05:02.160 --> 05:03.480]  And then the program stops.
[05:03.480 --> 05:08.040]  So it does the stop instruction and now the program is done.
[05:08.040 --> 05:10.480]  And of course, when it's done, you can see the output for three.
[05:10.480 --> 05:14.040]  And of course, it says stop in the accumulator course also has the value of three because
[05:14.040 --> 05:17.560]  that's what it had when the computer was done running.
[05:17.560 --> 05:24.520]  And I thought this was a really interesting way to teach kids about programming at sort
[05:24.520 --> 05:26.520]  of a high level.
[05:26.520 --> 05:30.840]  But I like to also talk a lot about computer history in my class.
[05:30.840 --> 05:35.840]  And so I'll do a lot of lectures where we kind of talk about how technology got from,
[05:35.840 --> 05:40.080]  you know, let's say A to B. For example, the first week in the course, we start talking
[05:40.080 --> 05:44.960]  about things like the ENIAC and the Colossus, and we walk our way all the way up through
[05:44.960 --> 05:47.880]  different areas and computing to today.
[05:47.880 --> 05:52.840]  And so I kind of like to back things up a little bit and kind of start with how did
[05:52.840 --> 05:57.040]  people used to program computers in a much earlier era?
[05:57.040 --> 06:02.800]  Now I wanted to kind of borrow what Brian had done in his toy machine simulator, but
[06:02.800 --> 06:06.160]  I wanted to take it in a different direction.
[06:06.160 --> 06:12.680]  And so I use this as a starting point to create my own toy machine simulator and I call that
[06:12.680 --> 06:15.520]  the toy CPU.
[06:15.520 --> 06:17.600]  Now where did I go with this?
[06:17.600 --> 06:24.080]  Well, actually, I wanted to do something that was a little bit sort of old school and to
[06:24.080 --> 06:28.420]  kind of really get the kids to understand how programming worked in sort of a switches
[06:28.420 --> 06:30.120]  and lights model.
[06:30.120 --> 06:34.000]  As I said earlier in the semester in our very first week, we talked with the students,
[06:34.000 --> 06:39.360]  I talked with the students about, you know, the history of computing and, you know, when
[06:39.360 --> 06:44.920]  they see the pictures of older computers that have switches and lights on the front panel
[06:44.920 --> 06:51.960]  and that's how you program the computer, they say, well, okay, I guess I understand
[06:51.960 --> 06:56.520]  that they use switches and lights, but I don't really know how that works.
[06:56.520 --> 06:59.120]  And so I'm like, well, let's talk about that.
[06:59.120 --> 07:04.000]  And so I then talked about the, you know, this Altair 8800, which is what you're seeing
[07:04.000 --> 07:10.720]  up on the screen, which definitely used a switches and lights model.
[07:10.720 --> 07:13.200]  But how do you actually program that?
[07:13.200 --> 07:18.360]  Well, I didn't want to actually use an Altair 8800.
[07:18.360 --> 07:23.480]  In my class, I figured that was way too much in terms of overkill.
[07:23.480 --> 07:28.320]  I really wanted to have something very simple that the students could sort of see just a
[07:28.320 --> 07:30.840]  very bare minimum of how things worked.
[07:30.840 --> 07:38.360]  And so I combined this concept of an Altair 8800-like machine with what Brian Kernighan
[07:38.360 --> 07:41.760]  had made for his toy machine simulator.
[07:41.760 --> 07:48.760]  And that's where I came up with the idea of the toy CPU simulator.
[07:48.760 --> 07:57.840]  And so it's meant to be sort of in the style of the Altair 8800 or the MSI 8080, basically
[07:57.880 --> 08:04.400]  where you have a series of switches and lights, and the lights will indicate in binary what's
[08:04.400 --> 08:05.400]  going on.
[08:05.400 --> 08:08.120]  Now, binary might seem to you like, well, if you're not teaching them programming, why
[08:08.120 --> 08:09.120]  are you teaching them binary?
[08:09.120 --> 08:13.400]  Well, actually in that class, do teach these students how binary works, because binary
[08:13.400 --> 08:16.960]  ends up getting used in a lot of different concepts and technology.
[08:16.960 --> 08:19.320]  Again, they're not doing a whole bunch of stuff with it.
[08:19.320 --> 08:24.000]  They're not like, you know, doing ads and some tracks and binary, but they're not doing
[08:24.000 --> 08:27.640]  like binary operations, but they do need to understand how binary works, because we
[08:27.640 --> 08:29.360]  talk about it in networking and things like that.
[08:29.360 --> 08:35.200]  So going with a toy CPU simulator that used binary is actually in keeping with some of
[08:35.200 --> 08:39.240]  the other things that we do in the class.
[08:39.240 --> 08:44.320]  And so what you're seeing here on screen is the simplest sort of interface I could come
[08:44.320 --> 08:48.800]  up with for the toy CPU simulator.
[08:48.800 --> 08:52.320]  You're seeing the counter, and that's in the upper left.
[08:52.320 --> 08:56.680]  And that's a series of eight what are meant to be LEDs.
[08:56.680 --> 09:03.320]  And that's going to show an eight bit or a one byte value, and that's the counter in
[09:03.320 --> 09:04.320]  the program memory.
[09:04.320 --> 09:06.760]  I'll talk about that in a second.
[09:06.760 --> 09:10.680]  Now for each counter, you're going to have an instruction in memory.
[09:10.680 --> 09:15.680]  And so on the right hand side, on the same line as the counter, you can see the instruction
[09:15.680 --> 09:20.080]  that's stored at that counter memory address.
[09:20.080 --> 09:26.000]  And so again, it's going to be an eight bit or one byte value, although we don't actually
[09:26.000 --> 09:30.720]  have that many instructions for the toy CPU.
[09:30.720 --> 09:33.080]  I'll talk about the instructions in just a second too.
[09:33.080 --> 09:38.920]  Now as the computer runs, it's going to have a very simple operation model where it's going
[09:38.920 --> 09:43.760]  to have a single accumulator, and then you can put values into the accumulator.
[09:43.760 --> 09:45.760]  You can copy values out of the accumulator.
[09:45.760 --> 09:48.320]  You can operate on the accumulator and things like that.
[09:48.320 --> 09:51.480]  So I need to be able to show what the accumulator looks like.
[09:51.480 --> 09:56.160]  And so that's what I've got there in the middle on the right hand side is the actual accumulator
[09:56.160 --> 09:57.160]  itself.
[09:57.160 --> 10:04.600]  Now the accumulator can hold from values from zero to 255, so it's 256 numbers.
[10:04.600 --> 10:09.400]  And of course, it's binary, so it's eight bits, it's one byte.
[10:09.400 --> 10:16.800]  And on the bottom line, I also made a status that kind of shows what the toy CPU is doing.
[10:16.920 --> 10:20.680]  So you can see what this is showing is that the system is powered on.
[10:20.680 --> 10:24.440]  So you can see PWR power on the right hand side.
[10:24.440 --> 10:28.320]  It's also in input mode, it's waiting for the user to actually do something.
[10:28.320 --> 10:30.520]  And so it's an input mode.
[10:30.520 --> 10:35.160]  As you go to different modes in the toy, it'll go into edit mode.
[10:35.160 --> 10:37.520]  And so we'll light up the light for edit.
[10:37.520 --> 10:40.920]  When you run the program, it runs the run.
[10:40.920 --> 10:44.600]  And then if anything needs to happen in terms of aborting or having an error or hitting
[10:44.600 --> 10:48.280]  a halt, things like that, we actually will light up those lights as well.
[10:48.280 --> 10:52.520]  And actually, when the toy CPU boots up, I wanted to be able to show that it's initializing,
[10:52.520 --> 10:54.680]  it's zeroing the memory.
[10:54.680 --> 10:59.640]  And so when we actually look at the toy CPU in a little bit, you'll actually see the initialization
[10:59.640 --> 11:05.800]  like the INI light will light up, and so we'll see power and INI lit up as it runs through
[11:05.800 --> 11:09.360]  memory and zeroes everything out.
[11:09.360 --> 11:12.200]  Now the counter is eight bits, it's one byte.
[11:12.200 --> 11:15.400]  That means it can store values from zero to 255.
[11:15.400 --> 11:25.400]  And so this toy CPU has that much memory, it gets capable of storing 256 bytes.
[11:25.400 --> 11:31.080]  And that's going to be combined or shared with program instructions as well as memory
[11:31.080 --> 11:34.280]  values in the program.
[11:34.280 --> 11:39.680]  Now in terms of the instructions, it's definitely a minimal instruction set computer.
[11:39.680 --> 11:44.520]  And you can see right there on the screen on the lower left of that black rectangle,
[11:44.520 --> 11:49.720]  I've got what looks like or what's meant to look like a piece of paper that's been taped
[11:49.720 --> 11:51.400]  to the front of the machine.
[11:51.400 --> 11:58.120]  And so that is showing you the different operations that this toy CPU is capable of doing.
[11:58.120 --> 12:02.760]  And it's meant to represent the binary instruction for each one of those.
[12:02.760 --> 12:08.000]  And so it, you know, stop and that'll obviously stop the machine or stop the program from
[12:08.000 --> 12:09.000]  running.
[12:09.000 --> 12:11.000]  That's basically the end of your program.
[12:11.000 --> 12:12.840]  And that's all zeros.
[12:12.840 --> 12:16.800]  And I did all zeros because when the machine boots up, it zeros out all the memory.
[12:16.800 --> 12:19.840]  And then if you're to run the program right away, at least it would just immediately stop.
[12:19.840 --> 12:25.040]  So it's sort of a safe way of stopping the system.
[12:25.040 --> 12:31.040]  And then you can operate on the binary values in the accumulator and you can see that the
[12:31.040 --> 12:35.960]  values are one and two or binary one and two.
[12:35.960 --> 12:42.720]  And that is, you know, the seven zeros and a, and a one or six zeros of one and a zero.
[12:42.720 --> 12:48.040]  What that's meant to represent sort of visually is that the, the bit in those last two places
[12:48.040 --> 12:52.200]  is either on the right hand side of the left hand side, and that'll shift the, the, the
[12:52.200 --> 12:57.520]  register, the, in the accumulator, all the bits to the right or to the left.
[12:57.520 --> 12:59.480]  And so it's a, it's a way to just do a binary shift.
[12:59.480 --> 13:00.480]  Now it's not a rotate.
[13:00.480 --> 13:02.200]  It's actually a shift.
[13:02.200 --> 13:08.400]  And so if you have the binary value of one and you shift to the right, it'll only shift
[13:08.400 --> 13:11.320]  by the way, right and left by one value.
[13:11.320 --> 13:14.960]  So if you want to shift multiple times, you just need to call it shift, you know, right,
[13:14.960 --> 13:17.080]  right and left shift multiple times.
[13:17.080 --> 13:21.560]  And so if you have a binary value of one in the accumulator and you do a right, it'll
[13:21.560 --> 13:24.320]  actually give you zero.
[13:24.320 --> 13:27.440]  And so you need to be careful that this is not actually a rotate.
[13:27.440 --> 13:32.360]  This really is a shift like you get in, in C programming.
[13:32.360 --> 13:39.120]  And then not as visually meant to represent in the instruction lights as for lights off
[13:39.120 --> 13:43.400]  and for lights on, it's meant to represent that this is flipping the values that are
[13:43.400 --> 13:45.720]  in the accumulator.
[13:45.720 --> 13:49.880]  And then there's the instruction for and, which is actually just one, actually two plus
[13:49.880 --> 13:51.400]  the plus not.
[13:51.400 --> 13:57.400]  And so that allows us to have a value here that, that doesn't end of what's in the accumulator.
[13:57.400 --> 14:04.400]  It was some other value, a register value, a value that's stored somewhere in memory.
[14:04.400 --> 14:10.440]  We can also do a binary or same thing with some other value that's in memory.
[14:10.440 --> 14:14.280]  And actually, by the way, I want you to notice I picked the these binary instructions very
[14:14.280 --> 14:15.280]  carefully.
[14:15.280 --> 14:22.160]  You'll notice that the fourth bit in, if it's been, if it's been turned on for that instruction,
[14:22.160 --> 14:27.240]  that means that the next, it takes, it takes an argument, it takes the next value.
[14:28.080 --> 14:34.600]  In the program instructions will be the, the, the actual value that it needs to operate
[14:34.600 --> 14:35.600]  with.
[14:35.600 --> 14:40.360]  So, or is going to, or what's in the accumulator with some other value in memory.
[14:40.360 --> 14:46.400]  And so that's why the third bit in, or fourth bit in is, is turned on.
[14:46.400 --> 14:51.160]  I can also do an exclusive or, and of course, I can also do things like very important,
[14:51.160 --> 14:54.120]  I need to be able to load a value into memory.
[14:54.120 --> 14:55.400]  So I can start working on it.
[14:55.640 --> 14:59.920]  If I can load a value into memory, I probably should be able to save a value somewhere back
[14:59.920 --> 15:00.920]  into memory.
[15:00.920 --> 15:07.640]  And so I can save a copy or store something that's in the accumulator into some part of
[15:07.640 --> 15:08.640]  my memory.
[15:09.640 --> 15:15.520]  And of course, I can add to the accumulator some value that's previously stored in memory
[15:15.520 --> 15:21.960]  and second also subtract from the accumulator some, some value that's already stored in memory.
[15:21.960 --> 15:24.080]  And then you need to have flow control of some kind.
[15:24.080 --> 15:28.840]  And so I have a go to instruction in here where it'll actually jump to some counter
[15:28.840 --> 15:31.600]  instructions somewhere in memory somewhere else.
[15:31.600 --> 15:33.880]  And it can also do a conditional jump.
[15:33.880 --> 15:35.880]  So it's called if zero.
[15:35.880 --> 15:41.160]  And so if the accumulator is zero, then it will jump somewhere in memory.
[15:41.160 --> 15:45.600]  And so if you want to do a comparison on something, for example, you need to do some binary operations
[15:45.600 --> 15:51.240]  for like an X or to see if you get zero and you can jump somewhere else in memory based
[15:51.240 --> 15:52.240]  on that.
[15:52.360 --> 15:58.960]  It really is meant to be a very minimal instruction set for the toy CPU.
[16:00.080 --> 16:06.800]  Now, I found I also had to have a null operation and not and because sometimes it's just helpful
[16:06.800 --> 16:09.600]  to just take out an instruction when you're debugging something.
[16:10.160 --> 16:15.160]  And actually the way that the program works is if it doesn't recognize an instruction that
[16:15.160 --> 16:17.640]  you've given it, that's the same as a knob.
[16:17.640 --> 16:20.880]  It's the same as saying, I'm just going to ignore this instruction.
[16:21.240 --> 16:26.360]  But remember, I said that the fourth bit in if that bit has been turned on that that tells
[16:26.360 --> 16:33.600]  the toy CPU that the next value of the next the next counter has something used to use.
[16:33.600 --> 16:42.840]  And so if you actually gave it an instruction that was just three zeros of one and then four
[16:42.840 --> 16:48.080]  zeros, then what that would do is that would that would still be recognized as a not because
[16:48.080 --> 16:52.280]  there's nothing that looks like that, but at the same time will have a side effect of
[16:52.280 --> 16:55.560]  actually skipping the next instruction and memory.
[16:56.600 --> 17:00.480]  Don't rely on that because maybe a future version of the toy CPU will get rid of that.
[17:00.480 --> 17:02.480]  But but that's actually what happens.
[17:02.480 --> 17:09.680]  So the safe guaranteed safe way to do a not instruction is to actually use the one followed
[17:09.680 --> 17:10.840]  by seven zeros.
[17:12.160 --> 17:16.040]  Now, why would I create the toy CPU to begin with?
[17:16.040 --> 17:17.320]  By the way, I probably should talk about that.
[17:17.320 --> 17:19.600]  Why do I create the toy CPU as opposed to going find something else?
[17:19.600 --> 17:26.040]  Well, as I said, I can go and find like a an Altair 8800 simulator.
[17:26.040 --> 17:27.200]  There are they exist.
[17:27.200 --> 17:30.440]  I could have just used one of those, but that's a lot of overhead for my students.
[17:30.440 --> 17:35.160]  I didn't want them necessarily like have to learn all of the instructions that are there
[17:35.160 --> 17:39.680]  in the in the Intel instruction set that seemed like a lot for them to have to tackle.
[17:40.800 --> 17:45.320]  There is actually another minimal instruction set computer called the what's called the
[17:45.320 --> 17:48.040]  digit rule that I really liked.
[17:48.040 --> 17:54.520]  I think it's about $40 and it's a it's a kit you can buy on some guy's website, but it
[17:54.520 --> 17:55.880]  actually is out of stock.
[17:55.880 --> 17:59.120]  It looks like it's it's sold out and then he hasn't made any more.
[17:59.120 --> 18:04.160]  So I would have bought one of those, but it wasn't available.
[18:04.160 --> 18:05.280]  So I had to build my own.
[18:05.280 --> 18:09.160]  So that's why I made the toy CPU.
[18:10.920 --> 18:15.280]  And so looking at the instruction set, this is what I was talking about here.
[18:15.280 --> 18:17.000]  You can stop.
[18:17.000 --> 18:21.880]  You can move things to the bits to the right and left by one, these different instructions.
[18:21.880 --> 18:26.960]  And it's always meant to be represented by that little card that's kind of taped to the
[18:26.960 --> 18:29.800]  front of the toy CPU.
[18:31.440 --> 18:36.400]  Well, let's actually look at how you might build a program for this.
[18:37.040 --> 18:40.200]  And this is where we actually get to explore the toy CPU.
[18:40.200 --> 18:44.000]  So if you want to download the toy CPU and and run it, there's a version, by the way,
[18:44.040 --> 18:48.600]  on the on my GitHub that is a binary for DOS.
[18:48.680 --> 18:52.280]  And since I have a free DOS background, obviously, that's why I wrote it for that.
[18:52.760 --> 18:57.960]  There is an old working prototype also for DOS version one that
[18:59.120 --> 19:01.480]  it doesn't actually let you input a program.
[19:01.480 --> 19:04.080]  It was just sort of meant to sort of an experiment to see what I could do with it.
[19:04.600 --> 19:09.000]  Version two was a Linux program that uses end curses.
[19:09.000 --> 19:13.360]  And if you want to run the program on a Linux machine, you can download the source code
[19:13.760 --> 19:17.600]  from a GitHub that and grab the source code to version two.
[19:17.600 --> 19:19.680]  There's a release version two.
[19:19.680 --> 19:22.920]  And you can compile that with end curses and that will that will work fine.
[19:23.400 --> 19:25.560]  But it was also kind of meant as a prototype.
[19:25.560 --> 19:28.240]  It's not very nice looking.
[19:28.240 --> 19:31.080]  This version, the DOS version is the one I really wanted to use.
[19:31.080 --> 19:33.320]  And so that's that's what we're going to be using here.
[19:33.960 --> 19:35.200]  Now, let's look at this one.
[19:35.200 --> 19:40.280]  So I find that before I write a program on the toy CPU,
[19:40.280 --> 19:43.840]  it's helped to kind of it helps to kind of write everything down on like a little piece of paper.
[19:43.840 --> 19:47.320]  So that's what I'm showing here in the left hand side is what it might look like.
[19:47.320 --> 19:49.680]  If you're going to write everything down on a piece of paper.
[19:50.120 --> 19:53.720]  And so if I want to blink all of the lights on the accumulator,
[19:54.560 --> 19:58.880]  I'm not talking about like, you know, like each light individually to light it all up,
[19:58.880 --> 20:00.440]  although you could do that.
[20:00.440 --> 20:02.640]  I'm just going to do the very simple example here.
[20:03.120 --> 20:06.880]  I'm going to light up all the right hand side, the four right hand side lights
[20:07.440 --> 20:10.080]  and I'm going to light up then the left hand side lights.
[20:10.600 --> 20:14.160]  And then I'm going to light all of them up together and then the program will be done.
[20:15.320 --> 20:16.640]  And so that's what we're going to do.
[20:16.640 --> 20:18.360]  So we're going to write a very simple program to do this.
[20:18.360 --> 20:21.200]  Now, you'll notice, by the way, when we eventually get to run this,
[20:21.640 --> 20:27.920]  that the the toy CPU has a very long delay.
[20:29.440 --> 20:34.200]  And that's meant so you can actually watch the system run.
[20:34.200 --> 20:37.960]  Now, let me actually bring up my the actual toy CPU.
[20:37.960 --> 20:42.120]  So here's here's the toy CPU and I'm going to go ahead and run the toy.
[20:42.120 --> 20:44.040]  I mean, before, so actually before we write a program,
[20:44.040 --> 20:46.200]  let's actually look at the toy CPU itself.
[20:46.200 --> 20:49.360]  So hit return on toy and this is the toy CPU.
[20:49.360 --> 20:52.520]  Now, I mentioned it's going to initialize the memory.
[20:52.520 --> 20:56.040]  And so it's basically going to wander through from zero to two hundred and fifty
[20:56.040 --> 20:58.880]  five and set each instruction to zero.
[20:58.880 --> 21:00.360]  And that's what you saw at the beginning.
[21:00.360 --> 21:01.320]  You can actually quit.
[21:01.320 --> 21:05.280]  You can actually watch, by the way, the light go over to halt.
[21:05.560 --> 21:07.200]  But let me just rerun that again.
[21:07.200 --> 21:10.880]  So let's do toy and you can see it go.
[21:10.880 --> 21:13.360]  The counter is going up from zero to two hundred and fifty five.
[21:13.360 --> 21:16.680]  And as it does that, it's setting each instruction to zero.
[21:16.680 --> 21:20.640]  The accumulator was already initialized to zero when the program starts up.
[21:21.360 --> 21:26.160]  And so here I am in input mode and of course, the system is on.
[21:26.160 --> 21:29.840]  So the power light is lit up and the input light is also lit up.
[21:30.040 --> 21:32.960]  And so I can see here, I've got the little card left inside.
[21:33.520 --> 21:37.920]  It's giving me the instructions for what I can do inside the toy CPU.
[21:38.680 --> 21:42.000]  Now, just to kind of wander through the interface a little bit here,
[21:42.640 --> 21:45.120]  this is in input mode right now.
[21:45.120 --> 21:48.080]  And so on the bottom of the screen, you can see the hints
[21:48.480 --> 21:52.080]  for how you can use input mode, input mode, the up and down arrows.
[21:52.360 --> 21:53.960]  We'll have to move between the counters.
[21:53.960 --> 21:56.480]  So I'm going to use the up and down arrows of my my keyboard.
[21:56.480 --> 21:58.840]  So if I go down one.
[21:58.840 --> 22:04.480]  So basically can imagine the top being zero and then everything after that.
[22:04.480 --> 22:07.920]  So basically we're trying to read instructions from one line to the next.
[22:08.120 --> 22:10.160]  It kind of made sense for me to do it that way.
[22:10.160 --> 22:13.400]  So that way we go down to go to the next instruction
[22:13.760 --> 22:16.520]  and up to go to the previous instruction, because when you write it down
[22:16.520 --> 22:19.080]  in a piece of paper, that's how you're going to write it.
[22:19.600 --> 22:21.960]  And so this is counter instruction zero.
[22:21.960 --> 22:26.520]  But we can see that the instruction itself is I'm sorry, the counter one.
[22:27.160 --> 22:30.960]  So this is the basically the second line of the program.
[22:30.960 --> 22:32.680]  But the instruction is zero.
[22:32.680 --> 22:38.040]  If I go down again, you can see I'm an instruction counter to the instruction
[22:38.040 --> 22:39.080]  self is also zero.
[22:39.080 --> 22:41.560]  So it's basically a stop command and the same thing.
[22:41.560 --> 22:44.480]  There's three, there's four, there's five, there's six.
[22:45.280 --> 22:50.200]  And so if I go all the way back up to zero, you can see that the system
[22:50.200 --> 22:52.680]  is has a stop instruction.
[22:52.680 --> 22:55.400]  Everything has been zeroed out.
[22:55.440 --> 22:58.440]  And so if I hit R, you can see down there on input mode,
[22:58.800 --> 23:00.000]  Enter will allow me to edit it.
[23:00.000 --> 23:02.640]  We'll look at that in a second, but R will actually run
[23:03.280 --> 23:05.120]  the program that I have in memory.
[23:05.120 --> 23:07.960]  And as I said, I zero everything out.
[23:08.200 --> 23:12.880]  And as you can see on that little piece of paper on the front of the toy CPU,
[23:13.320 --> 23:18.200]  all zeros means that the computer is going to just stop running the program.
[23:18.680 --> 23:19.960]  And that's a safe way to do it.
[23:19.960 --> 23:23.000]  So I hit R on my keyboard and it's going to run the program.
[23:23.000 --> 23:26.200]  You can see it will go to the run status and those lights in the bottom.
[23:26.760 --> 23:30.960]  Nothing happened in the because the first instruction, the counter zero
[23:31.280 --> 23:34.440]  had an instruction of stop, which means it immediately stopped the program.
[23:34.680 --> 23:35.880]  It also took a while.
[23:35.880 --> 23:38.640]  Every instruction has a delay built into it.
[23:38.960 --> 23:42.200]  So that way you can actually watch the CPU running.
[23:42.200 --> 23:46.040]  And that way, as I run the program, I can actually explain to my students
[23:46.040 --> 23:49.960]  or remind them about what's happening and they can kind of match what's happening
[23:49.960 --> 23:55.680]  on the program they wrote down, see it actually execute on the toy CPU itself.
[23:55.960 --> 23:57.200]  I'm just going to run it one more time.
[23:57.200 --> 23:59.800]  You can actually watch the status in the lower right hand corner
[24:00.120 --> 24:03.040]  is going to go from this input mode to run.
[24:04.080 --> 24:05.600]  But of course, nothing's going to happen
[24:05.600 --> 24:09.520]  because the program is immediately going to do a stop instruction
[24:09.520 --> 24:11.840]  on counter zero. So I'll do R right now.
[24:12.280 --> 24:14.280]  There it is, it's running, but it's got nothing to do.
[24:14.280 --> 24:15.840]  And so it immediately stops.
[24:15.840 --> 24:18.120]  And so we've actually moved pretty far, actually.
[24:18.120 --> 24:22.320]  This is this is something that my students learned how to see
[24:22.320 --> 24:24.760]  is that the computer is actually doing something.
[24:25.000 --> 24:27.400]  It's immediately stopping, but it's immediately doing something.
[24:28.240 --> 24:30.440]  So let's actually write a program.
[24:30.440 --> 24:35.560]  And so this is the program that I showed my students about how computers work,
[24:35.560 --> 24:40.040]  how programming actually worked in sort of this switches and lights model.
[24:40.640 --> 24:45.360]  And so the goal was that I would show them how to write a program.
[24:45.360 --> 24:47.080]  And then we would write a program.
[24:47.080 --> 24:49.120]  I would challenge them to write some programs
[24:49.120 --> 24:52.160]  and we would input it into the toy CPU and watch it run.
[24:53.320 --> 24:56.120]  So the first one's a very simple program.
[24:56.120 --> 24:59.400]  We're going to blink all of those lights on the accumulator.
[24:59.400 --> 25:02.720]  We're going to light up the lights on the right hand side of the accumulator.
[25:02.960 --> 25:05.160]  And we're going to light up the lights in the left hand side of the accumulator.
[25:05.400 --> 25:07.880]  We're going to light them all up and then we're going to stop.
[25:08.040 --> 25:08.920]  And so that's what we're doing here.
[25:08.920 --> 25:11.920]  We're just basically a series of load instructions.
[25:11.920 --> 25:14.000]  We're going to load the right.
[25:14.080 --> 25:18.720]  We're going to load the left and we're going to load them all and then we're going to stop.
[25:19.720 --> 25:23.080]  And so the way that I do that, if I bring up my little hint sheet
[25:24.280 --> 25:28.640]  and so if I were to look here at the next slide, you can see that
[25:29.520 --> 25:33.520]  using my little hint sheet there in the middle, I can now create
[25:33.880 --> 25:37.080]  an instruction set to put into memory.
[25:38.360 --> 25:42.280]  So instruction zero is going to be the load command.
[25:42.840 --> 25:45.080]  And that's what that binary looks like.
[25:45.080 --> 25:49.720]  It's zero, zero, zero, one, zero, one, zero, zero, right?
[25:49.720 --> 25:54.040]  So if you look on the card in the middle, you can see that that's what the load instruction is.
[25:55.000 --> 25:58.600]  And then we need to load from the right hand side.
[25:58.600 --> 26:04.920]  Well, as I write my instructions, I can write all of my instructions from zero to six.
[26:04.920 --> 26:08.880]  That's the actual program instructions and any memory after that
[26:09.760 --> 26:12.120]  from seven all the way up to 255.
[26:12.120 --> 26:14.920]  I can use for program memory.
[26:14.920 --> 26:19.000]  It just happens to be this easiest for your program memory that you're going to be using
[26:19.000 --> 26:21.240]  to be right after the stop instruction.
[26:21.240 --> 26:26.360]  And so this program is actually 10 bytes long from zero to nine.
[26:27.240 --> 26:32.360]  So I'm going to load from memory location seven because seven is the first instruction
[26:32.920 --> 26:34.840]  after I'm done with the program.
[26:36.040 --> 26:41.480]  And then I'm going to load from memory location eight because eight is the next one.
[26:41.480 --> 26:45.160]  And then I'm going to load from memory location nine and then I'm going to stop.
[26:45.160 --> 26:49.480]  And you can see that memory location seven has all the lights lit up on the right hand side
[26:50.200 --> 26:51.000]  of the accumulator.
[26:51.000 --> 26:56.120]  And then left will, number location eight will load up all the lights on the left hand side.
[26:56.120 --> 27:01.400]  And then memory location nine is going to load up all of the lights on the accumulator.
[27:01.400 --> 27:03.400]  It's going to be value 255.
[27:04.600 --> 27:07.400]  So I'm going to bring my virtual box in here.
[27:07.400 --> 27:09.480]  Let's actually write this program.
[27:09.480 --> 27:12.600]  And so here I am, I'm going to write a program.
[27:12.600 --> 27:14.600]  So I'm in input mode.
[27:14.600 --> 27:16.600]  And that means I can use the up and down arrows, right?
[27:16.600 --> 27:17.560]  So I can do up and down.
[27:18.280 --> 27:19.400]  That's instruction one.
[27:19.400 --> 27:20.360]  Here we are back at zero.
[27:20.360 --> 27:21.720]  I can do one, two, three.
[27:22.360 --> 27:23.640]  Going back up here to zero.
[27:23.640 --> 27:24.520]  So there's zero.
[27:24.520 --> 27:27.000]  So for zero, I want to have a load instruction.
[27:28.120 --> 27:29.720]  And so I'm going to hit return.
[27:29.720 --> 27:32.040]  So on the bottom of the screen, you can see a little hint.
[27:32.040 --> 27:35.480]  It says input mode and up, down for counter and that enter to edit.
[27:35.480 --> 27:40.600]  And that'll allow me to edit the instruction at counter zero.
[27:40.600 --> 27:43.480]  And so if I hit enter, you can see that now I get...
[27:43.480 --> 27:48.120]  First of all, the lights on the bottom indicate that I'm in now edit mode.
[27:49.320 --> 27:53.080]  And then I get a little underline under each light that I can turn on and off.
[27:53.080 --> 27:54.280]  And so now I'm in edit mode.
[27:54.280 --> 27:58.600]  And so the little hint on the very bottom of the screen says edit mode.
[27:58.600 --> 28:02.200]  I'm going to use left and right to change what bit I'm looking at.
[28:02.200 --> 28:04.440]  And we use space to flip the bit.
[28:05.480 --> 28:08.680]  And then when I'm done doing editing, I can just do enter.
[28:08.680 --> 28:10.360]  And that'll bring me back into edit mode.
[28:10.360 --> 28:11.320]  And that's right, input mode.
[28:12.120 --> 28:13.960]  And so I want to do a load.
[28:13.960 --> 28:14.840]  And so here I can...
[28:14.840 --> 28:16.920]  You can use my arrows right and left.
[28:16.920 --> 28:20.440]  We'll move the arrow or the indicator right and left.
[28:21.880 --> 28:24.200]  But I want to set the load instruction.
[28:24.200 --> 28:28.040]  So you can see the hint over there or the little program I got written out.
[28:28.680 --> 28:29.800]  The load instruction.
[28:30.520 --> 28:33.800]  And of course, I could use a little sheet of paper this tack to the front of the
[28:34.520 --> 28:35.320]  the toy CPU.
[28:35.320 --> 28:36.840]  But the load instruction is...
[28:37.960 --> 28:39.800]  I'm going to turn that on and that on.
[28:39.800 --> 28:41.560]  And that should be the load instruction, right?
[28:41.560 --> 28:46.120]  Sort of compare that with what I've got on my screen over here.
[28:46.120 --> 28:49.480]  0, 0, 0, 1, 0, 1, 0, 0.
[28:49.480 --> 28:50.680]  That's the load instruction.
[28:51.240 --> 28:54.200]  So now I've got that set so I can hit return.
[28:54.200 --> 28:57.640]  And that has now set the load instruction.
[28:57.640 --> 28:59.960]  Now I want to load from memory location seven.
[28:59.960 --> 29:01.080]  I want to go down one.
[29:01.640 --> 29:03.320]  And so there's counter number one.
[29:04.200 --> 29:07.080]  And so now I want to load from memory location seven.
[29:07.080 --> 29:08.360]  So I'm going to hit enter.
[29:08.360 --> 29:12.280]  And I'm going to go and set the instruction of seven.
[29:12.280 --> 29:15.960]  This is going to say load from memory location seven.
[29:15.960 --> 29:18.200]  So it does the load instruction first.
[29:18.200 --> 29:20.360]  And then it has to say, well, it's going to load from somewhere.
[29:20.360 --> 29:24.200]  So the next instruction in memory tells it where to load the memory...
[29:25.000 --> 29:26.760]  Where to load from memory.
[29:27.960 --> 29:28.920]  That value.
[29:28.920 --> 29:31.000]  And so I'm going to hit return because now I've entered seven.
[29:31.560 --> 29:33.480]  And now let's go down to instruction two.
[29:33.480 --> 29:34.440]  We used the down arrow.
[29:34.440 --> 29:36.600]  So now I'm on counter two.
[29:36.600 --> 29:38.680]  And now I want to do another load instruction.
[29:38.680 --> 29:40.040]  So I'm going to hit return.
[29:40.040 --> 29:41.800]  And I'm going to put in a load instruction.
[29:42.680 --> 29:44.280]  And so that's another load instruction.
[29:44.280 --> 29:47.480]  It's the same one I had back on memory location zero.
[29:47.480 --> 29:48.520]  Let me go back to zero.
[29:49.080 --> 29:50.760]  See, that's the one I had for zero.
[29:50.760 --> 29:52.760]  And then go back to memory instruction two.
[29:52.760 --> 29:55.400]  There's my load on two.
[29:56.280 --> 29:57.320]  And we're going to load this.
[29:57.320 --> 29:59.640]  Well, I'm going to load this from the left-hand side,
[29:59.640 --> 30:03.960]  which you can see in my program is going to be memory location eight.
[30:03.960 --> 30:07.960]  So the next line here in memory location are counter three.
[30:07.960 --> 30:10.360]  I now need to enter in the value of eight.
[30:11.720 --> 30:15.720]  And so if you remember your binary, those of you who maybe don't know binary,
[30:15.720 --> 30:16.680]  binary goes like this.
[30:16.680 --> 30:19.560]  From the right-hand side, I'm counting my bits.
[30:19.560 --> 30:26.760]  And so this is the ones place, the twos place, the fours place, the eights place, the 16,
[30:27.480 --> 30:30.440]  32, 64, 128.
[30:30.440 --> 30:36.520]  So to load from eight, well, that's zero, zero.
[30:36.520 --> 30:40.840]  So this is the ones place, the twos place, the fours place, the eights place.
[30:40.840 --> 30:44.520]  And so if we hit space on that, that is the value of eight.
[30:46.120 --> 30:47.720]  And so I hit return on that.
[30:47.720 --> 30:50.920]  And now I need to go down to instruction four.
[30:50.920 --> 30:51.960]  So use the down arrow.
[30:51.960 --> 30:53.880]  Now do another load instruction.
[30:53.880 --> 30:56.360]  And so I'm going to do a load instruction that looks like
[30:57.160 --> 30:57.480]  that.
[30:58.440 --> 31:01.560]  And now I need to load from memory location nine.
[31:01.560 --> 31:03.080]  So go down one more.
[31:03.800 --> 31:07.720]  And this is now instruction five or counter five.
[31:07.720 --> 31:08.520]  Hit return on that.
[31:08.520 --> 31:10.600]  Now I need to enter the value of nine.
[31:10.600 --> 31:15.320]  So again, if this is the ones place, the twos place, the fours place, the eights place,
[31:15.320 --> 31:18.280]  I need eight plus one is nine.
[31:19.080 --> 31:20.120]  And so hit return on that.
[31:20.120 --> 31:22.600]  And now I've got nine entered in counter five.
[31:23.240 --> 31:26.280]  And counter six is the stop instruction, which is all zero.
[31:26.280 --> 31:27.240]  So I can just leave that be.
[31:28.680 --> 31:29.880]  And then counter seven.
[31:29.880 --> 31:33.960]  Well, this is now the memory locations that are not instructions.
[31:33.960 --> 31:35.160]  They're just memory.
[31:35.160 --> 31:39.720]  And so I need to insert or light up all the right hand lights.
[31:39.720 --> 31:43.160]  And so hit enter on seven, counter seven.
[31:43.160 --> 31:46.440]  Let's go ahead and turn on all of these lights.
[31:47.640 --> 31:49.320]  And I'm going to hit return on that.
[31:49.320 --> 31:52.440]  And now go down to instruction eight, counter eight.
[31:53.160 --> 31:54.280]  And I edit this one.
[31:54.280 --> 31:56.040]  I'm going to light up the left hand side.
[31:56.040 --> 31:58.360]  I'm going to light these four up over here.
[32:00.120 --> 32:01.480]  Enter because I'm done doing that.
[32:01.480 --> 32:04.200]  And now we go down to instruction nine.
[32:04.200 --> 32:05.720]  I'm going to light them all up.
[32:05.720 --> 32:07.240]  So I'm going to hit enter.
[32:07.240 --> 32:11.240]  And I'm going to just light up all of lights.
[32:14.280 --> 32:14.840]  And that's it.
[32:14.840 --> 32:16.680]  We can now run the program.
[32:16.680 --> 32:23.560]  Now, every time you do run, it'll actually always start the program from counter zeros.
[32:23.640 --> 32:26.040]  Let's go ahead and do our to run the program.
[32:26.040 --> 32:29.000]  And we'll actually watch it light up the accumulator.
[32:29.000 --> 32:33.320]  So pay attention to the accumulator line and as we run it, it's going to load
[32:33.880 --> 32:38.360]  the value from memory location seven, which is going to light up all the lights on the right
[32:38.360 --> 32:39.320]  hand side.
[32:39.320 --> 32:40.280]  I'm just going to load them.
[32:40.840 --> 32:45.800]  The value from memory location eight, which is going to light up all the lights on left hand side.
[32:45.800 --> 32:50.120]  It's going to load the value from memory location nine and it will light up all the lights on the
[32:50.120 --> 32:51.880]  screen on the accumulator at once.
[32:52.520 --> 32:56.360]  So I'm going to do R and it starts with zero in the accumulator.
[32:56.360 --> 32:59.400]  And now it's going to load up all the right hand side.
[32:59.400 --> 33:00.840]  It's going to load up all the left hand side.
[33:00.840 --> 33:02.520]  It's going to load up all of them.
[33:02.520 --> 33:05.320]  And now the program is done and now we've exited.
[33:06.120 --> 33:07.640]  And so that's the program, right?
[33:07.640 --> 33:10.280]  So let's run it one more time so we can actually follow along.
[33:10.280 --> 33:13.480]  You can actually see the delay built into the toy CPU.
[33:13.480 --> 33:16.040]  So you can actually watch the program run.
[33:16.760 --> 33:18.760]  So I'm going to load from seven.
[33:19.560 --> 33:21.480]  I'm going to load from eight.
[33:22.040 --> 33:24.360]  I'm going to load from nine.
[33:25.160 --> 33:27.320]  And I'm going to stop the program.
[33:28.280 --> 33:29.240]  There we go.
[33:29.240 --> 33:33.080]  And now I'm back to counter zero, which has the load instruction built into it.
[33:34.040 --> 33:35.640]  And so now let me know how to do that one.
[33:35.640 --> 33:39.080]  There's actually a better way, an easier way to write,
[33:39.800 --> 33:43.400]  to write a program that will light up all those lights.
[33:43.400 --> 33:45.160]  And that is to do it this way.
[33:45.160 --> 33:46.920]  We're going to use binary instructions.
[33:47.720 --> 33:50.920]  So I'm going to load all the lights that are on the right hand side.
[33:51.960 --> 33:53.320]  And then I'm going to do a knot.
[33:54.040 --> 34:00.200]  I'm going to turn that zero, zero, zero, one, one, one.
[34:00.200 --> 34:01.480]  I'm going to do a knot on that.
[34:01.480 --> 34:05.800]  So every zero becomes a one and every one becomes a zero.
[34:05.800 --> 34:09.320]  And so that will turn it to one, one, one, one, zero, zero, zero.
[34:11.080 --> 34:15.560]  Now, because I don't want to move where my memory location is and things like that
[34:15.560 --> 34:19.000]  makes it a little bit easier to not have a change things in the program.
[34:19.000 --> 34:20.680]  I'm going to just use a knob instruction.
[34:20.680 --> 34:23.000]  That's where it ends up being easy to use this knob.
[34:23.560 --> 34:27.240]  And then I'm going to do an or from memory location seven.
[34:27.240 --> 34:30.680]  So what the or does, if you remember, what the or instruction does
[34:30.680 --> 34:35.400]  is it just takes two values and every time there's a, it just basically lines them up.
[34:35.960 --> 34:39.320]  And so every time you have a one in these two values,
[34:40.200 --> 34:41.560]  then you get a one in the output.
[34:42.120 --> 34:45.560]  And so you can have a one and a one, and that will give you a one,
[34:46.120 --> 34:48.120]  or you can have a one and a zero.
[34:48.120 --> 34:50.920]  And because it's an or, well, it gives you a one, right?
[34:50.920 --> 34:53.880]  One and a zero or together will give you a one.
[34:53.880 --> 34:57.240]  And then the only time you don't get a one at the end is if they're both zero, right?
[34:57.240 --> 35:01.800]  Zero and zero or together gives you a zero.
[35:01.800 --> 35:05.800]  So I want to use this program to actually light up the lights
[35:07.000 --> 35:10.040]  on the right-hand side, on the left-hand side, then all the lights together.
[35:10.040 --> 35:14.200]  By doing this, I don't actually need the last two instructions.
[35:14.840 --> 35:22.040]  So now my program is actually eight bytes long, eight bytes long from zero to seven.
[35:22.040 --> 35:24.840]  So let's go ahead and, and now look at what that would look like.
[35:24.840 --> 35:27.400]  So if I were to look at what the program looks like,
[35:30.040 --> 35:31.640]  the, this is what I have.
[35:31.640 --> 35:38.200]  So I'm going to do this instruction here from, from zero to seven.
[35:38.200 --> 35:41.640]  I'm just going to ignore the values that I have in my, in my program memory.
[35:41.640 --> 35:43.480]  That's an eight and nine.
[35:43.480 --> 35:47.640]  So let's go ahead and bring my, my toy CPU back up on screen.
[35:48.520 --> 35:50.120]  And now let's enter this program.
[35:50.120 --> 35:53.640]  So in memory location zero, I need to start with a load instruction.
[35:53.640 --> 35:56.760]  Well, I've already got a load instruction there, so I don't need to edit this one at all.
[35:56.760 --> 36:00.280]  And so now I go down to memory location one, counter one,
[36:00.280 --> 36:02.920]  and I need to load from memory location seven.
[36:02.920 --> 36:06.200]  Well, I've already got memory location seven in there, so I need to edit that.
[36:07.000 --> 36:10.600]  The next one I'm going to just do in memory location three, I'm sorry,
[36:10.600 --> 36:14.040]  memory location two, I need to enter the NOP instruction, right?
[36:14.040 --> 36:15.480]  So I'm going to enter the NOP instruction.
[36:15.480 --> 36:18.520]  So if I hit enter on this, now I can edit this.
[36:18.520 --> 36:21.000]  Now the NOP instruction, if we look at that little piece of paper
[36:21.560 --> 36:27.240]  tacked on the front of the toy CPU, the NOP instruction is a one followed by all zeros.
[36:29.320 --> 36:31.880]  And so that's my NOP instruction.
[36:32.680 --> 36:38.120]  Memory location three or counter three, I now need to give it the NOT instruction.
[36:38.920 --> 36:40.120]  And so this is a nice one.
[36:40.120 --> 36:44.440]  So if we just hit enter, and then we just have these four bits be zero,
[36:44.440 --> 36:46.840]  and then these four bits turn on.
[36:46.840 --> 36:48.600]  And that is the NOT instruction, right?
[36:48.600 --> 36:52.520]  See how it looks where you've got four zeros and four ones?
[36:53.240 --> 36:57.560]  It meant to imply that that's a NOT, all zeros become ones.
[36:58.280 --> 37:02.360]  And so that's our NOT instruction encounter three and encounter four.
[37:03.960 --> 37:06.120]  Hit just the down arrow, go to instruction four.
[37:06.120 --> 37:07.880]  We're going to do an OR instruction.
[37:07.880 --> 37:12.280]  So we're going to hit return on this and now turn this load into an OR.
[37:13.320 --> 37:17.640]  And so that bit is still the same, but I need to turn this off and turn this on.
[37:17.640 --> 37:19.560]  And that should be the OR instruction.
[37:19.560 --> 37:26.040]  So it always helps when you do a program to write out the binary instructions.
[37:26.040 --> 37:28.040]  So you're not having to do it kind of on the fly.
[37:29.720 --> 37:30.520]  And so there it is.
[37:30.520 --> 37:34.440]  This instruction four is an OR instruction.
[37:34.440 --> 37:37.960]  And now I'm going to go down, hit enter on that, and it puts me back into input mode.
[37:38.520 --> 37:40.760]  And let's go down to counter five.
[37:40.760 --> 37:47.160]  Counter five now needs to be memory location seven instead of memory location nine.
[37:47.160 --> 37:48.360]  And so hit enter on this.
[37:48.360 --> 37:50.920]  I need to now change this to memory location seven.
[37:51.720 --> 37:54.600]  And so seven as binary seven, right?
[37:54.600 --> 38:00.280]  So again, remembering our binary, the ones place the twos place the fours place the eights place.
[38:01.000 --> 38:05.960]  So one plus two plus four is seven, right?
[38:05.960 --> 38:09.320]  One plus two is three plus four is seven.
[38:09.320 --> 38:14.840]  So one, one, one is the binary value of seven.
[38:15.720 --> 38:19.720]  And so that's what I've got in instruction or counter five and hit enter there.
[38:19.960 --> 38:24.600]  And I go down to counter six, and that needs to be the stop instruction,
[38:24.600 --> 38:27.560]  which because I use not now, I don't have to change that, right?
[38:27.560 --> 38:28.680]  It's already stopped.
[38:28.680 --> 38:29.640]  And so I'm good.
[38:30.360 --> 38:33.960]  And then memory locator counter seven, if I use the down arrow,
[38:33.960 --> 38:38.040]  needs to be all the lights lit up on the right hand side.
[38:39.080 --> 38:42.680]  Now it doesn't matter what's in memory locations, eight and nine,
[38:42.680 --> 38:46.440]  because I'm never referencing memory locations, eight and nine.
[38:46.680 --> 38:50.040]  So using the down arrow, you can see this is memory location eight,
[38:50.040 --> 38:51.400]  which we're not going to use.
[38:51.400 --> 38:55.400]  And then this is memory location nine, which we're not going to use.
[38:56.360 --> 38:57.960]  And so now let's go ahead and run this.
[38:57.960 --> 39:02.360]  And so what we should see again is it's going to load memory location seven.
[39:03.320 --> 39:04.760]  This is memory location seven.
[39:05.320 --> 39:10.760]  It's going to load into the accumulator the lights that are all lit on the right hand side.
[39:12.440 --> 39:14.200]  And then it's going to do a not instruction.
[39:14.280 --> 39:19.240]  So it's going to flip those zeros to ones and those ones to zeros or anything that's off will get
[39:19.240 --> 39:21.560]  turned on anything that's on will get turned off.
[39:22.120 --> 39:24.920]  And that will light up the lights on the left hand side of the accumulator.
[39:26.120 --> 39:31.720]  And then it's going to do an or and that will basically turn on all the lights in the accumulator
[39:31.720 --> 39:36.200]  because the lights on the left with an or on all the lights on the right,
[39:36.200 --> 39:39.320]  we'll turn on all the lights on the accumulator.
[39:39.720 --> 39:47.160]  And so it's the same program we had before, but now we only had to do it with eight bytes
[39:47.960 --> 39:48.680]  instead of 10.
[39:48.680 --> 39:50.920]  So we go ahead and do R and this will run the program.
[39:50.920 --> 39:51.960]  We can actually watch it go.
[39:51.960 --> 39:55.400]  So it's going to load from seven and there it is on the right hand side.
[39:55.400 --> 39:58.600]  I'm going to now do a not instruction.
[39:58.600 --> 40:04.280]  So it's going to flip the bits over and then I'm going to do an or and that will now light
[40:04.280 --> 40:08.280]  up all the lights in the accumulator and now the program is done.
[40:08.280 --> 40:09.160]  Let's run it one more time.
[40:09.160 --> 40:10.520]  We can actually watch it run.
[40:10.520 --> 40:13.560]  So when there it is, there load from location seven,
[40:13.560 --> 40:17.640]  it's going to do a not and then it's going to do a not and then there's the not
[40:17.640 --> 40:23.800]  and then it's going to do an or with location seven and it's going to then do all of our lights
[40:23.800 --> 40:26.200]  up here and stop the program.
[40:27.720 --> 40:30.120]  And so that's how we're writing that program.
[40:30.120 --> 40:30.840]  Let's do another one.
[40:31.800 --> 40:33.480]  And so I've got another program in here.
[40:33.480 --> 40:36.280]  We're going to count down from a value.
[40:36.280 --> 40:37.560]  So we can count down from three.
[40:37.560 --> 40:39.240]  We're going to do three, two, one, zero.
[40:40.040 --> 40:43.720]  And so this one requires a little bit of working out some values.
[40:43.720 --> 40:46.840]  And so I want to load a value.
[40:46.840 --> 40:49.640]  All programs really start by loading a value.
[40:49.640 --> 40:53.640]  So I'm going to load a value into the accumulator and then I'm going to test it.
[40:54.280 --> 40:55.960]  Is that value zero?
[40:55.960 --> 40:57.880]  Because if it's zero, I can I can be done.
[40:58.520 --> 41:01.080]  So if it's zero, I'm going to just end the program.
[41:02.440 --> 41:05.320]  So if zero jumped to the end of the program.
[41:05.320 --> 41:10.520]  And so I need to write a little green arrow there that kind of points to what the end of
[41:10.520 --> 41:11.320]  the program is.
[41:11.320 --> 41:13.320]  And that way I kind of keep track about what's where.
[41:14.280 --> 41:15.960]  And then it's going to subtract.
[41:15.960 --> 41:21.080]  So if it's if it's if it didn't, if it wasn't zero, the accumulator wasn't zero,
[41:21.080 --> 41:26.040]  and it's some other value, and it can only be the values of zero and 255.
[41:26.040 --> 41:29.880]  So I can now subtract one from that, whatever's in there.
[41:31.400 --> 41:34.360]  And I can't actually tell it to just subtract one.
[41:34.360 --> 41:38.120]  I actually have to tell it to subtract a value that's stored in memory.
[41:38.120 --> 41:41.720]  So I need to store the memory one in memory somewhere.
[41:41.720 --> 41:46.920]  So the value one is I need to keep a note in here that that's one,
[41:46.920 --> 41:50.040]  which ends up being a place on instruction 10.
[41:52.040 --> 41:56.200]  And then now that I've subtracted one, let's go back to the beginning
[41:56.200 --> 41:58.120]  to where we test if it's zero.
[41:58.120 --> 42:01.880]  So I'm going to do a go to instruction and then need to loop back to the beginning.
[42:01.880 --> 42:05.480]  And so I write a little little arrow there, a little orange or arrow that kind of points
[42:05.480 --> 42:06.840]  back to the beginning of my loop.
[42:06.840 --> 42:08.520]  And that way I remember where everything is.
[42:09.160 --> 42:14.760]  And this is actually how I write instructions or how I write programs for the for the toy CPUs.
[42:14.760 --> 42:16.600]  I actually have to write them all out.
[42:16.600 --> 42:20.280]  And I'm going to write a little placeholder for I need to go to the end.
[42:20.280 --> 42:22.680]  I need to load a start value.
[42:22.680 --> 42:24.120]  I need to subtract one.
[42:24.120 --> 42:30.680]  And so I'll just put words in parentheses there or in quotes to remind myself that
[42:30.680 --> 42:32.280]  that needs to come from somewhere else.
[42:32.280 --> 42:35.720]  And so as long as I've got those labels written somewhere, then I'm good.
[42:37.240 --> 42:40.760]  Now if I were going to turn this into a program to run on the toy,
[42:40.760 --> 42:42.680]  I'm just going to go look at my next slide here.
[42:42.680 --> 42:44.920]  So I count down from three to one zero.
[42:45.800 --> 42:49.160]  And that means that I need to start with a load instruction, right?
[42:49.160 --> 42:51.480]  As I've got written a little piece of paper on the left hand side,
[42:51.480 --> 42:53.960]  that orange, that yellow piece of paper.
[42:54.600 --> 42:56.040]  I wrote down the load instruction.
[42:56.040 --> 42:59.160]  So on the right hand side, that's what the load instruction looks like.
[42:59.160 --> 43:01.400]  I need to load from a start value.
[43:01.400 --> 43:03.480]  And as I wrote it down the left hand side,
[43:03.480 --> 43:07.400]  the start value needs to be on memory address nine.
[43:08.040 --> 43:10.120]  And so that's what I've got written there in binary.
[43:10.120 --> 43:11.720]  Just write it down for binary nine.
[43:12.440 --> 43:14.440]  And then I need to do a test if zero.
[43:15.320 --> 43:18.440]  And so that's what the binary looks like on the right hand side for an if zero.
[43:18.440 --> 43:18.760]  You're right.
[43:18.760 --> 43:21.640]  Again, you can look at that little card in the middle of the screen.
[43:21.640 --> 43:23.640]  I just reproduced what the card looks like.
[43:23.640 --> 43:27.560]  So you can actually remind yourself that that's what the if zero instruction looks like.
[43:28.520 --> 43:31.720]  And if it's zero, it needs to jump to the end of the program.
[43:31.720 --> 43:35.000]  And as I wrote down in my little piece of paper on the left hand side,
[43:35.000 --> 43:38.280]  you can see that the end of the instruction or the end of the program
[43:39.960 --> 43:42.440]  is at memory location eight.
[43:43.320 --> 43:45.160]  And then it needs to do a subtraction.
[43:45.160 --> 43:48.200]  So there's my subtraction instruction on the right hand side.
[43:48.200 --> 43:50.120]  And we're going to subtract the value of one,
[43:50.120 --> 43:51.800]  which is sort of memory location 10.
[43:53.000 --> 43:55.880]  And then we're going to go to back to the beginning of the loop,
[43:55.880 --> 43:58.200]  which is a counter two.
[43:59.240 --> 44:00.040]  Then we can stop.
[44:00.040 --> 44:03.320]  And then we have our two variables at the end,
[44:03.320 --> 44:05.880]  one for the start value and one for the value of one.
[44:06.520 --> 44:11.720]  And so this program is 11 bytes long from zero to 10.
[44:11.720 --> 44:13.800]  So let's actually enter this into the toy.
[44:13.800 --> 44:15.560]  Let's actually watch it run.
[44:15.560 --> 44:19.240]  And so there's my toy and I'm in counter zero.
[44:19.240 --> 44:21.640]  And it already has the load instruction for me.
[44:21.640 --> 44:22.280]  So that's good.
[44:23.080 --> 44:27.080]  And then I'm going to now enter in memory location nine
[44:27.800 --> 44:31.000]  for the instruction one, right?
[44:31.000 --> 44:33.160]  So here it is with the value of seven.
[44:33.160 --> 44:34.840]  So now he changes to nine.
[44:35.560 --> 44:41.000]  And the value of nine is the value of eight plus one.
[44:41.000 --> 44:42.120]  And so that's what that is.
[44:42.120 --> 44:44.840]  One, two, four, and eight.
[44:44.840 --> 44:47.720]  And so eight plus one is nine.
[44:47.720 --> 44:50.920]  So now memory, counter zero has the value of nine.
[44:52.520 --> 44:54.520]  I go down to the counter two.
[44:55.240 --> 44:57.960]  And now I'm going to do an if zero instruction.
[44:57.960 --> 44:59.320]  So if zero, hit return here.
[44:59.320 --> 45:00.200]  Let's enter this.
[45:00.200 --> 45:07.560]  If zero should look like this as the if zero instruction.
[45:08.360 --> 45:13.080]  And then counter three, I need to pull from memory location eight.
[45:13.080 --> 45:14.760]  So hit enter on that.
[45:14.760 --> 45:16.280]  And that is eight.
[45:17.720 --> 45:19.720]  And then memory location four.
[45:19.720 --> 45:20.920]  That's four.
[45:20.920 --> 45:22.200]  I need to do a subtraction.
[45:23.000 --> 45:24.280]  And so to hit return on this.
[45:24.280 --> 45:25.160]  So I need to enter.
[45:25.160 --> 45:26.600]  And you can see on the right hand side,
[45:26.600 --> 45:30.280]  always helps to write down what your binary instructions are.
[45:30.280 --> 45:32.920]  So you can just very quickly enter them into the toy.
[45:32.920 --> 45:34.360]  And so that's the subtraction.
[45:35.000 --> 45:36.120]  We go down by one.
[45:36.680 --> 45:40.360]  And now I'm going to subtract from the value of one,
[45:40.360 --> 45:42.120]  which is stored in memory location 10.
[45:43.000 --> 45:45.480]  And 10 is eight plus two.
[45:45.800 --> 45:49.160]  So again, your binary is, this is one, two, four, and eight.
[45:49.800 --> 45:52.840]  So eight plus two is 10.
[45:54.760 --> 45:57.560]  And now memory location six, counter six,
[45:57.560 --> 45:59.080]  now needs to have a go to instruction.
[45:59.080 --> 46:00.760]  Well, before this was the end of my programs.
[46:00.760 --> 46:03.080]  And I need to actually enter the go to instruction,
[46:03.640 --> 46:04.760]  which looks like that.
[46:05.720 --> 46:09.720]  And then I need to go to the value or go to memory counter two.
[46:10.600 --> 46:13.640]  And so then you change this value here to two.
[46:14.600 --> 46:15.720]  Which looks like that.
[46:17.000 --> 46:20.360]  And then after that, counter eight needs to be the stop
[46:20.360 --> 46:23.160]  instruction, because that's the end of my program.
[46:25.160 --> 46:28.920]  And now memory locations nine and 10 have the start value
[46:28.920 --> 46:30.120]  and then the value of one.
[46:30.120 --> 46:31.560]  So I can subtract one from my value.
[46:31.560 --> 46:35.400]  So hit enter on, well, that's the stop.
[46:35.400 --> 46:36.520]  So I need to go down one.
[46:36.520 --> 46:37.560]  This is nine.
[46:37.560 --> 46:41.000]  And now I need to enter the start value of three.
[46:41.480 --> 46:45.880]  And so this is one and two, that's three, hit enter on that.
[46:45.880 --> 46:47.880]  Now I've entered three into counter nine.
[46:47.880 --> 46:51.480]  And then counter 10 needs to have the value of one.
[46:54.120 --> 46:55.800]  And so now if I run this program,
[46:55.800 --> 46:57.720]  if I've entered everything incorrectly,
[46:57.720 --> 46:59.320]  now I can run my program.
[46:59.320 --> 47:01.960]  And you can see that it starts with zero.
[47:01.960 --> 47:06.120]  It's now loaded in the value of three.
[47:06.120 --> 47:08.760]  And then it's going to subtract from three.
[47:09.400 --> 47:11.560]  And then it's going to subtract one.
[47:11.560 --> 47:12.360]  And now I'm two.
[47:13.080 --> 47:15.000]  And then it's going to check if it's zero and it's not.
[47:15.000 --> 47:15.880]  So keep going.
[47:15.880 --> 47:17.480]  It's now subtract one again.
[47:18.120 --> 47:21.000]  And once it's subtracted one, now we go down to one.
[47:21.000 --> 47:23.640]  And it's going to check, okay, is this zero?
[47:23.640 --> 47:24.440]  It's not zero.
[47:24.440 --> 47:28.120]  So I'm going to keep doing the loop and subtract one again.
[47:28.120 --> 47:29.800]  And now it gives us down to zero.
[47:29.800 --> 47:31.640]  And I was going to jump back to the beginning of the loop
[47:31.640 --> 47:32.440]  and test if it's zero.
[47:32.440 --> 47:33.640]  And if it is, it is.
[47:33.640 --> 47:35.720]  And now it's going to jump to the end of the program.
[47:35.720 --> 47:36.840]  And now we're done.
[47:37.800 --> 47:38.760]  There we go.
[47:38.760 --> 47:43.720]  And that is counting down three, two, one, zero.
[47:43.720 --> 47:48.360]  And this was a program that my students were actually able to enter.
[47:48.360 --> 47:50.760]  Once they saw how to enter a program,
[47:50.760 --> 47:54.040]  it took them a little while to kind of get their own first program,
[47:54.040 --> 47:55.800]  but they were actually able to do it.
[47:56.760 --> 47:59.720]  And it was really neat to watch these students who are not going
[47:59.720 --> 48:02.520]  to be computer science students, be able to write a program
[48:03.160 --> 48:07.400]  for a Switches and Lights model of computer.
[48:07.400 --> 48:08.920]  Let's go and look at another one here.
[48:08.920 --> 48:12.360]  So let's move a light from the left-hand side to the right-hand side.
[48:12.360 --> 48:15.000]  This is a very simple operation using shift.
[48:16.600 --> 48:18.280]  And so I'm going to load a starting value.
[48:18.280 --> 48:21.000]  You can see instruction eight is my starting value,
[48:21.000 --> 48:23.320]  which is the value on the left-hand side.
[48:24.280 --> 48:27.240]  And then it's going to test if that's zero.
[48:27.240 --> 48:28.840]  Because if it's zero, we're done.
[48:28.840 --> 48:31.720]  And so if it's zero, it will jump to the end of the program.
[48:32.760 --> 48:39.320]  And then if it's not zero, then we need to shift that light
[48:39.320 --> 48:41.480]  off to the right-hand side by one.
[48:41.480 --> 48:43.400]  So let's do the right instruction.
[48:43.400 --> 48:44.440]  Right doesn't take an argument.
[48:44.440 --> 48:46.840]  It just shifts the bits off to the right by one.
[48:48.040 --> 48:51.240]  And if they roll off the right-hand side, then they're lost.
[48:51.240 --> 48:53.480]  And they're going to jump back to the beginning of the loop.
[48:54.600 --> 48:58.680]  And then the instruction seven is where the program can actually end.
[48:58.680 --> 49:01.800]  And then instruction eight has the value
[49:01.800 --> 49:02.680]  that we're starting with.
[49:03.320 --> 49:07.640]  And so looking at turning that into a program,
[49:07.640 --> 49:09.960]  I only need instructions zero through eight.
[49:09.960 --> 49:11.880]  This is a nine-byte program.
[49:12.920 --> 49:15.240]  And so let's go ahead and enter that into the toy.
[49:16.600 --> 49:19.240]  And so I'm going to start on counter zero.
[49:19.240 --> 49:20.360]  And I'm going to load.
[49:20.360 --> 49:21.400]  There's my load instruction.
[49:21.400 --> 49:22.280]  It's already there.
[49:22.280 --> 49:23.640]  And now I'm going to go down by one.
[49:23.640 --> 49:24.840]  Let's go to counter one.
[49:24.840 --> 49:27.000]  I need to load from memory location eight.
[49:27.000 --> 49:28.040]  So it changes to an eight.
[49:32.600 --> 49:38.200]  And now counter two needs to be the test if something is zero.
[49:38.200 --> 49:40.840]  And this is already the if-zero instruction.
[49:42.600 --> 49:45.800]  You can see it's zero, zero, zero, one, one, zero, zero, one.
[49:45.800 --> 49:47.880]  That's the if-zero instruction.
[49:47.880 --> 49:50.360]  You can always tell because it's on a little card
[49:50.360 --> 49:52.680]  in the front of the toy CPU.
[49:52.680 --> 49:55.560]  But I also have written that out in binary on the right-hand side.
[49:55.560 --> 49:58.600]  So I know that counter two has the if-zero instruction.
[49:58.600 --> 50:00.200]  Go down to counter three.
[50:00.200 --> 50:03.480]  And this needs to be the instruction that
[50:03.480 --> 50:04.600]  is the end of the program.
[50:04.600 --> 50:06.360]  That's where the stop instruction lives.
[50:07.160 --> 50:11.000]  And that is going to be, so that is, I'm on three.
[50:11.000 --> 50:12.600]  And this needs to be the value of seven.
[50:13.480 --> 50:15.880]  And so I'm going to turn that off and turn these on.
[50:15.880 --> 50:19.160]  And that is now the binary value of seven.
[50:20.440 --> 50:21.560]  And now let's go down one.
[50:21.560 --> 50:23.320]  We can go to counter four.
[50:23.320 --> 50:25.720]  And this needs to be the right shift instruction.
[50:25.720 --> 50:29.400]  Shift all the bytes in there over by one.
[50:29.400 --> 50:30.840]  So we're going to turn this off.
[50:30.840 --> 50:33.160]  And that is now the right instruction.
[50:34.920 --> 50:36.360]  Enter on that to submit it.
[50:36.360 --> 50:38.120]  And then go down one.
[50:38.760 --> 50:41.240]  And now this is instruction five.
[50:41.240 --> 50:43.000]  And this needs to be the go-to instruction.
[50:43.000 --> 50:45.800]  So hit enter to edit this.
[50:45.800 --> 50:48.840]  And so these two lights and that one off,
[50:48.840 --> 50:50.840]  that should be the go-to instruction.
[50:53.320 --> 50:56.520]  And then submit that and then go down by one.
[50:56.520 --> 50:59.240]  This will now be counter six.
[50:59.240 --> 51:02.520]  That now needs to have the value of two because that is going
[51:02.520 --> 51:05.960]  to go back to instruction two on my program.
[51:05.960 --> 51:08.360]  So let's go ahead and enter the value of two.
[51:11.400 --> 51:15.400]  And let's go then to counter seven.
[51:15.400 --> 51:16.600]  So I'm going to use the down arrow
[51:16.600 --> 51:18.600]  and that brings me down to counter seven.
[51:18.600 --> 51:20.440]  And this needs to be the stop instruction.
[51:20.440 --> 51:23.000]  So I'm going to hit enter here and turn off this bit.
[51:23.000 --> 51:25.880]  And that now means that my program has stopped.
[51:27.480 --> 51:30.520]  And then eight is where we need to have the start value.
[51:30.520 --> 51:33.960]  Now it does take a while to run this program
[51:33.960 --> 51:35.800]  and actually watch the light move all the way
[51:35.800 --> 51:37.480]  from the left-hand side to the right-hand side.
[51:38.200 --> 51:40.760]  So for simplicity, just to kind of speed up the demo
[51:40.760 --> 51:43.000]  a little bit, let's start the bit right there.
[51:43.000 --> 51:44.840]  We're going to start the light right there.
[51:44.840 --> 51:47.000]  And we're going to watch it go from that end to the right
[51:47.000 --> 51:49.160]  and then it'll disappear and then the program will end.
[51:49.960 --> 51:52.360]  Now it doesn't matter what I have in instructions after that.
[51:52.360 --> 51:56.200]  So this is eight and then nine has some garbage value
[51:56.280 --> 51:58.360]  in it, but I don't care because my program never gets there.
[51:59.080 --> 52:00.600]  So let's go ahead and run this program.
[52:00.600 --> 52:02.200]  So again, what it's going to do is it's going to start
[52:02.200 --> 52:06.680]  with this value here from memory location eight.
[52:07.880 --> 52:09.240]  And it's going to light up that light.
[52:09.960 --> 52:11.880]  That's the fourth one from the right.
[52:12.760 --> 52:14.280]  And it's going to load that into the accumulator
[52:14.280 --> 52:16.440]  and then it's going to keep moving that light
[52:16.440 --> 52:20.840]  to the right by one until it gets to the value of one
[52:20.840 --> 52:24.120]  and then right shift one and that'll be the value of zero
[52:24.120 --> 52:25.640]  and then the program will end.
[52:26.520 --> 52:28.280]  So basically it's the same as moving that light
[52:29.160 --> 52:30.120]  to the right hand side.
[52:30.120 --> 52:33.000]  So we're going to just run R and now it's going to load
[52:33.640 --> 52:34.600]  the value.
[52:34.600 --> 52:35.480]  There it is.
[52:35.480 --> 52:39.640]  And now it's going to do various comparisons if zero
[52:39.640 --> 52:42.040]  and then it's going to do a right shift, which it just did.
[52:42.040 --> 52:43.400]  And let's go back to the beginning,
[52:43.960 --> 52:45.560]  do a test if it's zero and it's not.
[52:45.560 --> 52:47.800]  So we're going to do a right shift and there it is.
[52:48.600 --> 52:50.040]  And they're going to go back to the beginning
[52:50.040 --> 52:51.880]  and we're going to test if it's zero.
[52:51.880 --> 52:54.120]  And if it's not, then we'll do a right shift
[52:54.120 --> 52:55.720]  and then it's going to move it off by one.
[52:56.200 --> 52:58.120]  And let's go back to the beginning of the loop
[52:58.120 --> 52:59.720]  and it's going to test if it's zero.
[52:59.720 --> 53:02.360]  And if it's not, it's going to then do a right shift.
[53:02.920 --> 53:03.400]  There it is.
[53:03.400 --> 53:04.040]  Now it's zero.
[53:04.040 --> 53:05.240]  Let's go back to the beginning of the loop.
[53:05.240 --> 53:07.000]  It's testing if it's zero and it is.
[53:07.000 --> 53:09.960]  And now it's going to jump to the end of the program,
[53:09.960 --> 53:12.760]  which has a stop instruction and there it is.
[53:13.480 --> 53:16.760]  So that is a program that will just move a light
[53:16.760 --> 53:19.480]  from the left hand side over to the right.
[53:20.760 --> 53:22.920]  And I think we have time for one more program.
[53:22.920 --> 53:24.760]  So let's go and do one more program here.
[53:25.400 --> 53:29.080]  We're going to add the value one and two
[53:29.080 --> 53:31.880]  and we're going to store it in another location.
[53:31.880 --> 53:34.680]  So this is again something I had my students do.
[53:35.400 --> 53:37.640]  So that way they would have a basic understanding
[53:37.640 --> 53:41.400]  of how computers are working, how you program a computer,
[53:41.400 --> 53:44.440]  a very simple computer using a switches and lights model.
[53:45.320 --> 53:48.920]  And so I'm going to load a value into memory.
[53:48.920 --> 53:50.360]  I need to load my first value.
[53:51.160 --> 53:54.120]  And then I'm going to add to the accumulator
[53:55.320 --> 53:58.920]  some other value, my second value also stored for memory.
[53:59.480 --> 54:02.280]  And then the accumulator will now be the sum
[54:02.280 --> 54:04.120]  of the first and second numbers.
[54:05.000 --> 54:09.320]  And now we need to store that in memory somewhere else.
[54:09.320 --> 54:11.080]  And so I need to do a store instruction,
[54:11.080 --> 54:13.480]  store that sum somewhere else,
[54:13.480 --> 54:14.760]  and then I can stop the program.
[54:14.760 --> 54:19.000]  A very simple program and it needs three variables
[54:19.000 --> 54:20.360]  just to store values.
[54:20.360 --> 54:22.040]  One is going to need to have one variable
[54:22.040 --> 54:23.320]  that's going to store the value.
[54:23.320 --> 54:25.640]  First number we need to add, we'll put in the number one.
[54:26.760 --> 54:28.840]  And then the second number it needs to add,
[54:28.840 --> 54:29.880]  we'll put in the number two.
[54:30.760 --> 54:33.800]  And then another place for it to store the results.
[54:34.440 --> 54:36.760]  Now you can actually watch the accumulator change.
[54:36.760 --> 54:39.720]  We can actually go back later to see if the accumulator has changed.
[54:40.920 --> 54:43.640]  And so we're going to put in just a garbage value here
[54:43.640 --> 54:44.600]  if all the lights are on.
[54:44.600 --> 54:48.120]  So we can actually see it be one plus two will be three.
[54:48.120 --> 54:50.600]  We actually should see the value of three in there when we're done.
[54:51.480 --> 54:56.120]  So let's use that little card in the front of the toy CPU
[54:56.120 --> 54:58.520]  to actually figure out what our instructions need to look like.
[54:59.080 --> 55:00.680]  So we can start with the load instruction.
[55:01.640 --> 55:03.160]  And we're going to load from...
[55:03.160 --> 55:05.480]  Now we've kind of figured out by writing on the left-hand side
[55:05.480 --> 55:08.840]  a little sticky note that looks like a little sticky note.
[55:08.840 --> 55:10.360]  By writing out our program first,
[55:10.360 --> 55:12.920]  we can actually figure out that the first instruction
[55:12.920 --> 55:14.680]  or the first number it needs to pull from
[55:14.680 --> 55:17.960]  is going to be on instruction seven or counter seven.
[55:17.960 --> 55:19.320]  So we're doing on the right-hand side,
[55:19.320 --> 55:21.880]  we're doing a load from memory location seven.
[55:23.080 --> 55:25.880]  And then we're going to add to the accumulator
[55:25.880 --> 55:28.200]  what is in memory location eight.
[55:28.200 --> 55:30.680]  Turns out that's our second number is memory location eight.
[55:31.320 --> 55:32.600]  And then we're going to take that value,
[55:32.600 --> 55:34.360]  we're going to copy that value,
[55:34.360 --> 55:37.000]  we're going to store it into memory somewhere.
[55:37.000 --> 55:39.080]  And so we're going to use the store instruction
[55:39.080 --> 55:41.240]  and put that into the place we were for that,
[55:41.240 --> 55:42.840]  which is memory location nine.
[55:43.640 --> 55:44.440]  And once we've done that,
[55:44.440 --> 55:47.240]  we're going to stop the program and then we're done.
[55:47.240 --> 55:51.160]  So this is another 10 byte program from zero to nine.
[55:51.160 --> 55:53.720]  And by the way, I've borrowed all of these,
[55:53.720 --> 55:56.840]  many of these instructions from Brian Kernighan's toy
[55:56.840 --> 56:00.840]  and that was able to use the Brian Kernighan's toy
[56:00.840 --> 56:04.360]  after I showed my students the toy CPU.
[56:05.960 --> 56:08.520]  So let's go ahead and enter this add one plus two
[56:08.520 --> 56:09.880]  and store it in a variable.
[56:10.440 --> 56:13.960]  And so I'm going to now start at zero, counter zero,
[56:13.960 --> 56:16.600]  which is a load of variable or load of value.
[56:16.600 --> 56:18.280]  And that's already got the load instruction on.
[56:18.920 --> 56:21.560]  So I'm going to go down by one to memory location,
[56:21.560 --> 56:23.080]  our counters, counter one,
[56:23.080 --> 56:24.920]  which now needs to have a value of seven.
[56:24.920 --> 56:25.960]  So I had to enter here.
[56:26.520 --> 56:28.840]  And now let's turn that to binary value of seven.
[56:31.080 --> 56:32.760]  And I'm going to go down one more.
[56:32.760 --> 56:35.880]  So counter two, we're going to do the add instruction.
[56:35.880 --> 56:37.800]  So let's hit enter on this and edit this
[56:37.800 --> 56:39.080]  to be the add instruction.
[56:39.080 --> 56:40.440]  Now I've already written on the right hand side
[56:40.440 --> 56:41.800]  what add needs to look like.
[56:42.600 --> 56:44.360]  And so add looks like that.
[56:44.360 --> 56:45.640]  That's the add instruction.
[56:47.240 --> 56:48.280]  And so I'm done with that.
[56:48.280 --> 56:51.160]  And now we need to add from what variable
[56:51.160 --> 56:53.320]  or what place in memory.
[56:53.320 --> 56:56.920]  So counter three has the location of memory
[56:56.920 --> 56:57.640]  we're going to pull from.
[56:57.640 --> 56:59.080]  And that is memory location eight.
[56:59.880 --> 57:03.080]  And so that is the binary value of eight.
[57:05.160 --> 57:09.960]  And then counter four now needs to store that somewhere.
[57:09.960 --> 57:12.280]  So now we need to give it the store instruction,
[57:12.280 --> 57:13.240]  which we haven't used yet.
[57:13.240 --> 57:14.760]  So this is the store instruction.
[57:16.760 --> 57:17.960]  And where is it going to store it?
[57:17.960 --> 57:20.840]  Well, the next instruction here,
[57:20.840 --> 57:23.000]  instruction five, counter five,
[57:23.000 --> 57:24.360]  is going to have the memory location
[57:24.360 --> 57:25.320]  that we need to store it in,
[57:25.320 --> 57:29.080]  which is the memory value, memory location of nine.
[57:31.480 --> 57:34.280]  And then the next instruction, instruction six,
[57:34.280 --> 57:35.880]  needs to be the stop instructions.
[57:35.880 --> 57:38.520]  I need to turn off that one bit, the 30 set.
[57:38.520 --> 57:40.040]  And now I'm a stop instruction.
[57:40.840 --> 57:42.680]  And then I go down one more.
[57:42.680 --> 57:44.440]  And now I've got memory location seven.
[57:44.440 --> 57:45.880]  It's my first number I want to add.
[57:46.440 --> 57:48.600]  And I'm going to make that the value of one.
[57:50.760 --> 57:52.440]  And then memory location eight.
[57:53.080 --> 57:54.440]  I'm going to add the second number.
[57:55.000 --> 57:57.000]  Let's make it a nice number we can count,
[57:57.000 --> 57:58.200]  count down, which is number two.
[57:59.080 --> 58:01.400]  And now one plus two will be three,
[58:01.400 --> 58:03.000]  but we're going to store it over here
[58:03.000 --> 58:04.680]  in memory location nine.
[58:04.680 --> 58:06.680]  And just so we can see where things,
[58:06.680 --> 58:07.720]  how things get changed,
[58:07.720 --> 58:10.200]  let's actually change all these lights to ones,
[58:10.200 --> 58:11.800]  the value of 255.
[58:12.920 --> 58:14.520]  And so that's memory location nine.
[58:16.200 --> 58:17.240]  Enter on that.
[58:17.240 --> 58:19.160]  And now let's run the program.
[58:19.160 --> 58:20.840]  So again, you can see on the right-hand side
[58:20.840 --> 58:21.960]  what's going to be happening.
[58:21.960 --> 58:24.840]  It's going to load a value for memory location seven.
[58:24.840 --> 58:26.360]  That's the value of one.
[58:26.360 --> 58:28.440]  It's going to then add to the accumulator
[58:29.800 --> 58:33.000]  what's stored in memory location eight,
[58:33.000 --> 58:34.040]  which is the value of two.
[58:34.840 --> 58:37.560]  And so that will change the accumulator to the value of three.
[58:38.120 --> 58:39.880]  And then we're going to use the store instruction
[58:39.880 --> 58:41.000]  to store that somewhere.
[58:41.000 --> 58:44.040]  We're going to store it in memory location nine,
[58:44.040 --> 58:45.560]  which is what we've got on screen right now.
[58:45.560 --> 58:46.760]  And then it's going to stop.
[58:46.760 --> 58:48.200]  So when we're done with the program,
[58:48.200 --> 58:50.120]  we can go back to memory instruction nine.
[58:50.120 --> 58:50.840]  And we will.
[58:50.840 --> 58:55.960]  We can actually see that we've changed the value from 255 to three.
[58:55.960 --> 58:57.800]  So we are to run the program.
[58:58.520 --> 58:59.640]  It's now it's going to load.
[59:00.440 --> 59:01.720]  And there's our value.
[59:01.720 --> 59:02.600]  It's going to add.
[59:03.320 --> 59:04.520]  And that's now it's three.
[59:04.520 --> 59:05.480]  And I was going to store.
[59:06.200 --> 59:07.400]  And now it's going to store it.
[59:07.400 --> 59:08.760]  And now the program is done.
[59:10.520 --> 59:13.640]  And so now if I use the up and down keys,
[59:13.640 --> 59:16.920]  you can actually go down to this is zero counter one,
[59:16.920 --> 59:19.160]  counter two, counter three, counter four,
[59:19.160 --> 59:23.960]  counter five, six, seven, eight, nine.
[59:24.600 --> 59:27.960]  And nine is now the value of three.
[59:27.960 --> 59:31.640]  We actually were able to modify the contents of memory.
[59:33.000 --> 59:37.080]  And so this is another program that my students were able to write.
[59:37.080 --> 59:39.240]  Now again, they're not going to become computer science students.
[59:39.240 --> 59:42.520]  So they don't need to be experts in how computers work,
[59:42.520 --> 59:47.080]  but they need to have a basic understanding about how programs work.
[59:47.080 --> 59:50.440]  And now they have the sort of the grounding of how we would program
[59:50.440 --> 59:53.400]  computers is just sort of a switches and lights model.
[59:54.040 --> 01:00:00.600]  Now it became much easier for them to now see why we had programming languages
[01:00:00.600 --> 01:00:04.840]  that were higher level like C, Fortran, things like that.
[01:00:04.840 --> 01:00:07.320]  And so we were then able to carry this forward
[01:00:07.320 --> 01:00:09.560]  and talk about other programming languages.
[01:00:09.640 --> 01:00:14.040]  So this is the same program, add one plus two and store it in another variable
[01:00:15.080 --> 01:00:19.480]  written in the C programming language and the Fortran 77 programming language.
[01:00:19.480 --> 01:00:23.400]  So if you're a C programmer, you know that you're going to start a function called main.
[01:00:23.960 --> 01:00:29.960]  And then we're going to take the define a variable called sum.
[01:00:29.960 --> 01:00:33.720]  And we're going to just use the, we're going to add one plus two.
[01:00:33.720 --> 01:00:36.440]  And we're going to store in that variable called sum.
[01:00:36.440 --> 01:00:39.160]  And then we're going to, in this case, print it back out to the user.
[01:00:39.160 --> 01:00:43.080]  So by these other programming languages, we can actually now have things like displaying
[01:00:43.080 --> 01:00:44.440]  things to the screen.
[01:00:44.440 --> 01:00:48.280]  And so that prints out one plus two equals three,
[01:00:48.280 --> 01:00:49.800]  because that's the value of the sum variable.
[01:00:49.800 --> 01:00:51.800]  And then it returns back to the operating system.
[01:00:51.800 --> 01:00:54.120]  Or if you're a Fortran programmer on the right hand side,
[01:00:54.120 --> 01:00:55.880]  we're going to define a program called add.
[01:00:56.520 --> 01:00:59.080]  And it's going to find a variable called sum.
[01:00:59.080 --> 01:01:03.480]  And it's going to add the numbers of one and two and store it in the variable called sum.
[01:01:03.480 --> 01:01:10.040]  It's going to print out then the results one plus two equals three.
[01:01:11.400 --> 01:01:15.000]  And so by starting with sort of the switches and lights model,
[01:01:16.200 --> 01:01:21.560]  my students then understood at a basic level how computers operated.
[01:01:21.560 --> 01:01:27.480]  They're not using disk interfaces and screen and things like that.
[01:01:27.480 --> 01:01:30.920]  They're not querying the keyboard and other types of interrupts.
[01:01:30.920 --> 01:01:38.520]  It's just a very basic minimal instructions that computer that teaches them the basics
[01:01:38.520 --> 01:01:41.560]  on how a very simple computer might operate.
[01:01:41.560 --> 01:01:46.040]  And once they have that understanding, then they were able to carry that forward to then
[01:01:46.040 --> 01:01:51.800]  understand why we built other programming languages and why those other programming languages
[01:01:51.800 --> 01:01:54.760]  are so much easier for programmers to use.
[01:01:55.480 --> 01:01:58.600]  And so that is why I created the toy CPU.
[01:01:58.600 --> 01:02:02.360]  And just a couple of programs you can use in the toy CPU.
[01:02:02.360 --> 01:02:06.440]  I'm sure now that you've seen some demonstrations about how to write programs in the toy CPU,
[01:02:06.440 --> 01:02:07.400]  you can write your own.
[01:02:08.120 --> 01:02:09.880]  And I would encourage you to go ahead and do that.
[01:02:09.880 --> 01:02:14.920]  So again, on the screen, you can see the URL to download the toy CPU at github.com
[01:02:16.120 --> 01:02:18.920]  slash Fridos project slash toy CPU.
[01:02:19.960 --> 01:02:22.600]  If you have questions after this conference is over,
[01:02:22.600 --> 01:02:26.040]  you can certainly feel free to email me at jhaul at Fridos.org.
[01:02:26.040 --> 01:02:27.800]  Otherwise, I think we're going to do a Q&A now.
[01:02:27.800 --> 01:02:32.760]  And I'll be happy to hopefully I'm going to be on the chat and I can answer your questions there.
[01:02:33.400 --> 01:02:33.640]  All right.
[01:02:33.640 --> 01:02:40.280]  So thank you very much for attending this talk on how to use the toy CPU emulator to
[01:02:41.000 --> 01:02:42.600]  learn 8-bit programming.
[01:02:42.600 --> 01:02:43.320]  Thanks very much.
[01:02:43.320 --> 01:02:47.560]  And thanks for joining FOSDOM.
[01:02:57.000 --> 01:02:58.120]  I think we're live.
[01:02:58.680 --> 01:02:59.400]  We are.
[01:02:59.400 --> 01:03:03.720]  Anyway, so yeah, so yeah.
[01:03:03.720 --> 01:03:08.440]  So thank you very much for doing this and for kicking off the AmiDev rooms.
[01:03:09.960 --> 01:03:10.920]  What year are we?
[01:03:10.920 --> 01:03:18.200]  FOSDOM 2023 presentations was an amazing talk and especially cool because,
[01:03:18.200 --> 01:03:22.280]  you know, it's from the education point of view, educational system point of view,
[01:03:22.280 --> 01:03:23.240]  which is interesting.
[01:03:23.240 --> 01:03:24.040]  It's always interesting.
[01:03:25.000 --> 01:03:26.760]  So yeah, thank you for doing this.
[01:03:28.520 --> 01:03:32.280]  And yeah, we have a couple of questions and most of them are from me.
[01:03:32.280 --> 01:03:35.160]  So they're annoying questions, but please bear with me.
[01:03:37.400 --> 01:03:37.800]  Let's see.
[01:03:37.800 --> 01:03:40.680]  So yeah, so this was actually answered during this talk,
[01:03:40.680 --> 01:03:42.440]  but maybe you can go into it a little bit more.
[01:03:42.920 --> 01:03:47.000]  So yeah, why create a new project, right?
[01:03:47.000 --> 01:03:52.200]  Or toy CPU, there's a lot of like all the CPUs that are very simple instruction sets.
[01:03:52.520 --> 01:03:53.960]  So yeah.
[01:03:54.920 --> 01:03:59.560]  Yeah, and I thought about, you know, using something else.
[01:03:59.560 --> 01:04:05.720]  I mentioned in the video briefly that there's a project called the DigiRule 2
[01:04:05.720 --> 01:04:08.040]  that was exactly what I was looking for.
[01:04:08.040 --> 01:04:13.160]  I was looking for something that would be simple for my students to understand.
[01:04:13.160 --> 01:04:16.520]  You know, they're not computer science students or their business students.
[01:04:16.520 --> 01:04:20.120]  And so I wanted something to be very easy for them to understand,
[01:04:20.120 --> 01:04:24.360]  but at the same time, I also showed how the switches and lights model worked,
[01:04:24.360 --> 01:04:25.480]  because that was always the question.
[01:04:25.480 --> 01:04:28.600]  I've taught this class a couple of times and that's always the question.
[01:04:28.600 --> 01:04:33.240]  It's like, well, how do you do programming with switches and knobs and lights?
[01:04:34.200 --> 01:04:36.200]  And so I wanted to be able to show that.
[01:04:36.200 --> 01:04:37.640]  So I wanted it, but I wanted it to be simple.
[01:04:37.640 --> 01:04:39.800]  I didn't want to like get them lost with, you know,
[01:04:40.440 --> 01:04:43.000]  segmented memory and the registers and things like that.
[01:04:43.000 --> 01:04:44.360]  So I was just like, I wanted to create something.
[01:04:44.360 --> 01:04:45.560]  I wanted something that was simple.
[01:04:46.200 --> 01:04:49.000]  And the DigiRule 2 actually would have been perfect for that.
[01:04:49.000 --> 01:04:51.560]  And it's only, I think it's like, well, it's less than $100.
[01:04:51.560 --> 01:04:52.280]  I know that for sure.
[01:04:53.560 --> 01:04:55.720]  And that would have been perfect, but they're out of stock.
[01:04:55.720 --> 01:04:58.120]  It's an independent project and they're out of stock.
[01:04:58.120 --> 01:05:00.760]  So I wasn't able to buy one to show up in class.
[01:05:00.760 --> 01:05:03.800]  So for me, it was, let's just go ahead and write one.
[01:05:03.800 --> 01:05:04.760]  That's very simple.
[01:05:05.400 --> 01:05:11.800]  That has a minimal instruction set that it's enough to show the students kind of how it works.
[01:05:11.800 --> 01:05:16.040]  And so that's why I created the Toy CPU, rather than like I could have used a,
[01:05:16.440 --> 01:05:20.440]  you know, there are emulators out there that let you basically run a virtual,
[01:05:21.560 --> 01:05:24.920]  you know, Altair 8800 or, you know, something like that.
[01:05:24.920 --> 01:05:28.040]  But it's like, when I looked at it, it's like, it's a little bit too much,
[01:05:28.040 --> 01:05:31.640]  especially the ones that were showing how the internals of the CPU worked.
[01:05:31.640 --> 01:05:33.480]  And I didn't quite need to go that deep.
[01:05:34.360 --> 01:05:38.040]  So something like this ended up being simple enough,
[01:05:38.040 --> 01:05:41.960]  I think that these 100 level students could understand it.
[01:05:42.920 --> 01:05:45.800]  Yeah, okay. And during the talk, you mentioned, of course,
[01:05:45.800 --> 01:05:48.520]  you'd like to explain the history of everything to the students.
[01:05:48.520 --> 01:05:51.320]  And so did you explain punch cards to them?
[01:05:52.200 --> 01:05:54.440]  I did explain punch cards to them, but, you know,
[01:05:54.440 --> 01:05:56.680]  we didn't actually do anything as a demo of punch cards,
[01:05:56.680 --> 01:05:59.320]  but I actually have a physical punch card that I had in my office,
[01:06:00.120 --> 01:06:02.840]  my other office that I actually was able to show them and say,
[01:06:02.840 --> 01:06:04.440]  this is a punched card.
[01:06:04.440 --> 01:06:06.840]  And we actually were able to talk about how the punch cards work.
[01:06:07.480 --> 01:06:11.160]  Because yeah, I like to do that in my classes to actually, you know, it's the history.
[01:06:11.720 --> 01:06:15.480]  It's, you know, they learn how to use tools, that's part of the class.
[01:06:15.480 --> 01:06:18.360]  But the other part is they need to understand how technology works.
[01:06:18.920 --> 01:06:23.000]  And the way that I like to explain it is to explain kind of how we got from here to there,
[01:06:23.000 --> 01:06:26.040]  not just like, here's a computer in 2023.
[01:06:26.760 --> 01:06:30.760]  But actually, here's how we got to computers in 2023.
[01:06:30.760 --> 01:06:34.760]  And yeah, I like to show a lot of like how we got from there to here.
[01:06:34.760 --> 01:06:38.760]  Because I think if they kind of can see things, you know, changing over time,
[01:06:38.760 --> 01:06:43.640]  it's easier to look at, for example, a motherboard for a modern PC,
[01:06:43.640 --> 01:06:47.480]  and be able to recognize things on it, if they started with what we do,
[01:06:47.480 --> 01:06:50.280]  with starting by looking at the motherboard on Apple too.
[01:06:51.240 --> 01:06:54.280]  So, you know, that way it's like, oh, there's a CPU, there's the memory,
[01:06:54.280 --> 01:06:55.640]  there's these other things.
[01:06:55.640 --> 01:06:58.040]  And then we look at a more modern motherboard,
[01:06:58.040 --> 01:06:59.880]  then we look at a more modern board from that,
[01:06:59.880 --> 01:07:03.160]  and then we can look at, you know, what a phone motherboard and things like that.
[01:07:03.160 --> 01:07:05.880]  And the students, once they, once they kind of see kind of,
[01:07:06.600 --> 01:07:09.080]  you know, how things started and kind of walked their way up,
[01:07:09.960 --> 01:07:13.000]  I find the students are much better at actually being able to understand
[01:07:13.000 --> 01:07:15.320]  the technology at kind of a high level.
[01:07:15.320 --> 01:07:16.760]  So that's why I like to do this sort of this,
[01:07:16.760 --> 01:07:18.920]  how we got from here to, you know, from there to here.
[01:07:19.640 --> 01:07:22.200]  And that's also why I wanted to show my students kind of this
[01:07:23.320 --> 01:07:25.640]  switches and lights programming model.
[01:07:26.440 --> 01:07:27.080]  Yeah, all right.
[01:07:27.720 --> 01:07:30.840]  And the small question, even some of the slides you use simulator,
[01:07:30.840 --> 01:07:32.200]  and others you use emulator.
[01:07:32.280 --> 01:07:38.280]  And so what's the difference from your point of view for this particular project?
[01:07:39.800 --> 01:07:40.440]  In terms of what?
[01:07:40.440 --> 01:07:42.360]  The term or just what I was doing?
[01:07:42.920 --> 01:07:45.320]  No, the technology, excuse me.
[01:07:46.120 --> 01:07:50.840]  Oh, so yeah, I just wanted to, you know, basically, you know,
[01:07:50.840 --> 01:07:54.360]  simulate in kind of an older computer, you know, and that was the goal.
[01:07:55.240 --> 01:07:58.280]  And so, you know, I kind of use the term emulator and simulator,
[01:07:58.280 --> 01:08:00.280]  I guess, interchangeably there.
[01:08:00.280 --> 01:08:03.880]  But, you know, the goal was just to simulate kind of an older,
[01:08:04.840 --> 01:08:06.840]  the way a simpler machine would have worked.
[01:08:06.840 --> 01:08:11.160]  And this is the kind of way that a CPU would work from, you know, the 60s or 70s,
[01:08:11.160 --> 01:08:14.440]  you know, with the accumulator, single operations,
[01:08:15.640 --> 01:08:17.800]  you know, limited amount of memory and things like that.
[01:08:17.800 --> 01:08:20.840]  And so that was that was that was the choice there.
[01:08:22.200 --> 01:08:22.760]  Yeah, all right.
[01:08:24.120 --> 01:08:27.640]  Yeah, another question we joked about in the room is,
[01:08:27.640 --> 01:08:30.200]  so yes, this is pretty, yeah, it's pretty awesome.
[01:08:31.720 --> 01:08:35.800]  But it might be a complex for for students.
[01:08:35.800 --> 01:08:40.440]  So, so yeah, how did the students do actually business students?
[01:08:40.440 --> 01:08:42.760]  I mean, it's yeah, and that's a great point.
[01:08:42.760 --> 01:08:45.160]  It is a it is a little complicated.
[01:08:45.160 --> 01:08:48.040]  I mean, I'm kind of going back to old school on this one.
[01:08:48.040 --> 01:08:52.280]  And it is a bit much for students today to kind of understand how that works.
[01:08:52.360 --> 01:08:59.480]  You know, showing them the, you know, the the toy, you know, I showed them how the toy works,
[01:08:59.480 --> 01:09:05.560]  and we walked through the simple load instructions, and they were able to understand that that they
[01:09:05.560 --> 01:09:10.040]  mean they like, okay, great, once I understand how this works, I understand how the loading
[01:09:10.040 --> 01:09:12.520]  operations work to actually load these different values.
[01:09:12.520 --> 01:09:16.040]  They don't have to, you know, they do, you know, as part of the class, I actually do teach
[01:09:16.040 --> 01:09:19.640]  some binary because binary ends up being used in lots of different things, like they have
[01:09:19.640 --> 01:09:22.120]  to learn how networking works at a high level.
[01:09:22.120 --> 01:09:25.080]  And so learning how to binary works allows them to understand some of that.
[01:09:25.720 --> 01:09:28.360]  So this was not the first time they had seen binary.
[01:09:29.880 --> 01:09:33.800]  But, you know, they could they understand how load operations work.
[01:09:33.800 --> 01:09:35.960]  And so that was okay.
[01:09:37.400 --> 01:09:44.760]  You know, I would say most of the students were able to do the add one plus two program.
[01:09:44.760 --> 01:09:46.040]  That that's pretty straightforward.
[01:09:46.760 --> 01:09:50.440]  That's just loading a number and adding a number to it and then storing it somewhere else.
[01:09:50.440 --> 01:09:53.320]  And then it's just a matter of figuring out where all those numbers need to go.
[01:09:54.440 --> 01:09:57.000]  And I would say most of the students were able to do that one.
[01:09:57.720 --> 01:10:02.840]  I would say maybe half, maybe if I'm lucky, half of the students were able to do the
[01:10:03.800 --> 01:10:08.680]  countdown three, two, one, zero, because that one's that one's kind of complicated when you
[01:10:08.680 --> 01:10:13.720]  look at it for a non-computer science student, and maybe even for some computer science students
[01:10:13.800 --> 01:10:18.040]  at the 100 level, because it's got a loop in there and it's modifying values.
[01:10:18.040 --> 01:10:19.960]  And so I mean, that was that was a lot.
[01:10:20.600 --> 01:10:24.600]  So if I was lucky, maybe half of the students kind of got that one.
[01:10:25.640 --> 01:10:29.160]  And so that's why I kind of think, you know, it's like, well, if I were going to do this again,
[01:10:30.120 --> 01:10:34.040]  you know, what I, you know, I'll I'm scheduled to teach that class again.
[01:10:34.040 --> 01:10:37.720]  And so what I what I use the toy again, and I think it was an interesting experiment, but I'm
[01:10:38.440 --> 01:10:40.600]  I'm not sure that I would use the toy again.
[01:10:40.600 --> 01:10:46.440]  And it's kind of got a little bit, a little bit deep in some parts.
[01:10:46.440 --> 01:10:49.880]  So I think I might not use it again, but it was a great experiment to do this year.
[01:10:50.760 --> 01:10:51.320]  Yeah, okay.
[01:10:51.320 --> 01:10:51.720]  Okay.
[01:10:51.720 --> 01:10:55.800]  And none of the students saw the light and thought I'm going to go do computer science now.
[01:10:55.800 --> 01:10:57.880]  So I'm aware of that.
[01:10:57.880 --> 01:11:00.920]  What I tell them at the beginning, I said, I'm not going to try and convert you to be
[01:11:00.920 --> 01:11:01.880]  computer science student.
[01:11:01.880 --> 01:11:03.000]  But if you want to, that'd be great.
[01:11:03.720 --> 01:11:06.680]  But I don't think anybody in that room probably got converted on that one.
[01:11:07.640 --> 01:11:08.360]  Yeah, all right.
[01:11:08.360 --> 01:11:08.760]  All right.
[01:11:10.520 --> 01:11:12.040]  There's a question.
[01:11:12.040 --> 01:11:16.760]  So did you consider doing it like a web based version of this, like Brian did for toy?
[01:11:17.480 --> 01:11:20.760]  I did consider doing something that was web based.
[01:11:22.200 --> 01:11:30.360]  But something else I didn't mention in the talk was, you know, I created a mock up of this,
[01:11:30.520 --> 01:11:36.360]  just an experiment that was, you know, something that like wouldn't read input.
[01:11:36.360 --> 01:11:38.920]  It just, you know, you had to have a hard coded program, but it would run.
[01:11:38.920 --> 01:11:40.520]  It would display everything correctly.
[01:11:41.400 --> 01:11:47.880]  And then I did another experiment, sort of a mock up for that ran on Linux and curses mode.
[01:11:47.880 --> 01:11:52.680]  And then I thought, well, maybe the next one should be, you know, written in JavaScript,
[01:11:52.680 --> 01:11:57.160]  run on a website, you know, in theory, that would be too hard.
[01:11:57.160 --> 01:12:01.160]  But what ended up happening was, and I didn't mention this in the talk,
[01:12:01.160 --> 01:12:03.880]  is that there was a competition called Open Jam.
[01:12:04.520 --> 01:12:09.240]  And that's where you have a weekend to write a game from scratch.
[01:12:09.800 --> 01:12:14.760]  And it happened that the, around the same time that I was like, I should rewrite this program
[01:12:14.760 --> 01:12:19.240]  to make it look better, is when Open Jam announced, you know, what the topic was.
[01:12:19.240 --> 01:12:23.480]  And the topic was lights in the dark, because it was over Halloween.
[01:12:23.480 --> 01:12:28.520]  And I thought, lights in the dark, that's switches and lights programming.
[01:12:28.520 --> 01:12:34.840]  And so I decided that I would use that opportunity to do a switches and lights version of the program.
[01:12:36.040 --> 01:12:38.120]  And that's actually where it came from.
[01:12:38.120 --> 01:12:43.880]  It's like, well, my fastest path to do this is actually, you know, because I do Fridos,
[01:12:44.920 --> 01:12:48.520]  my fastest path on this is actually to write a little Fridos program to do it,
[01:12:48.520 --> 01:12:49.320]  which is what I did.
[01:12:49.320 --> 01:12:52.920]  And so I wrote this version of the program in about a day and a half.
[01:12:53.960 --> 01:12:57.640]  But I was only able to get there because I'd done these, you know, those prototypes before.
[01:12:58.600 --> 01:13:02.920]  So, you know, web-based actually would be a much better way to do it the way that Brian did.
[01:13:04.120 --> 01:13:05.880]  I just, and I would have done it.
[01:13:05.880 --> 01:13:09.800]  It's just that it happened to be that this other thing for Open Jam came up
[01:13:09.800 --> 01:13:13.000]  at just the right time when I was thinking about rewriting it.
[01:13:13.000 --> 01:13:14.200]  And so then I rewrote it.
[01:13:16.040 --> 01:13:16.600]  Yeah, okay.
[01:13:17.800 --> 01:13:18.120]  All right.
[01:13:18.120 --> 01:13:22.360]  And a fun little question is, what was the most complicated program yourself, I guess,
[01:13:22.360 --> 01:13:25.080]  wrote for this because the students, they went to the countdown thing.
[01:13:26.200 --> 01:13:26.520]  Yeah.
[01:13:27.080 --> 01:13:34.680]  So I think the most complicated program that I wrote with the toy, that's a good question.
[01:13:34.680 --> 01:13:35.880]  What is the most complicated one?
[01:13:38.120 --> 01:13:41.240]  You know, it would probably be something that had loops in it.
[01:13:42.520 --> 01:13:46.760]  Probably that countdown was pretty complicated
[01:13:47.960 --> 01:13:51.800]  because it's got a number of comparisons and loops and operations in it.
[01:13:51.800 --> 01:13:53.400]  I'm sure I did something else more complicated.
[01:13:53.400 --> 01:13:54.200]  Just not coming to mind.
[01:13:54.200 --> 01:13:59.640]  But that loops, the one where you're doing countdown, that one's pretty complicated.
[01:14:01.080 --> 01:14:07.400]  I'd love to do something that can count to negative numbers because you'll note that
[01:14:07.400 --> 01:14:12.120]  it's only a capable of displaying positive numbers, 0 to 255.
[01:14:12.920 --> 01:14:17.960]  And so I'd love to do something that can actually do, like, write a little program within that
[01:14:17.960 --> 01:14:22.120]  limitation that takes the last bit and uses that as a sign or something.
[01:14:22.120 --> 01:14:28.360]  So that way, I'd actually watch it count 3, 2, 1, 0, minus 1, minus 2, minus 3,
[01:14:28.360 --> 01:14:29.560]  which is possible to do.
[01:14:31.560 --> 01:14:33.960]  I haven't written that one, but that would be an interesting one to do as a demo.
[01:14:34.520 --> 01:14:37.640]  But I could see in my head right now how I would probably write that.
[01:14:37.640 --> 01:14:38.440]  So I'll probably write that.
[01:14:40.840 --> 01:14:41.240]  Yeah.
[01:14:41.240 --> 01:14:44.280]  Somebody mentioned in the chat that multiplication could be interesting.
[01:14:45.160 --> 01:14:45.560]  Yeah.
[01:14:45.560 --> 01:14:48.040]  Yeah. Multiplication, basically, it's addition.
[01:14:48.040 --> 01:14:54.840]  And I thought about adding addition or sorry, multiplication and division to the instructions.
[01:14:54.840 --> 01:15:01.800]  But then I was like, but the whole point is like, you can show that multiplication is just
[01:15:01.800 --> 01:15:03.800]  addition a number of times.
[01:15:03.800 --> 01:15:08.840]  So multiplication is just several additions.
[01:15:08.840 --> 01:15:11.560]  And I basically maintain two counters for that.
[01:15:11.560 --> 01:15:13.160]  And I could see that happening.
[01:15:13.160 --> 01:15:17.160]  Divisions kind of the same way, although you can't display decimals.
[01:15:17.160 --> 01:15:18.440]  But it can't be a floating point.
[01:15:18.440 --> 01:15:20.520]  But that would be an interesting program to write as well.
[01:15:22.360 --> 01:15:22.920]  Yeah, OK.
[01:15:24.280 --> 01:15:27.160]  And of course, the question everybody's wondering about, is it Turing complete?
[01:15:29.000 --> 01:15:29.560]  Say it again?
[01:15:30.760 --> 01:15:34.120]  The question everybody's wondering about is, is it Turing complete?
[01:15:34.840 --> 01:15:36.360]  Is it Turing complete?
[01:15:36.360 --> 01:15:37.480]  I don't know that it is.
[01:15:38.440 --> 01:15:44.040]  It was only ever meant as a very simple programming language, but I guess I'd never really considered
[01:15:44.040 --> 01:15:45.320]  if it was Turing complete or not.
[01:15:46.760 --> 01:15:47.320]  Yeah, all right.
[01:15:48.280 --> 01:15:53.240]  And something that really came to mind is, so from your perspective,
[01:15:53.880 --> 01:15:56.920]  how somebody is saying, yes, it is Turing complete.
[01:15:56.920 --> 01:15:57.800]  So there it is.
[01:15:59.080 --> 01:16:02.680]  I'm not sure what the basis for that is, if you can type that, please.
[01:16:03.480 --> 01:16:05.000]  In the meantime, I will ask a different question.
[01:16:05.960 --> 01:16:10.680]  But from your perspective, because this is a very interesting experiment,
[01:16:10.680 --> 01:16:17.240]  but generally speaking, the process itself, creating this, could also be very interesting
[01:16:17.240 --> 01:16:21.880]  to teach how to create stuff like this, writing emulators, writing simulators and stuff.
[01:16:21.880 --> 01:16:26.920]  And I was curious if you have an opinion about that.
[01:16:29.080 --> 01:16:33.320]  How good would teaching emulation fair, and how useful would it be?
[01:16:33.720 --> 01:16:37.160]  No, I don't teach a computer science class.
[01:16:37.160 --> 01:16:39.880]  I would love to, but I don't actually teach one, and I would love to.
[01:16:39.880 --> 01:16:44.680]  But one of the things that I believe that in teaching things like this,
[01:16:44.680 --> 01:16:49.160]  it actually does help to show how we got from point A to point B.
[01:16:49.160 --> 01:16:55.400]  And I think that there is something in teaching computer science that you probably should have
[01:16:56.040 --> 01:16:58.920]  students work on problems that are old.
[01:16:59.640 --> 01:17:08.280]  And for example, in a compiler class, it would be interesting to have a student
[01:17:09.240 --> 01:17:12.520]  write a compiler language, or invent their own language,
[01:17:12.520 --> 01:17:16.600]  where you can only use the characters that are on a punched card,
[01:17:16.600 --> 01:17:19.560]  and see what kind of program they would come up with.
[01:17:21.240 --> 01:17:24.840]  I, as an experiment, wrote a version of Landpart.
[01:17:24.840 --> 01:17:28.280]  That's the very first computer spreadsheet that ever existed.
[01:17:29.000 --> 01:17:32.920]  Just because I was curious to kind of see how certain things worked in that.
[01:17:33.720 --> 01:17:38.600]  And it was, I now know a ton about how Landpart works.
[01:17:38.600 --> 01:17:45.240]  And I think that if you ask students to do projects like that in a computer science class,
[01:17:45.240 --> 01:17:49.960]  where you write something that's very old, in this case, maybe write an emulator
[01:17:50.920 --> 01:17:57.960]  that simulates a very simple CPU, I think students will understand a lot more about
[01:17:57.960 --> 01:17:59.800]  how that technology works.
[01:18:00.600 --> 01:18:04.200]  Because they will have had to kind of dig into and actually understand for themselves
[01:18:04.200 --> 01:18:08.520]  how certain decisions get made, how certain limitations get worked around.
[01:18:10.200 --> 01:18:13.080]  Very simple CPUs, could they multiply?
[01:18:13.080 --> 01:18:14.680]  Is that something that we had at the beginning?
[01:18:14.680 --> 01:18:20.600]  Well, you can emulate that by writing a program that will do multiplication for you.
[01:18:20.600 --> 01:18:24.680]  And then is it easier to just create that as part of the CPU?
[01:18:24.680 --> 01:18:31.960]  So, yeah, I think that the, kind of get a little off maybe from where the question was,
[01:18:31.960 --> 01:18:36.200]  but I think it'd be very interesting to have a student write a program like this,
[01:18:36.760 --> 01:18:38.360]  an emulator like this.
[01:18:38.360 --> 01:18:39.400]  It doesn't take very long.
[01:18:39.400 --> 01:18:44.600]  As I mentioned, it took me about a day and a half, basically a weekend to write this version.
[01:18:45.400 --> 01:18:49.880]  So it's very within the capabilities of an undergraduate computer science student.
[01:18:50.840 --> 01:18:54.280]  And I think they would learn a lot about how computers work.
[01:18:55.640 --> 01:18:56.520]  Yeah, okay.
[01:18:57.640 --> 01:19:00.760]  I don't agree that it would take them a day and a half, but yeah.
[01:19:00.760 --> 01:19:04.920]  Yes, it might not take them a day and a half as an undergraduate computer science student.
[01:19:04.920 --> 01:19:09.400]  It'd be a good, like senior projects, mid-semester projects, something like that, right?
[01:19:09.400 --> 01:19:12.440]  Because then they'd be able to, they'd be able to work it out, try to figure it out on their own.
[01:19:13.240 --> 01:19:16.440]  That obviously took me a lot of time, because I've been doing programming for so long.
[01:19:16.440 --> 01:19:17.320]  But yeah, absolutely.
[01:19:18.680 --> 01:19:19.240]  Yeah, all right.
[01:19:20.120 --> 01:19:23.640]  And you just mentioned, or a couple of minutes ago, you mentioned your,
[01:19:23.640 --> 01:19:27.720]  this course, you're going to do it again next semester or next year next semester?
[01:19:27.720 --> 01:19:30.520]  Yeah, if I'm scheduled to do it in summer and in fall.
[01:19:30.520 --> 01:19:35.560]  And so we'll see if I end up doing something quite like this in that class.
[01:19:36.680 --> 01:19:41.880]  If I do use it, I probably would show it rather than asking students to write programs for it,
[01:19:41.880 --> 01:19:46.600]  just because it was, I think we got a little bit lost in the class with like doing the,
[01:19:46.600 --> 01:19:47.720]  trying to debug the loop.
[01:19:49.080 --> 01:19:53.000]  But the, maybe I'd keep them, like write some simple programs, like the ad programs,
[01:19:53.400 --> 01:19:55.240]  almost everyone was able to do that one.
[01:19:55.240 --> 01:19:56.920]  That would probably be a good one to have them see.
[01:19:56.920 --> 01:20:00.920]  And then we move on and show, you know, like I showed in the slides,
[01:20:00.920 --> 01:20:05.880]  then we actually moved on and said, okay, now that we know how you'd write like an ad one and two
[01:20:06.440 --> 01:20:10.600]  together in the toy CPU, now let's actually write that same program,
[01:20:10.600 --> 01:20:15.800]  or rather, I'll write that same program for you in higher level programming languages,
[01:20:15.800 --> 01:20:20.120]  like C, like Fortran, so that way the students can see like, oh, okay.
[01:20:20.120 --> 01:20:25.000]  So I know how the, you know, the machine did it, the toy did it.
[01:20:25.000 --> 01:20:32.040]  And now I can see why programming languages are so much easier to write stuff in because,
[01:20:32.040 --> 01:20:35.960]  you know, it's like, all right, so that's the, that's the program that you saw in the slides.
[01:20:35.960 --> 01:20:39.320]  That's the same program, but now I've written in C and in Fortran.
[01:20:40.280 --> 01:20:44.280]  And the students were like, oh, that's, that's why programming is such a big deal.
[01:20:44.280 --> 01:20:47.800]  And then we were all, you know, saying, okay, you can create way more interesting and complex
[01:20:47.880 --> 01:20:52.120]  programs using these programming languages because now you don't have to manage everything at the
[01:20:52.120 --> 01:20:56.040]  lower level, compiler does that for you. And they kind of, they, I think that they,
[01:20:56.920 --> 01:21:01.320]  the feedback the other semester was that the students said that they understood programming
[01:21:01.320 --> 01:21:07.320]  and how computers work a lot better because we had shown them kind of how things work very
[01:21:08.040 --> 01:21:14.440]  simple levels. So, you know, will I do it again next semester? I'm not quite sure, but I might,
[01:21:14.440 --> 01:21:20.360]  but I think I'd probably keep it to the very simple programming examples for them to tackle,
[01:21:20.360 --> 01:21:24.760]  like the adding to numbers. All right, fair enough, fair enough.
[01:21:26.360 --> 01:21:31.720]  That's another question. It's quite long. So, it says that the way the programs were written
[01:21:31.720 --> 01:21:36.200]  on the yellow notes used one line per memory location. I can understand that, but also it's
[01:21:36.200 --> 01:21:40.040]  a little bit confusing because you were using labels to beginning and end, for example,
[01:21:40.840 --> 01:21:44.440]  that didn't really have a place. Did you consider another layout for the assembly?
[01:21:46.360 --> 01:21:53.240]  Yeah, I suppose I could. What I was doing there, I was trying to talk it through on the slide,
[01:21:54.360 --> 01:21:59.720]  you know, the way that I would write these things out for my students is I would write
[01:21:59.720 --> 01:22:07.400]  things using the sort of the assembly notation, but I had to do it, you know, one, you know,
[01:22:07.400 --> 01:22:10.680]  I would try to do it one line at a time, like it would actually be inserted in the toy.
[01:22:11.800 --> 01:22:17.720]  And the way that I would do it, like on the whiteboard is I would say, okay, so we need to
[01:22:18.680 --> 01:22:22.680]  load, for example, the first number. And so I would just say load, and then we just,
[01:22:22.680 --> 01:22:29.000]  as a placeholder, the next line would say first number. And then we would go through and say,
[01:22:29.000 --> 01:22:33.160]  okay, we're going to add the second number. And so I would just say the add instruction,
[01:22:33.160 --> 01:22:39.480]  and then next line, I would just say the second number. And then, you know, it needs to be stored
[01:22:39.480 --> 01:22:44.440]  somewhere. So I say store, and then, you know, in some other location, and then the end, and then
[01:22:44.440 --> 01:22:50.760]  then we need, so then we're able to like draw lines to, okay, so the first number is going to be stored
[01:22:50.760 --> 01:22:56.360]  in this memory location down here. And so now we know that that, that we can actually, you know,
[01:22:56.360 --> 01:22:59.880]  we're able to erase it on the whiteboard and say, okay, so the first number is being stored at this
[01:22:59.880 --> 01:23:03.800]  memory location. So I can erase that, and I can actually put it in there. Kind of hard to show
[01:23:03.800 --> 01:23:09.160]  in a slide, because I kept the text, and I just used arrows. But that's, that's actually how we
[01:23:09.160 --> 01:23:15.800]  did it in class. And so the way that I would, that we actually did it in class was we actually
[01:23:15.800 --> 01:23:21.880]  did use the names of those instructions. And then once we had our list, so once we had our list of
[01:23:21.880 --> 01:23:25.880]  what all the instructions were, and what all the memory locations were, and we just write the memory
[01:23:25.880 --> 01:23:30.360]  locations as plain numbers, then we would do another column on the whiteboard that actually
[01:23:30.360 --> 01:23:36.280]  says, okay, now we're going to actually turn that into instructions for the, for the toy.
[01:23:37.320 --> 01:23:41.160]  And then we would just write the zeros and ones for each one. And that way they could see on the
[01:23:41.160 --> 01:23:46.600]  left-hand side of the whiteboard, you know, what the, what the instruction was, or what the memory
[01:23:46.600 --> 01:23:49.880]  location was, and on the right-hand side of the whiteboard, they could see what the binder
[01:23:49.880 --> 01:23:54.280]  representation was, and that kind of reinforced that this is exactly what we're putting in. And
[01:23:54.280 --> 01:23:58.040]  that was just a matter of taking those, those binary numbers and putting them into
[01:23:58.840 --> 01:24:04.120]  the toy and running them. So it was a little bit harder to kind of show as a slide, but we
[01:24:04.120 --> 01:24:08.760]  actually did go through that process on the whiteboard. It was a lot easier to do, if you can
[01:24:08.760 --> 01:24:15.000]  sort of erase some things and scratch things out and put some arrows in. So it was, you know,
[01:24:15.000 --> 01:24:19.640]  it ended up being a little bit more than what I was able, if I tried to do that on a slide,
[01:24:19.640 --> 01:24:23.000]  I think it'd be too busy. So I tried to keep the slide a little bit simpler.
[01:24:23.960 --> 01:24:30.920]  Yeah, all right, all right. And the question slash suggestion, actually. So will you place
[01:24:30.920 --> 01:24:35.320]  this video or something similar on YouTube, right? Because it's very interesting. And
[01:24:36.280 --> 01:24:40.200]  yeah, and I think I understand the reason behind the question, because not everybody
[01:24:40.200 --> 01:24:47.160]  comes to the FOSTA website. And yeah, so yeah. Absolutely. So, you know, I'm, I'm part of the
[01:24:47.240 --> 01:24:52.760]  Freedoss project, and we have a YouTube channel. And so our Freedoss project is freedoss.org,
[01:24:52.760 --> 01:24:59.320]  and I will put a copy of this video on our YouTube channel, either today or tomorrow,
[01:24:59.320 --> 01:25:05.560]  so that way everybody can see it. And so if you missed the presentation or just want to show it
[01:25:05.560 --> 01:25:11.400]  off to somebody else, you can click on our YouTube channel and watch it there. I'll also make sure
[01:25:11.400 --> 01:25:16.680]  we put a news item out on the website so that way people can see it if they just visit the website.
[01:25:16.680 --> 01:25:22.680]  Again, that's freedoss.org. Yeah, yeah. Unfortunately, the Q&A will still be here on FOSTA,
[01:25:22.680 --> 01:25:29.800]  but I'm not sure if that's unfortunate or not. Sure. But yeah, it's, the FOSTA videos used to
[01:25:29.800 --> 01:25:33.800]  be uploaded to YouTube, but for some reason YouTube blocked FOSTA because we were uploading
[01:25:33.800 --> 01:25:38.760]  too much to YouTube. So yeah, they just blocked the accounts and it's a running issue. So yeah.
[01:25:40.120 --> 01:25:42.520]  Oh, somebody's asking, how do you spell the YouTube channel?
[01:25:42.680 --> 01:25:50.920]  It's just freedoss.org. It was, in my slide, I had the, my email address, and that was
[01:25:50.920 --> 01:25:55.880]  Jay Hall at freedoss.org. And so the website is just freedoss.org. The YouTube channel is
[01:25:56.440 --> 01:26:02.520]  youtube.com slash freedoss project. Okay. It's also in the footer of our website.
[01:26:03.960 --> 01:26:10.200]  All right. I will manage to find it. All right, let's see. Did I get through everything?
[01:26:11.160 --> 01:26:17.560]  I think I went through everything. Let's just give, I see somebody typing. Let's give him a moment.
[01:26:22.680 --> 01:26:23.960]  Let's see. Let's see. Let's see.
[01:26:24.360 --> 01:26:42.120]  You still typing? All right. I think final question. You kind of like answered it already,
[01:26:42.120 --> 01:26:46.760]  but still, so if you, if you would make like,
[01:26:47.720 --> 01:26:54.120]  I can't really find the actual word, but like a sequel course for this one,
[01:26:54.680 --> 01:26:57.800]  how would you make it? Like a more advanced, so people that like this course.
[01:26:58.840 --> 01:27:03.800]  Oh yeah. So, you know, this class is MIS 100. It's meant to kind of introduce kind of how
[01:27:03.800 --> 01:27:09.240]  technology works and then how to use certain tools. You know, I would, I would love, I think
[01:27:09.240 --> 01:27:14.120]  it'd be very interesting to see a class that kind of goes into more depth. I think that, you know,
[01:27:14.120 --> 01:27:18.760]  for that kind of need to focus on certain things. And I really think that, you know,
[01:27:18.760 --> 01:27:23.640]  there's a lot to be said for any student. It doesn't matter what program they're in, any student,
[01:27:24.600 --> 01:27:30.440]  to understand how technology works kind of a basic level. The way that I tell my students at
[01:27:30.440 --> 01:27:34.760]  the beginning of the semester in that course is that, you know, I don't want you to graduate,
[01:27:34.760 --> 01:27:37.720]  and I mentioned this in the video, I don't want you to graduate from this class or from the,
[01:27:37.720 --> 01:27:43.800]  from the, from the university and, and think that technology is just you press a button and magic
[01:27:43.800 --> 01:27:48.120]  happens in the background and then you get back an answer. You should have some understanding.
[01:27:48.120 --> 01:27:53.400]  And so having, I think that, you know, to do more with this class, I think it's really just
[01:27:53.960 --> 01:27:57.880]  helping students to do more of a deeper dive on how technology works
[01:27:59.000 --> 01:28:05.400]  and how certain of these things, you know, come about. You know, I think that there's a lot that
[01:28:05.400 --> 01:28:12.520]  students can understand around how applications get put together. The challenge would be because
[01:28:12.520 --> 01:28:17.080]  these particular students are not meant to be computer science students or business students.
[01:28:17.080 --> 01:28:21.400]  And so how do you do it in a way that's going to be accessible to them? But I, but we do,
[01:28:21.400 --> 01:28:24.680]  we do have other classes that kind of go into that in more depth. And I think that
[01:28:25.640 --> 01:28:28.520]  that's, that would be, that was something I would encourage everybody to kind of every
[01:28:28.520 --> 01:28:35.080]  university to do something like that. All right, excellent. So I hope all universities listen.
[01:28:36.680 --> 01:28:41.560]  Yeah, we know how that goes. But all right, thank you very much, Jim. And we hope to see you soon
[01:28:41.560 --> 01:28:49.240]  in the Brussels again. Thank you. Thank you very much. Thanks. Thanks everybody. Bye.
